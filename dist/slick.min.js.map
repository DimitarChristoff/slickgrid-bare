{"version":3,"sources":["webpack:///slick.min.js","webpack:///webpack/bootstrap 1005c1f30a5451707e1a","webpack:///../src/slick.core.js","webpack:///external \"jquery\"","webpack:///../src/index.js","webpack:///../src/interact.js","webpack:///../src/slick-frozen.grid.js","webpack:///../src/slick.dataview.js","webpack:///../src/slick.groupmetadataprovider.js"],"names":["e","a","i","exports","modules","__webpack_require__","moduleId","installedModules","module","id","loaded","call","m","c","p","EventData","isPropagationStopped","isImmediatePropagationStopped","this","stopPropagation","stopImmediatePropagation","Event","handlers","subscribe","fn","push","unsubscribe","length","splice","notify","args","scope","returnValue","EventHandler","event","handler","unsubscribeAll","Range","fromRow","fromCell","toRow","toCell","undefined","Math","min","max","isSingleRow","isSingleCell","contains","row","cell","toString","NonDataItem","__nonDataRow","Group","__group","level","count","value","title","collapsed","totals","rows","groups","groupingKey","GroupTotals","__groupTotals","group","initialized","EditorLock","activeEditController","isActive","editController","activate","commitCurrentEdit","cancelCurrentEdit","deactivate","TreeColumns","treeColumns","init","mapToId","columns","forEach","column","columnsById","filter","node","condition","valid","sort","grid","b","indexA","getOrDefault","getColumnIndex","indexB","getDepth","getColumnsInDepth","depth","current","n","extractColumns","concat","result","hasOwnProperty","cloneTreeColumns","$","extend","hasDepth","getTreeColumns","getColumnsInGroup","visibleColumns","visible","reOrder","getById","getInIds","ids","map","Object","defineProperty","Slick","NonDataRow","GlobalEditorLock","keyCode","BACKSPACE","DELETE","DOWN","END","ENTER","ESCAPE","HOME","INSERT","LEFT","PAGE_DOWN","PAGE_UP","RIGHT","TAB","UP","SPACE","default","prototype","equals","require","_interopRequireDefault","obj","__esModule","_slick","enumerable","get","_slick2","_slickFrozen","_typeof","Symbol","iterator","constructor","realWindow","blank","isElement","o","_window","getWindow","window","test","Element","nodeType","nodeName","isWindow","thing","Window","isDocFrag","DocumentFragment","isArray","isObject","isFunction","isNumber","isBool","isString","trySelector","document","querySelector","dest","source","prop","pointerExtend","deprecated","vendor","prefixedPropREs","indexOf","copyCoords","src","page","x","y","client","timeStamp","setEventXY","targetObj","pointers","interaction","pointer","pointerAverage","getPageXY","tmpXY","getClientXY","Date","getTime","setEventDeltas","prev","cur","dt","speed","hypot","vx","vy","isNativePointer","supportsTouch","Touch","getXY","type","xy","isOperaMobile","scrollX","scrollY","getScrollXY","win","documentElement","scrollLeft","scrollTop","getPointerId","pointerId","identifier","getActualElement","element","SVGElementInstance","correspondingUseElement","rootNode","ownerDocument","defaultView","parentWindow","getElementClientRect","clientRect","SVGElement","getBoundingClientRect","getClientRects","left","right","top","bottom","width","height","getElementRect","isIOS7","scroll","getTouchPair","touches","changedTouches","average","pageX","pageY","clientX","clientY","screenX","screenY","touchBBox","minX","minY","maxX","maxY","touchDistance","deltaSource","defaultOptions","sourceX","sourceY","dx","dy","touchAngle","prevAngle","angle","atan","PI","dr","drClamped","getOriginXY","interactable","origin","options","parentElement","getRect","closest","_getQBezierValue","t","p1","p2","p3","iT","getQuadraticCurvePoint","startX","startY","cpX","cpY","endX","endY","position","easeOutQuad","d","nodeContains","parent","child","parentNode","selector","matchesSelector","host","inContext","_context","testIgnore","interactableElement","ignoreFrom","matchesUpTo","testAllow","allowFrom","checkAxis","axis","thisAxis","drag","checkSnap","action","snap","enabled","checkRestrict","restrict","checkAutoScroll","autoScroll","withinInteractionLimit","maxActions","name","maxPerElement","activeInteractions","targetCount","targetElementCount","len","interactions","otherAction","prepared","active","interacting","maxInteractions","target","indexOfDeepestElement","elements","dropzone","deepestZone","index","deepestZoneParents","dropzoneParents","unshift","HTMLElement","SVGSVGElement","ownerSVGElement","parents","lastChild","previousSibling","Interaction","dropTarget","dropElement","prevDropTarget","prevDropElement","edges","matches","matchElements","inertiaStatus","smoothEnd","ending","startEvent","upCoords","xe","ye","sx","sy","t0","vx0","vys","duration","resumeDx","resumeDy","lambda_v0","one_ve_v0","Function","bind","boundInertiaFrame","inertiaFrame","boundSmoothEndFrame","smoothEndFrame","that","activeDrops","dropzones","rects","pointerIds","downTargets","downTimes","holdTimers","prevCoords","curCoords","startCoords","pointerDelta","downEvent","downPointer","_eventTarget","_curEventTarget","prevEvent","tapTime","prevTap","startOffset","restrictOffset","snapOffsets","gesture","start","startDistance","prevDistance","distance","scale","startAngle","snapStatus","realX","realY","snappedX","snappedY","targets","locked","changed","restrictStatus","restrictedX","restrictedY","restricted","pointerIsDown","pointerWasMoved","gesturing","dragging","resizing","resizeAxes","mouse","getInteractionFromPointer","eventType","eventTarget","mouseEvent","pointerType","inertia","allowResume","supportsPointerEvent","doOnInteractions","method","path","curEventTarget","currentTarget","prevTouchTime","_updateEventTargets","InteractEvent","phase","related","starting","coords","relativePoints","range","elementRect","x0","y0","clientX0","clientY0","ctrlKey","altKey","shiftKey","metaKey","button","buttons","detail","relatedTarget","zeroResumeDelta","resize","square","axes","box","ds","da","prevScale","velocityX","velocityY","atan2","overlap","up","down","swipe","velocity","preventOriginalDefault","originalEvent","preventDefault","getActionCursor","cursor","actionCursors","cursorKey","edgeNames","checkResizeEdge","rect","margin","defaultActionChecker","resizeEdges","shouldResize","actionIsEnabled","resizeOptions","edge","validateAction","actionName","delegateListener","useCapture","fakeEvent","delegated","delegatedEvents","selectors","context","contexts","listeners","j","delegateUseCapture","interact","interactables","Interactable","_element","_iEvents","Node","events","add","pEventTypes","pointerDown","move","pointerHover","_doc","documents","listenToDocument","set","warnOnce","message","warned","console","warn","apply","arguments","endAllInteractions","pointerEnd","doc","PointerEvent","MSPointerEvent","over","out","cancel","selectorDown","pointerMove","pointerOver","pointerOut","pointerUp","pointerCancel","autoScrollMove","frameElement","parentDoc","error","windowParentError","checkAndPreventDefault","useAttachEvent","currentAction","array","nodeList","ie8MatchesSelector","replace","prefixedMatchesSelector","limit","el","createTextNode","wrap","sqrt","dynamicDrop","base","accept","actionChecker","styleCursor","dropChecker","manualStart","Infinity","drop","preserveAspectRatio","NaN","invert","perAction","endOnly","offsets","container","resistance","minSpeed","endSpeed","smoothEndDuration","_holdDuration","now","dtx","prevTimeX","dty","prevTimeY","scrollBy","isScrolling","cancelFrame","reqFrame","stop","DocumentTouch","navigator","userAgent","pointerMoveTolerance","all","atob","resizex","resizey","resizexy","resizetop","resizeleft","resizebottom","resizeright","resizetopleft","resizebottomright","resizetopright","resizebottomleft","wheelEvent","eventTypes","globalEvents","appName","match","platform","appVersion","requestAnimationFrame","cancelAnimationFrame","listener","elementIndex","typeCount","attachedListeners","supplied","wrapped","useCount","ret","listenerIndex","immediatePropagationStopped","srcElement","preventDef","stopProp","stopImmProp","addEvent","on","Boolean","remove","removeEvent","cancelBubble","_elements","_targets","_attachedListeners","webkit","ptr","pushCurMatches","curMatches","curMatchElements","prevTargetElement","addPointer","elementInteractable","elementAction","getAction","forEachSelector","validateSelector","style","pushMatches","querySelectorAll","eventCopy","pointerIndex","setTimeout","pointerHold","collectEventTargets","forceAction","newAction","setModifications","preEnd","shouldMove","shouldSnap","shouldRestrict","setSnapping","setRestriction","setStartOffsets","snapOffset","offset","pageUp","clientUp","inertiaPosition","recordPointer","duplicateMove","clearTimeout","absX","abs","absY","targetAxis","thisInteraction","getDraggable","selectorInteractable","dragStart","dragEvent","fire","setActiveDrops","dropEvents","getDropEvents","fireActiveDrops","dragMove","draggableElement","getDrop","leave","enter","resizeStart","resizeEvent","startRect","linkedEdges","_linkedEdges","resizeStartAspectRatio","resizeRects","previous","delta","deltaRect","resizeMove","invertible","originalEdges","swap","gestureStart","gestureEvent","gestureMove","isNaN","removePointer","ie8Dblclick","endEvent","inertiaOptions","pointerSpeed","inertiaPossible","endSnap","endRestrict","snapRestrict","vy0","v0","calcInertia","statusObject","useStatusXY","modifiedXe","modifiedYe","collectDrops","drops","dropElements","currentElement","prevElement","dragElement","possibleDrops","validDrops","dropCheck","dropIndex","pointerEvent","draggable","dragLeave","prevDropzone","dragEnter","dragmove","clearTargets","lambda","te","progress","exp","quadPoint","collectSelectors","els","isSet","firePointers","interval","createNewDoubleTap","originalPointer","double","propagationStopped","doubleTap","matchElement","pageCoords","status","relIndex","relative","inRange","snapChanged","restriction","prevent","inertiaDur","log","innerWidth","innerHeight","interactionListeners","indexOfElement","callback","setOnEvents","phases","ondrop","ondropactivate","ondropdeactivate","ondragenter","ondragleave","ondropmove","onstart","onmove","onend","oninertiastart","setPerAction","option","checker","dropped","dropOverlap","horizontal","vertical","dragRect","cx","cy","overlapArea","overlapRatio","newValue","resizable","squareResize","gesturable","actions","setOptions","thisOption","mode","createSnapGrid","gridOffset","anchors","paths","elementOrigin","allActions","rectChecker","iEvent","onEvent","funcName","search","trim","split","off","eventList","matchFound","useCap","methods","perActions","settings","setting","unset","enableDragging","enableResizing","enableGesturing","debug","downTime","getPointerAverage","getTouchBBox","getTouchDistance","getTouchAngle","newvalue","offsetX","offsetY","gridx","round","gridy","newX","newY","elems","lastTime","vendors","currTime","timeToCall","SlickGrid","data","$container","_jquery2","Error","maxSupportedCssHeight","getMaxSupportedCssHeight","scrollbarDimensions","measureScrollbar","defaults","validateAndEnforceOptions","columnDefaults","defaultColumnWidth","minWidth","maxWidth","empty","css","addClass","uid","$focusSink","appendTo","$paneHeaderL","$paneHeaderR","$paneTopL","$paneTopR","$paneBottomL","$paneBottomR","$headerScrollerL","$headerScrollerR","$headerScroller","$groupHeadersL","$groupHeadersR","$groupHeaders","$headerL","$headerR","$headers","$headerRowScrollerL","$headerRowScrollerR","$headerRowScroller","$headerRowSpacerL","getCanvasWidth","$headerRowSpacerR","$headerRowL","$headerRowR","$headerRow","$topPanelScrollerL","$topPanelScrollerR","$topPanelScroller","$topPanelL","$topPanelR","$topPanel","showTopPanel","hide","showHeaderRow","$viewportTopL","$viewportTopR","$viewportBottomL","$viewportBottomR","$viewport","$activeViewportNode","$canvasTopL","$canvasTopR","$canvasBottomL","$canvasBottomR","$canvas","$activeCanvasNode","$footerRowScrollerR","$footerRowScrollerL","$footerRowScroller","$footerRowSpacerL","$footerRowSpacerR","$footerRowL","$footerRowR","$footerRow","showFooterRow","$focusSink2","clone","explicitInitialization","finishInitialization","getViewportWidth","getViewportHeight","measureCellPaddingAndBorder","disableSelection","enableTextSelectionOnCells","is","setFrozenOptions","setPaneVisibility","setScroller","setOverflow","updateColumnCaches","createColumnHeaders","createColumnGroupHeaders","createColumnFooter","setupColumnSort","createCssRules","resizeCanvas","bindAncestorScrollEvents","handleScroll","mousewheel","frozenColumn","hasFrozenRows","handleMouseWheel","handleHeaderContextMenu","handleHeaderClick","delegate","handleHeaderMouseEnter","handleHeaderMouseLeave","handleHeaderRowScroll","handleFooterRowScroll","handleKeyDown","handleClick","handleDblClick","handleContextMenu","handleMouseEnter","handleMouseLeave","_interact2","handleDrag","handleDragStart","handleDragEnd","toLowerCase","hasFrozenColumns","registerPlugin","plugin","plugins","self","unregisterPlugin","destroy","setSelectionModel","model","selectionModel","onSelectedRangesChanged","handleSelectedRangesChanged","getSelectionModel","getCanvasNode","getActiveCanvasNode","setActiveCanvasNode","getCanvases","getViewportNode","getActiveViewportNode","setActiveViewportNode","$c","body","dim","clientWidth","clientHeight","getHeadersWidth","headersWidth","headersWidthL","headersWidthR","ii","viewportW","getHeadersWidthL","getHeadersWidthR","availableWidth","viewportHasVScroll","canvasWidthL","canvasWidthR","totalRowWidth","fullWidthRows","updateCanvasWidth","forceColumnWidthsUpdate","widthChanged","oldCanvasWidth","canvasWidth","oldCanvasWidthL","oldCanvasWidthR","viewportHasHScroll","applyColumnWidths","$target","jquery","attr","supportedHeight","testUpTo","div","elem","frozenBottom","scrollWidth","scrollHeight","$elem","$boundAncestors","handleActiveCellPositionChange","unbindAncestorScrollEvents","unbind","updateColumnHeader","columnId","toolTip","idx","columnDef","$header","children","eq","trigger","onBeforeHeaderCellDestroy","html","onHeaderCellRendered","getHeaderRow","getHeaderRowColumn","$headerRowTarget","getFooterRow","getFooterRowColumn","$footerRowTarget","$footer","find","each","onBeforeFooterRowCellDestroy","footerRowCell","onFooterRowCellRendered","columnsLength","frozenColumnsValid","groupColumns","indexGroup","headerCssClass","alert","applyColumnGroupHeaderWidths","onMouseEnter","onMouseLeave","removeClass","onBeforeHeaderRowCellDestroy","$headerTarget","header","headerColumnWidthDiff","enableColumnReorder","sortable","append","headerRowCell","onHeaderRowCellRendered","setSortColumns","sortColumns","setupColumnResize","setupColumnReorder","click","hasClass","$col","getEditorLock","sortOpts","sortAsc","multiColumnSort","defaultSortAsc","onSort","sortCols","col","sortCol","currentPositionInHeader","currentPosition","limitPositionInGroup","idColumn","groupColumnOfPreviousPosition","startLimit","endLimit","some","groupColumn","end","arr","lastIndexOf","columnPositionValidInGroup","$item","positionValid","text","placeholder","createElement","className","offsetWidth","offsetHeight","after","zIndex","marginLeft","transform","validPositionInGroup","removeChild","setColumns","getColumns","newColumns","removeData","onColumnsReordered","impactedColumns","getImpactedColumns","classList","columnElements","firstResizable","lastResizable","forceFitColumns","$handle","activeColumn","previousWidth","autosizeColumns","applyColumnHeaderWidths","syncColumnCellResize","invalidateAllRows","render","onColumnsResized","getVBoxDelta","$el","val","parseFloat","parseInt","frozenRow","numVisibleRows","frozenRowsHeight","rowHeight","dataLength","getDataLength","actualFrozenRow","show","overflow-x","overflow-y","$headerScrollContainer","$headerRowScrollContainer","$footerRowScrollContainer","$viewportScrollContainerX","$viewportScrollContainerY","h","v","headerColumnHeightDiff","r","cellWidthDiff","cellHeightDiff","absoluteColumnMinWidth","$style","rules","topPanelHeight","headerRowHeight","footerRowHeight","styleSheet","cssText","join","appendChild","getColumnCssRules","stylesheet","sheets","styleSheets","ownerNode","owningElement","columnCssRulesL","columnCssRulesR","columnIdx","cssRules","selectorText","exec","substr","removeCssRules","onBeforeDestroy","evt","editorLock","getEditController","prevTotal","widths","shrinkLeeway","total","availWidth","shrinkProportion","absMinWidth","shrinkSize","floor","growProportion","growSize","currentWidth","reRender","rerenderOnResize","$groupHeader","currentColumnIndex","$groupHeaderColumn","$headerColumn","next","outerWidth","headers","w","rule","setSortColumn","ascending","cols","headerColumnEls","columnIndex","getSortColumns","ranges","selectedRows","hash","k","canCellBeSelected","selectedCellCssClass","setCellCssStyles","onSelectedRowsChanged","getSelectedRows","columnPosLeft","columnPosRight","columnDefinitions","_treeColumns","getOptions","makeActiveCellNormal","enableAddRow","invalidateRow","zombieRowNodeFromLastMouseWheelEvent","autoHeight","leaveSpaceForNewRows","setData","newData","scrollToTop","updateRowCount","scrollTo","getData","getLength","getDataLengthIncludingAddNew","getDataItem","getItem","getTopPanel","setTopPanelVisibility","slideDown","slideUp","setHeaderRowVisibility","setFooterRowVisibility","fadeIn","getContainerNode","getRowTop","getRowFromPosition","th","oldOffset","ph","cj","newScrollTop","getVisibleRange","cleanupRows","updateRowPositions","prevScrollTop","vScrollDir","lastRenderedScrollTop","onViewportChanged","defaultFormatter","dataContext","getFormatter","rowMetadata","getItemMetadata","columnOverrides","formatter","formatterFactory","callFormatter","item","metadata","columnData","getEditor","columnMetadata","editor","editorFactory","getDataItemValueForColumn","dataItemColumnValueExtractor","field","appendRowHtml","stringArrayL","stringArrayR","dataLoading","rowCss","activeRow","addNewRowCssClass","cssClasses","frozenRowOffset","getFrozenRowOffset","rowHtml","colspan","leftPx","rightPx","appendCellHtml","stringArray","cellCss","cssClass","activeCell","key","cellCssClasses","rowsCache","cellRenderQueue","cellColSpans","rangeToKeep","removeFrozenRow","removeRowFromCache","invalidate","currentEditor","cacheEntry","rowNodeFromLastMouseWheelEvent","rowNode","postProcessedRows","renderedRows","counter_rows_removed","invalidateRows","rl","updateCell","cellNode","getCellNode","loadValue","innerHTML","invalidatePostProcessingResults","updateRow","ensureCellNodesInRowsCache","cellNodesByColumnIdx","viewportH","outerHeight","topPanelH","headerRowH","footerRowH","ceil","paneTopH","paneBottomH","viewportTopH","viewportBottomH","paneBottomTop","lastRenderedScrollLeft","dataLengthIncludingAddNew","numberOfRows","oldH","tempViewportH","oldViewportHasVScroll","l","activeCellNode","resetActiveCell","oldScrollTopInRange","viewportTop","viewportLeft","getRenderedRange","buffer","minBuffer","$lastNode","last","pop","cleanUpCells","totalCellsRemoved","cellsToRemove","cellToRemove","cleanUpAndRenderCells","cellsAdded","processedRows","totalCellsAdded","btm","processedRow","$node","renderRows","needToReselectCell","counter_rows_rendered","xRight","firstChild","startPostProcessing","enableAsyncPostRender","h_postrender","asyncPostProcessRows","asyncPostRenderDelay","postProcessFromRow","postProcessToRow","rendered","renderedFrozenRows","h_render","deltaX","deltaY","$rowNode","$gridCanvas","zombieRow","handled","_handleScroll","isMouseWheel","maxScrollDistanceY","maxScrollDistanceX","hasFrozenCols","vScrollDist","hScrollDist","prevScrollLeft","forceSyncScrolling","onScroll","asyncPostRender","updateCellCssStylesOnRenderedRows","addedHash","removedHash","addedRowHash","removedRowHash","addCellCssStyles","onCellCssStylesChanged","removeCellCssStyles","prevHash","getCellCssStyles","flashCell","toggleCellClass","times","$cell","queue","toggleClass","cellFlashingCssClass","dequeue","handleDragInit","dd","getCellFromEvent","cellExists","retval","onDragInit","interactEvent","onDragStart","onDrag","onDragEnd","onKeyDown","which","navigatePrev","cancelEditAndSetFocus","navigatePageDown","navigatePageUp","navigateLeft","navigateRight","navigateUp","navigateDown","navigateNext","editable","commitEditAndSetFocus","makeActiveCellEditable","activeElement","setFocus","onClick","canCellBeActive","scrollRowIntoView","setActiveCellInternal","onContextMenu","onDblClick","gotoCell","onHeaderMouseEnter","onHeaderMouseLeave","onHeaderContextMenu","onHeaderClick","getCellFromPoint","getCellFromNode","cls","getRowFromNode","rowOffset","isBottom","getCellNodeBox","y1","y2","x1","x2","tabbingDirection","focus","scrollCellIntoView","doPaging","getColspan","scrollRight","newCell","opt_editMode","activeCellChanged","$activeCellNode","$activeCellOffset","activePosX","autoEdit","isCellPotentiallyEditable","h_editorLoader","asyncEditorLoading","asyncEditorLoadDelay","scrollActiveCellIntoView","onActiveCellChanged","getActiveCell","clearTextSelection","selection","getSelection","sel","removeAllRanges","cannotTriggerInsert","onBeforeCellEditorDestroy","onBeforeEditCell","gridPosition","absBox","commitChanges","cancelChanges","serializedEditorValue","serializeValue","offsetTop","offsetLeft","offsetParent","getActiveCellPosition","getGridPosition","onActiveCellPositionChanged","cellBox","getCellEditor","getActiveCellNode","viewportScrollH","rowAtTop","rowAtBottom","scrollRowToTop","scrollPage","dir","deltaRows","enableCellNavigation","prevCell","prevActivePosX","findFirstFocusableCell","findLastFocusableCell","lastFocusableCell","gotoRight","posX","gotoLeft","firstFocusableCell","pos","gotoDown","gotoUp","gotoNext","gotoPrev","lastSelectableCell","navigate","tabbingDirections","stepFunctions","stepFn","isAddNewRow","setActiveCell","focusable","selectable","forceEdit","isValueChanged","validationResults","validate","editCommand","serializedValue","prevSerializedValue","execute","applyValue","onCellChange","undo","editCommandHandler","newItem","onAddNewRow","onValidationError","rowsToRanges","lastCell","setSelectedRows","setSelectedRanges","multiSelect","random","s","eval","expr","slickGridVersion","getViewport","editActiveCell","_jquery","_interact","FrozenGrid","DataView","beginUpdate","suspend","endUpdate","refresh","setRefreshHints","hints","refreshHints","setFilterArgs","filterArgs","updateIdxById","startingIndex","items","idProperty","idxById","ensureIdUniqueness","getItems","setItems","objectIdProperty","filteredItems","setPagingOptions","pageSize","pagesize","pagenum","totalRows","pageNum","onPagingInfoChanged","getPagingInfo","totalPages","dataView","comparer","sortComparer","fastSortField","reverse","fastSort","oldToString","reSort","setFilter","filterFn","inlineFilters","compiledFilter","compileFilter","compiledFilterWithCaching","compileFilterWithCaching","getGrouping","groupingInfos","setGrouping","groupingInfo","groupItemMetadataProvider","GroupItemMetadataProvider","toggledGroupsByLevel","Array","gi","groupingInfoDefaults","getterIsAFn","getter","compiledAccumulators","aggregators","compileAccumulatorLoop","groupBy","valueGetter","valueFormatter","setAggregators","groupAggregators","includeCollapsed","aggregateCollapsed","getItemByIdx","getIdxById","ensureRowsByIdCache","rowsById","getRowById","getItemById","mapIdsToRows","idArray","mapRowsToIds","rowArray","updateItem","updated","insertItem","insertBefore","addItem","deleteItem","displayTotalsRow","calculateTotals","getGroupRowMetadata","getTotalsRowMetadata","expandCollapseAllGroups","collapse","collapseAllGroups","expandAllGroups","expandCollapseGroup","collapseGroup","letArgs","slice","arg0","groupingDelimiter","expandGroup","getGroups","extractGroups","parentGroup","groupsByVal","predefinedValues","isLeafLevel","agg","aggregateChildGroups","storeResult","addGroupTotals","lazyTotalsCalculation","addTotals","groupCollapsed","toggledGroups","g","aggregateEmpty","flattenGroupedRows","groupedRows","gl","jj","getFunctionInfo","fnRegex","params","aggregator","accumulatorInfo","accumulate","displayName","filterInfo","filterPath1","filterPath2","filterBody","tpl","uncompiledFilter","uncompiledFilterWithCaching","cache","getFilteredAndPagedItems","batchFilter","batchFilterWithCaching","isFilterNarrowing","isFilterExpanding","filterCache","isFilterUnchanged","paged","getRowDiffs","newRows","eitherIsNonData","diff","from","to","ignoreDiffsBefore","ignoreDiffsAfter","recalc","_items","prevRefreshHints","countBefore","totalRowsBefore","onRowCountChanged","onRowsChanged","syncGridSelection","preserveHidden","preserveHiddenOnSelectionChange","setSelectedRowIds","rowIds","selectedRowIds","onSelectedRowIdsChanged","update","inHandler","newSelectedRowIds","existing","grep","syncGridCellCssStyles","storeCellCssStyles","hashById","newHash","AvgAggregator","field_","count_","nonNullCount_","sum_","groupTotals","avg","MinAggregator","min_","MaxAggregator","max_","SumAggregator","sum","_slick3","_slick4","Aggregators","Avg","Min","Max","Sum","Data","GroupMetaDataProvider","GroupItemMetaDataProvider","defaultGroupCellFormatter","enableExpandCollapse","indentation","toggleCssClass","toggleCollapsedCssClass","toggleExpandedCssClass","groupTitleCssClass","defaultTotalsCellFormatter","groupTotalsFormatter","_grid","handleGridClick","handleGridKeyDown","groupFocusable","groupCssClass","0","groupFormatter","totalsFocusable","totalsCssClass","totalsFormatter","_defaults"],"mappings":"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","file":"slick.min.js","sourcesContent":["(function(e, a) { for(var i in a) e[i] = a[i]; }(exports, /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"/\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(3);\n\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports) {\n\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t/** *\n\t * Contains core SlickGrid classes.\n\t * @module Core\n\t * @namespace Slick\n\t */\n\tvar Slick = {\n\t  Event: Event,\n\t  EventData: EventData,\n\t  EventHandler: EventHandler,\n\t  Range: Range,\n\t  NonDataRow: NonDataItem,\n\t  Group: Group,\n\t  GroupTotals: GroupTotals,\n\t  EditorLock: EditorLock,\n\t  /** *\n\t   * A global singleton editor lock.\n\t   * @class GlobalEditorLock\n\t   * @static\n\t   * @constructor\n\t   */\n\t  GlobalEditorLock: new EditorLock(),\n\t  TreeColumns: TreeColumns,\n\t\n\t  keyCode: {\n\t    BACKSPACE: 8,\n\t    DELETE: 46,\n\t    DOWN: 40,\n\t    END: 35,\n\t    ENTER: 13,\n\t    ESCAPE: 27,\n\t    HOME: 36,\n\t    INSERT: 45,\n\t    LEFT: 37,\n\t    PAGE_DOWN: 34,\n\t    PAGE_UP: 33,\n\t    RIGHT: 39,\n\t    TAB: 9,\n\t    UP: 38,\n\t    SPACE: 32\n\t  }\n\t};\n\t\n\texports.default = Slick;\n\t\n\t/***\n\t * An event object for passing data to event handlers and letting them control propagation.\n\t * <p>This is pretty much identical to how W3C and jQuery implement events.</p>\n\t * @class EventData\n\t * @constructor\n\t */\n\t\n\tfunction EventData() {\n\t  var isPropagationStopped = false;\n\t  var isImmediatePropagationStopped = false;\n\t\n\t  /***\n\t   * Stops event from propagating up the DOM tree.\n\t   * @method stopPropagation\n\t   */\n\t  this.stopPropagation = function () {\n\t    isPropagationStopped = true;\n\t  };\n\t\n\t  /***\n\t   * Returns whether stopPropagation was called on this event object.\n\t   * @method isPropagationStopped\n\t   * @return {Boolean}\n\t   */\n\t  this.isPropagationStopped = function () {\n\t    return isPropagationStopped;\n\t  };\n\t\n\t  /***\n\t   * Prevents the rest of the handlers from being executed.\n\t   * @method stopImmediatePropagation\n\t   */\n\t  this.stopImmediatePropagation = function () {\n\t    isImmediatePropagationStopped = true;\n\t  };\n\t\n\t  /***\n\t   * Returns whether stopImmediatePropagation was called on this event object.\\\n\t   * @method isImmediatePropagationStopped\n\t   * @return {Boolean}\n\t   */\n\t  this.isImmediatePropagationStopped = function () {\n\t    return isImmediatePropagationStopped;\n\t  };\n\t}\n\t\n\t/***\n\t * A simple publisher-subscriber implementation.\n\t * @class Event\n\t * @constructor\n\t */\n\tfunction Event() {\n\t  var handlers = [];\n\t\n\t  /***\n\t   * Adds an event handler to be called when the event is fired.\n\t   * <p>Event handler will receive two arguments - an <code>EventData</code> and the <code>data</code>\n\t   * object the event was fired with.<p>\n\t   * @method subscribe\n\t   * @param fn {Function} Event handler.\n\t   */\n\t  this.subscribe = function (fn) {\n\t    handlers.push(fn);\n\t  };\n\t\n\t  /***\n\t   * Removes an event handler added with <code>subscribe(fn)</code>.\n\t   * @method unsubscribe\n\t   * @param fn {Function} Event handler to be removed.\n\t   */\n\t  this.unsubscribe = function (fn) {\n\t    for (var i = handlers.length - 1; i >= 0; i--) {\n\t      if (handlers[i] === fn) {\n\t        handlers.splice(i, 1);\n\t      }\n\t    }\n\t  };\n\t\n\t  /***\n\t   * Fires an event notifying all subscribers.\n\t   * @method notify\n\t   * @param args {Object} Additional data object to be passed to all handlers.\n\t   * @param e {EventData}\n\t   *      Optional.\n\t   *      An <code>EventData</code> object to be passed to all handlers.\n\t   *      For DOM events, an existing W3C/jQuery event object can be passed in.\n\t   * @param scope {Object}\n\t   *      Optional.\n\t   *      The scope (\"this\") within which the handler will be executed.\n\t   *      If not specified, the scope will be set to the <code>Event</code> instance.\n\t   */\n\t  this.notify = function (args, e, scope) {\n\t    e = e || new EventData();\n\t    scope = scope || this;\n\t\n\t    var returnValue;\n\t    for (var i = 0; i < handlers.length && !(e.isPropagationStopped() || e.isImmediatePropagationStopped()); i++) {\n\t      returnValue = handlers[i].call(scope, e, args);\n\t    }\n\t\n\t    return returnValue;\n\t  };\n\t}\n\t\n\tfunction EventHandler() {\n\t  var handlers = [];\n\t\n\t  this.subscribe = function (event, handler) {\n\t    handlers.push({\n\t      event: event,\n\t      handler: handler\n\t    });\n\t    event.subscribe(handler);\n\t\n\t    return this; // allow chaining\n\t  };\n\t\n\t  this.unsubscribe = function (event, handler) {\n\t    var i = handlers.length;\n\t    while (i--) {\n\t      if (handlers[i].event === event && handlers[i].handler === handler) {\n\t        handlers.splice(i, 1);\n\t        event.unsubscribe(handler);\n\t        return;\n\t      }\n\t    }\n\t\n\t    return this; // allow chaining\n\t  };\n\t\n\t  this.unsubscribeAll = function () {\n\t    var i = handlers.length;\n\t    while (i--) {\n\t      handlers[i].event.unsubscribe(handlers[i].handler);\n\t    }\n\t    handlers = [];\n\t\n\t    return this; // allow chaining\n\t  };\n\t}\n\t\n\t/***\n\t * A structure containing a range of cells.\n\t * @class Range\n\t * @constructor\n\t * @param fromRow {Integer} Starting row.\n\t * @param fromCell {Integer} Starting cell.\n\t * @param toRow {Integer} Optional. Ending row. Defaults to <code>fromRow</code>.\n\t * @param toCell {Integer} Optional. Ending cell. Defaults to <code>fromCell</code>.\n\t */\n\tfunction Range(fromRow, fromCell, toRow, toCell) {\n\t  if (toRow === undefined && toCell === undefined) {\n\t    toRow = fromRow;\n\t    toCell = fromCell;\n\t  }\n\t\n\t  /***\n\t   * @property fromRow\n\t   * @type {Integer}\n\t   */\n\t  this.fromRow = Math.min(fromRow, toRow);\n\t\n\t  /***\n\t   * @property fromCell\n\t   * @type {Integer}\n\t   */\n\t  this.fromCell = Math.min(fromCell, toCell);\n\t\n\t  /***\n\t   * @property toRow\n\t   * @type {Integer}\n\t   */\n\t  this.toRow = Math.max(fromRow, toRow);\n\t\n\t  /***\n\t   * @property toCell\n\t   * @type {Integer}\n\t   */\n\t  this.toCell = Math.max(fromCell, toCell);\n\t\n\t  /***\n\t   * Returns whether a range represents a single row.\n\t   * @method isSingleRow\n\t   * @return {Boolean}\n\t   */\n\t  this.isSingleRow = function () {\n\t    return this.fromRow == this.toRow;\n\t  };\n\t\n\t  /***\n\t   * Returns whether a range represents a single cell.\n\t   * @method isSingleCell\n\t   * @return {Boolean}\n\t   */\n\t  this.isSingleCell = function () {\n\t    return this.fromRow == this.toRow && this.fromCell == this.toCell;\n\t  };\n\t\n\t  /***\n\t   * Returns whether a range contains a given cell.\n\t   * @method contains\n\t   * @param row {Integer}\n\t   * @param cell {Integer}\n\t   * @return {Boolean}\n\t   */\n\t  this.contains = function (row, cell) {\n\t    return row >= this.fromRow && row <= this.toRow && cell >= this.fromCell && cell <= this.toCell;\n\t  };\n\t\n\t  /***\n\t   * Returns a readable representation of a range.\n\t   * @method toString\n\t   * @return {String}\n\t   */\n\t  this.toString = function () {\n\t    if (this.isSingleCell()) {\n\t      return \"(\" + this.fromRow + \":\" + this.fromCell + \")\";\n\t    } else {\n\t      return \"(\" + this.fromRow + \":\" + this.fromCell + \" - \" + this.toRow + \":\" + this.toCell + \")\";\n\t    }\n\t  };\n\t}\n\t\n\t/***\n\t * A base class that all special / non-data rows (like Group and GroupTotals) derive from.\n\t * @class NonDataItem\n\t * @constructor\n\t */\n\tfunction NonDataItem() {\n\t  this.__nonDataRow = true;\n\t}\n\t\n\t/***\n\t * Information about a group of rows.\n\t * @class Group\n\t * @extends Slick.NonDataItem\n\t * @constructor\n\t */\n\tfunction Group() {\n\t  this.__group = true;\n\t\n\t  /**\n\t   * Grouping level, starting with 0.\n\t   * @property level\n\t   * @type {Number}\n\t   */\n\t  this.level = 0;\n\t\n\t  /***\n\t   * Number of rows in the group.\n\t   * @property count\n\t   * @type {Integer}\n\t   */\n\t  this.count = 0;\n\t\n\t  /***\n\t   * Grouping value.\n\t   * @property value\n\t   * @type {Object}\n\t   */\n\t  this.value = null;\n\t\n\t  /***\n\t   * Formatted display value of the group.\n\t   * @property title\n\t   * @type {String}\n\t   */\n\t  this.title = null;\n\t\n\t  /***\n\t   * Whether a group is collapsed.\n\t   * @property collapsed\n\t   * @type {Boolean}\n\t   */\n\t  this.collapsed = false;\n\t\n\t  /***\n\t   * GroupTotals, if any.\n\t   * @property totals\n\t   * @type {GroupTotals}\n\t   */\n\t  this.totals = null;\n\t\n\t  /**\n\t   * Rows that are part of the group.\n\t   * @property rows\n\t   * @type {Array}\n\t   */\n\t  this.rows = [];\n\t\n\t  /**\n\t   * Sub-groups that are part of the group.\n\t   * @property groups\n\t   * @type {Array}\n\t   */\n\t  this.groups = null;\n\t\n\t  /**\n\t   * A unique key used to identify the group.  This key can be used in calls to DataView\n\t   * collapseGroup() or expandGroup().\n\t   * @property groupingKey\n\t   * @type {Object}\n\t   */\n\t  this.groupingKey = null;\n\t}\n\t\n\tGroup.prototype = new NonDataItem();\n\t\n\t/***\n\t * Compares two Group instances.\n\t * @method equals\n\t * @return {Boolean}\n\t * @param group {Group} Group instance to compare to.\n\t */\n\tGroup.prototype.equals = function (group) {\n\t  return this.value === group.value && this.count === group.count && this.collapsed === group.collapsed && this.title === group.title;\n\t};\n\t\n\t/***\n\t * Information about group totals.\n\t * An instance of GroupTotals will be created for each totals row and passed to the aggregators\n\t * so that they can store arbitrary data in it.  That data can later be accessed by group totals\n\t * formatters during the display.\n\t * @class GroupTotals\n\t * @extends Slick.NonDataItem\n\t * @constructor\n\t */\n\tfunction GroupTotals() {\n\t  this.__groupTotals = true;\n\t\n\t  /***\n\t   * Parent Group.\n\t   * @param group\n\t   * @type {Group}\n\t   */\n\t  this.group = null;\n\t\n\t  /***\n\t   * Whether the totals have been fully initialized / calculated.\n\t   * Will be set to false for lazy-calculated group totals.\n\t   * @param initialized\n\t   * @type {Boolean}\n\t   */\n\t  this.initialized = false;\n\t}\n\t\n\tGroupTotals.prototype = new NonDataItem();\n\t\n\t/***\n\t * A locking helper to track the active edit controller and ensure that only a single controller\n\t * can be active at a time.  This prevents a whole class of state and validation synchronization\n\t * issues.  An edit controller (such as SlickGrid) can query if an active edit is in progress\n\t * and attempt a commit or cancel before proceeding.\n\t * @class EditorLock\n\t * @constructor\n\t */\n\tfunction EditorLock() {\n\t  var activeEditController = null;\n\t\n\t  /***\n\t   * Returns true if a specified edit controller is active (has the edit lock).\n\t   * If the parameter is not specified, returns true if any edit controller is active.\n\t   * @method isActive\n\t   * @param editController {EditController}\n\t   * @return {Boolean}\n\t   */\n\t  this.isActive = function (editController) {\n\t    return editController ? activeEditController === editController : activeEditController !== null;\n\t  };\n\t\n\t  /***\n\t   * Sets the specified edit controller as the active edit controller (acquire edit lock).\n\t   * If another edit controller is already active, and exception will be thrown.\n\t   * @method activate\n\t   * @param editController {EditController} edit controller acquiring the lock\n\t   */\n\t  this.activate = function (editController) {\n\t    if (editController === activeEditController) {\n\t      // already activated?\n\t      return;\n\t    }\n\t    if (activeEditController !== null) {\n\t      throw \"SlickGrid.EditorLock.activate: an editController is still active, can't activate another editController\";\n\t    }\n\t    if (!editController.commitCurrentEdit) {\n\t      throw \"SlickGrid.EditorLock.activate: editController must implement .commitCurrentEdit()\";\n\t    }\n\t    if (!editController.cancelCurrentEdit) {\n\t      throw \"SlickGrid.EditorLock.activate: editController must implement .cancelCurrentEdit()\";\n\t    }\n\t    activeEditController = editController;\n\t  };\n\t\n\t  /***\n\t   * Unsets the specified edit controller as the active edit controller (release edit lock).\n\t   * If the specified edit controller is not the active one, an exception will be thrown.\n\t   * @method deactivate\n\t   * @param editController {EditController} edit controller releasing the lock\n\t   */\n\t  this.deactivate = function (editController) {\n\t    if (activeEditController !== editController) {\n\t      throw \"SlickGrid.EditorLock.deactivate: specified editController is not the currently active one\";\n\t    }\n\t    activeEditController = null;\n\t  };\n\t\n\t  /***\n\t   * Attempts to commit the current edit by calling \"commitCurrentEdit\" method on the active edit\n\t   * controller and returns whether the commit attempt was successful (commit may fail due to validation\n\t   * errors, etc.).  Edit controller's \"commitCurrentEdit\" must return true if the commit has succeeded\n\t   * and false otherwise.  If no edit controller is active, returns true.\n\t   * @method commitCurrentEdit\n\t   * @return {Boolean}\n\t   */\n\t  this.commitCurrentEdit = function () {\n\t    return activeEditController ? activeEditController.commitCurrentEdit() : true;\n\t  };\n\t\n\t  /***\n\t   * Attempts to cancel the current edit by calling \"cancelCurrentEdit\" method on the active edit\n\t   * controller and returns whether the edit was successfully cancelled.  If no edit controller is\n\t   * active, returns true.\n\t   * @method cancelCurrentEdit\n\t   * @return {Boolean}\n\t   */\n\t  this.cancelCurrentEdit = function cancelCurrentEdit() {\n\t    return activeEditController ? activeEditController.cancelCurrentEdit() : true;\n\t  };\n\t}\n\t\n\t/**\n\t *\n\t * @param {Array} treeColumns Array com levels of columns\n\t * @returns {{hasDepth: 'hasDepth', getTreeColumns: 'getTreeColumns', extractColumns: 'extractColumns', getDepth: 'getDepth', getColumnsInDepth: 'getColumnsInDepth', getColumnsInGroup: 'getColumnsInGroup', visibleColumns: 'visibleColumns', filter: 'filter', reOrder: reOrder}}\n\t * @constructor\n\t */\n\tfunction TreeColumns(treeColumns) {\n\t\n\t  var columnsById = {};\n\t\n\t  function init() {\n\t    mapToId(treeColumns);\n\t  }\n\t\n\t  function mapToId(columns) {\n\t    columns.forEach(function (column) {\n\t      columnsById[column.id] = column;\n\t\n\t      if (column.columns) mapToId(column.columns);\n\t    });\n\t  }\n\t\n\t  function filter(node, condition) {\n\t\n\t    return node.filter(function (column) {\n\t\n\t      var valid = condition.call(column);\n\t\n\t      if (valid && column.columns) column.columns = filter(column.columns, condition);\n\t\n\t      return valid && (!column.columns || column.columns.length);\n\t    });\n\t  }\n\t\n\t  function sort(columns, grid) {\n\t    columns.sort(function (a, b) {\n\t      var indexA = getOrDefault(grid.getColumnIndex(a.id)),\n\t          indexB = getOrDefault(grid.getColumnIndex(b.id));\n\t\n\t      return indexA - indexB;\n\t    }).forEach(function (column) {\n\t      if (column.columns) sort(column.columns, grid);\n\t    });\n\t  }\n\t\n\t  function getOrDefault(value) {\n\t    return typeof value === 'undefined' ? -1 : value;\n\t  }\n\t\n\t  function getDepth(node) {\n\t    if (node.length) for (var i in node) {\n\t      return getDepth(node[i]);\n\t    } else if (node.columns) return 1 + getDepth(node.columns);else return 1;\n\t  }\n\t\n\t  function getColumnsInDepth(node, depth, current) {\n\t    var columns = [];\n\t    current = current || 0;\n\t\n\t    if (depth == current) {\n\t\n\t      if (node.length) node.forEach(function (n) {\n\t        if (n.columns) n.extractColumns = function () {\n\t          return extractColumns(n);\n\t        };\n\t      });\n\t\n\t      return node;\n\t    } else for (var i in node) {\n\t      if (node[i].columns) {\n\t        columns = columns.concat(getColumnsInDepth(node[i].columns, depth, current + 1));\n\t      }\n\t    }return columns;\n\t  }\n\t\n\t  function extractColumns(node) {\n\t    var result = [];\n\t\n\t    if (node.hasOwnProperty('length')) {\n\t\n\t      for (var i = 0; i < node.length; i++) {\n\t        result = result.concat(extractColumns(node[i]));\n\t      }\n\t    } else {\n\t\n\t      if (node.hasOwnProperty('columns')) result = result.concat(extractColumns(node.columns));else return node;\n\t    }\n\t\n\t    return result;\n\t  }\n\t\n\t  function cloneTreeColumns() {\n\t    return $.extend(true, [], treeColumns);\n\t  }\n\t\n\t  init();\n\t\n\t  this.hasDepth = function () {\n\t\n\t    for (var i in treeColumns) {\n\t      if (treeColumns[i].hasOwnProperty('columns')) return true;\n\t    }return false;\n\t  };\n\t\n\t  this.getTreeColumns = function () {\n\t    return treeColumns;\n\t  };\n\t\n\t  this.extractColumns = function () {\n\t    return this.hasDepth() ? extractColumns(treeColumns) : treeColumns;\n\t  };\n\t\n\t  this.getDepth = function () {\n\t    return getDepth(treeColumns);\n\t  };\n\t\n\t  this.getColumnsInDepth = function (depth) {\n\t    return getColumnsInDepth(treeColumns, depth);\n\t  };\n\t\n\t  this.getColumnsInGroup = function (groups) {\n\t    return extractColumns(groups);\n\t  };\n\t\n\t  this.visibleColumns = function () {\n\t    return filter(cloneTreeColumns(), function () {\n\t      return this.visible;\n\t    });\n\t  };\n\t\n\t  this.filter = function (condition) {\n\t    return filter(cloneTreeColumns(), condition);\n\t  };\n\t\n\t  this.reOrder = function (grid) {\n\t    return sort(treeColumns, grid);\n\t  };\n\t\n\t  this.getById = function (id) {\n\t    return columnsById[id];\n\t  };\n\t\n\t  this.getInIds = function (ids) {\n\t    return ids.map(function (id) {\n\t      return columnsById[id];\n\t    });\n\t  };\n\t}\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports) {\n\n\tmodule.exports = require(\"jquery\");\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _slick = __webpack_require__(1);\n\t\n\tObject.defineProperty(exports, 'Slick', {\n\t  enumerable: true,\n\t  get: function get() {\n\t    return _interopRequireDefault(_slick).default;\n\t  }\n\t});\n\t\n\tvar _slick2 = __webpack_require__(6);\n\t\n\tObject.defineProperty(exports, 'Data', {\n\t  enumerable: true,\n\t  get: function get() {\n\t    return _interopRequireDefault(_slick2).default;\n\t  }\n\t});\n\t\n\tvar _slickFrozen = __webpack_require__(5);\n\t\n\tObject.defineProperty(exports, 'Grid', {\n\t  enumerable: true,\n\t  get: function get() {\n\t    return _interopRequireDefault(_slickFrozen).default;\n\t  }\n\t});\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\t\n\t/**\n\t * interact.js v1.2.6\n\t *\n\t * Copyright (c) 2012-2015 Taye Adeyemi <dev@taye.me>\n\t * Open source under the MIT License.\n\t * https://raw.github.com/taye/interact.js/master/LICENSE\n\t *\n\t * This file has been monkey patched to pass the originalEvent on to drag events\n\t */\n\t(function (realWindow) {\n\t  'use strict';\n\t\n\t  // return early if there's no window to work with (eg. Node.js)\n\t\n\t  if (!realWindow) {\n\t    return;\n\t  }\n\t\n\t  var // get wrapped window if using Shadow DOM polyfill\n\t  window = function () {\n\t    // create a TextNode\n\t    var el = realWindow.document.createTextNode('');\n\t\n\t    // check if it's wrapped by a polyfill\n\t    if (el.ownerDocument !== realWindow.document && typeof realWindow.wrap === 'function' && realWindow.wrap(el) === el) {\n\t      // return wrapped window\n\t      return realWindow.wrap(realWindow);\n\t    }\n\t\n\t    // no Shadow DOM polyfil or native implementation\n\t    return realWindow;\n\t  }(),\n\t      document = window.document,\n\t      DocumentFragment = window.DocumentFragment || blank,\n\t      SVGElement = window.SVGElement || blank,\n\t      SVGSVGElement = window.SVGSVGElement || blank,\n\t      SVGElementInstance = window.SVGElementInstance || blank,\n\t      HTMLElement = window.HTMLElement || window.Element,\n\t      PointerEvent = window.PointerEvent || window.MSPointerEvent,\n\t      pEventTypes,\n\t      hypot = Math.hypot || function (x, y) {\n\t    return Math.sqrt(x * x + y * y);\n\t  },\n\t      tmpXY = {},\n\t      // reduce object creation in getXY()\n\t\n\t  documents = [],\n\t      // all documents being listened to\n\t\n\t  interactables = [],\n\t      // all set interactables\n\t  interactions = [],\n\t      // all interactions\n\t\n\t  dynamicDrop = false,\n\t\n\t\n\t  // {\n\t  //      type: {\n\t  //          selectors: ['selector', ...],\n\t  //          contexts : [document, ...],\n\t  //          listeners: [[listener, useCapture], ...]\n\t  //      }\n\t  //  }\n\t  delegatedEvents = {},\n\t      defaultOptions = {\n\t    base: {\n\t      accept: null,\n\t      actionChecker: null,\n\t      styleCursor: true,\n\t      preventDefault: 'auto',\n\t      origin: { x: 0, y: 0 },\n\t      deltaSource: 'page',\n\t      allowFrom: null,\n\t      ignoreFrom: null,\n\t      _context: document,\n\t      dropChecker: null\n\t    },\n\t\n\t    drag: {\n\t      enabled: false,\n\t      manualStart: true,\n\t      max: Infinity,\n\t      maxPerElement: 1,\n\t\n\t      snap: null,\n\t      restrict: null,\n\t      inertia: null,\n\t      autoScroll: null,\n\t\n\t      axis: 'xy'\n\t    },\n\t\n\t    drop: {\n\t      enabled: false,\n\t      accept: null,\n\t      overlap: 'pointer'\n\t    },\n\t\n\t    resize: {\n\t      enabled: false,\n\t      manualStart: false,\n\t      max: Infinity,\n\t      maxPerElement: 1,\n\t\n\t      snap: null,\n\t      restrict: null,\n\t      inertia: null,\n\t      autoScroll: null,\n\t\n\t      square: false,\n\t      preserveAspectRatio: false,\n\t      axis: 'xy',\n\t\n\t      // use default margin\n\t      margin: NaN,\n\t\n\t      // object with props left, right, top, bottom which are\n\t      // true/false values to resize when the pointer is over that edge,\n\t      // CSS selectors to match the handles for each direction\n\t      // or the Elements for each handle\n\t      edges: null,\n\t\n\t      // a value of 'none' will limit the resize rect to a minimum of 0x0\n\t      // 'negate' will alow the rect to have negative width/height\n\t      // 'reposition' will keep the width/height positive by swapping\n\t      // the top and bottom edges and/or swapping the left and right edges\n\t      invert: 'none'\n\t    },\n\t\n\t    gesture: {\n\t      manualStart: false,\n\t      enabled: false,\n\t      max: Infinity,\n\t      maxPerElement: 1,\n\t\n\t      restrict: null\n\t    },\n\t\n\t    perAction: {\n\t      manualStart: false,\n\t      max: Infinity,\n\t      maxPerElement: 1,\n\t\n\t      snap: {\n\t        enabled: false,\n\t        endOnly: false,\n\t        range: Infinity,\n\t        targets: null,\n\t        offsets: null,\n\t\n\t        relativePoints: null\n\t      },\n\t\n\t      restrict: {\n\t        enabled: false,\n\t        endOnly: false\n\t      },\n\t\n\t      autoScroll: {\n\t        enabled: false,\n\t        container: null, // the item that is scrolled (Window or HTMLElement)\n\t        margin: 60,\n\t        speed: 300 // the scroll speed in pixels per second\n\t      },\n\t\n\t      inertia: {\n\t        enabled: false,\n\t        resistance: 10, // the lambda in exponential decay\n\t        minSpeed: 100, // target speed must be above this for inertia to start\n\t        endSpeed: 10, // the speed at which inertia is slow enough to stop\n\t        allowResume: true, // allow resuming an action in inertia phase\n\t        zeroResumeDelta: true, // if an action is resumed after launch, set dx/dy to 0\n\t        smoothEndDuration: 300 // animate to snap/restrict endOnly if there's no inertia\n\t      }\n\t    },\n\t\n\t    _holdDuration: 600\n\t  },\n\t\n\t\n\t  // Things related to autoScroll\n\t  autoScroll = {\n\t    interaction: null,\n\t    i: null, // the handle returned by window.setInterval\n\t    x: 0, y: 0, // Direction each pulse is to scroll in\n\t\n\t    // scroll the window by the values in scroll.x/y\n\t    scroll: function scroll() {\n\t      var options = autoScroll.interaction.target.options[autoScroll.interaction.prepared.name].autoScroll,\n\t          container = options.container || getWindow(autoScroll.interaction.element),\n\t          now = new Date().getTime(),\n\t\n\t      // change in time in seconds\n\t      dtx = (now - autoScroll.prevTimeX) / 1000,\n\t          dty = (now - autoScroll.prevTimeY) / 1000,\n\t          vx,\n\t          vy,\n\t          sx,\n\t          sy;\n\t\n\t      // displacement\n\t      if (options.velocity) {\n\t        vx = options.velocity.x;\n\t        vy = options.velocity.y;\n\t      } else {\n\t        vx = vy = options.speed;\n\t      }\n\t\n\t      sx = vx * dtx;\n\t      sy = vy * dty;\n\t\n\t      if (sx >= 1 || sy >= 1) {\n\t        if (isWindow(container)) {\n\t          container.scrollBy(autoScroll.x * sx, autoScroll.y * sy);\n\t        } else if (container) {\n\t          container.scrollLeft += autoScroll.x * sx;\n\t          container.scrollTop += autoScroll.y * sy;\n\t        }\n\t\n\t        if (sx >= 1) autoScroll.prevTimeX = now;\n\t        if (sy >= 1) autoScroll.prevTimeY = now;\n\t      }\n\t\n\t      if (autoScroll.isScrolling) {\n\t        cancelFrame(autoScroll.i);\n\t        autoScroll.i = reqFrame(autoScroll.scroll);\n\t      }\n\t    },\n\t\n\t    isScrolling: false,\n\t    prevTimeX: 0,\n\t    prevTimeY: 0,\n\t\n\t    start: function start(interaction) {\n\t      autoScroll.isScrolling = true;\n\t      cancelFrame(autoScroll.i);\n\t\n\t      autoScroll.interaction = interaction;\n\t      autoScroll.prevTimeX = new Date().getTime();\n\t      autoScroll.prevTimeY = new Date().getTime();\n\t      autoScroll.i = reqFrame(autoScroll.scroll);\n\t    },\n\t\n\t    stop: function stop() {\n\t      autoScroll.isScrolling = false;\n\t      cancelFrame(autoScroll.i);\n\t    }\n\t  },\n\t\n\t\n\t  // Does the browser support touch input?\n\t  supportsTouch = 'ontouchstart' in window || window.DocumentTouch && document instanceof window.DocumentTouch,\n\t\n\t\n\t  // Does the browser support PointerEvents\n\t  // Avoid PointerEvent bugs introduced in Chrome 55\n\t  supportsPointerEvent = PointerEvent && !/Chrome/.test(navigator.userAgent),\n\t\n\t\n\t  // Less Precision with touch input\n\t  margin = supportsTouch || supportsPointerEvent ? 20 : 10,\n\t      pointerMoveTolerance = 1,\n\t\n\t\n\t  // for ignoring browser's simulated mouse events\n\t  prevTouchTime = 0,\n\t\n\t\n\t  // Allow this many interactions to happen simultaneously\n\t  maxInteractions = Infinity,\n\t\n\t\n\t  // Check if is IE9 or older\n\t  actionCursors = document.all && !window.atob ? {\n\t    drag: 'move',\n\t    resizex: 'e-resize',\n\t    resizey: 's-resize',\n\t    resizexy: 'se-resize',\n\t\n\t    resizetop: 'n-resize',\n\t    resizeleft: 'w-resize',\n\t    resizebottom: 's-resize',\n\t    resizeright: 'e-resize',\n\t    resizetopleft: 'se-resize',\n\t    resizebottomright: 'se-resize',\n\t    resizetopright: 'ne-resize',\n\t    resizebottomleft: 'ne-resize',\n\t\n\t    gesture: ''\n\t  } : {\n\t    drag: 'move',\n\t    resizex: 'ew-resize',\n\t    resizey: 'ns-resize',\n\t    resizexy: 'nwse-resize',\n\t\n\t    resizetop: 'ns-resize',\n\t    resizeleft: 'ew-resize',\n\t    resizebottom: 'ns-resize',\n\t    resizeright: 'ew-resize',\n\t    resizetopleft: 'nwse-resize',\n\t    resizebottomright: 'nwse-resize',\n\t    resizetopright: 'nesw-resize',\n\t    resizebottomleft: 'nesw-resize',\n\t\n\t    gesture: ''\n\t  },\n\t      actionIsEnabled = {\n\t    drag: true,\n\t    resize: true,\n\t    gesture: true\n\t  },\n\t\n\t\n\t  // because Webkit and Opera still use 'mousewheel' event type\n\t  wheelEvent = 'onmousewheel' in document ? 'mousewheel' : 'wheel',\n\t      eventTypes = ['dragstart', 'dragmove', 'draginertiastart', 'dragend', 'dragenter', 'dragleave', 'dropactivate', 'dropdeactivate', 'dropmove', 'drop', 'resizestart', 'resizemove', 'resizeinertiastart', 'resizeend', 'gesturestart', 'gesturemove', 'gestureinertiastart', 'gestureend', 'down', 'move', 'up', 'cancel', 'tap', 'doubletap', 'hold'],\n\t      globalEvents = {},\n\t\n\t\n\t  // Opera Mobile must be handled differently\n\t  isOperaMobile = navigator.appName == 'Opera' && supportsTouch && navigator.userAgent.match('Presto'),\n\t\n\t\n\t  // scrolling doesn't change the result of getClientRects on iOS 7\n\t  isIOS7 = /iP(hone|od|ad)/.test(navigator.platform) && /OS 7[^\\d]/.test(navigator.appVersion),\n\t\n\t\n\t  // prefix matchesSelector\n\t  prefixedMatchesSelector = 'matches' in Element.prototype ? 'matches' : 'webkitMatchesSelector' in Element.prototype ? 'webkitMatchesSelector' : 'mozMatchesSelector' in Element.prototype ? 'mozMatchesSelector' : 'oMatchesSelector' in Element.prototype ? 'oMatchesSelector' : 'msMatchesSelector',\n\t\n\t\n\t  // will be polyfill function if browser is IE8\n\t  ie8MatchesSelector,\n\t\n\t\n\t  // native requestAnimationFrame or polyfill\n\t  reqFrame = realWindow.requestAnimationFrame,\n\t      cancelFrame = realWindow.cancelAnimationFrame,\n\t\n\t\n\t  // Events wrapper\n\t  events = function () {\n\t    var useAttachEvent = 'attachEvent' in window && !('addEventListener' in window),\n\t        addEvent = useAttachEvent ? 'attachEvent' : 'addEventListener',\n\t        removeEvent = useAttachEvent ? 'detachEvent' : 'removeEventListener',\n\t        on = useAttachEvent ? 'on' : '',\n\t        elements = [],\n\t        targets = [],\n\t        attachedListeners = [];\n\t\n\t    function add(element, type, listener, useCapture) {\n\t      var elementIndex = indexOf(elements, element),\n\t          target = targets[elementIndex];\n\t\n\t      if (!target) {\n\t        target = {\n\t          events: {},\n\t          typeCount: 0\n\t        };\n\t\n\t        elementIndex = elements.push(element) - 1;\n\t        targets.push(target);\n\t\n\t        attachedListeners.push(useAttachEvent ? {\n\t          supplied: [],\n\t          wrapped: [],\n\t          useCount: []\n\t        } : null);\n\t      }\n\t\n\t      if (!target.events[type]) {\n\t        target.events[type] = [];\n\t        target.typeCount++;\n\t      }\n\t\n\t      if (!contains(target.events[type], listener)) {\n\t        var ret;\n\t\n\t        if (useAttachEvent) {\n\t          var listeners = attachedListeners[elementIndex],\n\t              listenerIndex = indexOf(listeners.supplied, listener);\n\t\n\t          var wrapped = listeners.wrapped[listenerIndex] || function (event) {\n\t            if (!event.immediatePropagationStopped) {\n\t              event.target = event.srcElement;\n\t              event.currentTarget = element;\n\t\n\t              event.preventDefault = event.preventDefault || preventDef;\n\t              event.stopPropagation = event.stopPropagation || stopProp;\n\t              event.stopImmediatePropagation = event.stopImmediatePropagation || stopImmProp;\n\t\n\t              if (/mouse|click/.test(event.type)) {\n\t                event.pageX = event.clientX + getWindow(element).document.documentElement.scrollLeft;\n\t                event.pageY = event.clientY + getWindow(element).document.documentElement.scrollTop;\n\t              }\n\t\n\t              listener(event);\n\t            }\n\t          };\n\t\n\t          ret = element[addEvent](on + type, wrapped, Boolean(useCapture));\n\t\n\t          if (listenerIndex === -1) {\n\t            listeners.supplied.push(listener);\n\t            listeners.wrapped.push(wrapped);\n\t            listeners.useCount.push(1);\n\t          } else {\n\t            listeners.useCount[listenerIndex]++;\n\t          }\n\t        } else {\n\t          ret = element[addEvent](type, listener, useCapture || false);\n\t        }\n\t        target.events[type].push(listener);\n\t\n\t        return ret;\n\t      }\n\t    }\n\t\n\t    function remove(element, type, listener, useCapture) {\n\t      var i,\n\t          elementIndex = indexOf(elements, element),\n\t          target = targets[elementIndex],\n\t          listeners,\n\t          listenerIndex,\n\t          wrapped = listener;\n\t\n\t      if (!target || !target.events) {\n\t        return;\n\t      }\n\t\n\t      if (useAttachEvent) {\n\t        listeners = attachedListeners[elementIndex];\n\t        listenerIndex = indexOf(listeners.supplied, listener);\n\t        wrapped = listeners.wrapped[listenerIndex];\n\t      }\n\t\n\t      if (type === 'all') {\n\t        for (type in target.events) {\n\t          if (target.events.hasOwnProperty(type)) {\n\t            remove(element, type, 'all');\n\t          }\n\t        }\n\t        return;\n\t      }\n\t\n\t      if (target.events[type]) {\n\t        var len = target.events[type].length;\n\t\n\t        if (listener === 'all') {\n\t          for (i = 0; i < len; i++) {\n\t            remove(element, type, target.events[type][i], Boolean(useCapture));\n\t          }\n\t          return;\n\t        } else {\n\t          for (i = 0; i < len; i++) {\n\t            if (target.events[type][i] === listener) {\n\t              element[removeEvent](on + type, wrapped, useCapture || false);\n\t              target.events[type].splice(i, 1);\n\t\n\t              if (useAttachEvent && listeners) {\n\t                listeners.useCount[listenerIndex]--;\n\t                if (listeners.useCount[listenerIndex] === 0) {\n\t                  listeners.supplied.splice(listenerIndex, 1);\n\t                  listeners.wrapped.splice(listenerIndex, 1);\n\t                  listeners.useCount.splice(listenerIndex, 1);\n\t                }\n\t              }\n\t\n\t              break;\n\t            }\n\t          }\n\t        }\n\t\n\t        if (target.events[type] && target.events[type].length === 0) {\n\t          target.events[type] = null;\n\t          target.typeCount--;\n\t        }\n\t      }\n\t\n\t      if (!target.typeCount) {\n\t        targets.splice(elementIndex, 1);\n\t        elements.splice(elementIndex, 1);\n\t        attachedListeners.splice(elementIndex, 1);\n\t      }\n\t    }\n\t\n\t    function preventDef() {\n\t      this.returnValue = false;\n\t    }\n\t\n\t    function stopProp() {\n\t      this.cancelBubble = true;\n\t    }\n\t\n\t    function stopImmProp() {\n\t      this.cancelBubble = true;\n\t      this.immediatePropagationStopped = true;\n\t    }\n\t\n\t    return {\n\t      add: add,\n\t      remove: remove,\n\t      useAttachEvent: useAttachEvent,\n\t\n\t      _elements: elements,\n\t      _targets: targets,\n\t      _attachedListeners: attachedListeners\n\t    };\n\t  }();\n\t\n\t  function blank() {}\n\t\n\t  function isElement(o) {\n\t    if (!o || (typeof o === 'undefined' ? 'undefined' : _typeof(o)) !== 'object') {\n\t      return false;\n\t    }\n\t\n\t    var _window = getWindow(o) || window;\n\t\n\t    return (/object|function/.test(_typeof(_window.Element)) ? o instanceof _window.Element //DOM2\n\t      : o.nodeType === 1 && typeof o.nodeName === \"string\"\n\t    );\n\t  }\n\t  function isWindow(thing) {\n\t    return thing === window || !!(thing && thing.Window) && thing instanceof thing.Window;\n\t  }\n\t  function isDocFrag(thing) {\n\t    return !!thing && thing instanceof DocumentFragment;\n\t  }\n\t  function isArray(thing) {\n\t    return isObject(thing) && _typeof(thing.length) !== undefined && isFunction(thing.splice);\n\t  }\n\t  function isObject(thing) {\n\t    return !!thing && (typeof thing === 'undefined' ? 'undefined' : _typeof(thing)) === 'object';\n\t  }\n\t  function isFunction(thing) {\n\t    return typeof thing === 'function';\n\t  }\n\t  function isNumber(thing) {\n\t    return typeof thing === 'number';\n\t  }\n\t  function isBool(thing) {\n\t    return typeof thing === 'boolean';\n\t  }\n\t  function isString(thing) {\n\t    return typeof thing === 'string';\n\t  }\n\t\n\t  function trySelector(value) {\n\t    if (!isString(value)) {\n\t      return false;\n\t    }\n\t\n\t    // an exception will be raised if it is invalid\n\t    document.querySelector(value);\n\t    return true;\n\t  }\n\t\n\t  function extend(dest, source) {\n\t    for (var prop in source) {\n\t      dest[prop] = source[prop];\n\t    }\n\t    return dest;\n\t  }\n\t\n\t  var prefixedPropREs = {\n\t    webkit: /(Movement[XY]|Radius[XY]|RotationAngle|Force)$/\n\t  };\n\t\n\t  function pointerExtend(dest, source) {\n\t    for (var prop in source) {\n\t      var deprecated = false;\n\t\n\t      // skip deprecated prefixed properties\n\t      for (var vendor in prefixedPropREs) {\n\t        if (prop.indexOf(vendor) === 0 && prefixedPropREs[vendor].test(prop)) {\n\t          deprecated = true;\n\t          break;\n\t        }\n\t      }\n\t\n\t      if (!deprecated) {\n\t        dest[prop] = source[prop];\n\t      }\n\t    }\n\t    return dest;\n\t  }\n\t\n\t  function copyCoords(dest, src) {\n\t    dest.page = dest.page || {};\n\t    dest.page.x = src.page.x;\n\t    dest.page.y = src.page.y;\n\t\n\t    dest.client = dest.client || {};\n\t    dest.client.x = src.client.x;\n\t    dest.client.y = src.client.y;\n\t\n\t    dest.timeStamp = src.timeStamp;\n\t  }\n\t\n\t  function _setEventXY(targetObj, pointers, interaction) {\n\t    var pointer = pointers.length > 1 ? pointerAverage(pointers) : pointers[0];\n\t\n\t    _getPageXY(pointer, tmpXY, interaction);\n\t    targetObj.page.x = tmpXY.x;\n\t    targetObj.page.y = tmpXY.y;\n\t\n\t    _getClientXY(pointer, tmpXY, interaction);\n\t    targetObj.client.x = tmpXY.x;\n\t    targetObj.client.y = tmpXY.y;\n\t\n\t    targetObj.timeStamp = new Date().getTime();\n\t  }\n\t\n\t  function setEventDeltas(targetObj, prev, cur) {\n\t    targetObj.page.x = cur.page.x - prev.page.x;\n\t    targetObj.page.y = cur.page.y - prev.page.y;\n\t    targetObj.client.x = cur.client.x - prev.client.x;\n\t    targetObj.client.y = cur.client.y - prev.client.y;\n\t    targetObj.timeStamp = new Date().getTime() - prev.timeStamp;\n\t\n\t    // set pointer velocity\n\t    var dt = Math.max(targetObj.timeStamp / 1000, 0.001);\n\t    targetObj.page.speed = hypot(targetObj.page.x, targetObj.page.y) / dt;\n\t    targetObj.page.vx = targetObj.page.x / dt;\n\t    targetObj.page.vy = targetObj.page.y / dt;\n\t\n\t    targetObj.client.speed = hypot(targetObj.client.x, targetObj.page.y) / dt;\n\t    targetObj.client.vx = targetObj.client.x / dt;\n\t    targetObj.client.vy = targetObj.client.y / dt;\n\t  }\n\t\n\t  function isNativePointer(pointer) {\n\t    return pointer instanceof window.Event || supportsTouch && window.Touch && pointer instanceof window.Touch;\n\t  }\n\t\n\t  // Get specified X/Y coords for mouse or event.touches[0]\n\t  function getXY(type, pointer, xy) {\n\t    xy = xy || {};\n\t    type = type || 'page';\n\t\n\t    xy.x = pointer[type + 'X'];\n\t    xy.y = pointer[type + 'Y'];\n\t\n\t    return xy;\n\t  }\n\t\n\t  function _getPageXY(pointer, page) {\n\t    page = page || {};\n\t\n\t    // Opera Mobile handles the viewport and scrolling oddly\n\t    if (isOperaMobile && isNativePointer(pointer)) {\n\t      getXY('screen', pointer, page);\n\t\n\t      page.x += window.scrollX;\n\t      page.y += window.scrollY;\n\t    } else {\n\t      getXY('page', pointer, page);\n\t    }\n\t\n\t    return page;\n\t  }\n\t\n\t  function _getClientXY(pointer, client) {\n\t    client = client || {};\n\t\n\t    if (isOperaMobile && isNativePointer(pointer)) {\n\t      // Opera Mobile handles the viewport and scrolling oddly\n\t      getXY('screen', pointer, client);\n\t    } else {\n\t      getXY('client', pointer, client);\n\t    }\n\t\n\t    return client;\n\t  }\n\t\n\t  function getScrollXY(win) {\n\t    win = win || window;\n\t    return {\n\t      x: win.scrollX || win.document.documentElement.scrollLeft,\n\t      y: win.scrollY || win.document.documentElement.scrollTop\n\t    };\n\t  }\n\t\n\t  function getPointerId(pointer) {\n\t    return isNumber(pointer.pointerId) ? pointer.pointerId : pointer.identifier;\n\t  }\n\t\n\t  function getActualElement(element) {\n\t    return element instanceof SVGElementInstance ? element.correspondingUseElement : element;\n\t  }\n\t\n\t  function getWindow(node) {\n\t    if (isWindow(node)) {\n\t      return node;\n\t    }\n\t\n\t    var rootNode = node.ownerDocument || node;\n\t\n\t    return rootNode.defaultView || rootNode.parentWindow || window;\n\t  }\n\t\n\t  function getElementClientRect(element) {\n\t    var clientRect = element instanceof SVGElement ? element.getBoundingClientRect() : element.getClientRects()[0];\n\t\n\t    return clientRect && {\n\t      left: clientRect.left,\n\t      right: clientRect.right,\n\t      top: clientRect.top,\n\t      bottom: clientRect.bottom,\n\t      width: clientRect.width || clientRect.right - clientRect.left,\n\t      height: clientRect.height || clientRect.bottom - clientRect.top\n\t    };\n\t  }\n\t\n\t  function getElementRect(element) {\n\t    var clientRect = getElementClientRect(element);\n\t\n\t    if (!isIOS7 && clientRect) {\n\t      var scroll = getScrollXY(getWindow(element));\n\t\n\t      clientRect.left += scroll.x;\n\t      clientRect.right += scroll.x;\n\t      clientRect.top += scroll.y;\n\t      clientRect.bottom += scroll.y;\n\t    }\n\t\n\t    return clientRect;\n\t  }\n\t\n\t  function getTouchPair(event) {\n\t    var touches = [];\n\t\n\t    // array of touches is supplied\n\t    if (isArray(event)) {\n\t      touches[0] = event[0];\n\t      touches[1] = event[1];\n\t    }\n\t    // an event\n\t    else {\n\t        if (event.type === 'touchend') {\n\t          if (event.touches.length === 1) {\n\t            touches[0] = event.touches[0];\n\t            touches[1] = event.changedTouches[0];\n\t          } else if (event.touches.length === 0) {\n\t            touches[0] = event.changedTouches[0];\n\t            touches[1] = event.changedTouches[1];\n\t          }\n\t        } else {\n\t          touches[0] = event.touches[0];\n\t          touches[1] = event.touches[1];\n\t        }\n\t      }\n\t\n\t    return touches;\n\t  }\n\t\n\t  function pointerAverage(pointers) {\n\t    var average = {\n\t      pageX: 0,\n\t      pageY: 0,\n\t      clientX: 0,\n\t      clientY: 0,\n\t      screenX: 0,\n\t      screenY: 0\n\t    };\n\t    var prop;\n\t\n\t    for (var i = 0; i < pointers.length; i++) {\n\t      for (prop in average) {\n\t        average[prop] += pointers[i][prop];\n\t      }\n\t    }\n\t    for (prop in average) {\n\t      average[prop] /= pointers.length;\n\t    }\n\t\n\t    return average;\n\t  }\n\t\n\t  function touchBBox(event) {\n\t    if (!event.length && !(event.touches && event.touches.length > 1)) {\n\t      return;\n\t    }\n\t\n\t    var touches = getTouchPair(event),\n\t        minX = Math.min(touches[0].pageX, touches[1].pageX),\n\t        minY = Math.min(touches[0].pageY, touches[1].pageY),\n\t        maxX = Math.max(touches[0].pageX, touches[1].pageX),\n\t        maxY = Math.max(touches[0].pageY, touches[1].pageY);\n\t\n\t    return {\n\t      x: minX,\n\t      y: minY,\n\t      left: minX,\n\t      top: minY,\n\t      width: maxX - minX,\n\t      height: maxY - minY\n\t    };\n\t  }\n\t\n\t  function touchDistance(event, deltaSource) {\n\t    deltaSource = deltaSource || defaultOptions.deltaSource;\n\t\n\t    var sourceX = deltaSource + 'X',\n\t        sourceY = deltaSource + 'Y',\n\t        touches = getTouchPair(event);\n\t\n\t    var dx = touches[0][sourceX] - touches[1][sourceX],\n\t        dy = touches[0][sourceY] - touches[1][sourceY];\n\t\n\t    return hypot(dx, dy);\n\t  }\n\t\n\t  function touchAngle(event, prevAngle, deltaSource) {\n\t    deltaSource = deltaSource || defaultOptions.deltaSource;\n\t\n\t    var sourceX = deltaSource + 'X',\n\t        sourceY = deltaSource + 'Y',\n\t        touches = getTouchPair(event),\n\t        dx = touches[0][sourceX] - touches[1][sourceX],\n\t        dy = touches[0][sourceY] - touches[1][sourceY],\n\t        angle = 180 * Math.atan(dy / dx) / Math.PI;\n\t\n\t    if (isNumber(prevAngle)) {\n\t      var dr = angle - prevAngle,\n\t          drClamped = dr % 360;\n\t\n\t      if (drClamped > 315) {\n\t        angle -= 360 + angle / 360 | 0 * 360;\n\t      } else if (drClamped > 135) {\n\t        angle -= 180 + angle / 360 | 0 * 360;\n\t      } else if (drClamped < -315) {\n\t        angle += 360 + angle / 360 | 0 * 360;\n\t      } else if (drClamped < -135) {\n\t        angle += 180 + angle / 360 | 0 * 360;\n\t      }\n\t    }\n\t\n\t    return angle;\n\t  }\n\t\n\t  function getOriginXY(interactable, element) {\n\t    var origin = interactable ? interactable.options.origin : defaultOptions.origin;\n\t\n\t    if (origin === 'parent') {\n\t      origin = parentElement(element);\n\t    } else if (origin === 'self') {\n\t      origin = interactable.getRect(element);\n\t    } else if (trySelector(origin)) {\n\t      origin = closest(element, origin) || { x: 0, y: 0 };\n\t    }\n\t\n\t    if (isFunction(origin)) {\n\t      origin = origin(interactable && element);\n\t    }\n\t\n\t    if (isElement(origin)) {\n\t      origin = getElementRect(origin);\n\t    }\n\t\n\t    origin.x = 'x' in origin ? origin.x : origin.left;\n\t    origin.y = 'y' in origin ? origin.y : origin.top;\n\t\n\t    return origin;\n\t  }\n\t\n\t  // http://stackoverflow.com/a/5634528/2280888\n\t  function _getQBezierValue(t, p1, p2, p3) {\n\t    var iT = 1 - t;\n\t    return iT * iT * p1 + 2 * iT * t * p2 + t * t * p3;\n\t  }\n\t\n\t  function getQuadraticCurvePoint(startX, startY, cpX, cpY, endX, endY, position) {\n\t    return {\n\t      x: _getQBezierValue(position, startX, cpX, endX),\n\t      y: _getQBezierValue(position, startY, cpY, endY)\n\t    };\n\t  }\n\t\n\t  // http://gizma.com/easing/\n\t  function easeOutQuad(t, b, c, d) {\n\t    t /= d;\n\t    return -c * t * (t - 2) + b;\n\t  }\n\t\n\t  function nodeContains(parent, child) {\n\t    while (child) {\n\t      if (child === parent) {\n\t        return true;\n\t      }\n\t\n\t      child = child.parentNode;\n\t    }\n\t\n\t    return false;\n\t  }\n\t\n\t  function closest(child, selector) {\n\t    var parent = parentElement(child);\n\t\n\t    while (isElement(parent)) {\n\t      if (matchesSelector(parent, selector)) {\n\t        return parent;\n\t      }\n\t\n\t      parent = parentElement(parent);\n\t    }\n\t\n\t    return null;\n\t  }\n\t\n\t  function parentElement(node) {\n\t    var parent = node.parentNode;\n\t\n\t    if (isDocFrag(parent)) {\n\t      // skip past #shado-root fragments\n\t      while ((parent = parent.host) && isDocFrag(parent)) {}\n\t\n\t      return parent;\n\t    }\n\t\n\t    return parent;\n\t  }\n\t\n\t  function inContext(interactable, element) {\n\t    return interactable._context === element.ownerDocument || nodeContains(interactable._context, element);\n\t  }\n\t\n\t  function testIgnore(interactable, interactableElement, element) {\n\t    var ignoreFrom = interactable.options.ignoreFrom;\n\t\n\t    if (!ignoreFrom || !isElement(element)) {\n\t      return false;\n\t    }\n\t\n\t    if (isString(ignoreFrom)) {\n\t      return matchesUpTo(element, ignoreFrom, interactableElement);\n\t    } else if (isElement(ignoreFrom)) {\n\t      return nodeContains(ignoreFrom, element);\n\t    }\n\t\n\t    return false;\n\t  }\n\t\n\t  function testAllow(interactable, interactableElement, element) {\n\t    var allowFrom = interactable.options.allowFrom;\n\t\n\t    if (!allowFrom) {\n\t      return true;\n\t    }\n\t\n\t    if (!isElement(element)) {\n\t      return false;\n\t    }\n\t\n\t    if (isString(allowFrom)) {\n\t      return matchesUpTo(element, allowFrom, interactableElement);\n\t    } else if (isElement(allowFrom)) {\n\t      return nodeContains(allowFrom, element);\n\t    }\n\t\n\t    return false;\n\t  }\n\t\n\t  function checkAxis(axis, interactable) {\n\t    if (!interactable) {\n\t      return false;\n\t    }\n\t\n\t    var thisAxis = interactable.options.drag.axis;\n\t\n\t    return axis === 'xy' || thisAxis === 'xy' || thisAxis === axis;\n\t  }\n\t\n\t  function checkSnap(interactable, action) {\n\t    var options = interactable.options;\n\t\n\t    if (/^resize/.test(action)) {\n\t      action = 'resize';\n\t    }\n\t\n\t    return options[action].snap && options[action].snap.enabled;\n\t  }\n\t\n\t  function checkRestrict(interactable, action) {\n\t    var options = interactable.options;\n\t\n\t    if (/^resize/.test(action)) {\n\t      action = 'resize';\n\t    }\n\t\n\t    return options[action].restrict && options[action].restrict.enabled;\n\t  }\n\t\n\t  function checkAutoScroll(interactable, action) {\n\t    var options = interactable.options;\n\t\n\t    if (/^resize/.test(action)) {\n\t      action = 'resize';\n\t    }\n\t\n\t    return options[action].autoScroll && options[action].autoScroll.enabled;\n\t  }\n\t\n\t  function withinInteractionLimit(interactable, element, action) {\n\t    var options = interactable.options,\n\t        maxActions = options[action.name].max,\n\t        maxPerElement = options[action.name].maxPerElement,\n\t        activeInteractions = 0,\n\t        targetCount = 0,\n\t        targetElementCount = 0;\n\t\n\t    for (var i = 0, len = interactions.length; i < len; i++) {\n\t      var interaction = interactions[i],\n\t          otherAction = interaction.prepared.name,\n\t          active = interaction.interacting();\n\t\n\t      if (!active) {\n\t        continue;\n\t      }\n\t\n\t      activeInteractions++;\n\t\n\t      if (activeInteractions >= maxInteractions) {\n\t        return false;\n\t      }\n\t\n\t      if (interaction.target !== interactable) {\n\t        continue;\n\t      }\n\t\n\t      targetCount += otherAction === action.name | 0;\n\t\n\t      if (targetCount >= maxActions) {\n\t        return false;\n\t      }\n\t\n\t      if (interaction.element === element) {\n\t        targetElementCount++;\n\t\n\t        if (otherAction !== action.name || targetElementCount >= maxPerElement) {\n\t          return false;\n\t        }\n\t      }\n\t    }\n\t\n\t    return maxInteractions > 0;\n\t  }\n\t\n\t  // Test for the element that's \"above\" all other qualifiers\n\t  function indexOfDeepestElement(elements) {\n\t    var dropzone,\n\t        deepestZone = elements[0],\n\t        index = deepestZone ? 0 : -1,\n\t        parent,\n\t        deepestZoneParents = [],\n\t        dropzoneParents = [],\n\t        child,\n\t        i,\n\t        n;\n\t\n\t    for (i = 1; i < elements.length; i++) {\n\t      dropzone = elements[i];\n\t\n\t      // an element might belong to multiple selector dropzones\n\t      if (!dropzone || dropzone === deepestZone) {\n\t        continue;\n\t      }\n\t\n\t      if (!deepestZone) {\n\t        deepestZone = dropzone;\n\t        index = i;\n\t        continue;\n\t      }\n\t\n\t      // check if the deepest or current are document.documentElement or document.rootElement\n\t      // - if the current dropzone is, do nothing and continue\n\t      if (dropzone.parentNode === dropzone.ownerDocument) {\n\t        continue;\n\t      }\n\t      // - if deepest is, update with the current dropzone and continue to next\n\t      else if (deepestZone.parentNode === dropzone.ownerDocument) {\n\t          deepestZone = dropzone;\n\t          index = i;\n\t          continue;\n\t        }\n\t\n\t      if (!deepestZoneParents.length) {\n\t        parent = deepestZone;\n\t        while (parent.parentNode && parent.parentNode !== parent.ownerDocument) {\n\t          deepestZoneParents.unshift(parent);\n\t          parent = parent.parentNode;\n\t        }\n\t      }\n\t\n\t      // if this element is an svg element and the current deepest is\n\t      // an HTMLElement\n\t      if (deepestZone instanceof HTMLElement && dropzone instanceof SVGElement && !(dropzone instanceof SVGSVGElement)) {\n\t\n\t        if (dropzone === deepestZone.parentNode) {\n\t          continue;\n\t        }\n\t\n\t        parent = dropzone.ownerSVGElement;\n\t      } else {\n\t        parent = dropzone;\n\t      }\n\t\n\t      dropzoneParents = [];\n\t\n\t      while (parent.parentNode !== parent.ownerDocument) {\n\t        dropzoneParents.unshift(parent);\n\t        parent = parent.parentNode;\n\t      }\n\t\n\t      n = 0;\n\t\n\t      // get (position of last common ancestor) + 1\n\t      while (dropzoneParents[n] && dropzoneParents[n] === deepestZoneParents[n]) {\n\t        n++;\n\t      }\n\t\n\t      var parents = [dropzoneParents[n - 1], dropzoneParents[n], deepestZoneParents[n]];\n\t\n\t      child = parents[0].lastChild;\n\t\n\t      while (child) {\n\t        if (child === parents[1]) {\n\t          deepestZone = dropzone;\n\t          index = i;\n\t          deepestZoneParents = [];\n\t\n\t          break;\n\t        } else if (child === parents[2]) {\n\t          break;\n\t        }\n\t\n\t        child = child.previousSibling;\n\t      }\n\t    }\n\t\n\t    return index;\n\t  }\n\t\n\t  function Interaction() {\n\t    this.target = null; // current interactable being interacted with\n\t    this.element = null; // the target element of the interactable\n\t    this.dropTarget = null; // the dropzone a drag target might be dropped into\n\t    this.dropElement = null; // the element at the time of checking\n\t    this.prevDropTarget = null; // the dropzone that was recently dragged away from\n\t    this.prevDropElement = null; // the element at the time of checking\n\t\n\t    this.prepared = { // action that's ready to be fired on next move event\n\t      name: null,\n\t      axis: null,\n\t      edges: null\n\t    };\n\t\n\t    this.matches = []; // all selectors that are matched by target element\n\t    this.matchElements = []; // corresponding elements\n\t\n\t    this.inertiaStatus = {\n\t      active: false,\n\t      smoothEnd: false,\n\t      ending: false,\n\t\n\t      startEvent: null,\n\t      upCoords: {},\n\t\n\t      xe: 0, ye: 0,\n\t      sx: 0, sy: 0,\n\t\n\t      t0: 0,\n\t      vx0: 0, vys: 0,\n\t      duration: 0,\n\t\n\t      resumeDx: 0,\n\t      resumeDy: 0,\n\t\n\t      lambda_v0: 0,\n\t      one_ve_v0: 0,\n\t      i: null\n\t    };\n\t\n\t    if (isFunction(Function.prototype.bind)) {\n\t      this.boundInertiaFrame = this.inertiaFrame.bind(this);\n\t      this.boundSmoothEndFrame = this.smoothEndFrame.bind(this);\n\t    } else {\n\t      var that = this;\n\t\n\t      this.boundInertiaFrame = function () {\n\t        return that.inertiaFrame();\n\t      };\n\t      this.boundSmoothEndFrame = function () {\n\t        return that.smoothEndFrame();\n\t      };\n\t    }\n\t\n\t    this.activeDrops = {\n\t      dropzones: [], // the dropzones that are mentioned below\n\t      elements: [], // elements of dropzones that accept the target draggable\n\t      rects: [] // the rects of the elements mentioned above\n\t    };\n\t\n\t    // keep track of added pointers\n\t    this.pointers = [];\n\t    this.pointerIds = [];\n\t    this.downTargets = [];\n\t    this.downTimes = [];\n\t    this.holdTimers = [];\n\t\n\t    // Previous native pointer move event coordinates\n\t    this.prevCoords = {\n\t      page: { x: 0, y: 0 },\n\t      client: { x: 0, y: 0 },\n\t      timeStamp: 0\n\t    };\n\t    // current native pointer move event coordinates\n\t    this.curCoords = {\n\t      page: { x: 0, y: 0 },\n\t      client: { x: 0, y: 0 },\n\t      timeStamp: 0\n\t    };\n\t\n\t    // Starting InteractEvent pointer coordinates\n\t    this.startCoords = {\n\t      page: { x: 0, y: 0 },\n\t      client: { x: 0, y: 0 },\n\t      timeStamp: 0\n\t    };\n\t\n\t    // Change in coordinates and time of the pointer\n\t    this.pointerDelta = {\n\t      page: { x: 0, y: 0, vx: 0, vy: 0, speed: 0 },\n\t      client: { x: 0, y: 0, vx: 0, vy: 0, speed: 0 },\n\t      timeStamp: 0\n\t    };\n\t\n\t    this.downEvent = null; // pointerdown/mousedown/touchstart event\n\t    this.downPointer = {};\n\t\n\t    this._eventTarget = null;\n\t    this._curEventTarget = null;\n\t\n\t    this.prevEvent = null; // previous action event\n\t    this.tapTime = 0; // time of the most recent tap event\n\t    this.prevTap = null;\n\t\n\t    this.startOffset = { left: 0, right: 0, top: 0, bottom: 0 };\n\t    this.restrictOffset = { left: 0, right: 0, top: 0, bottom: 0 };\n\t    this.snapOffsets = [];\n\t\n\t    this.gesture = {\n\t      start: { x: 0, y: 0 },\n\t\n\t      startDistance: 0, // distance between two touches of touchStart\n\t      prevDistance: 0,\n\t      distance: 0,\n\t\n\t      scale: 1, // gesture.distance / gesture.startDistance\n\t\n\t      startAngle: 0, // angle of line joining two touches\n\t      prevAngle: 0 // angle of the previous gesture event\n\t    };\n\t\n\t    this.snapStatus = {\n\t      x: 0, y: 0,\n\t      dx: 0, dy: 0,\n\t      realX: 0, realY: 0,\n\t      snappedX: 0, snappedY: 0,\n\t      targets: [],\n\t      locked: false,\n\t      changed: false\n\t    };\n\t\n\t    this.restrictStatus = {\n\t      dx: 0, dy: 0,\n\t      restrictedX: 0, restrictedY: 0,\n\t      snap: null,\n\t      restricted: false,\n\t      changed: false\n\t    };\n\t\n\t    this.restrictStatus.snap = this.snapStatus;\n\t\n\t    this.pointerIsDown = false;\n\t    this.pointerWasMoved = false;\n\t    this.gesturing = false;\n\t    this.dragging = false;\n\t    this.resizing = false;\n\t    this.resizeAxes = 'xy';\n\t\n\t    this.mouse = false;\n\t\n\t    interactions.push(this);\n\t  }\n\t\n\t  Interaction.prototype = {\n\t    getPageXY: function getPageXY(pointer, xy) {\n\t      return _getPageXY(pointer, xy, this);\n\t    },\n\t    getClientXY: function getClientXY(pointer, xy) {\n\t      return _getClientXY(pointer, xy, this);\n\t    },\n\t    setEventXY: function setEventXY(target, ptr) {\n\t      return _setEventXY(target, ptr, this);\n\t    },\n\t\n\t    pointerOver: function pointerOver(pointer, event, eventTarget) {\n\t      if (this.prepared.name || !this.mouse) {\n\t        return;\n\t      }\n\t\n\t      var curMatches = [],\n\t          curMatchElements = [],\n\t          prevTargetElement = this.element;\n\t\n\t      this.addPointer(pointer);\n\t\n\t      if (this.target && (testIgnore(this.target, this.element, eventTarget) || !testAllow(this.target, this.element, eventTarget))) {\n\t        // if the eventTarget should be ignored or shouldn't be allowed\n\t        // clear the previous target\n\t        this.target = null;\n\t        this.element = null;\n\t        this.matches = [];\n\t        this.matchElements = [];\n\t      }\n\t\n\t      var elementInteractable = interactables.get(eventTarget),\n\t          elementAction = elementInteractable && !testIgnore(elementInteractable, eventTarget, eventTarget) && testAllow(elementInteractable, eventTarget, eventTarget) && validateAction(elementInteractable.getAction(pointer, event, this, eventTarget), elementInteractable);\n\t\n\t      if (elementAction && !withinInteractionLimit(elementInteractable, eventTarget, elementAction)) {\n\t        elementAction = null;\n\t      }\n\t\n\t      function pushCurMatches(interactable, selector) {\n\t        if (interactable && inContext(interactable, eventTarget) && !testIgnore(interactable, eventTarget, eventTarget) && testAllow(interactable, eventTarget, eventTarget) && matchesSelector(eventTarget, selector)) {\n\t\n\t          curMatches.push(interactable);\n\t          curMatchElements.push(eventTarget);\n\t        }\n\t      }\n\t\n\t      if (elementAction) {\n\t        this.target = elementInteractable;\n\t        this.element = eventTarget;\n\t        this.matches = [];\n\t        this.matchElements = [];\n\t      } else {\n\t        interactables.forEachSelector(pushCurMatches);\n\t\n\t        if (this.validateSelector(pointer, event, curMatches, curMatchElements)) {\n\t          this.matches = curMatches;\n\t          this.matchElements = curMatchElements;\n\t\n\t          this.pointerHover(pointer, event, this.matches, this.matchElements);\n\t          events.add(eventTarget, supportsPointerEvent ? pEventTypes.move : 'mousemove', listeners.pointerHover);\n\t        } else if (this.target) {\n\t          if (nodeContains(prevTargetElement, eventTarget)) {\n\t            this.pointerHover(pointer, event, this.matches, this.matchElements);\n\t            events.add(this.element, supportsPointerEvent ? pEventTypes.move : 'mousemove', listeners.pointerHover);\n\t          } else {\n\t            this.target = null;\n\t            this.element = null;\n\t            this.matches = [];\n\t            this.matchElements = [];\n\t          }\n\t        }\n\t      }\n\t    },\n\t\n\t    // Check what action would be performed on pointerMove target if a mouse\n\t    // button were pressed and change the cursor accordingly\n\t    pointerHover: function pointerHover(pointer, event, eventTarget, curEventTarget, matches, matchElements) {\n\t      var target = this.target;\n\t\n\t      if (!this.prepared.name && this.mouse) {\n\t\n\t        var action;\n\t\n\t        // update pointer coords for defaultActionChecker to use\n\t        this.setEventXY(this.curCoords, [pointer]);\n\t\n\t        if (matches) {\n\t          action = this.validateSelector(pointer, event, matches, matchElements);\n\t        } else if (target) {\n\t          action = validateAction(target.getAction(this.pointers[0], event, this, this.element), this.target);\n\t        }\n\t\n\t        if (target && target.options.styleCursor) {\n\t          if (action) {\n\t            target._doc.documentElement.style.cursor = getActionCursor(action);\n\t          } else {\n\t            target._doc.documentElement.style.cursor = '';\n\t          }\n\t        }\n\t      } else if (this.prepared.name) {\n\t        this.checkAndPreventDefault(event, target, this.element);\n\t      }\n\t    },\n\t\n\t    pointerOut: function pointerOut(pointer, event, eventTarget) {\n\t      if (this.prepared.name) {\n\t        return;\n\t      }\n\t\n\t      // Remove temporary event listeners for selector Interactables\n\t      if (!interactables.get(eventTarget)) {\n\t        events.remove(eventTarget, supportsPointerEvent ? pEventTypes.move : 'mousemove', listeners.pointerHover);\n\t      }\n\t\n\t      if (this.target && this.target.options.styleCursor && !this.interacting()) {\n\t        this.target._doc.documentElement.style.cursor = '';\n\t      }\n\t    },\n\t\n\t    selectorDown: function selectorDown(pointer, event, eventTarget, curEventTarget) {\n\t      var that = this,\n\t\n\t      // copy event to be used in timeout for IE8\n\t      eventCopy = events.useAttachEvent ? extend({}, event) : event,\n\t          element = eventTarget,\n\t          pointerIndex = this.addPointer(pointer),\n\t          action;\n\t\n\t      this.holdTimers[pointerIndex] = setTimeout(function () {\n\t        that.pointerHold(events.useAttachEvent ? eventCopy : pointer, eventCopy, eventTarget, curEventTarget);\n\t      }, defaultOptions._holdDuration);\n\t\n\t      this.pointerIsDown = true;\n\t\n\t      // Check if the down event hits the current inertia target\n\t      if (this.inertiaStatus.active && this.target.selector) {\n\t        // climb up the DOM tree from the event target\n\t        while (isElement(element)) {\n\t\n\t          // if this element is the current inertia target element\n\t          if (element === this.element\n\t          // and the prospective action is the same as the ongoing one\n\t          && validateAction(this.target.getAction(pointer, event, this, this.element), this.target).name === this.prepared.name) {\n\t\n\t            // stop inertia so that the next move will be a normal one\n\t            cancelFrame(this.inertiaStatus.i);\n\t            this.inertiaStatus.active = false;\n\t\n\t            this.collectEventTargets(pointer, event, eventTarget, 'down');\n\t            return;\n\t          }\n\t          element = parentElement(element);\n\t        }\n\t      }\n\t\n\t      // do nothing if interacting\n\t      if (this.interacting()) {\n\t        this.collectEventTargets(pointer, event, eventTarget, 'down');\n\t        return;\n\t      }\n\t\n\t      function pushMatches(interactable, selector, context) {\n\t        var elements = ie8MatchesSelector ? context.querySelectorAll(selector) : undefined;\n\t\n\t        if (inContext(interactable, element) && !testIgnore(interactable, element, eventTarget) && testAllow(interactable, element, eventTarget) && matchesSelector(element, selector, elements)) {\n\t\n\t          that.matches.push(interactable);\n\t          that.matchElements.push(element);\n\t        }\n\t      }\n\t\n\t      // update pointer coords for defaultActionChecker to use\n\t      this.setEventXY(this.curCoords, [pointer]);\n\t      this.downEvent = event;\n\t\n\t      while (isElement(element) && !action) {\n\t        this.matches = [];\n\t        this.matchElements = [];\n\t\n\t        interactables.forEachSelector(pushMatches);\n\t\n\t        action = this.validateSelector(pointer, event, this.matches, this.matchElements);\n\t        element = parentElement(element);\n\t      }\n\t\n\t      if (action) {\n\t        this.prepared.name = action.name;\n\t        this.prepared.axis = action.axis;\n\t        this.prepared.edges = action.edges;\n\t\n\t        this.collectEventTargets(pointer, event, eventTarget, 'down');\n\t\n\t        return this.pointerDown(pointer, event, eventTarget, curEventTarget, action);\n\t      } else {\n\t        // do these now since pointerDown isn't being called from here\n\t        this.downTimes[pointerIndex] = new Date().getTime();\n\t        this.downTargets[pointerIndex] = eventTarget;\n\t        pointerExtend(this.downPointer, pointer);\n\t\n\t        copyCoords(this.prevCoords, this.curCoords);\n\t        this.pointerWasMoved = false;\n\t      }\n\t\n\t      this.collectEventTargets(pointer, event, eventTarget, 'down');\n\t    },\n\t\n\t    // Determine action to be performed on next pointerMove and add appropriate\n\t    // style and event Listeners\n\t    pointerDown: function pointerDown(pointer, event, eventTarget, curEventTarget, forceAction) {\n\t      if (!forceAction && !this.inertiaStatus.active && this.pointerWasMoved && this.prepared.name) {\n\t        this.checkAndPreventDefault(event, this.target, this.element);\n\t\n\t        return;\n\t      }\n\t\n\t      this.pointerIsDown = true;\n\t      this.downEvent = event;\n\t\n\t      var pointerIndex = this.addPointer(pointer),\n\t          action;\n\t\n\t      // If it is the second touch of a multi-touch gesture, keep the\n\t      // target the same and get a new action if a target was set by the\n\t      // first touch\n\t      if (this.pointerIds.length > 1 && this.target._element === this.element) {\n\t        var newAction = validateAction(forceAction || this.target.getAction(pointer, event, this, this.element), this.target);\n\t\n\t        if (withinInteractionLimit(this.target, this.element, newAction)) {\n\t          action = newAction;\n\t        }\n\t\n\t        this.prepared.name = null;\n\t      }\n\t      // Otherwise, set the target if there is no action prepared\n\t      else if (!this.prepared.name) {\n\t          var interactable = interactables.get(curEventTarget);\n\t\n\t          if (interactable && !testIgnore(interactable, curEventTarget, eventTarget) && testAllow(interactable, curEventTarget, eventTarget) && (action = validateAction(forceAction || interactable.getAction(pointer, event, this, curEventTarget), interactable, eventTarget)) && withinInteractionLimit(interactable, curEventTarget, action)) {\n\t            this.target = interactable;\n\t            this.element = curEventTarget;\n\t          }\n\t        }\n\t\n\t      var target = this.target,\n\t          options = target && target.options;\n\t\n\t      if (target && (forceAction || !this.prepared.name)) {\n\t        action = action || validateAction(forceAction || target.getAction(pointer, event, this, curEventTarget), target, this.element);\n\t\n\t        this.setEventXY(this.startCoords, this.pointers);\n\t\n\t        if (!action) {\n\t          return;\n\t        }\n\t\n\t        if (options.styleCursor) {\n\t          target._doc.documentElement.style.cursor = getActionCursor(action);\n\t        }\n\t\n\t        this.resizeAxes = action.name === 'resize' ? action.axis : null;\n\t\n\t        if (action === 'gesture' && this.pointerIds.length < 2) {\n\t          action = null;\n\t        }\n\t\n\t        this.prepared.name = action.name;\n\t        this.prepared.axis = action.axis;\n\t        this.prepared.edges = action.edges;\n\t\n\t        this.snapStatus.snappedX = this.snapStatus.snappedY = this.restrictStatus.restrictedX = this.restrictStatus.restrictedY = NaN;\n\t\n\t        this.downTimes[pointerIndex] = new Date().getTime();\n\t        this.downTargets[pointerIndex] = eventTarget;\n\t        pointerExtend(this.downPointer, pointer);\n\t\n\t        copyCoords(this.prevCoords, this.startCoords);\n\t        this.pointerWasMoved = false;\n\t\n\t        this.checkAndPreventDefault(event, target, this.element);\n\t      }\n\t      // if inertia is active try to resume action\n\t      else if (this.inertiaStatus.active && curEventTarget === this.element && validateAction(target.getAction(pointer, event, this, this.element), target).name === this.prepared.name) {\n\t\n\t          cancelFrame(this.inertiaStatus.i);\n\t          this.inertiaStatus.active = false;\n\t\n\t          this.checkAndPreventDefault(event, target, this.element);\n\t        }\n\t    },\n\t\n\t    setModifications: function setModifications(coords, preEnd) {\n\t      var target = this.target,\n\t          shouldMove = true,\n\t          shouldSnap = checkSnap(target, this.prepared.name) && (!target.options[this.prepared.name].snap.endOnly || preEnd),\n\t          shouldRestrict = checkRestrict(target, this.prepared.name) && (!target.options[this.prepared.name].restrict.endOnly || preEnd);\n\t\n\t      if (shouldSnap) {\n\t        this.setSnapping(coords);\n\t      } else {\n\t        this.snapStatus.locked = false;\n\t      }\n\t      if (shouldRestrict) {\n\t        this.setRestriction(coords);\n\t      } else {\n\t        this.restrictStatus.restricted = false;\n\t      }\n\t\n\t      if (shouldSnap && this.snapStatus.locked && !this.snapStatus.changed) {\n\t        shouldMove = shouldRestrict && this.restrictStatus.restricted && this.restrictStatus.changed;\n\t      } else if (shouldRestrict && this.restrictStatus.restricted && !this.restrictStatus.changed) {\n\t        shouldMove = false;\n\t      }\n\t\n\t      return shouldMove;\n\t    },\n\t\n\t    setStartOffsets: function setStartOffsets(action, interactable, element) {\n\t      var rect = interactable.getRect(element),\n\t          origin = getOriginXY(interactable, element),\n\t          snap = interactable.options[this.prepared.name].snap,\n\t          restrict = interactable.options[this.prepared.name].restrict,\n\t          width,\n\t          height;\n\t\n\t      if (rect) {\n\t        this.startOffset.left = this.startCoords.page.x - rect.left;\n\t        this.startOffset.top = this.startCoords.page.y - rect.top;\n\t\n\t        this.startOffset.right = rect.right - this.startCoords.page.x;\n\t        this.startOffset.bottom = rect.bottom - this.startCoords.page.y;\n\t\n\t        if ('width' in rect) {\n\t          width = rect.width;\n\t        } else {\n\t          width = rect.right - rect.left;\n\t        }\n\t        if ('height' in rect) {\n\t          height = rect.height;\n\t        } else {\n\t          height = rect.bottom - rect.top;\n\t        }\n\t      } else {\n\t        this.startOffset.left = this.startOffset.top = this.startOffset.right = this.startOffset.bottom = 0;\n\t      }\n\t\n\t      this.snapOffsets.splice(0);\n\t\n\t      var snapOffset = snap && snap.offset === 'startCoords' ? {\n\t        x: this.startCoords.page.x - origin.x,\n\t        y: this.startCoords.page.y - origin.y\n\t      } : snap && snap.offset || { x: 0, y: 0 };\n\t\n\t      if (rect && snap && snap.relativePoints && snap.relativePoints.length) {\n\t        for (var i = 0; i < snap.relativePoints.length; i++) {\n\t          this.snapOffsets.push({\n\t            x: this.startOffset.left - width * snap.relativePoints[i].x + snapOffset.x,\n\t            y: this.startOffset.top - height * snap.relativePoints[i].y + snapOffset.y\n\t          });\n\t        }\n\t      } else {\n\t        this.snapOffsets.push(snapOffset);\n\t      }\n\t\n\t      if (rect && restrict.elementRect) {\n\t        this.restrictOffset.left = this.startOffset.left - width * restrict.elementRect.left;\n\t        this.restrictOffset.top = this.startOffset.top - height * restrict.elementRect.top;\n\t\n\t        this.restrictOffset.right = this.startOffset.right - width * (1 - restrict.elementRect.right);\n\t        this.restrictOffset.bottom = this.startOffset.bottom - height * (1 - restrict.elementRect.bottom);\n\t      } else {\n\t        this.restrictOffset.left = this.restrictOffset.top = this.restrictOffset.right = this.restrictOffset.bottom = 0;\n\t      }\n\t    },\n\t\n\t    /*\\\n\t         * Interaction.start\n\t         [ method ]\n\t         *\n\t         * Start an action with the given Interactable and Element as tartgets. The\n\t         * action must be enabled for the target Interactable and an appropriate number\n\t         * of pointers must be held down  1 for drag/resize, 2 for gesture.\n\t         *\n\t         * Use it with `interactable.<action>able({ manualStart: false })` to always\n\t         * [start actions manually](https://github.com/taye/interact.js/issues/114)\n\t         *\n\t         - action       (object)  The action to be performed - drag, resize, etc.\n\t         - interactable (Interactable) The Interactable to target\n\t         - element      (Element) The DOM Element to target\n\t         = (object) interact\n\t         **\n\t         | interact(target)\n\t         |   .draggable({\n\t         |     // disable the default drag start by down->move\n\t         |     manualStart: true\n\t         |   })\n\t         |   // start dragging after the user holds the pointer down\n\t         |   .on('hold', function (event) {\n\t         |     var interaction = event.interaction;\n\t         |\n\t         |     if (!interaction.interacting()) {\n\t         |       interaction.start({ name: 'drag' },\n\t         |                         event.interactable,\n\t         |                         event.currentTarget);\n\t         |     }\n\t         | });\n\t        \\*/\n\t    start: function start(action, interactable, element) {\n\t      if (this.interacting() || !this.pointerIsDown || this.pointerIds.length < (action.name === 'gesture' ? 2 : 1)) {\n\t        return;\n\t      }\n\t\n\t      // if this interaction had been removed after stopping\n\t      // add it back\n\t      if (indexOf(interactions, this) === -1) {\n\t        interactions.push(this);\n\t      }\n\t\n\t      // set the startCoords if there was no prepared action\n\t      if (!this.prepared.name) {\n\t        this.setEventXY(this.startCoords, this.pointers);\n\t      }\n\t\n\t      this.prepared.name = action.name;\n\t      this.prepared.axis = action.axis;\n\t      this.prepared.edges = action.edges;\n\t      this.target = interactable;\n\t      this.element = element;\n\t\n\t      this.setStartOffsets(action.name, interactable, element);\n\t      this.setModifications(this.startCoords.page);\n\t\n\t      this.prevEvent = this[this.prepared.name + 'Start'](this.downEvent);\n\t    },\n\t\n\t    pointerMove: function pointerMove(pointer, event, eventTarget, curEventTarget, preEnd) {\n\t      if (this.inertiaStatus.active) {\n\t        var pageUp = this.inertiaStatus.upCoords.page;\n\t        var clientUp = this.inertiaStatus.upCoords.client;\n\t\n\t        var inertiaPosition = {\n\t          pageX: pageUp.x + this.inertiaStatus.sx,\n\t          pageY: pageUp.y + this.inertiaStatus.sy,\n\t          clientX: clientUp.x + this.inertiaStatus.sx,\n\t          clientY: clientUp.y + this.inertiaStatus.sy\n\t        };\n\t\n\t        this.setEventXY(this.curCoords, [inertiaPosition]);\n\t      } else {\n\t        this.recordPointer(pointer);\n\t        this.setEventXY(this.curCoords, this.pointers);\n\t      }\n\t\n\t      var duplicateMove = this.curCoords.page.x === this.prevCoords.page.x && this.curCoords.page.y === this.prevCoords.page.y && this.curCoords.client.x === this.prevCoords.client.x && this.curCoords.client.y === this.prevCoords.client.y;\n\t\n\t      var dx,\n\t          dy,\n\t          pointerIndex = this.mouse ? 0 : indexOf(this.pointerIds, getPointerId(pointer));\n\t\n\t      // register movement greater than pointerMoveTolerance\n\t      if (this.pointerIsDown && !this.pointerWasMoved) {\n\t        dx = this.curCoords.client.x - this.startCoords.client.x;\n\t        dy = this.curCoords.client.y - this.startCoords.client.y;\n\t\n\t        this.pointerWasMoved = hypot(dx, dy) > pointerMoveTolerance;\n\t      }\n\t\n\t      if (!duplicateMove && (!this.pointerIsDown || this.pointerWasMoved)) {\n\t        if (this.pointerIsDown) {\n\t          clearTimeout(this.holdTimers[pointerIndex]);\n\t        }\n\t\n\t        this.collectEventTargets(pointer, event, eventTarget, 'move');\n\t      }\n\t\n\t      if (!this.pointerIsDown) {\n\t        return;\n\t      }\n\t\n\t      if (duplicateMove && this.pointerWasMoved && !preEnd) {\n\t        this.checkAndPreventDefault(event, this.target, this.element);\n\t        return;\n\t      }\n\t\n\t      // set pointer coordinate, time changes and speeds\n\t      setEventDeltas(this.pointerDelta, this.prevCoords, this.curCoords);\n\t\n\t      if (!this.prepared.name) {\n\t        return;\n\t      }\n\t\n\t      if (this.pointerWasMoved\n\t      // ignore movement while inertia is active\n\t      && (!this.inertiaStatus.active || pointer instanceof InteractEvent && /inertiastart/.test(pointer.type))) {\n\t\n\t        // if just starting an action, calculate the pointer speed now\n\t        if (!this.interacting()) {\n\t          setEventDeltas(this.pointerDelta, this.prevCoords, this.curCoords);\n\t\n\t          // check if a drag is in the correct axis\n\t          if (this.prepared.name === 'drag') {\n\t            var absX = Math.abs(dx),\n\t                absY = Math.abs(dy),\n\t                targetAxis = this.target.options.drag.axis,\n\t                axis = absX > absY ? 'x' : absX < absY ? 'y' : 'xy';\n\t\n\t            // if the movement isn't in the axis of the interactable\n\t            if (axis !== 'xy' && targetAxis !== 'xy' && targetAxis !== axis) {\n\t              // cancel the prepared action\n\t              this.prepared.name = null;\n\t\n\t              // then try to get a drag from another ineractable\n\t\n\t              var element = eventTarget;\n\t\n\t              // check element interactables\n\t              while (isElement(element)) {\n\t                var elementInteractable = interactables.get(element);\n\t\n\t                if (elementInteractable && elementInteractable !== this.target && !elementInteractable.options.drag.manualStart && (elementInteractable.getAction(this.downPointer, this.downEvent, this, element) || {}).name === 'drag' && checkAxis(axis, elementInteractable)) {\n\t\n\t                  this.prepared.name = 'drag';\n\t                  this.target = elementInteractable;\n\t                  this.element = element;\n\t                  break;\n\t                }\n\t\n\t                element = parentElement(element);\n\t              }\n\t\n\t              // if there's no drag from element interactables,\n\t              // check the selector interactables\n\t              if (!this.prepared.name) {\n\t                var thisInteraction = this;\n\t\n\t                var getDraggable = function getDraggable(interactable, selector, context) {\n\t                  var elements = ie8MatchesSelector ? context.querySelectorAll(selector) : undefined;\n\t\n\t                  if (interactable === thisInteraction.target) {\n\t                    return;\n\t                  }\n\t\n\t                  if (inContext(interactable, eventTarget) && !interactable.options.drag.manualStart && !testIgnore(interactable, element, eventTarget) && testAllow(interactable, element, eventTarget) && matchesSelector(element, selector, elements) && interactable.getAction(thisInteraction.downPointer, thisInteraction.downEvent, thisInteraction, element).name === 'drag' && checkAxis(axis, interactable) && withinInteractionLimit(interactable, element, 'drag')) {\n\t\n\t                    return interactable;\n\t                  }\n\t                };\n\t\n\t                element = eventTarget;\n\t\n\t                while (isElement(element)) {\n\t                  var selectorInteractable = interactables.forEachSelector(getDraggable);\n\t\n\t                  if (selectorInteractable) {\n\t                    this.prepared.name = 'drag';\n\t                    this.target = selectorInteractable;\n\t                    this.element = element;\n\t                    break;\n\t                  }\n\t\n\t                  element = parentElement(element);\n\t                }\n\t              }\n\t            }\n\t          }\n\t        }\n\t\n\t        var starting = !!this.prepared.name && !this.interacting();\n\t\n\t        if (starting && (this.target.options[this.prepared.name].manualStart || !withinInteractionLimit(this.target, this.element, this.prepared))) {\n\t          this.stop(event);\n\t          return;\n\t        }\n\t\n\t        if (this.prepared.name && this.target) {\n\t          if (starting) {\n\t            this.start(this.prepared, this.target, this.element);\n\t          }\n\t\n\t          var shouldMove = this.setModifications(this.curCoords.page, preEnd);\n\t\n\t          // move if snapping or restriction doesn't prevent it\n\t          if (shouldMove || starting) {\n\t            this.prevEvent = this[this.prepared.name + 'Move'](event);\n\t          }\n\t\n\t          this.checkAndPreventDefault(event, this.target, this.element);\n\t        }\n\t      }\n\t\n\t      copyCoords(this.prevCoords, this.curCoords);\n\t\n\t      if (this.dragging || this.resizing) {\n\t        this.autoScrollMove(pointer);\n\t      }\n\t    },\n\t\n\t    dragStart: function dragStart(event) {\n\t      var dragEvent = new InteractEvent(this, event, 'drag', 'start', this.element);\n\t\n\t      dragEvent.originalEvent = event;\n\t      this.dragging = true;\n\t      this.target.fire(dragEvent);\n\t\n\t      // reset active dropzones\n\t      this.activeDrops.dropzones = [];\n\t      this.activeDrops.elements = [];\n\t      this.activeDrops.rects = [];\n\t\n\t      if (!this.dynamicDrop) {\n\t        this.setActiveDrops(this.element);\n\t      }\n\t\n\t      var dropEvents = this.getDropEvents(event, dragEvent);\n\t\n\t      if (dropEvents.activate) {\n\t        this.fireActiveDrops(dropEvents.activate);\n\t      }\n\t\n\t      return dragEvent;\n\t    },\n\t\n\t    dragMove: function dragMove(event) {\n\t      var target = this.target,\n\t          dragEvent = new InteractEvent(this, event, 'drag', 'move', this.element),\n\t          draggableElement = this.element,\n\t          drop = this.getDrop(dragEvent, event, draggableElement);\n\t\n\t      this.dropTarget = drop.dropzone;\n\t      this.dropElement = drop.element;\n\t\n\t      var dropEvents = this.getDropEvents(event, dragEvent);\n\t\n\t      target.fire(dragEvent);\n\t\n\t      if (dropEvents.leave) {\n\t        this.prevDropTarget.fire(dropEvents.leave);\n\t      }\n\t      if (dropEvents.enter) {\n\t        this.dropTarget.fire(dropEvents.enter);\n\t      }\n\t      if (dropEvents.move) {\n\t        this.dropTarget.fire(dropEvents.move);\n\t      }\n\t\n\t      this.prevDropTarget = this.dropTarget;\n\t      this.prevDropElement = this.dropElement;\n\t\n\t      return dragEvent;\n\t    },\n\t\n\t    resizeStart: function resizeStart(event) {\n\t      var resizeEvent = new InteractEvent(this, event, 'resize', 'start', this.element);\n\t\n\t      if (this.prepared.edges) {\n\t        var startRect = this.target.getRect(this.element);\n\t\n\t        /*\n\t                 * When using the `resizable.square` or `resizable.preserveAspectRatio` options, resizing from one edge\n\t                 * will affect another. E.g. with `resizable.square`, resizing to make the right edge larger will make\n\t                 * the bottom edge larger by the same amount. We call these 'linked' edges. Any linked edges will depend\n\t                 * on the active edges and the edge being interacted with.\n\t                 */\n\t        if (this.target.options.resize.square || this.target.options.resize.preserveAspectRatio) {\n\t          var linkedEdges = extend({}, this.prepared.edges);\n\t\n\t          linkedEdges.top = linkedEdges.top || linkedEdges.left && !linkedEdges.bottom;\n\t          linkedEdges.left = linkedEdges.left || linkedEdges.top && !linkedEdges.right;\n\t          linkedEdges.bottom = linkedEdges.bottom || linkedEdges.right && !linkedEdges.top;\n\t          linkedEdges.right = linkedEdges.right || linkedEdges.bottom && !linkedEdges.left;\n\t\n\t          this.prepared._linkedEdges = linkedEdges;\n\t        } else {\n\t          this.prepared._linkedEdges = null;\n\t        }\n\t\n\t        // if using `resizable.preserveAspectRatio` option, record aspect ratio at the start of the resize\n\t        if (this.target.options.resize.preserveAspectRatio) {\n\t          this.resizeStartAspectRatio = startRect.width / startRect.height;\n\t        }\n\t\n\t        this.resizeRects = {\n\t          start: startRect,\n\t          current: extend({}, startRect),\n\t          restricted: extend({}, startRect),\n\t          previous: extend({}, startRect),\n\t          delta: {\n\t            left: 0, right: 0, width: 0,\n\t            top: 0, bottom: 0, height: 0\n\t          }\n\t        };\n\t\n\t        resizeEvent.rect = this.resizeRects.restricted;\n\t        resizeEvent.deltaRect = this.resizeRects.delta;\n\t      }\n\t\n\t      this.target.fire(resizeEvent);\n\t\n\t      this.resizing = true;\n\t\n\t      return resizeEvent;\n\t    },\n\t\n\t    resizeMove: function resizeMove(event) {\n\t      var resizeEvent = new InteractEvent(this, event, 'resize', 'move', this.element);\n\t\n\t      var edges = this.prepared.edges,\n\t          invert = this.target.options.resize.invert,\n\t          invertible = invert === 'reposition' || invert === 'negate';\n\t\n\t      if (edges) {\n\t        var dx = resizeEvent.dx,\n\t            dy = resizeEvent.dy,\n\t            start = this.resizeRects.start,\n\t            current = this.resizeRects.current,\n\t            restricted = this.resizeRects.restricted,\n\t            delta = this.resizeRects.delta,\n\t            previous = extend(this.resizeRects.previous, restricted),\n\t            originalEdges = edges;\n\t\n\t        // `resize.preserveAspectRatio` takes precedence over `resize.square`\n\t        if (this.target.options.resize.preserveAspectRatio) {\n\t          var resizeStartAspectRatio = this.resizeStartAspectRatio;\n\t\n\t          edges = this.prepared._linkedEdges;\n\t\n\t          if (originalEdges.left && originalEdges.bottom || originalEdges.right && originalEdges.top) {\n\t            dy = -dx / resizeStartAspectRatio;\n\t          } else if (originalEdges.left || originalEdges.right) {\n\t            dy = dx / resizeStartAspectRatio;\n\t          } else if (originalEdges.top || originalEdges.bottom) {\n\t            dx = dy * resizeStartAspectRatio;\n\t          }\n\t        } else if (this.target.options.resize.square) {\n\t          edges = this.prepared._linkedEdges;\n\t\n\t          if (originalEdges.left && originalEdges.bottom || originalEdges.right && originalEdges.top) {\n\t            dy = -dx;\n\t          } else if (originalEdges.left || originalEdges.right) {\n\t            dy = dx;\n\t          } else if (originalEdges.top || originalEdges.bottom) {\n\t            dx = dy;\n\t          }\n\t        }\n\t\n\t        // update the 'current' rect without modifications\n\t        if (edges.top) {\n\t          current.top += dy;\n\t        }\n\t        if (edges.bottom) {\n\t          current.bottom += dy;\n\t        }\n\t        if (edges.left) {\n\t          current.left += dx;\n\t        }\n\t        if (edges.right) {\n\t          current.right += dx;\n\t        }\n\t\n\t        if (invertible) {\n\t          // if invertible, copy the current rect\n\t          extend(restricted, current);\n\t\n\t          if (invert === 'reposition') {\n\t            // swap edge values if necessary to keep width/height positive\n\t            var swap;\n\t\n\t            if (restricted.top > restricted.bottom) {\n\t              swap = restricted.top;\n\t\n\t              restricted.top = restricted.bottom;\n\t              restricted.bottom = swap;\n\t            }\n\t            if (restricted.left > restricted.right) {\n\t              swap = restricted.left;\n\t\n\t              restricted.left = restricted.right;\n\t              restricted.right = swap;\n\t            }\n\t          }\n\t        } else {\n\t          // if not invertible, restrict to minimum of 0x0 rect\n\t          restricted.top = Math.min(current.top, start.bottom);\n\t          restricted.bottom = Math.max(current.bottom, start.top);\n\t          restricted.left = Math.min(current.left, start.right);\n\t          restricted.right = Math.max(current.right, start.left);\n\t        }\n\t\n\t        restricted.width = restricted.right - restricted.left;\n\t        restricted.height = restricted.bottom - restricted.top;\n\t\n\t        for (var edge in restricted) {\n\t          delta[edge] = restricted[edge] - previous[edge];\n\t        }\n\t\n\t        resizeEvent.edges = this.prepared.edges;\n\t        resizeEvent.rect = restricted;\n\t        resizeEvent.deltaRect = delta;\n\t      }\n\t\n\t      this.target.fire(resizeEvent);\n\t\n\t      return resizeEvent;\n\t    },\n\t\n\t    gestureStart: function gestureStart(event) {\n\t      var gestureEvent = new InteractEvent(this, event, 'gesture', 'start', this.element);\n\t\n\t      gestureEvent.ds = 0;\n\t\n\t      this.gesture.startDistance = this.gesture.prevDistance = gestureEvent.distance;\n\t      this.gesture.startAngle = this.gesture.prevAngle = gestureEvent.angle;\n\t      this.gesture.scale = 1;\n\t\n\t      this.gesturing = true;\n\t\n\t      this.target.fire(gestureEvent);\n\t\n\t      return gestureEvent;\n\t    },\n\t\n\t    gestureMove: function gestureMove(event) {\n\t      if (!this.pointerIds.length) {\n\t        return this.prevEvent;\n\t      }\n\t\n\t      var gestureEvent;\n\t\n\t      gestureEvent = new InteractEvent(this, event, 'gesture', 'move', this.element);\n\t      gestureEvent.ds = gestureEvent.scale - this.gesture.scale;\n\t\n\t      this.target.fire(gestureEvent);\n\t\n\t      this.gesture.prevAngle = gestureEvent.angle;\n\t      this.gesture.prevDistance = gestureEvent.distance;\n\t\n\t      if (gestureEvent.scale !== Infinity && gestureEvent.scale !== null && gestureEvent.scale !== undefined && !isNaN(gestureEvent.scale)) {\n\t\n\t        this.gesture.scale = gestureEvent.scale;\n\t      }\n\t\n\t      return gestureEvent;\n\t    },\n\t\n\t    pointerHold: function pointerHold(pointer, event, eventTarget) {\n\t      this.collectEventTargets(pointer, event, eventTarget, 'hold');\n\t    },\n\t\n\t    pointerUp: function pointerUp(pointer, event, eventTarget, curEventTarget) {\n\t      var pointerIndex = this.mouse ? 0 : indexOf(this.pointerIds, getPointerId(pointer));\n\t\n\t      clearTimeout(this.holdTimers[pointerIndex]);\n\t\n\t      this.collectEventTargets(pointer, event, eventTarget, 'up');\n\t      this.collectEventTargets(pointer, event, eventTarget, 'tap');\n\t\n\t      this.pointerEnd(pointer, event, eventTarget, curEventTarget);\n\t\n\t      this.removePointer(pointer);\n\t    },\n\t\n\t    pointerCancel: function pointerCancel(pointer, event, eventTarget, curEventTarget) {\n\t      var pointerIndex = this.mouse ? 0 : indexOf(this.pointerIds, getPointerId(pointer));\n\t\n\t      clearTimeout(this.holdTimers[pointerIndex]);\n\t\n\t      this.collectEventTargets(pointer, event, eventTarget, 'cancel');\n\t      this.pointerEnd(pointer, event, eventTarget, curEventTarget);\n\t\n\t      this.removePointer(pointer);\n\t    },\n\t\n\t    // http://www.quirksmode.org/dom/events/click.html\n\t    // >Events leading to dblclick\n\t    //\n\t    // IE8 doesn't fire down event before dblclick.\n\t    // This workaround tries to fire a tap and doubletap after dblclick\n\t    ie8Dblclick: function ie8Dblclick(pointer, event, eventTarget) {\n\t      if (this.prevTap && event.clientX === this.prevTap.clientX && event.clientY === this.prevTap.clientY && eventTarget === this.prevTap.target) {\n\t\n\t        this.downTargets[0] = eventTarget;\n\t        this.downTimes[0] = new Date().getTime();\n\t        this.collectEventTargets(pointer, event, eventTarget, 'tap');\n\t      }\n\t    },\n\t\n\t    // End interact move events and stop auto-scroll unless inertia is enabled\n\t    pointerEnd: function pointerEnd(pointer, event, eventTarget, curEventTarget) {\n\t      var endEvent,\n\t          target = this.target,\n\t          options = target && target.options,\n\t          inertiaOptions = options && this.prepared.name && options[this.prepared.name].inertia,\n\t          inertiaStatus = this.inertiaStatus;\n\t\n\t      if (this.interacting()) {\n\t\n\t        if (inertiaStatus.active && !inertiaStatus.ending) {\n\t          return;\n\t        }\n\t\n\t        var pointerSpeed,\n\t            now = new Date().getTime(),\n\t            inertiaPossible = false,\n\t            inertia = false,\n\t            smoothEnd = false,\n\t            endSnap = checkSnap(target, this.prepared.name) && options[this.prepared.name].snap.endOnly,\n\t            endRestrict = checkRestrict(target, this.prepared.name) && options[this.prepared.name].restrict.endOnly,\n\t            dx = 0,\n\t            dy = 0,\n\t            startEvent;\n\t\n\t        if (this.dragging) {\n\t          if (options.drag.axis === 'x') {\n\t            pointerSpeed = Math.abs(this.pointerDelta.client.vx);\n\t          } else if (options.drag.axis === 'y') {\n\t            pointerSpeed = Math.abs(this.pointerDelta.client.vy);\n\t          } else /*options.drag.axis === 'xy'*/{\n\t              pointerSpeed = this.pointerDelta.client.speed;\n\t            }\n\t        } else {\n\t          pointerSpeed = this.pointerDelta.client.speed;\n\t        }\n\t\n\t        // check if inertia should be started\n\t        inertiaPossible = inertiaOptions && inertiaOptions.enabled && this.prepared.name !== 'gesture' && event !== inertiaStatus.startEvent;\n\t\n\t        inertia = inertiaPossible && now - this.curCoords.timeStamp < 50 && pointerSpeed > inertiaOptions.minSpeed && pointerSpeed > inertiaOptions.endSpeed;\n\t\n\t        if (inertiaPossible && !inertia && (endSnap || endRestrict)) {\n\t\n\t          var snapRestrict = {};\n\t\n\t          snapRestrict.snap = snapRestrict.restrict = snapRestrict;\n\t\n\t          if (endSnap) {\n\t            this.setSnapping(this.curCoords.page, snapRestrict);\n\t            if (snapRestrict.locked) {\n\t              dx += snapRestrict.dx;\n\t              dy += snapRestrict.dy;\n\t            }\n\t          }\n\t\n\t          if (endRestrict) {\n\t            this.setRestriction(this.curCoords.page, snapRestrict);\n\t            if (snapRestrict.restricted) {\n\t              dx += snapRestrict.dx;\n\t              dy += snapRestrict.dy;\n\t            }\n\t          }\n\t\n\t          if (dx || dy) {\n\t            smoothEnd = true;\n\t          }\n\t        }\n\t\n\t        if (inertia || smoothEnd) {\n\t          copyCoords(inertiaStatus.upCoords, this.curCoords);\n\t\n\t          this.pointers[0] = inertiaStatus.startEvent = startEvent = new InteractEvent(this, event, this.prepared.name, 'inertiastart', this.element);\n\t\n\t          inertiaStatus.t0 = now;\n\t\n\t          target.fire(inertiaStatus.startEvent);\n\t\n\t          if (inertia) {\n\t            inertiaStatus.vx0 = this.pointerDelta.client.vx;\n\t            inertiaStatus.vy0 = this.pointerDelta.client.vy;\n\t            inertiaStatus.v0 = pointerSpeed;\n\t\n\t            this.calcInertia(inertiaStatus);\n\t\n\t            var page = extend({}, this.curCoords.page),\n\t                origin = getOriginXY(target, this.element),\n\t                statusObject;\n\t\n\t            page.x = page.x + inertiaStatus.xe - origin.x;\n\t            page.y = page.y + inertiaStatus.ye - origin.y;\n\t\n\t            statusObject = {\n\t              useStatusXY: true,\n\t              x: page.x,\n\t              y: page.y,\n\t              dx: 0,\n\t              dy: 0,\n\t              snap: null\n\t            };\n\t\n\t            statusObject.snap = statusObject;\n\t\n\t            dx = dy = 0;\n\t\n\t            if (endSnap) {\n\t              var snap = this.setSnapping(this.curCoords.page, statusObject);\n\t\n\t              if (snap.locked) {\n\t                dx += snap.dx;\n\t                dy += snap.dy;\n\t              }\n\t            }\n\t\n\t            if (endRestrict) {\n\t              var restrict = this.setRestriction(this.curCoords.page, statusObject);\n\t\n\t              if (restrict.restricted) {\n\t                dx += restrict.dx;\n\t                dy += restrict.dy;\n\t              }\n\t            }\n\t\n\t            inertiaStatus.modifiedXe += dx;\n\t            inertiaStatus.modifiedYe += dy;\n\t\n\t            inertiaStatus.i = reqFrame(this.boundInertiaFrame);\n\t          } else {\n\t            inertiaStatus.smoothEnd = true;\n\t            inertiaStatus.xe = dx;\n\t            inertiaStatus.ye = dy;\n\t\n\t            inertiaStatus.sx = inertiaStatus.sy = 0;\n\t\n\t            inertiaStatus.i = reqFrame(this.boundSmoothEndFrame);\n\t          }\n\t\n\t          inertiaStatus.active = true;\n\t          return;\n\t        }\n\t\n\t        if (endSnap || endRestrict) {\n\t          // fire a move event at the snapped coordinates\n\t          this.pointerMove(pointer, event, eventTarget, curEventTarget, true);\n\t        }\n\t      }\n\t\n\t      if (this.dragging) {\n\t        endEvent = new InteractEvent(this, event, 'drag', 'end', this.element);\n\t\n\t        var draggableElement = this.element,\n\t            drop = this.getDrop(endEvent, event, draggableElement);\n\t\n\t        this.dropTarget = drop.dropzone;\n\t        this.dropElement = drop.element;\n\t\n\t        var dropEvents = this.getDropEvents(event, endEvent);\n\t\n\t        if (dropEvents.leave) {\n\t          this.prevDropTarget.fire(dropEvents.leave);\n\t        }\n\t        if (dropEvents.enter) {\n\t          this.dropTarget.fire(dropEvents.enter);\n\t        }\n\t        if (dropEvents.drop) {\n\t          this.dropTarget.fire(dropEvents.drop);\n\t        }\n\t        if (dropEvents.deactivate) {\n\t          this.fireActiveDrops(dropEvents.deactivate);\n\t        }\n\t\n\t        target.fire(endEvent);\n\t      } else if (this.resizing) {\n\t        endEvent = new InteractEvent(this, event, 'resize', 'end', this.element);\n\t        target.fire(endEvent);\n\t      } else if (this.gesturing) {\n\t        endEvent = new InteractEvent(this, event, 'gesture', 'end', this.element);\n\t        target.fire(endEvent);\n\t      }\n\t\n\t      this.stop(event);\n\t    },\n\t\n\t    collectDrops: function collectDrops(element) {\n\t      var drops = [],\n\t          elements = [],\n\t          i;\n\t\n\t      element = element || this.element;\n\t\n\t      // collect all dropzones and their elements which qualify for a drop\n\t      for (i = 0; i < interactables.length; i++) {\n\t        if (!interactables[i].options.drop.enabled) {\n\t          continue;\n\t        }\n\t\n\t        var current = interactables[i],\n\t            accept = current.options.drop.accept;\n\t\n\t        // test the draggable element against the dropzone's accept setting\n\t        if (isElement(accept) && accept !== element || isString(accept) && !matchesSelector(element, accept)) {\n\t\n\t          continue;\n\t        }\n\t\n\t        // query for new elements if necessary\n\t        var dropElements = current.selector ? current._context.querySelectorAll(current.selector) : [current._element];\n\t\n\t        for (var j = 0, len = dropElements.length; j < len; j++) {\n\t          var currentElement = dropElements[j];\n\t\n\t          if (currentElement === element) {\n\t            continue;\n\t          }\n\t\n\t          drops.push(current);\n\t          elements.push(currentElement);\n\t        }\n\t      }\n\t\n\t      return {\n\t        dropzones: drops,\n\t        elements: elements\n\t      };\n\t    },\n\t\n\t    fireActiveDrops: function fireActiveDrops(event) {\n\t      var i, current, currentElement, prevElement;\n\t\n\t      // loop through all active dropzones and trigger event\n\t      for (i = 0; i < this.activeDrops.dropzones.length; i++) {\n\t        current = this.activeDrops.dropzones[i];\n\t        currentElement = this.activeDrops.elements[i];\n\t\n\t        // prevent trigger of duplicate events on same element\n\t        if (currentElement !== prevElement) {\n\t          // set current element as event target\n\t          event.target = currentElement;\n\t          current.fire(event);\n\t        }\n\t        prevElement = currentElement;\n\t      }\n\t    },\n\t\n\t    // Collect a new set of possible drops and save them in activeDrops.\n\t    // setActiveDrops should always be called when a drag has just started or a\n\t    // drag event happens while dynamicDrop is true\n\t    setActiveDrops: function setActiveDrops(dragElement) {\n\t      // get dropzones and their elements that could receive the draggable\n\t      var possibleDrops = this.collectDrops(dragElement, true);\n\t\n\t      this.activeDrops.dropzones = possibleDrops.dropzones;\n\t      this.activeDrops.elements = possibleDrops.elements;\n\t      this.activeDrops.rects = [];\n\t\n\t      for (var i = 0; i < this.activeDrops.dropzones.length; i++) {\n\t        this.activeDrops.rects[i] = this.activeDrops.dropzones[i].getRect(this.activeDrops.elements[i]);\n\t      }\n\t    },\n\t\n\t    getDrop: function getDrop(dragEvent, event, dragElement) {\n\t      var validDrops = [];\n\t\n\t      if (dynamicDrop) {\n\t        this.setActiveDrops(dragElement);\n\t      }\n\t\n\t      // collect all dropzones and their elements which qualify for a drop\n\t      for (var j = 0; j < this.activeDrops.dropzones.length; j++) {\n\t        var current = this.activeDrops.dropzones[j],\n\t            currentElement = this.activeDrops.elements[j],\n\t            rect = this.activeDrops.rects[j];\n\t\n\t        validDrops.push(current.dropCheck(dragEvent, event, this.target, dragElement, currentElement, rect) ? currentElement : null);\n\t      }\n\t\n\t      // get the most appropriate dropzone based on DOM depth and order\n\t      var dropIndex = indexOfDeepestElement(validDrops),\n\t          dropzone = this.activeDrops.dropzones[dropIndex] || null,\n\t          element = this.activeDrops.elements[dropIndex] || null;\n\t\n\t      return {\n\t        dropzone: dropzone,\n\t        element: element\n\t      };\n\t    },\n\t\n\t    getDropEvents: function getDropEvents(pointerEvent, dragEvent) {\n\t      var dropEvents = {\n\t        enter: null,\n\t        leave: null,\n\t        activate: null,\n\t        deactivate: null,\n\t        move: null,\n\t        drop: null\n\t      };\n\t\n\t      if (this.dropElement !== this.prevDropElement) {\n\t        // if there was a prevDropTarget, create a dragleave event\n\t        if (this.prevDropTarget) {\n\t          dropEvents.leave = {\n\t            target: this.prevDropElement,\n\t            dropzone: this.prevDropTarget,\n\t            relatedTarget: dragEvent.target,\n\t            draggable: dragEvent.interactable,\n\t            dragEvent: dragEvent,\n\t            interaction: this,\n\t            timeStamp: dragEvent.timeStamp,\n\t            type: 'dragleave'\n\t          };\n\t\n\t          dragEvent.dragLeave = this.prevDropElement;\n\t          dragEvent.prevDropzone = this.prevDropTarget;\n\t        }\n\t        // if the dropTarget is not null, create a dragenter event\n\t        if (this.dropTarget) {\n\t          dropEvents.enter = {\n\t            target: this.dropElement,\n\t            dropzone: this.dropTarget,\n\t            relatedTarget: dragEvent.target,\n\t            draggable: dragEvent.interactable,\n\t            dragEvent: dragEvent,\n\t            interaction: this,\n\t            timeStamp: dragEvent.timeStamp,\n\t            type: 'dragenter'\n\t          };\n\t\n\t          dragEvent.dragEnter = this.dropElement;\n\t          dragEvent.dropzone = this.dropTarget;\n\t        }\n\t      }\n\t\n\t      if (dragEvent.type === 'dragend' && this.dropTarget) {\n\t        dropEvents.drop = {\n\t          target: this.dropElement,\n\t          dropzone: this.dropTarget,\n\t          relatedTarget: dragEvent.target,\n\t          draggable: dragEvent.interactable,\n\t          dragEvent: dragEvent,\n\t          interaction: this,\n\t          timeStamp: dragEvent.timeStamp,\n\t          type: 'drop'\n\t        };\n\t\n\t        dragEvent.dropzone = this.dropTarget;\n\t      }\n\t      if (dragEvent.type === 'dragstart') {\n\t        dropEvents.activate = {\n\t          target: null,\n\t          dropzone: null,\n\t          relatedTarget: dragEvent.target,\n\t          draggable: dragEvent.interactable,\n\t          dragEvent: dragEvent,\n\t          interaction: this,\n\t          timeStamp: dragEvent.timeStamp,\n\t          type: 'dropactivate'\n\t        };\n\t      }\n\t      if (dragEvent.type === 'dragend') {\n\t        dropEvents.deactivate = {\n\t          target: null,\n\t          dropzone: null,\n\t          relatedTarget: dragEvent.target,\n\t          draggable: dragEvent.interactable,\n\t          dragEvent: dragEvent,\n\t          interaction: this,\n\t          timeStamp: dragEvent.timeStamp,\n\t          type: 'dropdeactivate'\n\t        };\n\t      }\n\t      if (dragEvent.type === 'dragmove' && this.dropTarget) {\n\t        dropEvents.move = {\n\t          target: this.dropElement,\n\t          dropzone: this.dropTarget,\n\t          relatedTarget: dragEvent.target,\n\t          draggable: dragEvent.interactable,\n\t          dragEvent: dragEvent,\n\t          interaction: this,\n\t          dragmove: dragEvent,\n\t          timeStamp: dragEvent.timeStamp,\n\t          type: 'dropmove'\n\t        };\n\t        dragEvent.dropzone = this.dropTarget;\n\t      }\n\t\n\t      return dropEvents;\n\t    },\n\t\n\t    currentAction: function currentAction() {\n\t      return this.dragging && 'drag' || this.resizing && 'resize' || this.gesturing && 'gesture' || null;\n\t    },\n\t\n\t    interacting: function interacting() {\n\t      return this.dragging || this.resizing || this.gesturing;\n\t    },\n\t\n\t    clearTargets: function clearTargets() {\n\t      this.target = this.element = null;\n\t\n\t      this.dropTarget = this.dropElement = this.prevDropTarget = this.prevDropElement = null;\n\t    },\n\t\n\t    stop: function stop(event) {\n\t      if (this.interacting()) {\n\t        autoScroll.stop();\n\t        this.matches = [];\n\t        this.matchElements = [];\n\t\n\t        var target = this.target;\n\t\n\t        if (target.options.styleCursor) {\n\t          target._doc.documentElement.style.cursor = '';\n\t        }\n\t\n\t        // prevent Default only if were previously interacting\n\t        if (event && isFunction(event.preventDefault)) {\n\t          this.checkAndPreventDefault(event, target, this.element);\n\t        }\n\t\n\t        if (this.dragging) {\n\t          this.activeDrops.dropzones = this.activeDrops.elements = this.activeDrops.rects = null;\n\t        }\n\t      }\n\t\n\t      this.clearTargets();\n\t\n\t      this.pointerIsDown = this.snapStatus.locked = this.dragging = this.resizing = this.gesturing = false;\n\t      this.prepared.name = this.prevEvent = null;\n\t      this.inertiaStatus.resumeDx = this.inertiaStatus.resumeDy = 0;\n\t\n\t      // remove pointers if their ID isn't in this.pointerIds\n\t      for (var i = 0; i < this.pointers.length; i++) {\n\t        if (indexOf(this.pointerIds, getPointerId(this.pointers[i])) === -1) {\n\t          this.pointers.splice(i, 1);\n\t        }\n\t      }\n\t    },\n\t\n\t    inertiaFrame: function inertiaFrame() {\n\t      var inertiaStatus = this.inertiaStatus,\n\t          options = this.target.options[this.prepared.name].inertia,\n\t          lambda = options.resistance,\n\t          t = new Date().getTime() / 1000 - inertiaStatus.t0;\n\t\n\t      if (t < inertiaStatus.te) {\n\t\n\t        var progress = 1 - (Math.exp(-lambda * t) - inertiaStatus.lambda_v0) / inertiaStatus.one_ve_v0;\n\t\n\t        if (inertiaStatus.modifiedXe === inertiaStatus.xe && inertiaStatus.modifiedYe === inertiaStatus.ye) {\n\t          inertiaStatus.sx = inertiaStatus.xe * progress;\n\t          inertiaStatus.sy = inertiaStatus.ye * progress;\n\t        } else {\n\t          var quadPoint = getQuadraticCurvePoint(0, 0, inertiaStatus.xe, inertiaStatus.ye, inertiaStatus.modifiedXe, inertiaStatus.modifiedYe, progress);\n\t\n\t          inertiaStatus.sx = quadPoint.x;\n\t          inertiaStatus.sy = quadPoint.y;\n\t        }\n\t\n\t        this.pointerMove(inertiaStatus.startEvent, inertiaStatus.startEvent);\n\t\n\t        inertiaStatus.i = reqFrame(this.boundInertiaFrame);\n\t      } else {\n\t        inertiaStatus.ending = true;\n\t\n\t        inertiaStatus.sx = inertiaStatus.modifiedXe;\n\t        inertiaStatus.sy = inertiaStatus.modifiedYe;\n\t\n\t        this.pointerMove(inertiaStatus.startEvent, inertiaStatus.startEvent);\n\t        this.pointerEnd(inertiaStatus.startEvent, inertiaStatus.startEvent);\n\t\n\t        inertiaStatus.active = inertiaStatus.ending = false;\n\t      }\n\t    },\n\t\n\t    smoothEndFrame: function smoothEndFrame() {\n\t      var inertiaStatus = this.inertiaStatus,\n\t          t = new Date().getTime() - inertiaStatus.t0,\n\t          duration = this.target.options[this.prepared.name].inertia.smoothEndDuration;\n\t\n\t      if (t < duration) {\n\t        inertiaStatus.sx = easeOutQuad(t, 0, inertiaStatus.xe, duration);\n\t        inertiaStatus.sy = easeOutQuad(t, 0, inertiaStatus.ye, duration);\n\t\n\t        this.pointerMove(inertiaStatus.startEvent, inertiaStatus.startEvent);\n\t\n\t        inertiaStatus.i = reqFrame(this.boundSmoothEndFrame);\n\t      } else {\n\t        inertiaStatus.ending = true;\n\t\n\t        inertiaStatus.sx = inertiaStatus.xe;\n\t        inertiaStatus.sy = inertiaStatus.ye;\n\t\n\t        this.pointerMove(inertiaStatus.startEvent, inertiaStatus.startEvent);\n\t        this.pointerEnd(inertiaStatus.startEvent, inertiaStatus.startEvent);\n\t\n\t        inertiaStatus.smoothEnd = inertiaStatus.active = inertiaStatus.ending = false;\n\t      }\n\t    },\n\t\n\t    addPointer: function addPointer(pointer) {\n\t      var id = getPointerId(pointer),\n\t          index = this.mouse ? 0 : indexOf(this.pointerIds, id);\n\t\n\t      if (index === -1) {\n\t        index = this.pointerIds.length;\n\t      }\n\t\n\t      this.pointerIds[index] = id;\n\t      this.pointers[index] = pointer;\n\t\n\t      return index;\n\t    },\n\t\n\t    removePointer: function removePointer(pointer) {\n\t      var id = getPointerId(pointer),\n\t          index = this.mouse ? 0 : indexOf(this.pointerIds, id);\n\t\n\t      if (index === -1) {\n\t        return;\n\t      }\n\t\n\t      this.pointers.splice(index, 1);\n\t      this.pointerIds.splice(index, 1);\n\t      this.downTargets.splice(index, 1);\n\t      this.downTimes.splice(index, 1);\n\t      this.holdTimers.splice(index, 1);\n\t    },\n\t\n\t    recordPointer: function recordPointer(pointer) {\n\t      var index = this.mouse ? 0 : indexOf(this.pointerIds, getPointerId(pointer));\n\t\n\t      if (index === -1) {\n\t        return;\n\t      }\n\t\n\t      this.pointers[index] = pointer;\n\t    },\n\t\n\t    collectEventTargets: function collectEventTargets(pointer, event, eventTarget, eventType) {\n\t      var pointerIndex = this.mouse ? 0 : indexOf(this.pointerIds, getPointerId(pointer));\n\t\n\t      // do not fire a tap event if the pointer was moved before being lifted\n\t      if (eventType === 'tap' && (this.pointerWasMoved\n\t      // or if the pointerup target is different to the pointerdown target\n\t      || !(this.downTargets[pointerIndex] && this.downTargets[pointerIndex] === eventTarget))) {\n\t        return;\n\t      }\n\t\n\t      var targets = [],\n\t          elements = [],\n\t          element = eventTarget;\n\t\n\t      function collectSelectors(interactable, selector, context) {\n\t        var els = ie8MatchesSelector ? context.querySelectorAll(selector) : undefined;\n\t\n\t        if (interactable._iEvents[eventType] && isElement(element) && inContext(interactable, element) && !testIgnore(interactable, element, eventTarget) && testAllow(interactable, element, eventTarget) && matchesSelector(element, selector, els)) {\n\t\n\t          targets.push(interactable);\n\t          elements.push(element);\n\t        }\n\t      }\n\t\n\t      while (element) {\n\t        if (interact.isSet(element) && interact(element)._iEvents[eventType]) {\n\t          targets.push(interact(element));\n\t          elements.push(element);\n\t        }\n\t\n\t        interactables.forEachSelector(collectSelectors);\n\t\n\t        element = parentElement(element);\n\t      }\n\t\n\t      // create the tap event even if there are no listeners so that\n\t      // doubletap can still be created and fired\n\t      if (targets.length || eventType === 'tap') {\n\t        this.firePointers(pointer, event, eventTarget, targets, elements, eventType);\n\t      }\n\t    },\n\t\n\t    firePointers: function firePointers(pointer, event, eventTarget, targets, elements, eventType) {\n\t      var pointerIndex = this.mouse ? 0 : indexOf(this.pointerIds, getPointerId(pointer)),\n\t          pointerEvent = {},\n\t          i,\n\t\n\t      // for tap events\n\t      interval,\n\t          createNewDoubleTap;\n\t\n\t      // if it's a doubletap then the event properties would have been\n\t      // copied from the tap event and provided as the pointer argument\n\t      if (eventType === 'doubletap') {\n\t        pointerEvent = pointer;\n\t      } else {\n\t        pointerExtend(pointerEvent, event);\n\t        if (event !== pointer) {\n\t          pointerExtend(pointerEvent, pointer);\n\t        }\n\t\n\t        pointerEvent.preventDefault = preventOriginalDefault;\n\t        pointerEvent.stopPropagation = InteractEvent.prototype.stopPropagation;\n\t        pointerEvent.stopImmediatePropagation = InteractEvent.prototype.stopImmediatePropagation;\n\t        pointerEvent.interaction = this;\n\t\n\t        pointerEvent.timeStamp = new Date().getTime();\n\t        pointerEvent.originalEvent = event;\n\t        pointerEvent.originalPointer = pointer;\n\t        pointerEvent.type = eventType;\n\t        pointerEvent.pointerId = getPointerId(pointer);\n\t        pointerEvent.pointerType = this.mouse ? 'mouse' : !supportsPointerEvent ? 'touch' : isString(pointer.pointerType) ? pointer.pointerType : [,, 'touch', 'pen', 'mouse'][pointer.pointerType];\n\t      }\n\t\n\t      if (eventType === 'tap') {\n\t        pointerEvent.dt = pointerEvent.timeStamp - this.downTimes[pointerIndex];\n\t\n\t        interval = pointerEvent.timeStamp - this.tapTime;\n\t        createNewDoubleTap = !!(this.prevTap && this.prevTap.type !== 'doubletap' && this.prevTap.target === pointerEvent.target && interval < 500);\n\t\n\t        pointerEvent.double = createNewDoubleTap;\n\t\n\t        this.tapTime = pointerEvent.timeStamp;\n\t      }\n\t\n\t      for (i = 0; i < targets.length; i++) {\n\t        pointerEvent.currentTarget = elements[i];\n\t        pointerEvent.interactable = targets[i];\n\t        targets[i].fire(pointerEvent);\n\t\n\t        if (pointerEvent.immediatePropagationStopped || pointerEvent.propagationStopped && elements[i + 1] !== pointerEvent.currentTarget) {\n\t          break;\n\t        }\n\t      }\n\t\n\t      if (createNewDoubleTap) {\n\t        var doubleTap = {};\n\t\n\t        extend(doubleTap, pointerEvent);\n\t\n\t        doubleTap.dt = interval;\n\t        doubleTap.type = 'doubletap';\n\t\n\t        this.collectEventTargets(doubleTap, event, eventTarget, 'doubletap');\n\t\n\t        this.prevTap = doubleTap;\n\t      } else if (eventType === 'tap') {\n\t        this.prevTap = pointerEvent;\n\t      }\n\t    },\n\t\n\t    validateSelector: function validateSelector(pointer, event, matches, matchElements) {\n\t      for (var i = 0, len = matches.length; i < len; i++) {\n\t        var match = matches[i],\n\t            matchElement = matchElements[i],\n\t            action = validateAction(match.getAction(pointer, event, this, matchElement), match);\n\t\n\t        if (action && withinInteractionLimit(match, matchElement, action)) {\n\t          this.target = match;\n\t          this.element = matchElement;\n\t\n\t          return action;\n\t        }\n\t      }\n\t    },\n\t\n\t    setSnapping: function setSnapping(pageCoords, status) {\n\t      var snap = this.target.options[this.prepared.name].snap,\n\t          targets = [],\n\t          target,\n\t          page,\n\t          i;\n\t\n\t      status = status || this.snapStatus;\n\t\n\t      if (status.useStatusXY) {\n\t        page = { x: status.x, y: status.y };\n\t      } else {\n\t        var origin = getOriginXY(this.target, this.element);\n\t\n\t        page = extend({}, pageCoords);\n\t\n\t        page.x -= origin.x;\n\t        page.y -= origin.y;\n\t      }\n\t\n\t      status.realX = page.x;\n\t      status.realY = page.y;\n\t\n\t      page.x = page.x - this.inertiaStatus.resumeDx;\n\t      page.y = page.y - this.inertiaStatus.resumeDy;\n\t\n\t      var len = snap.targets ? snap.targets.length : 0;\n\t\n\t      for (var relIndex = 0; relIndex < this.snapOffsets.length; relIndex++) {\n\t        var relative = {\n\t          x: page.x - this.snapOffsets[relIndex].x,\n\t          y: page.y - this.snapOffsets[relIndex].y\n\t        };\n\t\n\t        for (i = 0; i < len; i++) {\n\t          if (isFunction(snap.targets[i])) {\n\t            target = snap.targets[i](relative.x, relative.y, this);\n\t          } else {\n\t            target = snap.targets[i];\n\t          }\n\t\n\t          if (!target) {\n\t            continue;\n\t          }\n\t\n\t          targets.push({\n\t            x: isNumber(target.x) ? target.x + this.snapOffsets[relIndex].x : relative.x,\n\t            y: isNumber(target.y) ? target.y + this.snapOffsets[relIndex].y : relative.y,\n\t\n\t            range: isNumber(target.range) ? target.range : snap.range\n\t          });\n\t        }\n\t      }\n\t\n\t      var closest = {\n\t        target: null,\n\t        inRange: false,\n\t        distance: 0,\n\t        range: 0,\n\t        dx: 0,\n\t        dy: 0\n\t      };\n\t\n\t      for (i = 0, len = targets.length; i < len; i++) {\n\t        target = targets[i];\n\t\n\t        var range = target.range,\n\t            dx = target.x - page.x,\n\t            dy = target.y - page.y,\n\t            distance = hypot(dx, dy),\n\t            inRange = distance <= range;\n\t\n\t        // Infinite targets count as being out of range\n\t        // compared to non infinite ones that are in range\n\t        if (range === Infinity && closest.inRange && closest.range !== Infinity) {\n\t          inRange = false;\n\t        }\n\t\n\t        if (!closest.target || (inRange\n\t        // is the closest target in range?\n\t        ? closest.inRange && range !== Infinity\n\t        // the pointer is relatively deeper in this target\n\t        ? distance / range < closest.distance / closest.range\n\t        // this target has Infinite range and the closest doesn't\n\t        : range === Infinity && closest.range !== Infinity ||\n\t        // OR this target is closer that the previous closest\n\t        distance < closest.distance :\n\t        // The other is not in range and the pointer is closer to this target\n\t        !closest.inRange && distance < closest.distance)) {\n\t\n\t          if (range === Infinity) {\n\t            inRange = true;\n\t          }\n\t\n\t          closest.target = target;\n\t          closest.distance = distance;\n\t          closest.range = range;\n\t          closest.inRange = inRange;\n\t          closest.dx = dx;\n\t          closest.dy = dy;\n\t\n\t          status.range = range;\n\t        }\n\t      }\n\t\n\t      var snapChanged;\n\t\n\t      if (closest.target) {\n\t        snapChanged = status.snappedX !== closest.target.x || status.snappedY !== closest.target.y;\n\t\n\t        status.snappedX = closest.target.x;\n\t        status.snappedY = closest.target.y;\n\t      } else {\n\t        snapChanged = true;\n\t\n\t        status.snappedX = NaN;\n\t        status.snappedY = NaN;\n\t      }\n\t\n\t      status.dx = closest.dx;\n\t      status.dy = closest.dy;\n\t\n\t      status.changed = snapChanged || closest.inRange && !status.locked;\n\t      status.locked = closest.inRange;\n\t\n\t      return status;\n\t    },\n\t\n\t    setRestriction: function setRestriction(pageCoords, status) {\n\t      var target = this.target,\n\t          restrict = target && target.options[this.prepared.name].restrict,\n\t          restriction = restrict && restrict.restriction,\n\t          page;\n\t\n\t      if (!restriction) {\n\t        return status;\n\t      }\n\t\n\t      status = status || this.restrictStatus;\n\t\n\t      page = status.useStatusXY ? page = { x: status.x, y: status.y } : page = extend({}, pageCoords);\n\t\n\t      if (status.snap && status.snap.locked) {\n\t        page.x += status.snap.dx || 0;\n\t        page.y += status.snap.dy || 0;\n\t      }\n\t\n\t      page.x -= this.inertiaStatus.resumeDx;\n\t      page.y -= this.inertiaStatus.resumeDy;\n\t\n\t      status.dx = 0;\n\t      status.dy = 0;\n\t      status.restricted = false;\n\t\n\t      var rect, restrictedX, restrictedY;\n\t\n\t      if (isString(restriction)) {\n\t        if (restriction === 'parent') {\n\t          restriction = parentElement(this.element);\n\t        } else if (restriction === 'self') {\n\t          restriction = target.getRect(this.element);\n\t        } else {\n\t          restriction = closest(this.element, restriction);\n\t        }\n\t\n\t        if (!restriction) {\n\t          return status;\n\t        }\n\t      }\n\t\n\t      if (isFunction(restriction)) {\n\t        restriction = restriction(page.x, page.y, this.element);\n\t      }\n\t\n\t      if (isElement(restriction)) {\n\t        restriction = getElementRect(restriction);\n\t      }\n\t\n\t      rect = restriction;\n\t\n\t      if (!restriction) {\n\t        restrictedX = page.x;\n\t        restrictedY = page.y;\n\t      }\n\t      // object is assumed to have\n\t      // x, y, width, height or\n\t      // left, top, right, bottom\n\t      else if ('x' in restriction && 'y' in restriction) {\n\t          restrictedX = Math.max(Math.min(rect.x + rect.width - this.restrictOffset.right, page.x), rect.x + this.restrictOffset.left);\n\t          restrictedY = Math.max(Math.min(rect.y + rect.height - this.restrictOffset.bottom, page.y), rect.y + this.restrictOffset.top);\n\t        } else {\n\t          restrictedX = Math.max(Math.min(rect.right - this.restrictOffset.right, page.x), rect.left + this.restrictOffset.left);\n\t          restrictedY = Math.max(Math.min(rect.bottom - this.restrictOffset.bottom, page.y), rect.top + this.restrictOffset.top);\n\t        }\n\t\n\t      status.dx = restrictedX - page.x;\n\t      status.dy = restrictedY - page.y;\n\t\n\t      status.changed = status.restrictedX !== restrictedX || status.restrictedY !== restrictedY;\n\t      status.restricted = !!(status.dx || status.dy);\n\t\n\t      status.restrictedX = restrictedX;\n\t      status.restrictedY = restrictedY;\n\t\n\t      return status;\n\t    },\n\t\n\t    checkAndPreventDefault: function checkAndPreventDefault(event, interactable, element) {\n\t      if (!(interactable = interactable || this.target)) {\n\t        return;\n\t      }\n\t\n\t      var options = interactable.options,\n\t          prevent = options.preventDefault;\n\t\n\t      if (prevent === 'auto' && element && !/^(input|select|textarea)$/i.test(event.target.nodeName)) {\n\t        // do not preventDefault on pointerdown if the prepared action is a drag\n\t        // and dragging can only start from a certain direction - this allows\n\t        // a touch to pan the viewport if a drag isn't in the right direction\n\t        if (/down|start/i.test(event.type) && this.prepared.name === 'drag' && options.drag.axis !== 'xy') {\n\t\n\t          return;\n\t        }\n\t\n\t        // with manualStart, only preventDefault while interacting\n\t        if (options[this.prepared.name] && options[this.prepared.name].manualStart && !this.interacting()) {\n\t          return;\n\t        }\n\t\n\t        event.preventDefault();\n\t        return;\n\t      }\n\t\n\t      if (prevent === 'always') {\n\t        event.preventDefault();\n\t        return;\n\t      }\n\t    },\n\t\n\t    calcInertia: function calcInertia(status) {\n\t      var inertiaOptions = this.target.options[this.prepared.name].inertia,\n\t          lambda = inertiaOptions.resistance,\n\t          inertiaDur = -Math.log(inertiaOptions.endSpeed / status.v0) / lambda;\n\t\n\t      status.x0 = this.prevEvent.pageX;\n\t      status.y0 = this.prevEvent.pageY;\n\t      status.t0 = status.startEvent.timeStamp / 1000;\n\t      status.sx = status.sy = 0;\n\t\n\t      status.modifiedXe = status.xe = (status.vx0 - inertiaDur) / lambda;\n\t      status.modifiedYe = status.ye = (status.vy0 - inertiaDur) / lambda;\n\t      status.te = inertiaDur;\n\t\n\t      status.lambda_v0 = lambda / status.v0;\n\t      status.one_ve_v0 = 1 - inertiaOptions.endSpeed / status.v0;\n\t    },\n\t\n\t    autoScrollMove: function autoScrollMove(pointer) {\n\t      if (!(this.interacting() && checkAutoScroll(this.target, this.prepared.name))) {\n\t        return;\n\t      }\n\t\n\t      if (this.inertiaStatus.active) {\n\t        autoScroll.x = autoScroll.y = 0;\n\t        return;\n\t      }\n\t\n\t      var top,\n\t          right,\n\t          bottom,\n\t          left,\n\t          options = this.target.options[this.prepared.name].autoScroll,\n\t          container = options.container || getWindow(this.element);\n\t\n\t      if (isWindow(container)) {\n\t        left = pointer.clientX < autoScroll.margin;\n\t        top = pointer.clientY < autoScroll.margin;\n\t        right = pointer.clientX > container.innerWidth - autoScroll.margin;\n\t        bottom = pointer.clientY > container.innerHeight - autoScroll.margin;\n\t      } else {\n\t        var rect = getElementClientRect(container);\n\t\n\t        left = pointer.clientX < rect.left + autoScroll.margin;\n\t        top = pointer.clientY < rect.top + autoScroll.margin;\n\t        right = pointer.clientX > rect.right - autoScroll.margin;\n\t        bottom = pointer.clientY > rect.bottom - autoScroll.margin;\n\t      }\n\t\n\t      autoScroll.x = right ? 1 : left ? -1 : 0;\n\t      autoScroll.y = bottom ? 1 : top ? -1 : 0;\n\t\n\t      if (!autoScroll.isScrolling) {\n\t        // set the autoScroll properties to those of the target\n\t        autoScroll.margin = options.margin;\n\t        autoScroll.speed = options.speed;\n\t\n\t        autoScroll.start(this);\n\t      }\n\t    },\n\t\n\t    _updateEventTargets: function _updateEventTargets(target, currentTarget) {\n\t      this._eventTarget = target;\n\t      this._curEventTarget = currentTarget;\n\t    }\n\t\n\t  };\n\t\n\t  function getInteractionFromPointer(pointer, eventType, eventTarget) {\n\t    var i = 0,\n\t        len = interactions.length,\n\t        mouseEvent = /mouse/i.test(pointer.pointerType || eventType)\n\t    // MSPointerEvent.MSPOINTER_TYPE_MOUSE\n\t    || pointer.pointerType === 4,\n\t        interaction;\n\t\n\t    var id = getPointerId(pointer);\n\t\n\t    // try to resume inertia with a new pointer\n\t    if (/down|start/i.test(eventType)) {\n\t      for (i = 0; i < len; i++) {\n\t        interaction = interactions[i];\n\t\n\t        var element = eventTarget;\n\t\n\t        if (interaction.inertiaStatus.active && interaction.target.options[interaction.prepared.name].inertia.allowResume && interaction.mouse === mouseEvent) {\n\t          while (element) {\n\t            // if the element is the interaction element\n\t            if (element === interaction.element) {\n\t              return interaction;\n\t            }\n\t            element = parentElement(element);\n\t          }\n\t        }\n\t      }\n\t    }\n\t\n\t    // if it's a mouse interaction\n\t    if (mouseEvent || !(supportsTouch || supportsPointerEvent)) {\n\t\n\t      // find a mouse interaction that's not in inertia phase\n\t      for (i = 0; i < len; i++) {\n\t        if (interactions[i].mouse && !interactions[i].inertiaStatus.active) {\n\t          return interactions[i];\n\t        }\n\t      }\n\t\n\t      // find any interaction specifically for mouse.\n\t      // if the eventType is a mousedown, and inertia is active\n\t      // ignore the interaction\n\t      for (i = 0; i < len; i++) {\n\t        if (interactions[i].mouse && !(/down/.test(eventType) && interactions[i].inertiaStatus.active)) {\n\t          return interaction;\n\t        }\n\t      }\n\t\n\t      // create a new interaction for mouse\n\t      interaction = new Interaction();\n\t      interaction.mouse = true;\n\t\n\t      return interaction;\n\t    }\n\t\n\t    // get interaction that has this pointer\n\t    for (i = 0; i < len; i++) {\n\t      if (contains(interactions[i].pointerIds, id)) {\n\t        return interactions[i];\n\t      }\n\t    }\n\t\n\t    // at this stage, a pointerUp should not return an interaction\n\t    if (/up|end|out/i.test(eventType)) {\n\t      return null;\n\t    }\n\t\n\t    // get first idle interaction\n\t    for (i = 0; i < len; i++) {\n\t      interaction = interactions[i];\n\t\n\t      if ((!interaction.prepared.name || interaction.target.options.gesture.enabled) && !interaction.interacting() && !(!mouseEvent && interaction.mouse)) {\n\t\n\t        return interaction;\n\t      }\n\t    }\n\t\n\t    return new Interaction();\n\t  }\n\t\n\t  function doOnInteractions(method) {\n\t    return function (event) {\n\t      var interaction,\n\t          eventTarget = getActualElement(event.path ? event.path[0] : event.target),\n\t          curEventTarget = getActualElement(event.currentTarget),\n\t          i;\n\t\n\t      if (supportsTouch && /touch/.test(event.type)) {\n\t        prevTouchTime = new Date().getTime();\n\t\n\t        for (i = 0; i < event.changedTouches.length; i++) {\n\t          var pointer = event.changedTouches[i];\n\t\n\t          interaction = getInteractionFromPointer(pointer, event.type, eventTarget);\n\t\n\t          if (!interaction) {\n\t            continue;\n\t          }\n\t\n\t          interaction._updateEventTargets(eventTarget, curEventTarget);\n\t\n\t          interaction[method](pointer, event, eventTarget, curEventTarget);\n\t        }\n\t      } else {\n\t        if (!supportsPointerEvent && /mouse/.test(event.type)) {\n\t          // ignore mouse events while touch interactions are active\n\t          for (i = 0; i < interactions.length; i++) {\n\t            if (!interactions[i].mouse && interactions[i].pointerIsDown) {\n\t              return;\n\t            }\n\t          }\n\t\n\t          // try to ignore mouse events that are simulated by the browser\n\t          // after a touch event\n\t          if (new Date().getTime() - prevTouchTime < 500) {\n\t            return;\n\t          }\n\t        }\n\t\n\t        interaction = getInteractionFromPointer(event, event.type, eventTarget);\n\t\n\t        if (!interaction) {\n\t          return;\n\t        }\n\t\n\t        interaction._updateEventTargets(eventTarget, curEventTarget);\n\t\n\t        interaction[method](event, event, eventTarget, curEventTarget);\n\t      }\n\t    };\n\t  }\n\t\n\t  function InteractEvent(interaction, event, action, phase, element, related) {\n\t    var client,\n\t        page,\n\t        target = interaction.target,\n\t        snapStatus = interaction.snapStatus,\n\t        restrictStatus = interaction.restrictStatus,\n\t        pointers = interaction.pointers,\n\t        deltaSource = (target && target.options || defaultOptions).deltaSource,\n\t        sourceX = deltaSource + 'X',\n\t        sourceY = deltaSource + 'Y',\n\t        options = target ? target.options : defaultOptions,\n\t        origin = getOriginXY(target, element),\n\t        starting = phase === 'start',\n\t        ending = phase === 'end',\n\t        coords = starting ? interaction.startCoords : interaction.curCoords;\n\t\n\t    element = element || interaction.element;\n\t\n\t    page = extend({}, coords.page);\n\t    client = extend({}, coords.client);\n\t\n\t    page.x -= origin.x;\n\t    page.y -= origin.y;\n\t\n\t    client.x -= origin.x;\n\t    client.y -= origin.y;\n\t\n\t    var relativePoints = options[action].snap && options[action].snap.relativePoints;\n\t\n\t    if (checkSnap(target, action) && !(starting && relativePoints && relativePoints.length)) {\n\t      this.snap = {\n\t        range: snapStatus.range,\n\t        locked: snapStatus.locked,\n\t        x: snapStatus.snappedX,\n\t        y: snapStatus.snappedY,\n\t        realX: snapStatus.realX,\n\t        realY: snapStatus.realY,\n\t        dx: snapStatus.dx,\n\t        dy: snapStatus.dy\n\t      };\n\t\n\t      if (snapStatus.locked) {\n\t        page.x += snapStatus.dx;\n\t        page.y += snapStatus.dy;\n\t        client.x += snapStatus.dx;\n\t        client.y += snapStatus.dy;\n\t      }\n\t    }\n\t\n\t    if (checkRestrict(target, action) && !(starting && options[action].restrict.elementRect) && restrictStatus.restricted) {\n\t      page.x += restrictStatus.dx;\n\t      page.y += restrictStatus.dy;\n\t      client.x += restrictStatus.dx;\n\t      client.y += restrictStatus.dy;\n\t\n\t      this.restrict = {\n\t        dx: restrictStatus.dx,\n\t        dy: restrictStatus.dy\n\t      };\n\t    }\n\t\n\t    this.pageX = page.x;\n\t    this.pageY = page.y;\n\t    this.clientX = client.x;\n\t    this.clientY = client.y;\n\t\n\t    this.x0 = interaction.startCoords.page.x - origin.x;\n\t    this.y0 = interaction.startCoords.page.y - origin.y;\n\t    this.clientX0 = interaction.startCoords.client.x - origin.x;\n\t    this.clientY0 = interaction.startCoords.client.y - origin.y;\n\t    this.ctrlKey = event.ctrlKey;\n\t    this.altKey = event.altKey;\n\t    this.shiftKey = event.shiftKey;\n\t    this.metaKey = event.metaKey;\n\t    this.button = event.button;\n\t    this.buttons = event.buttons;\n\t    this.target = element;\n\t    this.t0 = interaction.downTimes[0];\n\t    this.type = action + (phase || '');\n\t\n\t    this.interaction = interaction;\n\t    this.interactable = target;\n\t\n\t    var inertiaStatus = interaction.inertiaStatus;\n\t\n\t    if (inertiaStatus.active) {\n\t      this.detail = 'inertia';\n\t    }\n\t\n\t    if (related) {\n\t      this.relatedTarget = related;\n\t    }\n\t\n\t    // end event dx, dy is difference between start and end points\n\t    if (ending) {\n\t      if (deltaSource === 'client') {\n\t        this.dx = client.x - interaction.startCoords.client.x;\n\t        this.dy = client.y - interaction.startCoords.client.y;\n\t      } else {\n\t        this.dx = page.x - interaction.startCoords.page.x;\n\t        this.dy = page.y - interaction.startCoords.page.y;\n\t      }\n\t    } else if (starting) {\n\t      this.dx = 0;\n\t      this.dy = 0;\n\t    }\n\t    // copy properties from previousmove if starting inertia\n\t    else if (phase === 'inertiastart') {\n\t        this.dx = interaction.prevEvent.dx;\n\t        this.dy = interaction.prevEvent.dy;\n\t      } else {\n\t        if (deltaSource === 'client') {\n\t          this.dx = client.x - interaction.prevEvent.clientX;\n\t          this.dy = client.y - interaction.prevEvent.clientY;\n\t        } else {\n\t          this.dx = page.x - interaction.prevEvent.pageX;\n\t          this.dy = page.y - interaction.prevEvent.pageY;\n\t        }\n\t      }\n\t    if (interaction.prevEvent && interaction.prevEvent.detail === 'inertia' && !inertiaStatus.active && options[action].inertia && options[action].inertia.zeroResumeDelta) {\n\t\n\t      inertiaStatus.resumeDx += this.dx;\n\t      inertiaStatus.resumeDy += this.dy;\n\t\n\t      this.dx = this.dy = 0;\n\t    }\n\t\n\t    if (action === 'resize' && interaction.resizeAxes) {\n\t      if (options.resize.square) {\n\t        if (interaction.resizeAxes === 'y') {\n\t          this.dx = this.dy;\n\t        } else {\n\t          this.dy = this.dx;\n\t        }\n\t        this.axes = 'xy';\n\t      } else {\n\t        this.axes = interaction.resizeAxes;\n\t\n\t        if (interaction.resizeAxes === 'x') {\n\t          this.dy = 0;\n\t        } else if (interaction.resizeAxes === 'y') {\n\t          this.dx = 0;\n\t        }\n\t      }\n\t    } else if (action === 'gesture') {\n\t      this.touches = [pointers[0], pointers[1]];\n\t\n\t      if (starting) {\n\t        this.distance = touchDistance(pointers, deltaSource);\n\t        this.box = touchBBox(pointers);\n\t        this.scale = 1;\n\t        this.ds = 0;\n\t        this.angle = touchAngle(pointers, undefined, deltaSource);\n\t        this.da = 0;\n\t      } else if (ending || event instanceof InteractEvent) {\n\t        this.distance = interaction.prevEvent.distance;\n\t        this.box = interaction.prevEvent.box;\n\t        this.scale = interaction.prevEvent.scale;\n\t        this.ds = this.scale - 1;\n\t        this.angle = interaction.prevEvent.angle;\n\t        this.da = this.angle - interaction.gesture.startAngle;\n\t      } else {\n\t        this.distance = touchDistance(pointers, deltaSource);\n\t        this.box = touchBBox(pointers);\n\t        this.scale = this.distance / interaction.gesture.startDistance;\n\t        this.angle = touchAngle(pointers, interaction.gesture.prevAngle, deltaSource);\n\t\n\t        this.ds = this.scale - interaction.gesture.prevScale;\n\t        this.da = this.angle - interaction.gesture.prevAngle;\n\t      }\n\t    }\n\t\n\t    if (starting) {\n\t      this.timeStamp = interaction.downTimes[0];\n\t      this.dt = 0;\n\t      this.duration = 0;\n\t      this.speed = 0;\n\t      this.velocityX = 0;\n\t      this.velocityY = 0;\n\t    } else if (phase === 'inertiastart') {\n\t      this.timeStamp = interaction.prevEvent.timeStamp;\n\t      this.dt = interaction.prevEvent.dt;\n\t      this.duration = interaction.prevEvent.duration;\n\t      this.speed = interaction.prevEvent.speed;\n\t      this.velocityX = interaction.prevEvent.velocityX;\n\t      this.velocityY = interaction.prevEvent.velocityY;\n\t    } else {\n\t      this.timeStamp = new Date().getTime();\n\t      this.dt = this.timeStamp - interaction.prevEvent.timeStamp;\n\t      this.duration = this.timeStamp - interaction.downTimes[0];\n\t\n\t      if (event instanceof InteractEvent) {\n\t        var dx = this[sourceX] - interaction.prevEvent[sourceX],\n\t            dy = this[sourceY] - interaction.prevEvent[sourceY],\n\t            dt = this.dt / 1000;\n\t\n\t        this.speed = hypot(dx, dy) / dt;\n\t        this.velocityX = dx / dt;\n\t        this.velocityY = dy / dt;\n\t      }\n\t      // if normal move or end event, use previous user event coords\n\t      else {\n\t          // speed and velocity in pixels per second\n\t          this.speed = interaction.pointerDelta[deltaSource].speed;\n\t          this.velocityX = interaction.pointerDelta[deltaSource].vx;\n\t          this.velocityY = interaction.pointerDelta[deltaSource].vy;\n\t        }\n\t    }\n\t\n\t    if ((ending || phase === 'inertiastart') && interaction.prevEvent.speed > 600 && this.timeStamp - interaction.prevEvent.timeStamp < 150) {\n\t\n\t      var angle = 180 * Math.atan2(interaction.prevEvent.velocityY, interaction.prevEvent.velocityX) / Math.PI,\n\t          overlap = 22.5;\n\t\n\t      if (angle < 0) {\n\t        angle += 360;\n\t      }\n\t\n\t      var left = 135 - overlap <= angle && angle < 225 + overlap,\n\t          up = 225 - overlap <= angle && angle < 315 + overlap,\n\t          right = !left && (315 - overlap <= angle || angle < 45 + overlap),\n\t          down = !up && 45 - overlap <= angle && angle < 135 + overlap;\n\t\n\t      this.swipe = {\n\t        up: up,\n\t        down: down,\n\t        left: left,\n\t        right: right,\n\t        angle: angle,\n\t        speed: interaction.prevEvent.speed,\n\t        velocity: {\n\t          x: interaction.prevEvent.velocityX,\n\t          y: interaction.prevEvent.velocityY\n\t        }\n\t      };\n\t    }\n\t  }\n\t\n\t  InteractEvent.prototype = {\n\t    preventDefault: blank,\n\t    stopImmediatePropagation: function stopImmediatePropagation() {\n\t      this.immediatePropagationStopped = this.propagationStopped = true;\n\t    },\n\t    stopPropagation: function stopPropagation() {\n\t      this.propagationStopped = true;\n\t    }\n\t  };\n\t\n\t  function preventOriginalDefault() {\n\t    this.originalEvent.preventDefault();\n\t  }\n\t\n\t  function getActionCursor(action) {\n\t    var cursor = '';\n\t\n\t    if (action.name === 'drag') {\n\t      cursor = actionCursors.drag;\n\t    }\n\t    if (action.name === 'resize') {\n\t      if (action.axis) {\n\t        cursor = actionCursors[action.name + action.axis];\n\t      } else if (action.edges) {\n\t        var cursorKey = 'resize',\n\t            edgeNames = ['top', 'bottom', 'left', 'right'];\n\t\n\t        for (var i = 0; i < 4; i++) {\n\t          if (action.edges[edgeNames[i]]) {\n\t            cursorKey += edgeNames[i];\n\t          }\n\t        }\n\t\n\t        cursor = actionCursors[cursorKey];\n\t      }\n\t    }\n\t\n\t    return cursor;\n\t  }\n\t\n\t  function checkResizeEdge(name, value, page, element, interactableElement, rect, margin) {\n\t    // false, '', undefined, null\n\t    if (!value) {\n\t      return false;\n\t    }\n\t\n\t    // true value, use pointer coords and element rect\n\t    if (value === true) {\n\t      // if dimensions are negative, \"switch\" edges\n\t      var width = isNumber(rect.width) ? rect.width : rect.right - rect.left,\n\t          height = isNumber(rect.height) ? rect.height : rect.bottom - rect.top;\n\t\n\t      if (width < 0) {\n\t        if (name === 'left') {\n\t          name = 'right';\n\t        } else if (name === 'right') {\n\t          name = 'left';\n\t        }\n\t      }\n\t      if (height < 0) {\n\t        if (name === 'top') {\n\t          name = 'bottom';\n\t        } else if (name === 'bottom') {\n\t          name = 'top';\n\t        }\n\t      }\n\t\n\t      if (name === 'left') {\n\t        return page.x < (width >= 0 ? rect.left : rect.right) + margin;\n\t      }\n\t      if (name === 'top') {\n\t        return page.y < (height >= 0 ? rect.top : rect.bottom) + margin;\n\t      }\n\t\n\t      if (name === 'right') {\n\t        return page.x > (width >= 0 ? rect.right : rect.left) - margin;\n\t      }\n\t      if (name === 'bottom') {\n\t        return page.y > (height >= 0 ? rect.bottom : rect.top) - margin;\n\t      }\n\t    }\n\t\n\t    // the remaining checks require an element\n\t    if (!isElement(element)) {\n\t      return false;\n\t    }\n\t\n\t    return isElement(value)\n\t    // the value is an element to use as a resize handle\n\t    ? value === element\n\t    // otherwise check if element matches value as selector\n\t    : matchesUpTo(element, value, interactableElement);\n\t  }\n\t\n\t  function defaultActionChecker(pointer, interaction, element) {\n\t    var rect = this.getRect(element),\n\t        shouldResize = false,\n\t        action = null,\n\t        resizeAxes = null,\n\t        resizeEdges,\n\t        page = extend({}, interaction.curCoords.page),\n\t        options = this.options;\n\t\n\t    if (!rect) {\n\t      return null;\n\t    }\n\t\n\t    if (actionIsEnabled.resize && options.resize.enabled) {\n\t      var resizeOptions = options.resize;\n\t\n\t      resizeEdges = {\n\t        left: false, right: false, top: false, bottom: false\n\t      };\n\t\n\t      // if using resize.edges\n\t      if (isObject(resizeOptions.edges)) {\n\t        for (var edge in resizeEdges) {\n\t          resizeEdges[edge] = checkResizeEdge(edge, resizeOptions.edges[edge], page, interaction._eventTarget, element, rect, resizeOptions.margin || margin);\n\t        }\n\t\n\t        resizeEdges.left = resizeEdges.left && !resizeEdges.right;\n\t        resizeEdges.top = resizeEdges.top && !resizeEdges.bottom;\n\t\n\t        shouldResize = resizeEdges.left || resizeEdges.right || resizeEdges.top || resizeEdges.bottom;\n\t      } else {\n\t        var right = options.resize.axis !== 'y' && page.x > rect.right - margin,\n\t            bottom = options.resize.axis !== 'x' && page.y > rect.bottom - margin;\n\t\n\t        shouldResize = right || bottom;\n\t        resizeAxes = (right ? 'x' : '') + (bottom ? 'y' : '');\n\t      }\n\t    }\n\t\n\t    action = shouldResize ? 'resize' : actionIsEnabled.drag && options.drag.enabled ? 'drag' : null;\n\t\n\t    if (actionIsEnabled.gesture && interaction.pointerIds.length >= 2 && !(interaction.dragging || interaction.resizing)) {\n\t      action = 'gesture';\n\t    }\n\t\n\t    if (action) {\n\t      return {\n\t        name: action,\n\t        axis: resizeAxes,\n\t        edges: resizeEdges\n\t      };\n\t    }\n\t\n\t    return null;\n\t  }\n\t\n\t  // Check if action is enabled globally and the current target supports it\n\t  // If so, return the validated action. Otherwise, return null\n\t  function validateAction(action, interactable) {\n\t    if (!isObject(action)) {\n\t      return null;\n\t    }\n\t\n\t    var actionName = action.name,\n\t        options = interactable.options;\n\t\n\t    if ((actionName === 'resize' && options.resize.enabled || actionName === 'drag' && options.drag.enabled || actionName === 'gesture' && options.gesture.enabled) && actionIsEnabled[actionName]) {\n\t\n\t      if (actionName === 'resize' || actionName === 'resizeyx') {\n\t        actionName = 'resizexy';\n\t      }\n\t\n\t      return action;\n\t    }\n\t    return null;\n\t  }\n\t\n\t  var listeners = {},\n\t      interactionListeners = ['dragStart', 'dragMove', 'resizeStart', 'resizeMove', 'gestureStart', 'gestureMove', 'pointerOver', 'pointerOut', 'pointerHover', 'selectorDown', 'pointerDown', 'pointerMove', 'pointerUp', 'pointerCancel', 'pointerEnd', 'addPointer', 'removePointer', 'recordPointer', 'autoScrollMove'];\n\t\n\t  for (var i = 0, len = interactionListeners.length; i < len; i++) {\n\t    var name = interactionListeners[i];\n\t\n\t    listeners[name] = doOnInteractions(name);\n\t  }\n\t\n\t  // bound to the interactable context when a DOM event\n\t  // listener is added to a selector interactable\n\t  function delegateListener(event, useCapture) {\n\t    var fakeEvent = {},\n\t        delegated = delegatedEvents[event.type],\n\t        eventTarget = getActualElement(event.path ? event.path[0] : event.target),\n\t        element = eventTarget;\n\t\n\t    useCapture = useCapture ? true : false;\n\t\n\t    // duplicate the event so that currentTarget can be changed\n\t    for (var prop in event) {\n\t      fakeEvent[prop] = event[prop];\n\t    }\n\t\n\t    fakeEvent.originalEvent = event;\n\t    fakeEvent.preventDefault = preventOriginalDefault;\n\t\n\t    // climb up document tree looking for selector matches\n\t    while (isElement(element)) {\n\t      for (var i = 0; i < delegated.selectors.length; i++) {\n\t        var selector = delegated.selectors[i],\n\t            context = delegated.contexts[i];\n\t\n\t        if (matchesSelector(element, selector) && nodeContains(context, eventTarget) && nodeContains(context, element)) {\n\t\n\t          var listeners = delegated.listeners[i];\n\t\n\t          fakeEvent.currentTarget = element;\n\t\n\t          for (var j = 0; j < listeners.length; j++) {\n\t            if (listeners[j][1] === useCapture) {\n\t              listeners[j][0](fakeEvent);\n\t            }\n\t          }\n\t        }\n\t      }\n\t\n\t      element = parentElement(element);\n\t    }\n\t  }\n\t\n\t  function delegateUseCapture(event) {\n\t    return delegateListener.call(this, event, true);\n\t  }\n\t\n\t  interactables.indexOfElement = function indexOfElement(element, context) {\n\t    context = context || document;\n\t\n\t    for (var i = 0; i < this.length; i++) {\n\t      var interactable = this[i];\n\t\n\t      if (interactable.selector === element && interactable._context === context || !interactable.selector && interactable._element === element) {\n\t\n\t        return i;\n\t      }\n\t    }\n\t    return -1;\n\t  };\n\t\n\t  interactables.get = function interactableGet(element, options) {\n\t    return this[this.indexOfElement(element, options && options.context)];\n\t  };\n\t\n\t  interactables.forEachSelector = function (callback) {\n\t    for (var i = 0; i < this.length; i++) {\n\t      var interactable = this[i];\n\t\n\t      if (!interactable.selector) {\n\t        continue;\n\t      }\n\t\n\t      var ret = callback(interactable, interactable.selector, interactable._context, i, this);\n\t\n\t      if (ret !== undefined) {\n\t        return ret;\n\t      }\n\t    }\n\t  };\n\t\n\t  /*\\\n\t     * interact\n\t     [ method ]\n\t     *\n\t     * The methods of this variable can be used to set elements as\n\t     * interactables and also to change various default settings.\n\t     *\n\t     * Calling it as a function and passing an element or a valid CSS selector\n\t     * string returns an Interactable object which has various methods to\n\t     * configure it.\n\t     *\n\t     - element (Element | string) The HTML or SVG Element to interact with or CSS selector\n\t     = (object) An @Interactable\n\t     *\n\t     > Usage\n\t     | interact(document.getElementById('draggable')).draggable(true);\n\t     |\n\t     | var rectables = interact('rect');\n\t     | rectables\n\t     |     .gesturable(true)\n\t     |     .on('gesturemove', function (event) {\n\t     |         // something cool...\n\t     |     })\n\t     |     .autoScroll(true);\n\t    \\*/\n\t  function interact(element, options) {\n\t    return interactables.get(element, options) || new Interactable(element, options);\n\t  }\n\t\n\t  /*\\\n\t     * Interactable\n\t     [ property ]\n\t     **\n\t     * Object type returned by @interact\n\t    \\*/\n\t  function Interactable(element, options) {\n\t    this._element = element;\n\t    this._iEvents = this._iEvents || {};\n\t\n\t    var _window;\n\t\n\t    if (trySelector(element)) {\n\t      this.selector = element;\n\t\n\t      var context = options && options.context;\n\t\n\t      _window = context ? getWindow(context) : window;\n\t\n\t      if (context && (_window.Node ? context instanceof _window.Node : isElement(context) || context === _window.document)) {\n\t\n\t        this._context = context;\n\t      }\n\t    } else {\n\t      _window = getWindow(element);\n\t\n\t      if (isElement(element, _window)) {\n\t\n\t        if (supportsPointerEvent) {\n\t          events.add(this._element, pEventTypes.down, listeners.pointerDown);\n\t          events.add(this._element, pEventTypes.move, listeners.pointerHover);\n\t        } else {\n\t          events.add(this._element, 'mousedown', listeners.pointerDown);\n\t          events.add(this._element, 'mousemove', listeners.pointerHover);\n\t          events.add(this._element, 'touchstart', listeners.pointerDown);\n\t          events.add(this._element, 'touchmove', listeners.pointerHover);\n\t        }\n\t      }\n\t    }\n\t\n\t    this._doc = _window.document;\n\t\n\t    if (!contains(documents, this._doc)) {\n\t      listenToDocument(this._doc);\n\t    }\n\t\n\t    interactables.push(this);\n\t\n\t    this.set(options);\n\t  }\n\t\n\t  Interactable.prototype = {\n\t    setOnEvents: function setOnEvents(action, phases) {\n\t      if (action === 'drop') {\n\t        if (isFunction(phases.ondrop)) {\n\t          this.ondrop = phases.ondrop;\n\t        }\n\t        if (isFunction(phases.ondropactivate)) {\n\t          this.ondropactivate = phases.ondropactivate;\n\t        }\n\t        if (isFunction(phases.ondropdeactivate)) {\n\t          this.ondropdeactivate = phases.ondropdeactivate;\n\t        }\n\t        if (isFunction(phases.ondragenter)) {\n\t          this.ondragenter = phases.ondragenter;\n\t        }\n\t        if (isFunction(phases.ondragleave)) {\n\t          this.ondragleave = phases.ondragleave;\n\t        }\n\t        if (isFunction(phases.ondropmove)) {\n\t          this.ondropmove = phases.ondropmove;\n\t        }\n\t      } else {\n\t        action = 'on' + action;\n\t\n\t        if (isFunction(phases.onstart)) {\n\t          this[action + 'start'] = phases.onstart;\n\t        }\n\t        if (isFunction(phases.onmove)) {\n\t          this[action + 'move'] = phases.onmove;\n\t        }\n\t        if (isFunction(phases.onend)) {\n\t          this[action + 'end'] = phases.onend;\n\t        }\n\t        if (isFunction(phases.oninertiastart)) {\n\t          this[action + 'inertiastart'] = phases.oninertiastart;\n\t        }\n\t      }\n\t\n\t      return this;\n\t    },\n\t\n\t    /*\\\n\t         * Interactable.draggable\n\t         [ method ]\n\t         *\n\t         * Gets or sets whether drag actions can be performed on the\n\t         * Interactable\n\t         *\n\t         = (boolean) Indicates if this can be the target of drag events\n\t         | var isDraggable = interact('ul li').draggable();\n\t         * or\n\t         - options (boolean | object) #optional true/false or An object with event listeners to be fired on drag events (object makes the Interactable draggable)\n\t         = (object) This Interactable\n\t         | interact(element).draggable({\n\t         |     onstart: function (event) {},\n\t         |     onmove : function (event) {},\n\t         |     onend  : function (event) {},\n\t         |\n\t         |     // the axis in which the first movement must be\n\t         |     // for the drag sequence to start\n\t         |     // 'xy' by default - any direction\n\t         |     axis: 'x' || 'y' || 'xy',\n\t         |\n\t         |     // max number of drags that can happen concurrently\n\t         |     // with elements of this Interactable. Infinity by default\n\t         |     max: Infinity,\n\t         |\n\t         |     // max number of drags that can target the same element+Interactable\n\t         |     // 1 by default\n\t         |     maxPerElement: 2\n\t         | });\n\t        \\*/\n\t    draggable: function draggable(options) {\n\t      if (isObject(options)) {\n\t        this.options.drag.enabled = options.enabled === false ? false : true;\n\t        this.setPerAction('drag', options);\n\t        this.setOnEvents('drag', options);\n\t\n\t        if (/^x$|^y$|^xy$/.test(options.axis)) {\n\t          this.options.drag.axis = options.axis;\n\t        } else if (options.axis === null) {\n\t          delete this.options.drag.axis;\n\t        }\n\t\n\t        return this;\n\t      }\n\t\n\t      if (isBool(options)) {\n\t        this.options.drag.enabled = options;\n\t\n\t        return this;\n\t      }\n\t\n\t      return this.options.drag;\n\t    },\n\t\n\t    setPerAction: function setPerAction(action, options) {\n\t      // for all the default per-action options\n\t      for (var option in options) {\n\t        // if this option exists for this action\n\t        if (option in defaultOptions[action]) {\n\t          // if the option in the options arg is an object value\n\t          if (isObject(options[option])) {\n\t            // duplicate the object\n\t            this.options[action][option] = extend(this.options[action][option] || {}, options[option]);\n\t\n\t            if (isObject(defaultOptions.perAction[option]) && 'enabled' in defaultOptions.perAction[option]) {\n\t              this.options[action][option].enabled = options[option].enabled === false ? false : true;\n\t            }\n\t          } else if (isBool(options[option]) && isObject(defaultOptions.perAction[option])) {\n\t            this.options[action][option].enabled = options[option];\n\t          } else if (options[option] !== undefined) {\n\t            // or if it's not undefined, do a plain assignment\n\t            this.options[action][option] = options[option];\n\t          }\n\t        }\n\t      }\n\t    },\n\t\n\t    /*\\\n\t         * Interactable.dropzone\n\t         [ method ]\n\t         *\n\t         * Returns or sets whether elements can be dropped onto this\n\t         * Interactable to trigger drop events\n\t         *\n\t         * Dropzones can receive the following events:\n\t         *  - `dropactivate` and `dropdeactivate` when an acceptable drag starts and ends\n\t         *  - `dragenter` and `dragleave` when a draggable enters and leaves the dropzone\n\t         *  - `dragmove` when a draggable that has entered the dropzone is moved\n\t         *  - `drop` when a draggable is dropped into this dropzone\n\t         *\n\t         *  Use the `accept` option to allow only elements that match the given CSS selector or element.\n\t         *\n\t         *  Use the `overlap` option to set how drops are checked for. The allowed values are:\n\t         *   - `'pointer'`, the pointer must be over the dropzone (default)\n\t         *   - `'center'`, the draggable element's center must be over the dropzone\n\t         *   - a number from 0-1 which is the `(intersection area) / (draggable area)`.\n\t         *       e.g. `0.5` for drop to happen when half of the area of the\n\t         *       draggable is over the dropzone\n\t         *\n\t         - options (boolean | object | null) #optional The new value to be set.\n\t         | interact('.drop').dropzone({\n\t         |   accept: '.can-drop' || document.getElementById('single-drop'),\n\t         |   overlap: 'pointer' || 'center' || zeroToOne\n\t         | }\n\t         = (boolean | object) The current setting or this Interactable\n\t        \\*/\n\t    dropzone: function dropzone(options) {\n\t      if (isObject(options)) {\n\t        this.options.drop.enabled = options.enabled === false ? false : true;\n\t        this.setOnEvents('drop', options);\n\t\n\t        if (/^(pointer|center)$/.test(options.overlap)) {\n\t          this.options.drop.overlap = options.overlap;\n\t        } else if (isNumber(options.overlap)) {\n\t          this.options.drop.overlap = Math.max(Math.min(1, options.overlap), 0);\n\t        }\n\t        if ('accept' in options) {\n\t          this.options.drop.accept = options.accept;\n\t        }\n\t        if ('checker' in options) {\n\t          this.options.drop.checker = options.checker;\n\t        }\n\t\n\t        return this;\n\t      }\n\t\n\t      if (isBool(options)) {\n\t        this.options.drop.enabled = options;\n\t\n\t        return this;\n\t      }\n\t\n\t      return this.options.drop;\n\t    },\n\t\n\t    dropCheck: function dropCheck(dragEvent, event, draggable, draggableElement, dropElement, rect) {\n\t      var dropped = false;\n\t\n\t      // if the dropzone has no rect (eg. display: none)\n\t      // call the custom dropChecker or just return false\n\t      if (!(rect = rect || this.getRect(dropElement))) {\n\t        return this.options.drop.checker ? this.options.drop.checker(dragEvent, event, dropped, this, dropElement, draggable, draggableElement) : false;\n\t      }\n\t\n\t      var dropOverlap = this.options.drop.overlap;\n\t\n\t      if (dropOverlap === 'pointer') {\n\t        var page = _getPageXY(dragEvent),\n\t            origin = getOriginXY(draggable, draggableElement),\n\t            horizontal,\n\t            vertical;\n\t\n\t        page.x += origin.x;\n\t        page.y += origin.y;\n\t\n\t        horizontal = page.x > rect.left && page.x < rect.right;\n\t        vertical = page.y > rect.top && page.y < rect.bottom;\n\t\n\t        dropped = horizontal && vertical;\n\t      }\n\t\n\t      var dragRect = draggable.getRect(draggableElement);\n\t\n\t      if (dropOverlap === 'center') {\n\t        var cx = dragRect.left + dragRect.width / 2,\n\t            cy = dragRect.top + dragRect.height / 2;\n\t\n\t        dropped = cx >= rect.left && cx <= rect.right && cy >= rect.top && cy <= rect.bottom;\n\t      }\n\t\n\t      if (isNumber(dropOverlap)) {\n\t        var overlapArea = Math.max(0, Math.min(rect.right, dragRect.right) - Math.max(rect.left, dragRect.left)) * Math.max(0, Math.min(rect.bottom, dragRect.bottom) - Math.max(rect.top, dragRect.top)),\n\t            overlapRatio = overlapArea / (dragRect.width * dragRect.height);\n\t\n\t        dropped = overlapRatio >= dropOverlap;\n\t      }\n\t\n\t      if (this.options.drop.checker) {\n\t        dropped = this.options.drop.checker(dragEvent, event, dropped, this, dropElement, draggable, draggableElement);\n\t      }\n\t\n\t      return dropped;\n\t    },\n\t\n\t    /*\\\n\t         * Interactable.dropChecker\n\t         [ method ]\n\t         *\n\t         * DEPRECATED. Use interactable.dropzone({ checker: function... }) instead.\n\t         *\n\t         * Gets or sets the function used to check if a dragged element is\n\t         * over this Interactable.\n\t         *\n\t         - checker (function) #optional The function that will be called when checking for a drop\n\t         = (Function | Interactable) The checker function or this Interactable\n\t         *\n\t         * The checker function takes the following arguments:\n\t         *\n\t         - dragEvent (InteractEvent) The related dragmove or dragend event\n\t         - event (TouchEvent | PointerEvent | MouseEvent) The user move/up/end Event related to the dragEvent\n\t         - dropped (boolean) The value from the default drop checker\n\t         - dropzone (Interactable) The dropzone interactable\n\t         - dropElement (Element) The dropzone element\n\t         - draggable (Interactable) The Interactable being dragged\n\t         - draggableElement (Element) The actual element that's being dragged\n\t         *\n\t         > Usage:\n\t         | interact(target)\n\t         | .dropChecker(function(dragEvent,         // related dragmove or dragend event\n\t         |                       event,             // TouchEvent/PointerEvent/MouseEvent\n\t         |                       dropped,           // bool result of the default checker\n\t         |                       dropzone,          // dropzone Interactable\n\t         |                       dropElement,       // dropzone elemnt\n\t         |                       draggable,         // draggable Interactable\n\t         |                       draggableElement) {// draggable element\n\t         |\n\t         |   return dropped && event.target.hasAttribute('allow-drop');\n\t         | }\n\t        \\*/\n\t    dropChecker: function dropChecker(checker) {\n\t      if (isFunction(checker)) {\n\t        this.options.drop.checker = checker;\n\t\n\t        return this;\n\t      }\n\t      if (checker === null) {\n\t        delete this.options.getRect;\n\t\n\t        return this;\n\t      }\n\t\n\t      return this.options.drop.checker;\n\t    },\n\t\n\t    /*\\\n\t         * Interactable.accept\n\t         [ method ]\n\t         *\n\t         * Deprecated. add an `accept` property to the options object passed to\n\t         * @Interactable.dropzone instead.\n\t         *\n\t         * Gets or sets the Element or CSS selector match that this\n\t         * Interactable accepts if it is a dropzone.\n\t         *\n\t         - newValue (Element | string | null) #optional\n\t         * If it is an Element, then only that element can be dropped into this dropzone.\n\t         * If it is a string, the element being dragged must match it as a selector.\n\t         * If it is null, the accept options is cleared - it accepts any element.\n\t         *\n\t         = (string | Element | null | Interactable) The current accept option if given `undefined` or this Interactable\n\t        \\*/\n\t    accept: function accept(newValue) {\n\t      if (isElement(newValue)) {\n\t        this.options.drop.accept = newValue;\n\t\n\t        return this;\n\t      }\n\t\n\t      // test if it is a valid CSS selector\n\t      if (trySelector(newValue)) {\n\t        this.options.drop.accept = newValue;\n\t\n\t        return this;\n\t      }\n\t\n\t      if (newValue === null) {\n\t        delete this.options.drop.accept;\n\t\n\t        return this;\n\t      }\n\t\n\t      return this.options.drop.accept;\n\t    },\n\t\n\t    /*\\\n\t         * Interactable.resizable\n\t         [ method ]\n\t         *\n\t         * Gets or sets whether resize actions can be performed on the\n\t         * Interactable\n\t         *\n\t         = (boolean) Indicates if this can be the target of resize elements\n\t         | var isResizeable = interact('input[type=text]').resizable();\n\t         * or\n\t         - options (boolean | object) #optional true/false or An object with event listeners to be fired on resize events (object makes the Interactable resizable)\n\t         = (object) This Interactable\n\t         | interact(element).resizable({\n\t         |     onstart: function (event) {},\n\t         |     onmove : function (event) {},\n\t         |     onend  : function (event) {},\n\t         |\n\t         |     edges: {\n\t         |       top   : true,       // Use pointer coords to check for resize.\n\t         |       left  : false,      // Disable resizing from left edge.\n\t         |       bottom: '.resize-s',// Resize if pointer target matches selector\n\t         |       right : handleEl    // Resize if pointer target is the given Element\n\t         |     },\n\t         |\n\t         |     // Width and height can be adjusted independently. When `true`, width and\n\t         |     // height are adjusted at a 1:1 ratio.\n\t         |     square: false,\n\t         |\n\t         |     // Width and height can be adjusted independently. When `true`, width and\n\t         |     // height maintain the aspect ratio they had when resizing started.\n\t         |     preserveAspectRatio: false,\n\t         |\n\t         |     // a value of 'none' will limit the resize rect to a minimum of 0x0\n\t         |     // 'negate' will allow the rect to have negative width/height\n\t         |     // 'reposition' will keep the width/height positive by swapping\n\t         |     // the top and bottom edges and/or swapping the left and right edges\n\t         |     invert: 'none' || 'negate' || 'reposition'\n\t         |\n\t         |     // limit multiple resizes.\n\t         |     // See the explanation in the @Interactable.draggable example\n\t         |     max: Infinity,\n\t         |     maxPerElement: 1,\n\t         | });\n\t        \\*/\n\t    resizable: function resizable(options) {\n\t      if (isObject(options)) {\n\t        this.options.resize.enabled = options.enabled === false ? false : true;\n\t        this.setPerAction('resize', options);\n\t        this.setOnEvents('resize', options);\n\t\n\t        if (/^x$|^y$|^xy$/.test(options.axis)) {\n\t          this.options.resize.axis = options.axis;\n\t        } else if (options.axis === null) {\n\t          this.options.resize.axis = defaultOptions.resize.axis;\n\t        }\n\t\n\t        if (isBool(options.preserveAspectRatio)) {\n\t          this.options.resize.preserveAspectRatio = options.preserveAspectRatio;\n\t        } else if (isBool(options.square)) {\n\t          this.options.resize.square = options.square;\n\t        }\n\t\n\t        return this;\n\t      }\n\t      if (isBool(options)) {\n\t        this.options.resize.enabled = options;\n\t\n\t        return this;\n\t      }\n\t      return this.options.resize;\n\t    },\n\t\n\t    /*\\\n\t         * Interactable.squareResize\n\t         [ method ]\n\t         *\n\t         * Deprecated. Add a `square: true || false` property to @Interactable.resizable instead\n\t         *\n\t         * Gets or sets whether resizing is forced 1:1 aspect\n\t         *\n\t         = (boolean) Current setting\n\t         *\n\t         * or\n\t         *\n\t         - newValue (boolean) #optional\n\t         = (object) this Interactable\n\t        \\*/\n\t    squareResize: function squareResize(newValue) {\n\t      if (isBool(newValue)) {\n\t        this.options.resize.square = newValue;\n\t\n\t        return this;\n\t      }\n\t\n\t      if (newValue === null) {\n\t        delete this.options.resize.square;\n\t\n\t        return this;\n\t      }\n\t\n\t      return this.options.resize.square;\n\t    },\n\t\n\t    /*\\\n\t         * Interactable.gesturable\n\t         [ method ]\n\t         *\n\t         * Gets or sets whether multitouch gestures can be performed on the\n\t         * Interactable's element\n\t         *\n\t         = (boolean) Indicates if this can be the target of gesture events\n\t         | var isGestureable = interact(element).gesturable();\n\t         * or\n\t         - options (boolean | object) #optional true/false or An object with event listeners to be fired on gesture events (makes the Interactable gesturable)\n\t         = (object) this Interactable\n\t         | interact(element).gesturable({\n\t         |     onstart: function (event) {},\n\t         |     onmove : function (event) {},\n\t         |     onend  : function (event) {},\n\t         |\n\t         |     // limit multiple gestures.\n\t         |     // See the explanation in @Interactable.draggable example\n\t         |     max: Infinity,\n\t         |     maxPerElement: 1,\n\t         | });\n\t        \\*/\n\t    gesturable: function gesturable(options) {\n\t      if (isObject(options)) {\n\t        this.options.gesture.enabled = options.enabled === false ? false : true;\n\t        this.setPerAction('gesture', options);\n\t        this.setOnEvents('gesture', options);\n\t\n\t        return this;\n\t      }\n\t\n\t      if (isBool(options)) {\n\t        this.options.gesture.enabled = options;\n\t\n\t        return this;\n\t      }\n\t\n\t      return this.options.gesture;\n\t    },\n\t\n\t    /*\\\n\t         * Interactable.autoScroll\n\t         [ method ]\n\t         **\n\t         * Deprecated. Add an `autoscroll` property to the options object\n\t         * passed to @Interactable.draggable or @Interactable.resizable instead.\n\t         *\n\t         * Returns or sets whether dragging and resizing near the edges of the\n\t         * window/container trigger autoScroll for this Interactable\n\t         *\n\t         = (object) Object with autoScroll properties\n\t         *\n\t         * or\n\t         *\n\t         - options (object | boolean) #optional\n\t         * options can be:\n\t         * - an object with margin, distance and interval properties,\n\t         * - true or false to enable or disable autoScroll or\n\t         = (Interactable) this Interactable\n\t        \\*/\n\t    autoScroll: function autoScroll(options) {\n\t      if (isObject(options)) {\n\t        options = extend({ actions: ['drag', 'resize'] }, options);\n\t      } else if (isBool(options)) {\n\t        options = { actions: ['drag', 'resize'], enabled: options };\n\t      }\n\t\n\t      return this.setOptions('autoScroll', options);\n\t    },\n\t\n\t    /*\\\n\t         * Interactable.snap\n\t         [ method ]\n\t         **\n\t         * Deprecated. Add a `snap` property to the options object passed\n\t         * to @Interactable.draggable or @Interactable.resizable instead.\n\t         *\n\t         * Returns or sets if and how action coordinates are snapped. By\n\t         * default, snapping is relative to the pointer coordinates. You can\n\t         * change this by setting the\n\t         * [`elementOrigin`](https://github.com/taye/interact.js/pull/72).\n\t         **\n\t         = (boolean | object) `false` if snap is disabled; object with snap properties if snap is enabled\n\t         **\n\t         * or\n\t         **\n\t         - options (object | boolean | null) #optional\n\t         = (Interactable) this Interactable\n\t         > Usage\n\t         | interact(document.querySelector('#thing')).snap({\n\t         |     targets: [\n\t         |         // snap to this specific point\n\t         |         {\n\t         |             x: 100,\n\t         |             y: 100,\n\t         |             range: 25\n\t         |         },\n\t         |         // give this function the x and y page coords and snap to the object returned\n\t         |         function (x, y) {\n\t         |             return {\n\t         |                 x: x,\n\t         |                 y: (75 + 50 * Math.sin(x * 0.04)),\n\t         |                 range: 40\n\t         |             };\n\t         |         },\n\t         |         // create a function that snaps to a grid\n\t         |         interact.createSnapGrid({\n\t         |             x: 50,\n\t         |             y: 50,\n\t         |             range: 10,              // optional\n\t         |             offset: { x: 5, y: 10 } // optional\n\t         |         })\n\t         |     ],\n\t         |     // do not snap during normal movement.\n\t         |     // Instead, trigger only one snapped move event\n\t         |     // immediately before the end event.\n\t         |     endOnly: true,\n\t         |\n\t         |     relativePoints: [\n\t         |         { x: 0, y: 0 },  // snap relative to the top left of the element\n\t         |         { x: 1, y: 1 },  // and also to the bottom right\n\t         |     ],\n\t         |\n\t         |     // offset the snap target coordinates\n\t         |     // can be an object with x/y or 'startCoords'\n\t         |     offset: { x: 50, y: 50 }\n\t         |   }\n\t         | });\n\t        \\*/\n\t    snap: function snap(options) {\n\t      var ret = this.setOptions('snap', options);\n\t\n\t      if (ret === this) {\n\t        return this;\n\t      }\n\t\n\t      return ret.drag;\n\t    },\n\t\n\t    setOptions: function setOptions(option, options) {\n\t      var actions = options && isArray(options.actions) ? options.actions : ['drag'];\n\t\n\t      var i;\n\t\n\t      if (isObject(options) || isBool(options)) {\n\t        for (i = 0; i < actions.length; i++) {\n\t          var action = /resize/.test(actions[i]) ? 'resize' : actions[i];\n\t\n\t          if (!isObject(this.options[action])) {\n\t            continue;\n\t          }\n\t\n\t          var thisOption = this.options[action][option];\n\t\n\t          if (isObject(options)) {\n\t            extend(thisOption, options);\n\t            thisOption.enabled = options.enabled === false ? false : true;\n\t\n\t            if (option === 'snap') {\n\t              if (thisOption.mode === 'grid') {\n\t                thisOption.targets = [interact.createSnapGrid(extend({\n\t                  offset: thisOption.gridOffset || { x: 0, y: 0 }\n\t                }, thisOption.grid || {}))];\n\t              } else if (thisOption.mode === 'anchor') {\n\t                thisOption.targets = thisOption.anchors;\n\t              } else if (thisOption.mode === 'path') {\n\t                thisOption.targets = thisOption.paths;\n\t              }\n\t\n\t              if ('elementOrigin' in options) {\n\t                thisOption.relativePoints = [options.elementOrigin];\n\t              }\n\t            }\n\t          } else if (isBool(options)) {\n\t            thisOption.enabled = options;\n\t          }\n\t        }\n\t\n\t        return this;\n\t      }\n\t\n\t      var ret = {},\n\t          allActions = ['drag', 'resize', 'gesture'];\n\t\n\t      for (i = 0; i < allActions.length; i++) {\n\t        if (option in defaultOptions[allActions[i]]) {\n\t          ret[allActions[i]] = this.options[allActions[i]][option];\n\t        }\n\t      }\n\t\n\t      return ret;\n\t    },\n\t\n\t    /*\\\n\t         * Interactable.inertia\n\t         [ method ]\n\t         **\n\t         * Deprecated. Add an `inertia` property to the options object passed\n\t         * to @Interactable.draggable or @Interactable.resizable instead.\n\t         *\n\t         * Returns or sets if and how events continue to run after the pointer is released\n\t         **\n\t         = (boolean | object) `false` if inertia is disabled; `object` with inertia properties if inertia is enabled\n\t         **\n\t         * or\n\t         **\n\t         - options (object | boolean | null) #optional\n\t         = (Interactable) this Interactable\n\t         > Usage\n\t         | // enable and use default settings\n\t         | interact(element).inertia(true);\n\t         |\n\t         | // enable and use custom settings\n\t         | interact(element).inertia({\n\t         |     // value greater than 0\n\t         |     // high values slow the object down more quickly\n\t         |     resistance     : 16,\n\t         |\n\t         |     // the minimum launch speed (pixels per second) that results in inertia start\n\t         |     minSpeed       : 200,\n\t         |\n\t         |     // inertia will stop when the object slows down to this speed\n\t         |     endSpeed       : 20,\n\t         |\n\t         |     // boolean; should actions be resumed when the pointer goes down during inertia\n\t         |     allowResume    : true,\n\t         |\n\t         |     // boolean; should the jump when resuming from inertia be ignored in event.dx/dy\n\t         |     zeroResumeDelta: false,\n\t         |\n\t         |     // if snap/restrict are set to be endOnly and inertia is enabled, releasing\n\t         |     // the pointer without triggering inertia will animate from the release\n\t         |     // point to the snaped/restricted point in the given amount of time (ms)\n\t         |     smoothEndDuration: 300,\n\t         |\n\t         |     // an array of action types that can have inertia (no gesture)\n\t         |     actions        : ['drag', 'resize']\n\t         | });\n\t         |\n\t         | // reset custom settings and use all defaults\n\t         | interact(element).inertia(null);\n\t        \\*/\n\t    inertia: function inertia(options) {\n\t      var ret = this.setOptions('inertia', options);\n\t\n\t      if (ret === this) {\n\t        return this;\n\t      }\n\t\n\t      return ret.drag;\n\t    },\n\t\n\t    getAction: function getAction(pointer, event, interaction, element) {\n\t      var action = this.defaultActionChecker(pointer, interaction, element);\n\t\n\t      if (this.options.actionChecker) {\n\t        return this.options.actionChecker(pointer, event, action, this, element, interaction);\n\t      }\n\t\n\t      return action;\n\t    },\n\t\n\t    defaultActionChecker: defaultActionChecker,\n\t\n\t    /*\\\n\t         * Interactable.actionChecker\n\t         [ method ]\n\t         *\n\t         * Gets or sets the function used to check action to be performed on\n\t         * pointerDown\n\t         *\n\t         - checker (function | null) #optional A function which takes a pointer event, defaultAction string, interactable, element and interaction as parameters and returns an object with name property 'drag' 'resize' or 'gesture' and optionally an `edges` object with boolean 'top', 'left', 'bottom' and right props.\n\t         = (Function | Interactable) The checker function or this Interactable\n\t         *\n\t         | interact('.resize-drag')\n\t         |   .resizable(true)\n\t         |   .draggable(true)\n\t         |   .actionChecker(function (pointer, event, action, interactable, element, interaction) {\n\t         |\n\t         |   if (interact.matchesSelector(event.target, '.drag-handle') {\n\t         |     // force drag with handle target\n\t         |     action.name = drag;\n\t         |   }\n\t         |   else {\n\t         |     // resize from the top and right edges\n\t         |     action.name  = 'resize';\n\t         |     action.edges = { top: true, right: true };\n\t         |   }\n\t         |\n\t         |   return action;\n\t         | });\n\t        \\*/\n\t    actionChecker: function actionChecker(checker) {\n\t      if (isFunction(checker)) {\n\t        this.options.actionChecker = checker;\n\t\n\t        return this;\n\t      }\n\t\n\t      if (checker === null) {\n\t        delete this.options.actionChecker;\n\t\n\t        return this;\n\t      }\n\t\n\t      return this.options.actionChecker;\n\t    },\n\t\n\t    /*\\\n\t         * Interactable.getRect\n\t         [ method ]\n\t         *\n\t         * The default function to get an Interactables bounding rect. Can be\n\t         * overridden using @Interactable.rectChecker.\n\t         *\n\t         - element (Element) #optional The element to measure.\n\t         = (object) The object's bounding rectangle.\n\t         o {\n\t         o     top   : 0,\n\t         o     left  : 0,\n\t         o     bottom: 0,\n\t         o     right : 0,\n\t         o     width : 0,\n\t         o     height: 0\n\t         o }\n\t        \\*/\n\t    getRect: function rectCheck(element) {\n\t      element = element || this._element;\n\t\n\t      if (this.selector && !isElement(element)) {\n\t        element = this._context.querySelector(this.selector);\n\t      }\n\t\n\t      return getElementRect(element);\n\t    },\n\t\n\t    /*\\\n\t         * Interactable.rectChecker\n\t         [ method ]\n\t         *\n\t         * Returns or sets the function used to calculate the interactable's\n\t         * element's rectangle\n\t         *\n\t         - checker (function) #optional A function which returns this Interactable's bounding rectangle. See @Interactable.getRect\n\t         = (function | object) The checker function or this Interactable\n\t        \\*/\n\t    rectChecker: function rectChecker(checker) {\n\t      if (isFunction(checker)) {\n\t        this.getRect = checker;\n\t\n\t        return this;\n\t      }\n\t\n\t      if (checker === null) {\n\t        delete this.options.getRect;\n\t\n\t        return this;\n\t      }\n\t\n\t      return this.getRect;\n\t    },\n\t\n\t    /*\\\n\t         * Interactable.styleCursor\n\t         [ method ]\n\t         *\n\t         * Returns or sets whether the action that would be performed when the\n\t         * mouse on the element are checked on `mousemove` so that the cursor\n\t         * may be styled appropriately\n\t         *\n\t         - newValue (boolean) #optional\n\t         = (boolean | Interactable) The current setting or this Interactable\n\t        \\*/\n\t    styleCursor: function styleCursor(newValue) {\n\t      if (isBool(newValue)) {\n\t        this.options.styleCursor = newValue;\n\t\n\t        return this;\n\t      }\n\t\n\t      if (newValue === null) {\n\t        delete this.options.styleCursor;\n\t\n\t        return this;\n\t      }\n\t\n\t      return this.options.styleCursor;\n\t    },\n\t\n\t    /*\\\n\t         * Interactable.preventDefault\n\t         [ method ]\n\t         *\n\t         * Returns or sets whether to prevent the browser's default behaviour\n\t         * in response to pointer events. Can be set to:\n\t         *  - `'always'` to always prevent\n\t         *  - `'never'` to never prevent\n\t         *  - `'auto'` to let interact.js try to determine what would be best\n\t         *\n\t         - newValue (string) #optional `true`, `false` or `'auto'`\n\t         = (string | Interactable) The current setting or this Interactable\n\t        \\*/\n\t    preventDefault: function preventDefault(newValue) {\n\t      if (/^(always|never|auto)$/.test(newValue)) {\n\t        this.options.preventDefault = newValue;\n\t        return this;\n\t      }\n\t\n\t      if (isBool(newValue)) {\n\t        this.options.preventDefault = newValue ? 'always' : 'never';\n\t        return this;\n\t      }\n\t\n\t      return this.options.preventDefault;\n\t    },\n\t\n\t    /*\\\n\t         * Interactable.origin\n\t         [ method ]\n\t         *\n\t         * Gets or sets the origin of the Interactable's element.  The x and y\n\t         * of the origin will be subtracted from action event coordinates.\n\t         *\n\t         - origin (object | string) #optional An object eg. { x: 0, y: 0 } or string 'parent', 'self' or any CSS selector\n\t         * OR\n\t         - origin (Element) #optional An HTML or SVG Element whose rect will be used\n\t         **\n\t         = (object) The current origin or this Interactable\n\t        \\*/\n\t    origin: function origin(newValue) {\n\t      if (trySelector(newValue)) {\n\t        this.options.origin = newValue;\n\t        return this;\n\t      } else if (isObject(newValue)) {\n\t        this.options.origin = newValue;\n\t        return this;\n\t      }\n\t\n\t      return this.options.origin;\n\t    },\n\t\n\t    /*\\\n\t         * Interactable.deltaSource\n\t         [ method ]\n\t         *\n\t         * Returns or sets the mouse coordinate types used to calculate the\n\t         * movement of the pointer.\n\t         *\n\t         - newValue (string) #optional Use 'client' if you will be scrolling while interacting; Use 'page' if you want autoScroll to work\n\t         = (string | object) The current deltaSource or this Interactable\n\t        \\*/\n\t    deltaSource: function deltaSource(newValue) {\n\t      if (newValue === 'page' || newValue === 'client') {\n\t        this.options.deltaSource = newValue;\n\t\n\t        return this;\n\t      }\n\t\n\t      return this.options.deltaSource;\n\t    },\n\t\n\t    /*\\\n\t         * Interactable.restrict\n\t         [ method ]\n\t         **\n\t         * Deprecated. Add a `restrict` property to the options object passed to\n\t         * @Interactable.draggable, @Interactable.resizable or @Interactable.gesturable instead.\n\t         *\n\t         * Returns or sets the rectangles within which actions on this\n\t         * interactable (after snap calculations) are restricted. By default,\n\t         * restricting is relative to the pointer coordinates. You can change\n\t         * this by setting the\n\t         * [`elementRect`](https://github.com/taye/interact.js/pull/72).\n\t         **\n\t         - options (object) #optional an object with keys drag, resize, and/or gesture whose values are rects, Elements, CSS selectors, or 'parent' or 'self'\n\t         = (object) The current restrictions object or this Interactable\n\t         **\n\t         | interact(element).restrict({\n\t         |     // the rect will be `interact.getElementRect(element.parentNode)`\n\t         |     drag: element.parentNode,\n\t         |\n\t         |     // x and y are relative to the the interactable's origin\n\t         |     resize: { x: 100, y: 100, width: 200, height: 200 }\n\t         | })\n\t         |\n\t         | interact('.draggable').restrict({\n\t         |     // the rect will be the selected element's parent\n\t         |     drag: 'parent',\n\t         |\n\t         |     // do not restrict during normal movement.\n\t         |     // Instead, trigger only one restricted move event\n\t         |     // immediately before the end event.\n\t         |     endOnly: true,\n\t         |\n\t         |     // https://github.com/taye/interact.js/pull/72#issue-41813493\n\t         |     elementRect: { top: 0, left: 0, bottom: 1, right: 1 }\n\t         | });\n\t        \\*/\n\t    restrict: function restrict(options) {\n\t      if (!isObject(options)) {\n\t        return this.setOptions('restrict', options);\n\t      }\n\t\n\t      var actions = ['drag', 'resize', 'gesture'],\n\t          ret;\n\t\n\t      for (var i = 0; i < actions.length; i++) {\n\t        var action = actions[i];\n\t\n\t        if (action in options) {\n\t          var perAction = extend({\n\t            actions: [action],\n\t            restriction: options[action]\n\t          }, options);\n\t\n\t          ret = this.setOptions('restrict', perAction);\n\t        }\n\t      }\n\t\n\t      return ret;\n\t    },\n\t\n\t    /*\\\n\t         * Interactable.context\n\t         [ method ]\n\t         *\n\t         * Gets the selector context Node of the Interactable. The default is `window.document`.\n\t         *\n\t         = (Node) The context Node of this Interactable\n\t         **\n\t        \\*/\n\t    context: function context() {\n\t      return this._context;\n\t    },\n\t\n\t    _context: document,\n\t\n\t    /*\\\n\t         * Interactable.ignoreFrom\n\t         [ method ]\n\t         *\n\t         * If the target of the `mousedown`, `pointerdown` or `touchstart`\n\t         * event or any of it's parents match the given CSS selector or\n\t         * Element, no drag/resize/gesture is started.\n\t         *\n\t         - newValue (string | Element | null) #optional a CSS selector string, an Element or `null` to not ignore any elements\n\t         = (string | Element | object) The current ignoreFrom value or this Interactable\n\t         **\n\t         | interact(element, { ignoreFrom: document.getElementById('no-action') });\n\t         | // or\n\t         | interact(element).ignoreFrom('input, textarea, a');\n\t        \\*/\n\t    ignoreFrom: function ignoreFrom(newValue) {\n\t      if (trySelector(newValue)) {\n\t        // CSS selector to match event.target\n\t        this.options.ignoreFrom = newValue;\n\t        return this;\n\t      }\n\t\n\t      if (isElement(newValue)) {\n\t        // specific element\n\t        this.options.ignoreFrom = newValue;\n\t        return this;\n\t      }\n\t\n\t      return this.options.ignoreFrom;\n\t    },\n\t\n\t    /*\\\n\t         * Interactable.allowFrom\n\t         [ method ]\n\t         *\n\t         * A drag/resize/gesture is started only If the target of the\n\t         * `mousedown`, `pointerdown` or `touchstart` event or any of it's\n\t         * parents match the given CSS selector or Element.\n\t         *\n\t         - newValue (string | Element | null) #optional a CSS selector string, an Element or `null` to allow from any element\n\t         = (string | Element | object) The current allowFrom value or this Interactable\n\t         **\n\t         | interact(element, { allowFrom: document.getElementById('drag-handle') });\n\t         | // or\n\t         | interact(element).allowFrom('.handle');\n\t        \\*/\n\t    allowFrom: function allowFrom(newValue) {\n\t      if (trySelector(newValue)) {\n\t        // CSS selector to match event.target\n\t        this.options.allowFrom = newValue;\n\t        return this;\n\t      }\n\t\n\t      if (isElement(newValue)) {\n\t        // specific element\n\t        this.options.allowFrom = newValue;\n\t        return this;\n\t      }\n\t\n\t      return this.options.allowFrom;\n\t    },\n\t\n\t    /*\\\n\t         * Interactable.element\n\t         [ method ]\n\t         *\n\t         * If this is not a selector Interactable, it returns the element this\n\t         * interactable represents\n\t         *\n\t         = (Element) HTML / SVG Element\n\t        \\*/\n\t    element: function element() {\n\t      return this._element;\n\t    },\n\t\n\t    /*\\\n\t         * Interactable.fire\n\t         [ method ]\n\t         *\n\t         * Calls listeners for the given InteractEvent type bound globally\n\t         * and directly to this Interactable\n\t         *\n\t         - iEvent (InteractEvent) The InteractEvent object to be fired on this Interactable\n\t         = (Interactable) this Interactable\n\t        \\*/\n\t    fire: function fire(iEvent) {\n\t      if (!(iEvent && iEvent.type) || !contains(eventTypes, iEvent.type)) {\n\t        return this;\n\t      }\n\t\n\t      var listeners,\n\t          i,\n\t          len,\n\t          onEvent = 'on' + iEvent.type,\n\t          funcName = '';\n\t\n\t      // Interactable#on() listeners\n\t      if (iEvent.type in this._iEvents) {\n\t        listeners = this._iEvents[iEvent.type];\n\t\n\t        for (i = 0, len = listeners.length; i < len && !iEvent.immediatePropagationStopped; i++) {\n\t          funcName = listeners[i].name;\n\t          listeners[i](iEvent);\n\t        }\n\t      }\n\t\n\t      // interactable.onevent listener\n\t      if (isFunction(this[onEvent])) {\n\t        funcName = this[onEvent].name;\n\t        this[onEvent](iEvent);\n\t      }\n\t\n\t      // interact.on() listeners\n\t      if (iEvent.type in globalEvents && (listeners = globalEvents[iEvent.type])) {\n\t\n\t        for (i = 0, len = listeners.length; i < len && !iEvent.immediatePropagationStopped; i++) {\n\t          funcName = listeners[i].name;\n\t          listeners[i](iEvent);\n\t        }\n\t      }\n\t\n\t      return this;\n\t    },\n\t\n\t    /*\\\n\t         * Interactable.on\n\t         [ method ]\n\t         *\n\t         * Binds a listener for an InteractEvent or DOM event.\n\t         *\n\t         - eventType  (string | array | object) The types of events to listen for\n\t         - listener   (function) The function to be called on the given event(s)\n\t         - useCapture (boolean) #optional useCapture flag for addEventListener\n\t         = (object) This Interactable\n\t        \\*/\n\t    on: function on(eventType, listener, useCapture) {\n\t      var i;\n\t\n\t      if (isString(eventType) && eventType.search(' ') !== -1) {\n\t        eventType = eventType.trim().split(/ +/);\n\t      }\n\t\n\t      if (isArray(eventType)) {\n\t        for (i = 0; i < eventType.length; i++) {\n\t          this.on(eventType[i], listener, useCapture);\n\t        }\n\t\n\t        return this;\n\t      }\n\t\n\t      if (isObject(eventType)) {\n\t        for (var prop in eventType) {\n\t          this.on(prop, eventType[prop], listener);\n\t        }\n\t\n\t        return this;\n\t      }\n\t\n\t      if (eventType === 'wheel') {\n\t        eventType = wheelEvent;\n\t      }\n\t\n\t      // convert to boolean\n\t      useCapture = useCapture ? true : false;\n\t\n\t      if (contains(eventTypes, eventType)) {\n\t        // if this type of event was never bound to this Interactable\n\t        if (!(eventType in this._iEvents)) {\n\t          this._iEvents[eventType] = [listener];\n\t        } else {\n\t          this._iEvents[eventType].push(listener);\n\t        }\n\t      }\n\t      // delegated event for selector\n\t      else if (this.selector) {\n\t          if (!delegatedEvents[eventType]) {\n\t            delegatedEvents[eventType] = {\n\t              selectors: [],\n\t              contexts: [],\n\t              listeners: []\n\t            };\n\t\n\t            // add delegate listener functions\n\t            for (i = 0; i < documents.length; i++) {\n\t              events.add(documents[i], eventType, delegateListener);\n\t              events.add(documents[i], eventType, delegateUseCapture, true);\n\t            }\n\t          }\n\t\n\t          var delegated = delegatedEvents[eventType],\n\t              index;\n\t\n\t          for (index = delegated.selectors.length - 1; index >= 0; index--) {\n\t            if (delegated.selectors[index] === this.selector && delegated.contexts[index] === this._context) {\n\t              break;\n\t            }\n\t          }\n\t\n\t          if (index === -1) {\n\t            index = delegated.selectors.length;\n\t\n\t            delegated.selectors.push(this.selector);\n\t            delegated.contexts.push(this._context);\n\t            delegated.listeners.push([]);\n\t          }\n\t\n\t          // keep listener and useCapture flag\n\t          delegated.listeners[index].push([listener, useCapture]);\n\t        } else {\n\t          events.add(this._element, eventType, listener, useCapture);\n\t        }\n\t\n\t      return this;\n\t    },\n\t\n\t    /*\\\n\t         * Interactable.off\n\t         [ method ]\n\t         *\n\t         * Removes an InteractEvent or DOM event listener\n\t         *\n\t         - eventType  (string | array | object) The types of events that were listened for\n\t         - listener   (function) The listener function to be removed\n\t         - useCapture (boolean) #optional useCapture flag for removeEventListener\n\t         = (object) This Interactable\n\t        \\*/\n\t    off: function off(eventType, listener, useCapture) {\n\t      var i;\n\t\n\t      if (isString(eventType) && eventType.search(' ') !== -1) {\n\t        eventType = eventType.trim().split(/ +/);\n\t      }\n\t\n\t      if (isArray(eventType)) {\n\t        for (i = 0; i < eventType.length; i++) {\n\t          this.off(eventType[i], listener, useCapture);\n\t        }\n\t\n\t        return this;\n\t      }\n\t\n\t      if (isObject(eventType)) {\n\t        for (var prop in eventType) {\n\t          this.off(prop, eventType[prop], listener);\n\t        }\n\t\n\t        return this;\n\t      }\n\t\n\t      var eventList,\n\t          index = -1;\n\t\n\t      // convert to boolean\n\t      useCapture = useCapture ? true : false;\n\t\n\t      if (eventType === 'wheel') {\n\t        eventType = wheelEvent;\n\t      }\n\t\n\t      // if it is an action event type\n\t      if (contains(eventTypes, eventType)) {\n\t        eventList = this._iEvents[eventType];\n\t\n\t        if (eventList && (index = indexOf(eventList, listener)) !== -1) {\n\t          this._iEvents[eventType].splice(index, 1);\n\t        }\n\t      }\n\t      // delegated event\n\t      else if (this.selector) {\n\t          var delegated = delegatedEvents[eventType],\n\t              matchFound = false;\n\t\n\t          if (!delegated) {\n\t            return this;\n\t          }\n\t\n\t          // count from last index of delegated to 0\n\t          for (index = delegated.selectors.length - 1; index >= 0; index--) {\n\t            // look for matching selector and context Node\n\t            if (delegated.selectors[index] === this.selector && delegated.contexts[index] === this._context) {\n\t\n\t              var listeners = delegated.listeners[index];\n\t\n\t              // each item of the listeners array is an array: [function, useCaptureFlag]\n\t              for (i = listeners.length - 1; i >= 0; i--) {\n\t                var fn = listeners[i][0],\n\t                    useCap = listeners[i][1];\n\t\n\t                // check if the listener functions and useCapture flags match\n\t                if (fn === listener && useCap === useCapture) {\n\t                  // remove the listener from the array of listeners\n\t                  listeners.splice(i, 1);\n\t\n\t                  // if all listeners for this interactable have been removed\n\t                  // remove the interactable from the delegated arrays\n\t                  if (!listeners.length) {\n\t                    delegated.selectors.splice(index, 1);\n\t                    delegated.contexts.splice(index, 1);\n\t                    delegated.listeners.splice(index, 1);\n\t\n\t                    // remove delegate function from context\n\t                    events.remove(this._context, eventType, delegateListener);\n\t                    events.remove(this._context, eventType, delegateUseCapture, true);\n\t\n\t                    // remove the arrays if they are empty\n\t                    if (!delegated.selectors.length) {\n\t                      delegatedEvents[eventType] = null;\n\t                    }\n\t                  }\n\t\n\t                  // only remove one listener\n\t                  matchFound = true;\n\t                  break;\n\t                }\n\t              }\n\t\n\t              if (matchFound) {\n\t                break;\n\t              }\n\t            }\n\t          }\n\t        }\n\t        // remove listener from this Interatable's element\n\t        else {\n\t            events.remove(this._element, eventType, listener, useCapture);\n\t          }\n\t\n\t      return this;\n\t    },\n\t\n\t    /*\\\n\t         * Interactable.set\n\t         [ method ]\n\t         *\n\t         * Reset the options of this Interactable\n\t         - options (object) The new settings to apply\n\t         = (object) This Interactable\n\t        \\*/\n\t    set: function set(options) {\n\t      if (!isObject(options)) {\n\t        options = {};\n\t      }\n\t\n\t      this.options = extend({}, defaultOptions.base);\n\t\n\t      var i,\n\t          actions = ['drag', 'drop', 'resize', 'gesture'],\n\t          methods = ['draggable', 'dropzone', 'resizable', 'gesturable'],\n\t          perActions = extend(extend({}, defaultOptions.perAction), options[action] || {});\n\t\n\t      for (i = 0; i < actions.length; i++) {\n\t        var action = actions[i];\n\t\n\t        this.options[action] = extend({}, defaultOptions[action]);\n\t\n\t        this.setPerAction(action, perActions);\n\t\n\t        this[methods[i]](options[action]);\n\t      }\n\t\n\t      var settings = ['accept', 'actionChecker', 'allowFrom', 'deltaSource', 'dropChecker', 'ignoreFrom', 'origin', 'preventDefault', 'rectChecker', 'styleCursor'];\n\t\n\t      for (i = 0, len = settings.length; i < len; i++) {\n\t        var setting = settings[i];\n\t\n\t        this.options[setting] = defaultOptions.base[setting];\n\t\n\t        if (setting in options) {\n\t          this[setting](options[setting]);\n\t        }\n\t      }\n\t\n\t      return this;\n\t    },\n\t\n\t    /*\\\n\t         * Interactable.unset\n\t         [ method ]\n\t         *\n\t         * Remove this interactable from the list of interactables and remove\n\t         * it's drag, drop, resize and gesture capabilities\n\t         *\n\t         = (object) @interact\n\t        \\*/\n\t    unset: function unset() {\n\t      events.remove(this._element, 'all');\n\t\n\t      if (!isString(this.selector)) {\n\t        events.remove(this, 'all');\n\t        if (this.options.styleCursor) {\n\t          this._element.style.cursor = '';\n\t        }\n\t      } else {\n\t        // remove delegated events\n\t        for (var type in delegatedEvents) {\n\t          var delegated = delegatedEvents[type];\n\t\n\t          for (var i = 0; i < delegated.selectors.length; i++) {\n\t            if (delegated.selectors[i] === this.selector && delegated.contexts[i] === this._context) {\n\t\n\t              delegated.selectors.splice(i, 1);\n\t              delegated.contexts.splice(i, 1);\n\t              delegated.listeners.splice(i, 1);\n\t\n\t              // remove the arrays if they are empty\n\t              if (!delegated.selectors.length) {\n\t                delegatedEvents[type] = null;\n\t              }\n\t            }\n\t\n\t            events.remove(this._context, type, delegateListener);\n\t            events.remove(this._context, type, delegateUseCapture, true);\n\t\n\t            break;\n\t          }\n\t        }\n\t      }\n\t\n\t      this.dropzone(false);\n\t\n\t      interactables.splice(indexOf(interactables, this), 1);\n\t\n\t      return interact;\n\t    }\n\t  };\n\t\n\t  function warnOnce(method, message) {\n\t    var warned = false;\n\t\n\t    return function () {\n\t      if (!warned) {\n\t        window.console.warn(message);\n\t        warned = true;\n\t      }\n\t\n\t      return method.apply(this, arguments);\n\t    };\n\t  }\n\t\n\t  Interactable.prototype.snap = warnOnce(Interactable.prototype.snap, 'Interactable#snap is deprecated. See the new documentation for snapping at http://interactjs.io/docs/snapping');\n\t  Interactable.prototype.restrict = warnOnce(Interactable.prototype.restrict, 'Interactable#restrict is deprecated. See the new documentation for resticting at http://interactjs.io/docs/restriction');\n\t  Interactable.prototype.inertia = warnOnce(Interactable.prototype.inertia, 'Interactable#inertia is deprecated. See the new documentation for inertia at http://interactjs.io/docs/inertia');\n\t  Interactable.prototype.autoScroll = warnOnce(Interactable.prototype.autoScroll, 'Interactable#autoScroll is deprecated. See the new documentation for autoScroll at http://interactjs.io/docs/#autoscroll');\n\t  Interactable.prototype.squareResize = warnOnce(Interactable.prototype.squareResize, 'Interactable#squareResize is deprecated. See http://interactjs.io/docs/#resize-square');\n\t\n\t  Interactable.prototype.accept = warnOnce(Interactable.prototype.accept, 'Interactable#accept is deprecated. use Interactable#dropzone({ accept: target }) instead');\n\t  Interactable.prototype.dropChecker = warnOnce(Interactable.prototype.dropChecker, 'Interactable#dropChecker is deprecated. use Interactable#dropzone({ dropChecker: checkerFunction }) instead');\n\t  Interactable.prototype.context = warnOnce(Interactable.prototype.context, 'Interactable#context as a method is deprecated. It will soon be a DOM Node instead');\n\t\n\t  /*\\\n\t     * interact.isSet\n\t     [ method ]\n\t     *\n\t     * Check if an element has been set\n\t     - element (Element) The Element being searched for\n\t     = (boolean) Indicates if the element or CSS selector was previously passed to interact\n\t    \\*/\n\t  interact.isSet = function (element, options) {\n\t    return interactables.indexOfElement(element, options && options.context) !== -1;\n\t  };\n\t\n\t  /*\\\n\t     * interact.on\n\t     [ method ]\n\t     *\n\t     * Adds a global listener for an InteractEvent or adds a DOM event to\n\t     * `document`\n\t     *\n\t     - type       (string | array | object) The types of events to listen for\n\t     - listener   (function) The function to be called on the given event(s)\n\t     - useCapture (boolean) #optional useCapture flag for addEventListener\n\t     = (object) interact\n\t    \\*/\n\t  interact.on = function (type, listener, useCapture) {\n\t    if (isString(type) && type.search(' ') !== -1) {\n\t      type = type.trim().split(/ +/);\n\t    }\n\t\n\t    if (isArray(type)) {\n\t      for (var i = 0; i < type.length; i++) {\n\t        interact.on(type[i], listener, useCapture);\n\t      }\n\t\n\t      return interact;\n\t    }\n\t\n\t    if (isObject(type)) {\n\t      for (var prop in type) {\n\t        interact.on(prop, type[prop], listener);\n\t      }\n\t\n\t      return interact;\n\t    }\n\t\n\t    // if it is an InteractEvent type, add listener to globalEvents\n\t    if (contains(eventTypes, type)) {\n\t      // if this type of event was never bound\n\t      if (!globalEvents[type]) {\n\t        globalEvents[type] = [listener];\n\t      } else {\n\t        globalEvents[type].push(listener);\n\t      }\n\t    }\n\t    // If non InteractEvent type, addEventListener to document\n\t    else {\n\t        events.add(document, type, listener, useCapture);\n\t      }\n\t\n\t    return interact;\n\t  };\n\t\n\t  /*\\\n\t     * interact.off\n\t     [ method ]\n\t     *\n\t     * Removes a global InteractEvent listener or DOM event from `document`\n\t     *\n\t     - type       (string | array | object) The types of events that were listened for\n\t     - listener   (function) The listener function to be removed\n\t     - useCapture (boolean) #optional useCapture flag for removeEventListener\n\t     = (object) interact\n\t     \\*/\n\t  interact.off = function (type, listener, useCapture) {\n\t    if (isString(type) && type.search(' ') !== -1) {\n\t      type = type.trim().split(/ +/);\n\t    }\n\t\n\t    if (isArray(type)) {\n\t      for (var i = 0; i < type.length; i++) {\n\t        interact.off(type[i], listener, useCapture);\n\t      }\n\t\n\t      return interact;\n\t    }\n\t\n\t    if (isObject(type)) {\n\t      for (var prop in type) {\n\t        interact.off(prop, type[prop], listener);\n\t      }\n\t\n\t      return interact;\n\t    }\n\t\n\t    if (!contains(eventTypes, type)) {\n\t      events.remove(document, type, listener, useCapture);\n\t    } else {\n\t      var index;\n\t\n\t      if (type in globalEvents && (index = indexOf(globalEvents[type], listener)) !== -1) {\n\t        globalEvents[type].splice(index, 1);\n\t      }\n\t    }\n\t\n\t    return interact;\n\t  };\n\t\n\t  /*\\\n\t     * interact.enableDragging\n\t     [ method ]\n\t     *\n\t     * Deprecated.\n\t     *\n\t     * Returns or sets whether dragging is enabled for any Interactables\n\t     *\n\t     - newValue (boolean) #optional `true` to allow the action; `false` to disable action for all Interactables\n\t     = (boolean | object) The current setting or interact\n\t    \\*/\n\t  interact.enableDragging = warnOnce(function (newValue) {\n\t    if (newValue !== null && newValue !== undefined) {\n\t      actionIsEnabled.drag = newValue;\n\t\n\t      return interact;\n\t    }\n\t    return actionIsEnabled.drag;\n\t  }, 'interact.enableDragging is deprecated and will soon be removed.');\n\t\n\t  /*\\\n\t     * interact.enableResizing\n\t     [ method ]\n\t     *\n\t     * Deprecated.\n\t     *\n\t     * Returns or sets whether resizing is enabled for any Interactables\n\t     *\n\t     - newValue (boolean) #optional `true` to allow the action; `false` to disable action for all Interactables\n\t     = (boolean | object) The current setting or interact\n\t    \\*/\n\t  interact.enableResizing = warnOnce(function (newValue) {\n\t    if (newValue !== null && newValue !== undefined) {\n\t      actionIsEnabled.resize = newValue;\n\t\n\t      return interact;\n\t    }\n\t    return actionIsEnabled.resize;\n\t  }, 'interact.enableResizing is deprecated and will soon be removed.');\n\t\n\t  /*\\\n\t     * interact.enableGesturing\n\t     [ method ]\n\t     *\n\t     * Deprecated.\n\t     *\n\t     * Returns or sets whether gesturing is enabled for any Interactables\n\t     *\n\t     - newValue (boolean) #optional `true` to allow the action; `false` to disable action for all Interactables\n\t     = (boolean | object) The current setting or interact\n\t    \\*/\n\t  interact.enableGesturing = warnOnce(function (newValue) {\n\t    if (newValue !== null && newValue !== undefined) {\n\t      actionIsEnabled.gesture = newValue;\n\t\n\t      return interact;\n\t    }\n\t    return actionIsEnabled.gesture;\n\t  }, 'interact.enableGesturing is deprecated and will soon be removed.');\n\t\n\t  interact.eventTypes = eventTypes;\n\t\n\t  /*\\\n\t     * interact.debug\n\t     [ method ]\n\t     *\n\t     * Returns debugging data\n\t     = (object) An object with properties that outline the current state and expose internal functions and variables\n\t    \\*/\n\t  interact.debug = function () {\n\t    var interaction = interactions[0] || new Interaction();\n\t\n\t    return {\n\t      interactions: interactions,\n\t      target: interaction.target,\n\t      dragging: interaction.dragging,\n\t      resizing: interaction.resizing,\n\t      gesturing: interaction.gesturing,\n\t      prepared: interaction.prepared,\n\t      matches: interaction.matches,\n\t      matchElements: interaction.matchElements,\n\t\n\t      prevCoords: interaction.prevCoords,\n\t      startCoords: interaction.startCoords,\n\t\n\t      pointerIds: interaction.pointerIds,\n\t      pointers: interaction.pointers,\n\t      addPointer: listeners.addPointer,\n\t      removePointer: listeners.removePointer,\n\t      recordPointer: listeners.recordPointer,\n\t\n\t      snap: interaction.snapStatus,\n\t      restrict: interaction.restrictStatus,\n\t      inertia: interaction.inertiaStatus,\n\t\n\t      downTime: interaction.downTimes[0],\n\t      downEvent: interaction.downEvent,\n\t      downPointer: interaction.downPointer,\n\t      prevEvent: interaction.prevEvent,\n\t\n\t      Interactable: Interactable,\n\t      interactables: interactables,\n\t      pointerIsDown: interaction.pointerIsDown,\n\t      defaultOptions: defaultOptions,\n\t      defaultActionChecker: defaultActionChecker,\n\t\n\t      actionCursors: actionCursors,\n\t      dragMove: listeners.dragMove,\n\t      resizeMove: listeners.resizeMove,\n\t      gestureMove: listeners.gestureMove,\n\t      pointerUp: listeners.pointerUp,\n\t      pointerDown: listeners.pointerDown,\n\t      pointerMove: listeners.pointerMove,\n\t      pointerHover: listeners.pointerHover,\n\t\n\t      eventTypes: eventTypes,\n\t\n\t      events: events,\n\t      globalEvents: globalEvents,\n\t      delegatedEvents: delegatedEvents,\n\t\n\t      prefixedPropREs: prefixedPropREs\n\t    };\n\t  };\n\t\n\t  // expose the functions used to calculate multi-touch properties\n\t  interact.getPointerAverage = pointerAverage;\n\t  interact.getTouchBBox = touchBBox;\n\t  interact.getTouchDistance = touchDistance;\n\t  interact.getTouchAngle = touchAngle;\n\t\n\t  interact.getElementRect = getElementRect;\n\t  interact.getElementClientRect = getElementClientRect;\n\t  interact.matchesSelector = matchesSelector;\n\t  interact.closest = closest;\n\t\n\t  /*\\\n\t     * interact.margin\n\t     [ method ]\n\t     *\n\t     * Deprecated. Use `interact(target).resizable({ margin: number });` instead.\n\t     * Returns or sets the margin for autocheck resizing used in\n\t     * @Interactable.getAction. That is the distance from the bottom and right\n\t     * edges of an element clicking in which will start resizing\n\t     *\n\t     - newValue (number) #optional\n\t     = (number | interact) The current margin value or interact\n\t    \\*/\n\t  interact.margin = warnOnce(function (newvalue) {\n\t    if (isNumber(newvalue)) {\n\t      margin = newvalue;\n\t\n\t      return interact;\n\t    }\n\t    return margin;\n\t  }, 'interact.margin is deprecated. Use interact(target).resizable({ margin: number }); instead.');\n\t\n\t  /*\\\n\t     * interact.supportsTouch\n\t     [ method ]\n\t     *\n\t     = (boolean) Whether or not the browser supports touch input\n\t    \\*/\n\t  interact.supportsTouch = function () {\n\t    return supportsTouch;\n\t  };\n\t\n\t  /*\\\n\t     * interact.supportsPointerEvent\n\t     [ method ]\n\t     *\n\t     = (boolean) Whether or not the browser supports PointerEvents\n\t    \\*/\n\t  interact.supportsPointerEvent = function () {\n\t    return supportsPointerEvent;\n\t  };\n\t\n\t  /*\\\n\t     * interact.stop\n\t     [ method ]\n\t     *\n\t     * Cancels all interactions (end events are not fired)\n\t     *\n\t     - event (Event) An event on which to call preventDefault()\n\t     = (object) interact\n\t    \\*/\n\t  interact.stop = function (event) {\n\t    for (var i = interactions.length - 1; i >= 0; i--) {\n\t      interactions[i].stop(event);\n\t    }\n\t\n\t    return interact;\n\t  };\n\t\n\t  /*\\\n\t     * interact.dynamicDrop\n\t     [ method ]\n\t     *\n\t     * Returns or sets whether the dimensions of dropzone elements are\n\t     * calculated on every dragmove or only on dragstart for the default\n\t     * dropChecker\n\t     *\n\t     - newValue (boolean) #optional True to check on each move. False to check only before start\n\t     = (boolean | interact) The current setting or interact\n\t    \\*/\n\t  interact.dynamicDrop = function (newValue) {\n\t    if (isBool(newValue)) {\n\t      //if (dragging && dynamicDrop !== newValue && !newValue) {\n\t      //calcRects(dropzones);\n\t      //}\n\t\n\t      dynamicDrop = newValue;\n\t\n\t      return interact;\n\t    }\n\t    return dynamicDrop;\n\t  };\n\t\n\t  /*\\\n\t     * interact.pointerMoveTolerance\n\t     [ method ]\n\t     * Returns or sets the distance the pointer must be moved before an action\n\t     * sequence occurs. This also affects tolerance for tap events.\n\t     *\n\t     - newValue (number) #optional The movement from the start position must be greater than this value\n\t     = (number | Interactable) The current setting or interact\n\t    \\*/\n\t  interact.pointerMoveTolerance = function (newValue) {\n\t    if (isNumber(newValue)) {\n\t      pointerMoveTolerance = newValue;\n\t\n\t      return this;\n\t    }\n\t\n\t    return pointerMoveTolerance;\n\t  };\n\t\n\t  /*\\\n\t     * interact.maxInteractions\n\t     [ method ]\n\t     **\n\t     * Returns or sets the maximum number of concurrent interactions allowed.\n\t     * By default only 1 interaction is allowed at a time (for backwards\n\t     * compatibility). To allow multiple interactions on the same Interactables\n\t     * and elements, you need to enable it in the draggable, resizable and\n\t     * gesturable `'max'` and `'maxPerElement'` options.\n\t     **\n\t     - newValue (number) #optional Any number. newValue <= 0 means no interactions.\n\t    \\*/\n\t  interact.maxInteractions = function (newValue) {\n\t    if (isNumber(newValue)) {\n\t      maxInteractions = newValue;\n\t\n\t      return this;\n\t    }\n\t\n\t    return maxInteractions;\n\t  };\n\t\n\t  interact.createSnapGrid = function (grid) {\n\t    return function (x, y) {\n\t      var offsetX = 0,\n\t          offsetY = 0;\n\t\n\t      if (isObject(grid.offset)) {\n\t        offsetX = grid.offset.x;\n\t        offsetY = grid.offset.y;\n\t      }\n\t\n\t      var gridx = Math.round((x - offsetX) / grid.x),\n\t          gridy = Math.round((y - offsetY) / grid.y),\n\t          newX = gridx * grid.x + offsetX,\n\t          newY = gridy * grid.y + offsetY;\n\t\n\t      return {\n\t        x: newX,\n\t        y: newY,\n\t        range: grid.range\n\t      };\n\t    };\n\t  };\n\t\n\t  function endAllInteractions(event) {\n\t    for (var i = 0; i < interactions.length; i++) {\n\t      interactions[i].pointerEnd(event, event);\n\t    }\n\t  }\n\t\n\t  function listenToDocument(doc) {\n\t    if (contains(documents, doc)) {\n\t      return;\n\t    }\n\t\n\t    var win = doc.defaultView || doc.parentWindow;\n\t\n\t    // add delegate event listener\n\t    for (var eventType in delegatedEvents) {\n\t      events.add(doc, eventType, delegateListener);\n\t      events.add(doc, eventType, delegateUseCapture, true);\n\t    }\n\t\n\t    if (supportsPointerEvent) {\n\t      if (PointerEvent === win.MSPointerEvent) {\n\t        pEventTypes = {\n\t          up: 'MSPointerUp', down: 'MSPointerDown', over: 'mouseover',\n\t          out: 'mouseout', move: 'MSPointerMove', cancel: 'MSPointerCancel' };\n\t      } else {\n\t        pEventTypes = {\n\t          up: 'pointerup', down: 'pointerdown', over: 'pointerover',\n\t          out: 'pointerout', move: 'pointermove', cancel: 'pointercancel' };\n\t      }\n\t\n\t      events.add(doc, pEventTypes.down, listeners.selectorDown);\n\t      events.add(doc, pEventTypes.move, listeners.pointerMove);\n\t      events.add(doc, pEventTypes.over, listeners.pointerOver);\n\t      events.add(doc, pEventTypes.out, listeners.pointerOut);\n\t      events.add(doc, pEventTypes.up, listeners.pointerUp);\n\t      events.add(doc, pEventTypes.cancel, listeners.pointerCancel);\n\t\n\t      // autoscroll\n\t      events.add(doc, pEventTypes.move, listeners.autoScrollMove);\n\t    } else {\n\t      events.add(doc, 'mousedown', listeners.selectorDown);\n\t      events.add(doc, 'mousemove', listeners.pointerMove);\n\t      events.add(doc, 'mouseup', listeners.pointerUp);\n\t      events.add(doc, 'mouseover', listeners.pointerOver);\n\t      events.add(doc, 'mouseout', listeners.pointerOut);\n\t\n\t      events.add(doc, 'touchstart', listeners.selectorDown);\n\t      events.add(doc, 'touchmove', listeners.pointerMove);\n\t      events.add(doc, 'touchend', listeners.pointerUp);\n\t      events.add(doc, 'touchcancel', listeners.pointerCancel);\n\t\n\t      // autoscroll\n\t      events.add(doc, 'mousemove', listeners.autoScrollMove);\n\t      events.add(doc, 'touchmove', listeners.autoScrollMove);\n\t    }\n\t\n\t    events.add(win, 'blur', endAllInteractions);\n\t\n\t    try {\n\t      if (win.frameElement) {\n\t        var parentDoc = win.frameElement.ownerDocument,\n\t            parentWindow = parentDoc.defaultView;\n\t\n\t        events.add(parentDoc, 'mouseup', listeners.pointerEnd);\n\t        events.add(parentDoc, 'touchend', listeners.pointerEnd);\n\t        events.add(parentDoc, 'touchcancel', listeners.pointerEnd);\n\t        events.add(parentDoc, 'pointerup', listeners.pointerEnd);\n\t        events.add(parentDoc, 'MSPointerUp', listeners.pointerEnd);\n\t        events.add(parentWindow, 'blur', endAllInteractions);\n\t      }\n\t    } catch (error) {\n\t      interact.windowParentError = error;\n\t    }\n\t\n\t    // prevent native HTML5 drag on interact.js target elements\n\t    events.add(doc, 'dragstart', function (event) {\n\t      for (var i = 0; i < interactions.length; i++) {\n\t        var interaction = interactions[i];\n\t\n\t        if (interaction.element && (interaction.element === event.target || nodeContains(interaction.element, event.target))) {\n\t\n\t          interaction.checkAndPreventDefault(event, interaction.target, interaction.element);\n\t          return;\n\t        }\n\t      }\n\t    });\n\t\n\t    if (events.useAttachEvent) {\n\t      // For IE's lack of Event#preventDefault\n\t      events.add(doc, 'selectstart', function (event) {\n\t        var interaction = interactions[0];\n\t\n\t        if (interaction.currentAction()) {\n\t          interaction.checkAndPreventDefault(event);\n\t        }\n\t      });\n\t\n\t      // For IE's bad dblclick event sequence\n\t      events.add(doc, 'dblclick', doOnInteractions('ie8Dblclick'));\n\t    }\n\t\n\t    documents.push(doc);\n\t  }\n\t\n\t  listenToDocument(document);\n\t\n\t  function indexOf(array, target) {\n\t    for (var i = 0, len = array.length; i < len; i++) {\n\t      if (array[i] === target) {\n\t        return i;\n\t      }\n\t    }\n\t\n\t    return -1;\n\t  }\n\t\n\t  function contains(array, target) {\n\t    return indexOf(array, target) !== -1;\n\t  }\n\t\n\t  function matchesSelector(element, selector, nodeList) {\n\t    if (ie8MatchesSelector) {\n\t      return ie8MatchesSelector(element, selector, nodeList);\n\t    }\n\t\n\t    // remove /deep/ from selectors if shadowDOM polyfill is used\n\t    if (window !== realWindow) {\n\t      selector = selector.replace(/\\/deep\\//g, ' ');\n\t    }\n\t\n\t    return element[prefixedMatchesSelector](selector);\n\t  }\n\t\n\t  function matchesUpTo(element, selector, limit) {\n\t    while (isElement(element)) {\n\t      if (matchesSelector(element, selector)) {\n\t        return true;\n\t      }\n\t\n\t      element = parentElement(element);\n\t\n\t      if (element === limit) {\n\t        return matchesSelector(element, selector);\n\t      }\n\t    }\n\t\n\t    return false;\n\t  }\n\t\n\t  // For IE8's lack of an Element#matchesSelector\n\t  // taken from http://tanalin.com/en/blog/2012/12/matches-selector-ie8/ and modified\n\t  if (!(prefixedMatchesSelector in Element.prototype) || !isFunction(Element.prototype[prefixedMatchesSelector])) {\n\t    ie8MatchesSelector = function ie8MatchesSelector(element, selector, elems) {\n\t      elems = elems || element.parentNode.querySelectorAll(selector);\n\t\n\t      for (var i = 0, len = elems.length; i < len; i++) {\n\t        if (elems[i] === element) {\n\t          return true;\n\t        }\n\t      }\n\t\n\t      return false;\n\t    };\n\t  }\n\t\n\t  // requestAnimationFrame polyfill\n\t  (function () {\n\t    var lastTime = 0,\n\t        vendors = ['ms', 'moz', 'webkit', 'o'];\n\t\n\t    for (var x = 0; x < vendors.length && !realWindow.requestAnimationFrame; ++x) {\n\t      reqFrame = realWindow[vendors[x] + 'RequestAnimationFrame'];\n\t      cancelFrame = realWindow[vendors[x] + 'CancelAnimationFrame'] || realWindow[vendors[x] + 'CancelRequestAnimationFrame'];\n\t    }\n\t\n\t    if (!reqFrame) {\n\t      reqFrame = function reqFrame(callback) {\n\t        var currTime = new Date().getTime(),\n\t            timeToCall = Math.max(0, 16 - (currTime - lastTime)),\n\t            id = setTimeout(function () {\n\t          callback(currTime + timeToCall);\n\t        }, timeToCall);\n\t        lastTime = currTime + timeToCall;\n\t        return id;\n\t      };\n\t    }\n\t\n\t    if (!cancelFrame) {\n\t      cancelFrame = function cancelFrame(id) {\n\t        clearTimeout(id);\n\t      };\n\t    }\n\t  })();\n\t\n\t  /* global exports: true, module, define */\n\t\n\t  // http://documentcloud.github.io/underscore/docs/underscore.html#section-11\n\t  if (true) {\n\t    if (typeof module !== 'undefined' && module.exports) {\n\t      exports = module.exports = interact;\n\t    }\n\t    exports.interact = interact;\n\t  }\n\t  // AMD\n\t  else if (typeof define === 'function' && define.amd) {\n\t      define('interact', function () {\n\t        return interact;\n\t      });\n\t    } else {\n\t      realWindow.interact = interact;\n\t    }\n\t})(typeof window === 'undefined' ? undefined : window);\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _jquery = __webpack_require__(2);\n\t\n\tvar _jquery2 = _interopRequireDefault(_jquery);\n\t\n\tvar _interact = __webpack_require__(4);\n\t\n\tvar _interact2 = _interopRequireDefault(_interact);\n\t\n\tvar _slick = __webpack_require__(1);\n\t\n\tvar _slick2 = _interopRequireDefault(_slick);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\t// Slick.Grid globals pretense\n\t_slick2.default.FrozenGrid = SlickGrid; /**\n\t                                         * @license\n\t                                         * (c) 2009-2013 Michael Leibman\n\t                                         * michael{dot}leibman{at}gmail{dot}com\n\t                                         * http://github.com/mleibman/slickgrid\n\t                                         *\n\t                                         * Distributed under MIT license.\n\t                                         * All rights reserved.\n\t                                         *\n\t                                         * SlickGrid v2.2\n\t                                         *\n\t                                         * NOTES:\n\t                                         *     Cell/row DOM manipulations are done directly bypassing jQuery's DOM manipulation methods.\n\t                                         *     This increases the speed dramatically, but can only be done safely because there are no event handlers\n\t                                         *     or data associated with any cell/row DOM nodes.  Cell editors must make sure they implement .destroy()\n\t                                         *     and do proper cleanup.\n\t                                         */\n\t\n\texports.default = SlickGrid;\n\t\n\t// shared across all grids on the page\n\t\n\tvar scrollbarDimensions;\n\tvar maxSupportedCssHeight; // browser's breaking point\n\t\n\t//////////////////////////////////////////////////////////////////////////////////////////////\n\t// SlickGrid class implementation (available as Slick.Grid)\n\t\n\t/**\n\t * Creates a new instance of the grid.\n\t * @class SlickGrid\n\t * @constructor\n\t * @param {Node}              container   Container node to create the grid in.\n\t * @param {Array,Object}      data        An array of objects for databinding.\n\t * @param {Array}             columns     An array of column definitions.\n\t * @param {Object}            options     Grid options.\n\t **/\n\tfunction SlickGrid(container, data, columns, options) {\n\t  // settings\n\t  var defaults = {\n\t    explicitInitialization: false,\n\t    rowHeight: 25,\n\t    defaultColumnWidth: 80,\n\t    enableAddRow: false,\n\t    leaveSpaceForNewRows: false,\n\t    editable: false,\n\t    autoEdit: true,\n\t    enableCellNavigation: true,\n\t    enableColumnReorder: true,\n\t    asyncEditorLoading: false,\n\t    asyncEditorLoadDelay: 100,\n\t    forceFitColumns: false,\n\t    enableAsyncPostRender: false,\n\t    asyncPostRenderDelay: 50,\n\t    autoHeight: false,\n\t    editorLock: _slick2.default.GlobalEditorLock,\n\t    showHeaderRow: false,\n\t    headerRowHeight: 25,\n\t    showFooterRow: false,\n\t    footerRowHeight: 25,\n\t    showTopPanel: false,\n\t    topPanelHeight: 25,\n\t    formatterFactory: null,\n\t    editorFactory: null,\n\t    cellFlashingCssClass: \"flashing\",\n\t    selectedCellCssClass: \"selected\",\n\t    multiSelect: true,\n\t    enableTextSelectionOnCells: false,\n\t    dataItemColumnValueExtractor: null,\n\t    frozenBottom: false,\n\t    frozenColumn: -1,\n\t    frozenRow: -1,\n\t    fullWidthRows: false,\n\t    multiColumnSort: false,\n\t    defaultFormatter: defaultFormatter,\n\t    forceSyncScrolling: false,\n\t    addNewRowCssClass: \"new-row\"\n\t  };\n\t\n\t  var columnDefaults = {\n\t    name: \"\",\n\t    resizable: true,\n\t    sortable: false,\n\t    minWidth: 30,\n\t    rerenderOnResize: false,\n\t    headerCssClass: null,\n\t    defaultSortAsc: true,\n\t    focusable: true,\n\t    selectable: true\n\t  };\n\t\n\t  // scroller\n\t  var th; // virtual height\n\t  var h; // real scrollable height\n\t  var ph; // page height\n\t  var n; // number of pages\n\t  var cj; // \"jumpiness\" coefficient\n\t\n\t  var page = 0; // current page\n\t  var offset = 0; // current page offset\n\t  var vScrollDir = 1;\n\t\n\t  // private\n\t  var initialized = false;\n\t  var $container;\n\t  var uid = \"slickgrid_\" + Math.round(1000000 * Math.random());\n\t  var self = this;\n\t  var $focusSink, $focusSink2;\n\t  var $groupHeaders = (0, _jquery2.default)();\n\t  var $headerScroller;\n\t  var $headers;\n\t  var $headerRow, $headerRowScroller, $headerRowSpacerL, $headerRowSpacerR;\n\t  var $footerRow, $footerRowScroller, $footerRowSpacerL, $footerRowSpacerR;\n\t  var $topPanelScroller;\n\t  var $topPanel;\n\t  var $viewport;\n\t  var $canvas;\n\t  var $style;\n\t  var $boundAncestors;\n\t  var treeColumns;\n\t  var stylesheet, columnCssRulesL, columnCssRulesR;\n\t  var viewportH, viewportW;\n\t  var canvasWidth, canvasWidthL, canvasWidthR;\n\t  var headersWidth, headersWidthL, headersWidthR;\n\t  var viewportHasHScroll, viewportHasVScroll;\n\t  var headerColumnWidthDiff = 0,\n\t      headerColumnHeightDiff = 0,\n\t      // border+padding\n\t  cellWidthDiff = 0,\n\t      cellHeightDiff = 0;\n\t  var absoluteColumnMinWidth;\n\t  var hasFrozenRows = false;\n\t  var frozenRowsHeight = 0;\n\t  var actualFrozenRow = -1;\n\t  var paneTopH = 0;\n\t  var paneBottomH = 0;\n\t  var viewportTopH = 0;\n\t  var viewportBottomH = 0;\n\t  var topPanelH = 0;\n\t  var headerRowH = 0;\n\t  var footerRowH = 0;\n\t\n\t  var tabbingDirection = 1;\n\t  var $activeCanvasNode;\n\t  var $activeViewportNode;\n\t  var activePosX;\n\t  var activeRow, activeCell;\n\t  var activeCellNode = null;\n\t  var currentEditor = null;\n\t  var serializedEditorValue;\n\t  var editController;\n\t\n\t  var rowsCache = {};\n\t  var renderedRows = 0;\n\t  var numVisibleRows = 0;\n\t  var prevScrollTop = 0;\n\t  var scrollTop = 0;\n\t  var lastRenderedScrollTop = 0;\n\t  var lastRenderedScrollLeft = 0;\n\t  var prevScrollLeft = 0;\n\t  var scrollLeft = 0;\n\t\n\t  var selectionModel;\n\t  var selectedRows = [];\n\t\n\t  var plugins = [];\n\t  var cellCssClasses = {};\n\t\n\t  var columnsById = {};\n\t  var sortColumns = [];\n\t  var columnPosLeft = [];\n\t  var columnPosRight = [];\n\t\n\t  // async call handles\n\t  var h_editorLoader = null;\n\t  var h_render = null;\n\t  var h_postrender = null;\n\t  var postProcessedRows = {};\n\t  var postProcessToRow = null;\n\t  var postProcessFromRow = null;\n\t\n\t  // perf counters\n\t  var counter_rows_rendered = 0;\n\t  var counter_rows_removed = 0;\n\t\n\t  // These two variables work around a bug with inertial scrolling in Webkit/Blink on Mac.\n\t  // See http://crbug.com/312427.\n\t  var rowNodeFromLastMouseWheelEvent; // this node must not be deleted while inertial scrolling\n\t  var zombieRowNodeFromLastMouseWheelEvent; // node that was hidden instead of getting deleted\n\t\n\t  var $paneHeaderL;\n\t  var $paneHeaderR;\n\t  var $paneTopL;\n\t  var $paneTopR;\n\t  var $paneBottomL;\n\t  var $paneBottomR;\n\t\n\t  var $headerScrollerL;\n\t  var $headerScrollerR;\n\t\n\t  var $headerL;\n\t  var $headerR;\n\t\n\t  var $groupHeadersL;\n\t  var $groupHeadersR;\n\t\n\t  var $headerRowScrollerL;\n\t  var $headerRowScrollerR;\n\t\n\t  var $footerRowScrollerL;\n\t  var $footerRowScrollerR;\n\t\n\t  var $headerRowL;\n\t  var $headerRowR;\n\t\n\t  var $footerRowL;\n\t  var $footerRowR;\n\t\n\t  var $topPanelScrollerL;\n\t  var $topPanelScrollerR;\n\t\n\t  var $topPanelL;\n\t  var $topPanelR;\n\t\n\t  var $viewportTopL;\n\t  var $viewportTopR;\n\t  var $viewportBottomL;\n\t  var $viewportBottomR;\n\t\n\t  var $canvasTopL;\n\t  var $canvasTopR;\n\t  var $canvasBottomL;\n\t  var $canvasBottomR;\n\t\n\t  var $viewportScrollContainerX;\n\t  var $viewportScrollContainerY;\n\t  var $headerScrollContainer;\n\t  var $headerRowScrollContainer;\n\t  var $footerRowScrollContainer;\n\t\n\t  //////////////////////////////////////////////////////////////////////////////////////////////\n\t  // Initialization\n\t\n\t  function init() {\n\t    $container = (0, _jquery2.default)(container);\n\t    if ($container.length < 1) {\n\t      throw new Error(\"SlickGrid requires a valid container, \" + container + \" does not exist in the DOM.\");\n\t    }\n\t\n\t    // calculate these only once and share between grid instances\n\t    maxSupportedCssHeight = maxSupportedCssHeight || getMaxSupportedCssHeight();\n\t    scrollbarDimensions = scrollbarDimensions || measureScrollbar();\n\t\n\t    options = _jquery2.default.extend({}, defaults, options);\n\t    validateAndEnforceOptions();\n\t    columnDefaults.width = options.defaultColumnWidth;\n\t\n\t    treeColumns = new _slick2.default.TreeColumns(columns);\n\t    columns = treeColumns.extractColumns();\n\t\n\t    columnsById = {};\n\t    for (var i = 0; i < columns.length; i++) {\n\t      var m = columns[i] = _jquery2.default.extend({}, columnDefaults, columns[i]);\n\t      columnsById[m.id] = i;\n\t      if (m.minWidth && m.width < m.minWidth) {\n\t        m.width = m.minWidth;\n\t      }\n\t      if (m.maxWidth && m.width > m.maxWidth) {\n\t        m.width = m.maxWidth;\n\t      }\n\t    }\n\t\n\t    editController = {\n\t      \"commitCurrentEdit\": commitCurrentEdit,\n\t      \"cancelCurrentEdit\": cancelCurrentEdit\n\t    };\n\t\n\t    $container.empty().css(\"overflow\", \"hidden\").css(\"outline\", 0).addClass(uid).addClass(\"ui-widget\");\n\t\n\t    // set up a positioning container if needed\n\t    if (!/relative|absolute|fixed/.test($container.css(\"position\"))) {\n\t      $container.css(\"position\", \"relative\");\n\t    }\n\t\n\t    $focusSink = (0, _jquery2.default)(\"<div tabIndex='0' hideFocus style='position:fixed;width:0;height:0;top:0;left:0;outline:0;'></div>\").appendTo($container);\n\t\n\t    // Containers used for scrolling frozen columns and rows\n\t    $paneHeaderL = (0, _jquery2.default)(\"<div class='slick-pane slick-pane-header slick-pane-left' tabIndex='0' />\").appendTo($container);\n\t    $paneHeaderR = (0, _jquery2.default)(\"<div class='slick-pane slick-pane-header slick-pane-right' tabIndex='0' />\").appendTo($container);\n\t    $paneTopL = (0, _jquery2.default)(\"<div class='slick-pane slick-pane-top slick-pane-left' tabIndex='0' />\").appendTo($container);\n\t    $paneTopR = (0, _jquery2.default)(\"<div class='slick-pane slick-pane-top slick-pane-right' tabIndex='0' />\").appendTo($container);\n\t    $paneBottomL = (0, _jquery2.default)(\"<div class='slick-pane slick-pane-bottom slick-pane-left' tabIndex='0' />\").appendTo($container);\n\t    $paneBottomR = (0, _jquery2.default)(\"<div class='slick-pane slick-pane-bottom slick-pane-right' tabIndex='0' />\").appendTo($container);\n\t\n\t    // Append the header scroller containers\n\t    $headerScrollerL = (0, _jquery2.default)(\"<div class='ui-state-default slick-header slick-header-left' />\").appendTo($paneHeaderL);\n\t    $headerScrollerR = (0, _jquery2.default)(\"<div class='ui-state-default slick-header slick-header-right' />\").appendTo($paneHeaderR);\n\t\n\t    // Cache the header scroller containers\n\t    $headerScroller = (0, _jquery2.default)().add($headerScrollerL).add($headerScrollerR);\n\t\n\t    if (treeColumns.hasDepth()) {\n\t      $groupHeadersL = [], $groupHeadersR = [];\n\t      for (var index = 0; index < treeColumns.getDepth() - 1; index++) {\n\t        $groupHeadersL[index] = (0, _jquery2.default)(\"<div class='slick-group-header-columns slick-group-header-columns-left' style='left:-1000px' />\").appendTo($headerScrollerL);\n\t        $groupHeadersR[index] = (0, _jquery2.default)(\"<div class='slick-group-header-columns slick-group-header-columns-right' style='left:-1000px' />\").appendTo($headerScrollerR);\n\t      }\n\t\n\t      $groupHeaders = (0, _jquery2.default)().add($groupHeadersL).add($groupHeadersR);\n\t    }\n\t\n\t    // Append the columnn containers to the headers\n\t    $headerL = (0, _jquery2.default)(\"<div class='slick-header-columns slick-header-columns-left' style='left:-1000px' />\").appendTo($headerScrollerL);\n\t    $headerR = (0, _jquery2.default)(\"<div class='slick-header-columns slick-header-columns-right' style='left:-1000px' />\").appendTo($headerScrollerR);\n\t\n\t    // Cache the header columns\n\t    $headers = (0, _jquery2.default)().add($headerL).add($headerR);\n\t\n\t    $headerRowScrollerL = (0, _jquery2.default)(\"<div class='ui-state-default slick-headerrow' />\").appendTo($paneTopL);\n\t    $headerRowScrollerR = (0, _jquery2.default)(\"<div class='ui-state-default slick-headerrow' />\").appendTo($paneTopR);\n\t\n\t    $headerRowScroller = (0, _jquery2.default)().add($headerRowScrollerL).add($headerRowScrollerR);\n\t\n\t    $headerRowSpacerL = (0, _jquery2.default)(\"<div style='display:block;height:1px;position:absolute;top:0;left:0;'></div>\").css(\"width\", getCanvasWidth() + scrollbarDimensions.width + \"px\").appendTo($headerRowScrollerL);\n\t    $headerRowSpacerR = (0, _jquery2.default)(\"<div style='display:block;height:1px;position:absolute;top:0;left:0;'></div>\").css(\"width\", getCanvasWidth() + scrollbarDimensions.width + \"px\").appendTo($headerRowScrollerR);\n\t\n\t    $headerRowL = (0, _jquery2.default)(\"<div class='slick-headerrow-columns slick-headerrow-columns-left' />\").appendTo($headerRowScrollerL);\n\t    $headerRowR = (0, _jquery2.default)(\"<div class='slick-headerrow-columns slick-headerrow-columns-right' />\").appendTo($headerRowScrollerR);\n\t\n\t    $headerRow = (0, _jquery2.default)().add($headerRowL).add($headerRowR);\n\t\n\t    // Append the top panel scroller\n\t    $topPanelScrollerL = (0, _jquery2.default)(\"<div class='ui-state-default slick-top-panel-scroller' />\").appendTo($paneTopL);\n\t    $topPanelScrollerR = (0, _jquery2.default)(\"<div class='ui-state-default slick-top-panel-scroller' />\").appendTo($paneTopR);\n\t\n\t    $topPanelScroller = (0, _jquery2.default)().add($topPanelScrollerL).add($topPanelScrollerR);\n\t\n\t    // Append the top panel\n\t    $topPanelL = (0, _jquery2.default)(\"<div class='slick-top-panel' style='width:10000px' />\").appendTo($topPanelScrollerL);\n\t    $topPanelR = (0, _jquery2.default)(\"<div class='slick-top-panel' style='width:10000px' />\").appendTo($topPanelScrollerR);\n\t\n\t    $topPanel = (0, _jquery2.default)().add($topPanelL).add($topPanelR);\n\t\n\t    if (!options.showTopPanel) {\n\t      $topPanelScroller.hide();\n\t    }\n\t\n\t    if (!options.showHeaderRow) {\n\t      $headerRowScroller.hide();\n\t    }\n\t\n\t    // Append the viewport containers\n\t    $viewportTopL = (0, _jquery2.default)(\"<div class='slick-viewport slick-viewport-top slick-viewport-left' tabIndex='0' hideFocus />\").appendTo($paneTopL);\n\t    $viewportTopR = (0, _jquery2.default)(\"<div class='slick-viewport slick-viewport-top slick-viewport-right' tabIndex='0' hideFocus />\").appendTo($paneTopR);\n\t    $viewportBottomL = (0, _jquery2.default)(\"<div class='slick-viewport slick-viewport-bottom slick-viewport-left' tabIndex='0' hideFocus />\").appendTo($paneBottomL);\n\t    $viewportBottomR = (0, _jquery2.default)(\"<div class='slick-viewport slick-viewport-bottom slick-viewport-right' tabIndex='0' hideFocus />\").appendTo($paneBottomR);\n\t\n\t    // Cache the viewports\n\t    $viewport = (0, _jquery2.default)().add($viewportTopL).add($viewportTopR).add($viewportBottomL).add($viewportBottomR);\n\t\n\t    // Default the active viewport to the top left\n\t    $activeViewportNode = $viewportTopL;\n\t\n\t    // Append the canvas containers\n\t    $canvasTopL = (0, _jquery2.default)(\"<div class='grid-canvas grid-canvas-top grid-canvas-left' tabIndex='0' hideFocus />\").appendTo($viewportTopL);\n\t    $canvasTopR = (0, _jquery2.default)(\"<div class='grid-canvas grid-canvas-top grid-canvas-right' tabIndex='0' hideFocus />\").appendTo($viewportTopR);\n\t    $canvasBottomL = (0, _jquery2.default)(\"<div class='grid-canvas grid-canvas-bottom grid-canvas-left' tabIndex='0' hideFocus />\").appendTo($viewportBottomL);\n\t    $canvasBottomR = (0, _jquery2.default)(\"<div class='grid-canvas grid-canvas-bottom grid-canvas-right' tabIndex='0' hideFocus />\").appendTo($viewportBottomR);\n\t\n\t    // Cache the canvases\n\t    $canvas = (0, _jquery2.default)().add($canvasTopL).add($canvasTopR).add($canvasBottomL).add($canvasBottomR);\n\t\n\t    // Default the active canvas to the top left\n\t    $activeCanvasNode = $canvasTopL;\n\t\n\t    // footer Row\n\t    $footerRowScrollerR = (0, _jquery2.default)(\"<div class='ui-state-default slick-footerrow' />\").appendTo($paneTopR);\n\t    $footerRowScrollerL = (0, _jquery2.default)(\"<div class='ui-state-default slick-footerrow' />\").appendTo($paneTopL);\n\t\n\t    $footerRowScroller = (0, _jquery2.default)().add($footerRowScrollerL).add($footerRowScrollerR);\n\t\n\t    $footerRowSpacerL = (0, _jquery2.default)(\"<div style='display:block;height:1px;position:absolute;top:0;left:0;'></div>\").css(\"width\", getCanvasWidth() + scrollbarDimensions.width + \"px\").appendTo($footerRowScrollerL);\n\t    $footerRowSpacerR = (0, _jquery2.default)(\"<div style='display:block;height:1px;position:absolute;top:0;left:0;'></div>\").css(\"width\", getCanvasWidth() + scrollbarDimensions.width + \"px\").appendTo($footerRowScrollerR);\n\t\n\t    $footerRowL = (0, _jquery2.default)(\"<div class='slick-footerrow-columns slick-footerrow-columns-left' />\").appendTo($footerRowScrollerL);\n\t    $footerRowR = (0, _jquery2.default)(\"<div class='slick-footerrow-columns slick-footerrow-columns-right' />\").appendTo($footerRowScrollerR);\n\t\n\t    $footerRow = (0, _jquery2.default)().add($footerRowL).add($footerRowR);\n\t\n\t    if (!options.showFooterRow) {\n\t      $footerRowScroller.hide();\n\t    }\n\t\n\t    $focusSink2 = $focusSink.clone().appendTo($container);\n\t\n\t    if (!options.explicitInitialization) {\n\t      finishInitialization();\n\t    }\n\t  }\n\t\n\t  function finishInitialization() {\n\t    if (!initialized) {\n\t      initialized = true;\n\t\n\t      getViewportWidth();\n\t      getViewportHeight();\n\t\n\t      // header columns and cells may have different padding/border skewing width calculations (box-sizing, hello?)\n\t      // calculate the diff so we can set consistent sizes\n\t      measureCellPaddingAndBorder();\n\t\n\t      // for usability reasons, all text selection in SlickGrid is disabled\n\t      // with the exception of input and textarea elements (selection must\n\t      // be enabled there so that editors work as expected); note that\n\t      // selection in grid cells (grid body) is already unavailable in\n\t      // all browsers except IE\n\t      disableSelection($headers); // disable all text selection in header (including input and textarea)\n\t\n\t      if (!options.enableTextSelectionOnCells) {\n\t        // disable text selection in grid cells except in input and textarea elements\n\t        // (this is IE-specific, because selectstart event will only fire in IE)\n\t        $viewport.bind(\"selectstart.ui\", function (event) {\n\t          return (0, _jquery2.default)(event.target).is(\"input,textarea\");\n\t        });\n\t      }\n\t\n\t      setFrozenOptions();\n\t      setPaneVisibility();\n\t      setScroller();\n\t      setOverflow();\n\t\n\t      updateColumnCaches();\n\t      createColumnHeaders();\n\t      createColumnGroupHeaders();\n\t      createColumnFooter();\n\t      setupColumnSort();\n\t      createCssRules();\n\t      resizeCanvas();\n\t      bindAncestorScrollEvents();\n\t\n\t      $container.bind(\"resize.slickgrid\", resizeCanvas);\n\t      $viewport.on(\"scroll\", handleScroll);\n\t\n\t      if (_jquery2.default.fn.mousewheel && (options.frozenColumn > -1 || hasFrozenRows)) {\n\t        $viewport.on(\"mousewheel\", handleMouseWheel);\n\t      }\n\t\n\t      $headerScroller.bind(\"contextmenu\", handleHeaderContextMenu).bind(\"click\", handleHeaderClick).delegate(\".slick-header-column\", \"mouseenter\", handleHeaderMouseEnter).delegate(\".slick-header-column\", \"mouseleave\", handleHeaderMouseLeave);\n\t      $headerRowScroller.bind(\"scroll\", handleHeaderRowScroll);\n\t\n\t      $footerRowScroller.bind(\"scroll\", handleFooterRowScroll);\n\t\n\t      $focusSink.add($focusSink2).bind(\"keydown\", handleKeyDown);\n\t      $canvas.bind(\"keydown\", handleKeyDown).bind(\"click\", handleClick).bind(\"dblclick\", handleDblClick).bind(\"contextmenu\", handleContextMenu).delegate(\".slick-cell\", \"mouseenter\", handleMouseEnter).delegate(\".slick-cell\", \"mouseleave\", handleMouseLeave);\n\t\n\t      // legacy support for drag events\n\t      (0, _interact2.default)($canvas[0]).allowFrom('div.slick-cell').draggable({\n\t        onmove: handleDrag,\n\t        onstart: handleDragStart,\n\t        onend: handleDragEnd\n\t      }).styleCursor(false);\n\t\n\t      // Work around http://crbug.com/312427.\n\t      if (navigator.userAgent.toLowerCase().match(/webkit/) && navigator.userAgent.toLowerCase().match(/macintosh/)) {\n\t        $canvas.on(\"mousewheel\", handleMouseWheel);\n\t      }\n\t    }\n\t  }\n\t\n\t  function hasFrozenColumns() {\n\t    return options.frozenColumn > -1;\n\t  }\n\t\n\t  function registerPlugin(plugin) {\n\t    plugins.unshift(plugin);\n\t    plugin.init(self);\n\t  }\n\t\n\t  function unregisterPlugin(plugin) {\n\t    for (var i = plugins.length; i >= 0; i--) {\n\t      if (plugins[i] === plugin) {\n\t        if (plugins[i].destroy) {\n\t          plugins[i].destroy();\n\t        }\n\t        plugins.splice(i, 1);\n\t        break;\n\t      }\n\t    }\n\t  }\n\t\n\t  function setSelectionModel(model) {\n\t    if (selectionModel) {\n\t      selectionModel.onSelectedRangesChanged.unsubscribe(handleSelectedRangesChanged);\n\t      if (selectionModel.destroy) {\n\t        selectionModel.destroy();\n\t      }\n\t    }\n\t\n\t    selectionModel = model;\n\t    if (selectionModel) {\n\t      selectionModel.init(self);\n\t      selectionModel.onSelectedRangesChanged.subscribe(handleSelectedRangesChanged);\n\t    }\n\t  }\n\t\n\t  function getSelectionModel() {\n\t    return selectionModel;\n\t  }\n\t\n\t  function getCanvasNode() {\n\t    return $canvas[0];\n\t  }\n\t\n\t  function getActiveCanvasNode(element) {\n\t    setActiveCanvasNode(element);\n\t\n\t    return $activeCanvasNode[0];\n\t  }\n\t\n\t  function getCanvases() {\n\t    return $canvas;\n\t  }\n\t\n\t  function setActiveCanvasNode(element) {\n\t    if (element) {\n\t      $activeCanvasNode = (0, _jquery2.default)(element.target).closest('.grid-canvas');\n\t    }\n\t  }\n\t\n\t  function getViewportNode() {\n\t    return $viewport[0];\n\t  }\n\t\n\t  function getActiveViewportNode(element) {\n\t    setActiveViewportNode(element);\n\t\n\t    return $activeViewportNode[0];\n\t  }\n\t\n\t  function setActiveViewportNode(element) {\n\t    if (element) {\n\t      $activeViewportNode = (0, _jquery2.default)(element.target).closest('.slick-viewport');\n\t    }\n\t  }\n\t\n\t  function measureScrollbar() {\n\t    var $c = (0, _jquery2.default)(\"<div class='scrollbar-fix' style='position:absolute; top:-10000px; left:-10000px; width:100px; height:100px; overflow:scroll;'></div>\").appendTo(document.body);\n\t    var dim = {\n\t      width: $c.width() - $c[0].clientWidth,\n\t      height: $c.height() - $c[0].clientHeight\n\t    };\n\t    $c.remove();\n\t    return dim;\n\t  }\n\t\n\t  function getHeadersWidth() {\n\t    headersWidth = headersWidthL = headersWidthR = 0;\n\t\n\t    for (var i = 0, ii = columns.length; i < ii; i++) {\n\t      var width = columns[i].width;\n\t\n\t      if (options.frozenColumn > -1 && i > options.frozenColumn) {\n\t        headersWidthR += width;\n\t      } else {\n\t        headersWidthL += width;\n\t      }\n\t    }\n\t\n\t    if (hasFrozenColumns()) {\n\t      headersWidthL = headersWidthL + 1000;\n\t\n\t      headersWidthR = Math.max(headersWidthR, viewportW) + headersWidthL;\n\t      headersWidthR += scrollbarDimensions.width;\n\t    } else {\n\t      headersWidthL += scrollbarDimensions.width;\n\t      headersWidthL = Math.max(headersWidthL, viewportW) + 1000;\n\t    }\n\t\n\t    headersWidth = headersWidthL + headersWidthR;\n\t  }\n\t\n\t  function getHeadersWidthL() {\n\t    headersWidthL = 0;\n\t\n\t    columns.forEach(function (column, i) {\n\t      if (!(options.frozenColumn > -1 && i > options.frozenColumn)) headersWidthL += column.width;\n\t    });\n\t\n\t    if (hasFrozenColumns()) {\n\t      headersWidthL += 1000;\n\t    } else {\n\t      headersWidthL += scrollbarDimensions.width;\n\t      headersWidthL = Math.max(headersWidthL, viewportW) + 1000;\n\t    }\n\t\n\t    return headersWidthL;\n\t  }\n\t\n\t  function getHeadersWidthR() {\n\t    headersWidthR = 0;\n\t\n\t    columns.forEach(function (column, i) {\n\t      if (options.frozenColumn > -1 && i > options.frozenColumn) headersWidthR += column.width;\n\t    });\n\t\n\t    if (hasFrozenColumns()) {\n\t      headersWidthR = Math.max(headersWidthR, viewportW) + getHeadersWidthL();\n\t      headersWidthR += scrollbarDimensions.width;\n\t    }\n\t\n\t    return headersWidthR;\n\t  }\n\t\n\t  function getCanvasWidth() {\n\t    var availableWidth = viewportHasVScroll ? viewportW - scrollbarDimensions.width : viewportW;\n\t\n\t    var i = columns.length;\n\t\n\t    canvasWidthL = canvasWidthR = 0;\n\t\n\t    while (i--) {\n\t      if (hasFrozenColumns() && i > options.frozenColumn) {\n\t        canvasWidthR += columns[i].width;\n\t      } else {\n\t        canvasWidthL += columns[i].width;\n\t      }\n\t    }\n\t\n\t    var totalRowWidth = canvasWidthL + canvasWidthR;\n\t\n\t    return options.fullWidthRows ? Math.max(totalRowWidth, availableWidth) : totalRowWidth;\n\t  }\n\t\n\t  function updateCanvasWidth(forceColumnWidthsUpdate) {\n\t    var oldCanvasWidth = canvasWidth;\n\t    var oldCanvasWidthL = canvasWidthL;\n\t    var oldCanvasWidthR = canvasWidthR;\n\t    var widthChanged;\n\t    canvasWidth = getCanvasWidth();\n\t\n\t    widthChanged = canvasWidth !== oldCanvasWidth || canvasWidthL !== oldCanvasWidthL || canvasWidthR !== oldCanvasWidthR;\n\t\n\t    if (widthChanged || hasFrozenColumns() || hasFrozenRows) {\n\t      $canvasTopL.width(canvasWidthL);\n\t\n\t      getHeadersWidth();\n\t\n\t      $headerL.width(headersWidthL);\n\t      $headerR.width(headersWidthR);\n\t\n\t      if (hasFrozenColumns()) {\n\t        $canvasTopR.width(canvasWidthR);\n\t\n\t        $paneHeaderL.width(canvasWidthL);\n\t        $paneHeaderR.css('left', canvasWidthL);\n\t        $paneHeaderR.css('width', viewportW - canvasWidthL);\n\t\n\t        $paneTopL.width(canvasWidthL);\n\t        $paneTopR.css('left', canvasWidthL);\n\t        $paneTopR.css('width', viewportW - canvasWidthL);\n\t\n\t        $headerRowScrollerL.width(canvasWidthL);\n\t        $headerRowScrollerR.width(viewportW - canvasWidthL);\n\t\n\t        $headerRowL.width(canvasWidthL);\n\t        $headerRowR.width(canvasWidthR);\n\t\n\t        $footerRowScrollerL.width(canvasWidthL);\n\t        $footerRowScrollerR.width(viewportW - canvasWidthL);\n\t\n\t        $footerRowL.width(canvasWidthL);\n\t        $footerRowR.width(canvasWidthR);\n\t\n\t        $viewportTopL.width(canvasWidthL);\n\t        $viewportTopR.width(viewportW - canvasWidthL);\n\t\n\t        if (hasFrozenRows) {\n\t          $paneBottomL.width(canvasWidthL);\n\t          $paneBottomR.css('left', canvasWidthL);\n\t\n\t          $viewportBottomL.width(canvasWidthL);\n\t          $viewportBottomR.width(viewportW - canvasWidthL);\n\t\n\t          $canvasBottomL.width(canvasWidthL);\n\t          $canvasBottomR.width(canvasWidthR);\n\t        }\n\t      } else {\n\t        $paneHeaderL.width('100%');\n\t\n\t        $paneTopL.width('100%');\n\t\n\t        $headerRowScrollerL.width('100%');\n\t\n\t        $headerRowL.width(canvasWidth);\n\t\n\t        $footerRowScrollerL.width('100%');\n\t\n\t        $footerRowL.width(canvasWidth);\n\t\n\t        $viewportTopL.width('100%');\n\t\n\t        if (hasFrozenRows) {\n\t          $viewportBottomL.width('100%');\n\t          $canvasBottomL.width(canvasWidthL);\n\t        }\n\t      }\n\t\n\t      viewportHasHScroll = canvasWidth > viewportW - scrollbarDimensions.width;\n\t    }\n\t\n\t    $headerRowSpacerL.width(canvasWidth + (viewportHasVScroll ? scrollbarDimensions.width : 0));\n\t    $headerRowSpacerR.width(canvasWidth + (viewportHasVScroll ? scrollbarDimensions.width : 0));\n\t\n\t    $footerRowSpacerL.width(canvasWidth + (viewportHasVScroll ? scrollbarDimensions.width : 0));\n\t    $footerRowSpacerR.width(canvasWidth + (viewportHasVScroll ? scrollbarDimensions.width : 0));\n\t\n\t    if (widthChanged || forceColumnWidthsUpdate) {\n\t      applyColumnWidths();\n\t    }\n\t  }\n\t\n\t  function disableSelection($target) {\n\t    if ($target && $target.jquery) {\n\t      $target.attr(\"unselectable\", \"on\").css(\"MozUserSelect\", \"none\").bind(\"selectstart.ui\", function () {\n\t        return false;\n\t      }); // from jquery:ui.core.js 1.7.2\n\t    }\n\t  }\n\t\n\t  function getMaxSupportedCssHeight() {\n\t    var supportedHeight = 1000000;\n\t    // FF reports the height back but still renders blank after ~6M px\n\t    var testUpTo = navigator.userAgent.toLowerCase().match(/firefox/) ? 6000000 : 1000000000;\n\t    var div = (0, _jquery2.default)(\"<div style='display:none' />\").appendTo(document.body);\n\t\n\t    while (true) {\n\t      var test = supportedHeight * 2;\n\t      div.css(\"height\", test);\n\t      if (test > testUpTo || div.height() !== test) {\n\t        break;\n\t      } else {\n\t        supportedHeight = test;\n\t      }\n\t    }\n\t\n\t    div.remove();\n\t    return supportedHeight;\n\t  }\n\t\n\t  // TODO:  this is static.  need to handle page mutation.\n\t  function bindAncestorScrollEvents() {\n\t    var elem = hasFrozenRows && !options.frozenBottom ? $canvasBottomL[0] : $canvasTopL[0];\n\t    while ((elem = elem.parentNode) != document.body && elem != null) {\n\t      // bind to scroll containers only\n\t      if (elem == $viewportTopL[0] || elem.scrollWidth != elem.clientWidth || elem.scrollHeight != elem.clientHeight) {\n\t        var $elem = (0, _jquery2.default)(elem);\n\t        if (!$boundAncestors) {\n\t          $boundAncestors = $elem;\n\t        } else {\n\t          $boundAncestors = $boundAncestors.add($elem);\n\t        }\n\t        $elem.bind(\"scroll.\" + uid, handleActiveCellPositionChange);\n\t      }\n\t    }\n\t  }\n\t\n\t  function unbindAncestorScrollEvents() {\n\t    if (!$boundAncestors) {\n\t      return;\n\t    }\n\t    $boundAncestors.unbind(\"scroll.\" + uid);\n\t    $boundAncestors = null;\n\t  }\n\t\n\t  function updateColumnHeader(columnId, title, toolTip) {\n\t    if (!initialized) {\n\t      return;\n\t    }\n\t    var idx = getColumnIndex(columnId);\n\t    if (idx == null) {\n\t      return;\n\t    }\n\t\n\t    var columnDef = columns[idx];\n\t    var $header = $headers.children().eq(idx);\n\t    if ($header) {\n\t      if (title !== undefined) {\n\t        columns[idx].name = title;\n\t      }\n\t      if (toolTip !== undefined) {\n\t        columns[idx].toolTip = toolTip;\n\t      }\n\t\n\t      trigger(self.onBeforeHeaderCellDestroy, {\n\t        \"node\": $header[0],\n\t        \"column\": columnDef\n\t      });\n\t\n\t      $header.attr(\"title\", toolTip || \"\").children().eq(0).html(title);\n\t\n\t      trigger(self.onHeaderCellRendered, {\n\t        \"node\": $header[0],\n\t        \"column\": columnDef\n\t      });\n\t    }\n\t  }\n\t\n\t  function getHeaderRow() {\n\t    return hasFrozenColumns() ? $headerRow : $headerRow[0];\n\t  }\n\t\n\t  function getHeaderRowColumn(columnId) {\n\t    var idx = getColumnIndex(columnId);\n\t\n\t    var $headerRowTarget;\n\t\n\t    if (hasFrozenColumns()) {\n\t      if (idx <= options.frozenColumn) {\n\t        $headerRowTarget = $headerRowL;\n\t      } else {\n\t        $headerRowTarget = $headerRowR;\n\t\n\t        idx -= options.frozenColumn + 1;\n\t      }\n\t    } else {\n\t      $headerRowTarget = $headerRowL;\n\t    }\n\t\n\t    var $header = $headerRowTarget.children().eq(idx);\n\t    return $header && $header[0];\n\t  }\n\t\n\t  function getFooterRow() {\n\t    return hasFrozenColumns() ? $footerRow : $footerRow[0];\n\t  }\n\t\n\t  function getFooterRowColumn(columnId) {\n\t    var idx = getColumnIndex(columnId);\n\t\n\t    var $footerRowTarget;\n\t\n\t    if (hasFrozenColumns()) {\n\t      if (idx <= options.frozenColumn) {\n\t        $footerRowTarget = $footerRowL;\n\t      } else {\n\t        $footerRowTarget = $footerRowR;\n\t\n\t        idx -= options.frozenColumn + 1;\n\t      }\n\t    } else {\n\t      $footerRowTarget = $footerRowL;\n\t    }\n\t\n\t    var $footer = $footerRowTarget.children().eq(idx);\n\t    return $footer && $footer[0];\n\t  }\n\t\n\t  function createColumnFooter() {\n\t    $footerRow.find(\".slick-footerrow-column\").each(function () {\n\t      var columnDef = (0, _jquery2.default)(this).data(\"column\");\n\t      if (columnDef) {\n\t        trigger(self.onBeforeFooterRowCellDestroy, {\n\t          \"node\": this,\n\t          \"column\": columnDef\n\t        });\n\t      }\n\t    });\n\t\n\t    $footerRowL.empty();\n\t    $footerRowR.empty();\n\t\n\t    for (var i = 0; i < columns.length; i++) {\n\t      var m = columns[i];\n\t\n\t      var footerRowCell = (0, _jquery2.default)(\"<div class='ui-state-default slick-footerrow-column l\" + i + \" r\" + i + \"'></div>\").data(\"column\", m).addClass(hasFrozenColumns() && i <= options.frozenColumn ? 'frozen' : '').appendTo(hasFrozenColumns() && i > options.frozenColumn ? $footerRowR : $footerRowL);\n\t\n\t      trigger(self.onFooterRowCellRendered, {\n\t        \"node\": footerRowCell[0],\n\t        \"column\": m\n\t      });\n\t    }\n\t  }\n\t\n\t  function createColumnGroupHeaders() {\n\t    var columnsLength = 0;\n\t    var frozenColumnsValid = false;\n\t\n\t    if (!treeColumns.hasDepth()) return;\n\t\n\t    for (var index = 0; index < $groupHeadersL.length; index++) {\n\t\n\t      $groupHeadersL[index].empty();\n\t      $groupHeadersR[index].empty();\n\t\n\t      var groupColumns = treeColumns.getColumnsInDepth(index);\n\t\n\t      for (var indexGroup in groupColumns) {\n\t        var m = groupColumns[indexGroup];\n\t\n\t        columnsLength += m.extractColumns().length;\n\t\n\t        if (hasFrozenColumns() && index == 0 && columnsLength - 1 === options.frozenColumn) frozenColumnsValid = true;\n\t\n\t        (0, _jquery2.default)(\"<div class='ui-state-default slick-group-header-column' />\").html(\"<span class='slick-column-name'>\" + m.name + \"</span>\").attr(\"id\", \"\" + uid + m.id).attr(\"title\", m.toolTip || \"\").data(\"column\", m).addClass(m.headerCssClass || \"\").addClass(hasFrozenColumns() && columnsLength - 1 <= options.frozenColumn ? 'frozen' : '').appendTo(hasFrozenColumns() && columnsLength - 1 > options.frozenColumn ? $groupHeadersR[index] : $groupHeadersL[index]);\n\t      }\n\t\n\t      if (hasFrozenColumns() && index == 0 && !frozenColumnsValid) {\n\t        $groupHeadersL[index].empty();\n\t        $groupHeadersR[index].empty();\n\t        alert(\"All columns of group should to be grouped!\");\n\t        break;\n\t      }\n\t    }\n\t\n\t    applyColumnGroupHeaderWidths();\n\t  }\n\t\n\t  function createColumnHeaders() {\n\t    function onMouseEnter() {\n\t      (0, _jquery2.default)(this).addClass(\"ui-state-hover\");\n\t    }\n\t\n\t    function onMouseLeave() {\n\t      (0, _jquery2.default)(this).removeClass(\"ui-state-hover\");\n\t    }\n\t\n\t    $headers.find(\".slick-header-column\").each(function () {\n\t      var columnDef = (0, _jquery2.default)(this).data(\"column\");\n\t      if (columnDef) {\n\t        trigger(self.onBeforeHeaderCellDestroy, {\n\t          \"node\": this,\n\t          \"column\": columnDef\n\t        });\n\t      }\n\t    });\n\t\n\t    $headerL.empty();\n\t    $headerR.empty();\n\t\n\t    getHeadersWidth();\n\t\n\t    $headerL.width(headersWidthL);\n\t    $headerR.width(headersWidthR);\n\t\n\t    $headerRow.find(\".slick-headerrow-column\").each(function () {\n\t      var columnDef = (0, _jquery2.default)(this).data(\"column\");\n\t      if (columnDef) {\n\t        trigger(self.onBeforeHeaderRowCellDestroy, {\n\t          \"node\": this,\n\t          \"column\": columnDef\n\t        });\n\t      }\n\t    });\n\t\n\t    $headerRowL.empty();\n\t    $headerRowR.empty();\n\t\n\t    for (var i = 0; i < columns.length; i++) {\n\t      var m = columns[i];\n\t\n\t      var $headerTarget = hasFrozenColumns() ? i <= options.frozenColumn ? $headerL : $headerR : $headerL;\n\t      var $headerRowTarget = hasFrozenColumns() ? i <= options.frozenColumn ? $headerRowL : $headerRowR : $headerRowL;\n\t\n\t      var header = (0, _jquery2.default)(\"<div class='ui-state-default slick-header-column' />\").html(\"<span class='slick-column-name'>\" + m.name + \"</span>\").width(m.width - headerColumnWidthDiff).attr(\"id\", \"\" + uid + m.id).attr(\"title\", m.toolTip || \"\").data(\"column\", m).addClass(m.headerCssClass || \"\").addClass(hasFrozenColumns() && i <= options.frozenColumn ? 'frozen' : '').appendTo($headerTarget);\n\t\n\t      if (options.enableColumnReorder || m.sortable) {\n\t        header.on('mouseenter', onMouseEnter).on('mouseleave', onMouseLeave);\n\t      }\n\t\n\t      if (m.sortable) {\n\t        header.addClass(\"slick-header-sortable\");\n\t        header.append(\"<span class='slick-sort-indicator' />\");\n\t      }\n\t\n\t      trigger(self.onHeaderCellRendered, {\n\t        \"node\": header[0],\n\t        \"column\": m\n\t      });\n\t\n\t      if (options.showHeaderRow) {\n\t        var headerRowCell = (0, _jquery2.default)(\"<div class='ui-state-default slick-headerrow-column l\" + i + \" r\" + i + \"'></div>\").data(\"column\", m).appendTo($headerRowTarget);\n\t\n\t        trigger(self.onHeaderRowCellRendered, {\n\t          \"node\": headerRowCell[0],\n\t          \"column\": m\n\t        });\n\t      }\n\t    }\n\t\n\t    setSortColumns(sortColumns);\n\t    setupColumnResize();\n\t    if (options.enableColumnReorder) {\n\t      setupColumnReorder();\n\t    }\n\t  }\n\t\n\t  function setupColumnSort() {\n\t    $headers.click(function (e) {\n\t      // temporary workaround for a bug in jQuery 1.7.1 (http://bugs.jquery.com/ticket/11328)\n\t      e.metaKey = e.metaKey || e.ctrlKey;\n\t\n\t      if ((0, _jquery2.default)(e.target).hasClass(\"slick-resizable-handle\")) {\n\t        return;\n\t      }\n\t\n\t      var $col = (0, _jquery2.default)(e.target).closest(\".slick-header-column\");\n\t      if (!$col.length) {\n\t        return;\n\t      }\n\t\n\t      var column = $col.data(\"column\");\n\t      if (column.sortable) {\n\t        if (!getEditorLock().commitCurrentEdit()) {\n\t          return;\n\t        }\n\t\n\t        var sortOpts = null;\n\t        var i = 0;\n\t        for (; i < sortColumns.length; i++) {\n\t          if (sortColumns[i].columnId == column.id) {\n\t            sortOpts = sortColumns[i];\n\t            sortOpts.sortAsc = !sortOpts.sortAsc;\n\t            break;\n\t          }\n\t        }\n\t\n\t        if (e.metaKey && options.multiColumnSort) {\n\t          if (sortOpts) {\n\t            sortColumns.splice(i, 1);\n\t          }\n\t        } else {\n\t          if (!e.shiftKey && !e.metaKey || !options.multiColumnSort) {\n\t            sortColumns = [];\n\t          }\n\t\n\t          if (!sortOpts) {\n\t            sortOpts = {\n\t              columnId: column.id,\n\t              sortAsc: column.defaultSortAsc\n\t            };\n\t            sortColumns.push(sortOpts);\n\t          } else if (sortColumns.length == 0) {\n\t            sortColumns.push(sortOpts);\n\t          }\n\t        }\n\t\n\t        setSortColumns(sortColumns);\n\t\n\t        if (!options.multiColumnSort) {\n\t          trigger(self.onSort, {\n\t            multiColumnSort: false,\n\t            sortCol: column,\n\t            sortAsc: sortOpts.sortAsc\n\t          }, e);\n\t        } else {\n\t          trigger(self.onSort, {\n\t            multiColumnSort: true,\n\t            sortCols: _jquery2.default.map(sortColumns, function (col) {\n\t              return {\n\t                sortCol: columns[getColumnIndex(col.columnId)],\n\t                sortAsc: col.sortAsc\n\t              };\n\t            })\n\t          }, e);\n\t        }\n\t      }\n\t    });\n\t  }\n\t\n\t  function currentPositionInHeader(id) {\n\t    var currentPosition = 0;\n\t    $headers.find('.slick-header-column').each(function (i) {\n\t      if (this.id == id) {\n\t        currentPosition = i;\n\t        return false;\n\t      }\n\t    });\n\t\n\t    return currentPosition;\n\t  }\n\t\n\t  function limitPositionInGroup(idColumn) {\n\t    var groupColumnOfPreviousPosition,\n\t        startLimit = 0,\n\t        endLimit = 0;\n\t\n\t    treeColumns.getColumnsInDepth($groupHeadersL.length - 1).some(function (groupColumn) {\n\t      startLimit = endLimit;\n\t      endLimit += groupColumn.columns.length;\n\t\n\t      groupColumn.columns.some(function (column) {\n\t\n\t        if (column.id === idColumn) groupColumnOfPreviousPosition = groupColumn;\n\t\n\t        return groupColumnOfPreviousPosition;\n\t      });\n\t\n\t      return groupColumnOfPreviousPosition;\n\t    });\n\t\n\t    endLimit--;\n\t\n\t    return {\n\t      start: startLimit,\n\t      end: endLimit,\n\t      group: groupColumnOfPreviousPosition\n\t    };\n\t  }\n\t\n\t  function remove(arr, elem) {\n\t    var index = arr.lastIndexOf(elem);\n\t    if (index > -1) {\n\t      arr.splice(index, 1);\n\t      remove(arr, elem);\n\t    }\n\t  }\n\t\n\t  function columnPositionValidInGroup($item) {\n\t    var currentPosition = currentPositionInHeader($item[0].id);\n\t    var limit = limitPositionInGroup($item.data('column').id);\n\t    var positionValid = limit.start <= currentPosition && currentPosition <= limit.end;\n\t\n\t    return {\n\t      limit: limit,\n\t      valid: positionValid,\n\t      message: positionValid ? '' : 'Column \"'.concat($item.text(), '\" can be reordered only within the \"', limit.group.name, '\" group!')\n\t    };\n\t  }\n\t\n\t  function setupColumnReorder() {\n\t    var x = 0;\n\t    var delta = 0;\n\t    var placeholder = document.createElement('div');\n\t\n\t    placeholder.className = 'interact-placeholder';\n\t\n\t    (0, _interact2.default)('.slick-header-column', { context: $container[0] }).ignoreFrom('.slick-resizable-handle').draggable({\n\t      inertia: true,\n\t      // keep the element within the area of it's parent\n\t      restrict: {\n\t        restriction: 'parent',\n\t        endOnly: true,\n\t        elementRect: { top: 0, left: 0, bottom: 0, right: 0 }\n\t      },\n\t      // enable autoScroll\n\t      autoScroll: true,\n\t      axis: 'x',\n\t      onstart: function onstart(event) {\n\t        x = 0;\n\t        delta = event.target.offsetWidth;\n\t\n\t        // get old order\n\t        $headers.find('.slick-header-column').each(function (index) {\n\t          (0, _jquery2.default)(this).data('index', index);\n\t        });\n\t\n\t        placeholder.style.height = event.target.offsetHeight + 'px';\n\t        placeholder.style.width = delta + 'px';\n\t\n\t        (0, _jquery2.default)(event.target).after(placeholder).css({\n\t          position: 'absolute',\n\t          zIndex: 1000,\n\t          marginLeft: (0, _jquery2.default)(event.target).position().left - 1000\n\t        });\n\t      },\n\t\n\t      onmove: function onmove(event) {\n\t        x += event.dx;\n\t        event.target.style.transform = 'translate3d(' + x + 'px, -3px, 100px)';\n\t        event.target.style.zIndex = 1000;\n\t      },\n\t\n\t      onend: function onend(event) {\n\t        x = 0;\n\t        delta = 0;\n\t\n\t        if (treeColumns.hasDepth()) {\n\t          var validPositionInGroup = columnPositionValidInGroup((0, _jquery2.default)(event.target));\n\t          var limit = validPositionInGroup.limit;\n\t\n\t          var cancel = !validPositionInGroup.valid;\n\t\n\t          if (cancel) alert(validPositionInGroup.message);\n\t        }\n\t\n\t        placeholder.parentNode.removeChild(placeholder);\n\t\n\t        if (cancel) {\n\t          event.target.style.transform = 'none';\n\t          setColumns(getColumns());\n\t          return;\n\t        }\n\t\n\t        (0, _jquery2.default)(event.target).css({\n\t          position: 'relative',\n\t          zIndex: '',\n\t          marginLeft: 0,\n\t          transform: 'none'\n\t        });\n\t\n\t        var newColumns = [];\n\t        $headers.find('.slick-header-column').each(function (index) {\n\t          newColumns.push(columns[(0, _jquery2.default)(this).data('index')]);\n\t          (0, _jquery2.default)(this).removeData('index');\n\t        });\n\t\n\t        setColumns(newColumns);\n\t\n\t        trigger(self.onColumnsReordered, { impactedColumns: getImpactedColumns(limit), grid: self });\n\t        setupColumnResize();\n\t      }\n\t    }).dropzone({\n\t      accept: '.slick-header-column',\n\t\n\t      ondragenter: function ondragenter(event) {\n\t        event.target.classList.add('interact-drop-active');\n\t        event.relatedTarget.classList.add('interact-can-drop');\n\t      },\n\t\n\t      ondragleave: function ondragleave(event) {\n\t        event.target.classList.remove('interact-drop-active');\n\t        event.relatedTarget.classList.remove('interact-can-drop');\n\t      },\n\t\n\t      ondrop: function ondrop(event) {\n\t        event.target.classList.remove('interact-drop-active');\n\t        event.relatedTarget.classList.remove('interact-can-drop');\n\t        (0, _jquery2.default)(event.target)[x > 0 ? 'after' : 'before'](event.relatedTarget);\n\t      }\n\t    }).styleCursor(false);\n\t  }\n\t\n\t  function getImpactedColumns(limit) {\n\t    var impactedColumns = [];\n\t\n\t    if (limit != undefined) {\n\t\n\t      for (var i = limit.start; i <= limit.end; i++) {\n\t        impactedColumns.push(columns[i]);\n\t      }\n\t    } else {\n\t\n\t      impactedColumns = columns;\n\t    }\n\t\n\t    return impactedColumns;\n\t  }\n\t\n\t  function setupColumnResize() {\n\t    var $col, j, c, pageX, columnElements, minPageX, maxPageX, firstResizable, lastResizable;\n\t    columnElements = $headers.children();\n\t    columnElements.find('.slick-resizable-handle').remove();\n\t    columnElements.each(function (i, e) {\n\t      if (columns[i].resizable) {\n\t        if (firstResizable === undefined) {\n\t          firstResizable = i;\n\t        }\n\t        lastResizable = i;\n\t      }\n\t    });\n\t    if (firstResizable === undefined) {\n\t      return;\n\t    }\n\t    columnElements.each(function (i, element) {\n\t      if (i < firstResizable || options.forceFitColumns && i >= lastResizable) {\n\t        return;\n\t      }\n\t      $col = (0, _jquery2.default)(element);\n\t\n\t      var $handle = (0, _jquery2.default)(\"<div class='slick-resizable-handle' />\");\n\t      $handle.appendTo(element);\n\t\n\t      if ($col.data('resizable')) return;\n\t\n\t      var activeColumn = columns[i];\n\t      if (activeColumn.resizable) {\n\t        $col.data('resizable', true);\n\t        (0, _interact2.default)(element).resizable({\n\t          preserveAspectRatio: false,\n\t          edges: { left: true, right: true, bottom: false, top: false }\n\t        }).on('resizestart', function (event) {\n\t          if (!getEditorLock().commitCurrentEdit()) {\n\t            return false;\n\t          }\n\t          activeColumn.previousWidth = event.rect.width;\n\t          event.target.classList.add('slick-header-column-active');\n\t        }).on('resizemove', function (event) {\n\t          var x = event.dx;\n\t          var width = activeColumn.width += x;\n\t\n\t          if (activeColumn.minWidth > 0 && activeColumn.minWidth > width) width = activeColumn.minWidth;else if (activeColumn.maxWidth > 0 && activeColumn.maxWidth < width) width = activeColumn.maxWidth;\n\t\n\t          activeColumn.width = width;\n\t\n\t          if (options.forceFitColumns) {\n\t            autosizeColumns();\n\t          }\n\t          applyColumnHeaderWidths();\n\t          if (options.syncColumnCellResize) {\n\t            applyColumnWidths();\n\t          }\n\t        }).on('resizeend', function (event) {\n\t          event.target.classList.remove('slick-header-column-active');\n\t          if (treeColumns.hasDepth()) createColumnGroupHeaders();\n\t\n\t          invalidateAllRows();\n\t          updateCanvasWidth(true);\n\t          render();\n\t          trigger(self.onColumnsResized, { grid: self });\n\t        });\n\t      }\n\t    });\n\t  }\n\t\n\t  function getVBoxDelta($el) {\n\t    var p = [\"borderTopWidth\", \"borderBottomWidth\", \"paddingTop\", \"paddingBottom\"];\n\t    var delta = 0;\n\t    _jquery2.default.each(p, function (n, val) {\n\t      delta += parseFloat($el.css(val)) || 0;\n\t    });\n\t    return delta;\n\t  }\n\t\n\t  function setFrozenOptions() {\n\t    options.frozenColumn = options.frozenColumn >= 0 && options.frozenColumn < columns.length ? parseInt(options.frozenColumn) : -1;\n\t\n\t    options.frozenRow = options.frozenRow >= 0 && options.frozenRow < numVisibleRows ? parseInt(options.frozenRow) : -1;\n\t\n\t    if (options.frozenRow > -1) {\n\t      hasFrozenRows = true;\n\t      frozenRowsHeight = options.frozenRow * options.rowHeight;\n\t\n\t      var dataLength = getDataLength() || this.data.length;\n\t\n\t      actualFrozenRow = options.frozenBottom ? dataLength - options.frozenRow : options.frozenRow;\n\t    } else {\n\t      hasFrozenRows = false;\n\t    }\n\t  }\n\t\n\t  function setPaneVisibility() {\n\t    if (hasFrozenColumns()) {\n\t      $paneHeaderR.show();\n\t      $paneTopR.show();\n\t\n\t      if (hasFrozenRows) {\n\t        $paneBottomL.show();\n\t        $paneBottomR.show();\n\t      } else {\n\t        $paneBottomR.hide();\n\t        $paneBottomL.hide();\n\t      }\n\t    } else {\n\t      $paneHeaderR.hide();\n\t      $paneTopR.hide();\n\t      $paneBottomR.hide();\n\t\n\t      if (hasFrozenRows) {\n\t        $paneBottomL.show();\n\t      } else {\n\t        $paneBottomR.hide();\n\t        $paneBottomL.hide();\n\t      }\n\t    }\n\t  }\n\t\n\t  function setOverflow() {\n\t    $viewportTopL.css({\n\t      'overflow-x': hasFrozenColumns() ? hasFrozenRows ? 'hidden' : 'scroll' : hasFrozenRows ? 'hidden' : 'auto',\n\t      'overflow-y': hasFrozenColumns() ? hasFrozenRows ? 'hidden' : 'hidden' : hasFrozenRows ? 'scroll' : 'auto'\n\t    });\n\t\n\t    $viewportTopR.css({\n\t      'overflow-x': hasFrozenColumns() ? hasFrozenRows ? 'hidden' : 'scroll' : hasFrozenRows ? 'hidden' : 'auto',\n\t      'overflow-y': hasFrozenColumns() ? hasFrozenRows ? 'scroll' : 'auto' : hasFrozenRows ? 'scroll' : 'auto'\n\t    });\n\t\n\t    $viewportBottomL.css({\n\t      'overflow-x': hasFrozenColumns() ? hasFrozenRows ? 'scroll' : 'auto' : hasFrozenRows ? 'auto' : 'auto',\n\t      'overflow-y': hasFrozenColumns() ? hasFrozenRows ? 'hidden' : 'hidden' : hasFrozenRows ? 'scroll' : 'auto'\n\t    });\n\t\n\t    $viewportBottomR.css({\n\t      'overflow-x': hasFrozenColumns() ? hasFrozenRows ? 'scroll' : 'auto' : hasFrozenRows ? 'auto' : 'auto',\n\t      'overflow-y': hasFrozenColumns() ? hasFrozenRows ? 'auto' : 'auto' : hasFrozenRows ? 'auto' : 'auto'\n\t    });\n\t  }\n\t\n\t  function setScroller() {\n\t    if (hasFrozenColumns()) {\n\t      $headerScrollContainer = $headerScrollerR;\n\t      $headerRowScrollContainer = $headerRowScrollerR;\n\t      $footerRowScrollContainer = $footerRowScrollerR;\n\t\n\t      if (hasFrozenRows) {\n\t        if (options.frozenBottom) {\n\t          $viewportScrollContainerX = $viewportBottomR;\n\t          $viewportScrollContainerY = $viewportTopR;\n\t        } else {\n\t          $viewportScrollContainerX = $viewportScrollContainerY = $viewportBottomR;\n\t        }\n\t      } else {\n\t        $viewportScrollContainerX = $viewportScrollContainerY = $viewportTopR;\n\t      }\n\t    } else {\n\t      $headerScrollContainer = $headerScrollerL;\n\t      $headerRowScrollContainer = $headerRowScrollerL;\n\t      $footerRowScrollContainer = $footerRowScrollerL;\n\t\n\t      if (hasFrozenRows) {\n\t        if (options.frozenBottom) {\n\t          $viewportScrollContainerX = $viewportBottomL;\n\t          $viewportScrollContainerY = $viewportTopL;\n\t        } else {\n\t          $viewportScrollContainerX = $viewportScrollContainerY = $viewportBottomL;\n\t        }\n\t      } else {\n\t        $viewportScrollContainerX = $viewportScrollContainerY = $viewportTopL;\n\t      }\n\t    }\n\t  }\n\t\n\t  function measureCellPaddingAndBorder() {\n\t    var el;\n\t    var h = [\"borderLeftWidth\", \"borderRightWidth\", \"paddingLeft\", \"paddingRight\"];\n\t    var v = [\"borderTopWidth\", \"borderBottomWidth\", \"paddingTop\", \"paddingBottom\"];\n\t\n\t    el = (0, _jquery2.default)(\"<div class='ui-state-default slick-header-column' style='visibility:hidden'>-</div>\").appendTo($headers);\n\t    headerColumnWidthDiff = headerColumnHeightDiff = 0;\n\t    if (el.css(\"box-sizing\") != \"border-box\" && el.css(\"-moz-box-sizing\") != \"border-box\" && el.css(\"-webkit-box-sizing\") != \"border-box\") {\n\t      _jquery2.default.each(h, function (n, val) {\n\t        headerColumnWidthDiff += parseFloat(el.css(val)) || 0;\n\t      });\n\t      _jquery2.default.each(v, function (n, val) {\n\t        headerColumnHeightDiff += parseFloat(el.css(val)) || 0;\n\t      });\n\t    }\n\t    el.remove();\n\t\n\t    var r = (0, _jquery2.default)(\"<div class='slick-row' />\").appendTo($canvas);\n\t    el = (0, _jquery2.default)(\"<div class='slick-cell' id='' style='visibility:hidden'>-</div>\").appendTo(r);\n\t    cellWidthDiff = cellHeightDiff = 0;\n\t    if (el.css(\"box-sizing\") != \"border-box\" && el.css(\"-moz-box-sizing\") != \"border-box\" && el.css(\"-webkit-box-sizing\") != \"border-box\") {\n\t      _jquery2.default.each(h, function (n, val) {\n\t        cellWidthDiff += parseFloat(el.css(val)) || 0;\n\t      });\n\t      _jquery2.default.each(v, function (n, val) {\n\t        cellHeightDiff += parseFloat(el.css(val)) || 0;\n\t      });\n\t    }\n\t    r.remove();\n\t\n\t    absoluteColumnMinWidth = Math.max(headerColumnWidthDiff, cellWidthDiff);\n\t  }\n\t\n\t  function createCssRules() {\n\t    $style = (0, _jquery2.default)(\"<style type='text/css' rel='stylesheet' />\").appendTo((0, _jquery2.default)(\"head\"));\n\t    var rowHeight = options.rowHeight - cellHeightDiff;\n\t    var rules = [\".\" + uid + \" .slick-group-header-column { left: 1000px; }\", \".\" + uid + \" .slick-header-column { left: 1000px; }\", \".\" + uid + \" .slick-top-panel { height:\" + options.topPanelHeight + \"px; }\", \".\" + uid + \" .slick-headerrow-columns { height:\" + options.headerRowHeight + \"px; }\", \".\" + uid + \" .slick-cell { height:\" + rowHeight + \"px; }\", \".\" + uid + \" .slick-row { height:\" + options.rowHeight + \"px; }\", \".\" + uid + \" .slick-footerrow-columns { height:\" + options.footerRowHeight + \"px; }\"];\n\t\n\t    for (var i = 0; i < columns.length; i++) {\n\t      rules.push(\".\" + uid + \" .l\" + i + \" { }\");\n\t      rules.push(\".\" + uid + \" .r\" + i + \" { }\");\n\t    }\n\t\n\t    if ($style[0].styleSheet) {\n\t      // IE\n\t      $style[0].styleSheet.cssText = rules.join(\" \");\n\t    } else {\n\t      $style[0].appendChild(document.createTextNode(rules.join(\" \")));\n\t    }\n\t  }\n\t\n\t  function getColumnCssRules(idx) {\n\t    if (!stylesheet) {\n\t      var sheets = document.styleSheets;\n\t      for (var i = 0; i < sheets.length; i++) {\n\t        if ((sheets[i].ownerNode || sheets[i].owningElement) == $style[0]) {\n\t          stylesheet = sheets[i];\n\t          break;\n\t        }\n\t      }\n\t\n\t      if (!stylesheet) {\n\t        throw new Error(\"Cannot find stylesheet.\");\n\t      }\n\t\n\t      // find and cache column CSS rules\n\t      columnCssRulesL = [];\n\t      columnCssRulesR = [];\n\t      var cssRules = stylesheet.cssRules || stylesheet.rules;\n\t      var matches, columnIdx;\n\t      for (var i = 0; i < cssRules.length; i++) {\n\t        var selector = cssRules[i].selectorText;\n\t        if (matches = /\\.l\\d+/.exec(selector)) {\n\t          columnIdx = parseInt(matches[0].substr(2, matches[0].length - 2), 10);\n\t          columnCssRulesL[columnIdx] = cssRules[i];\n\t        } else if (matches = /\\.r\\d+/.exec(selector)) {\n\t          columnIdx = parseInt(matches[0].substr(2, matches[0].length - 2), 10);\n\t          columnCssRulesR[columnIdx] = cssRules[i];\n\t        }\n\t      }\n\t    }\n\t\n\t    return {\n\t      \"left\": columnCssRulesL[idx],\n\t      \"right\": columnCssRulesR[idx]\n\t    };\n\t  }\n\t\n\t  function removeCssRules() {\n\t    $style.remove();\n\t    stylesheet = null;\n\t  }\n\t\n\t  function destroy() {\n\t    getEditorLock().cancelCurrentEdit();\n\t\n\t    trigger(self.onBeforeDestroy, {});\n\t\n\t    var i = plugins.length;\n\t    while (i--) {\n\t      unregisterPlugin(plugins[i]);\n\t    }\n\t\n\t    unbindAncestorScrollEvents();\n\t    $container.unbind(\".slickgrid\");\n\t    removeCssRules();\n\t\n\t    $container.empty().removeClass(uid);\n\t  }\n\t\n\t  //////////////////////////////////////////////////////////////////////////////////////////////\n\t  // General\n\t\n\t  function trigger(evt, args, e) {\n\t    e = e || new _slick2.default.EventData();\n\t    args = args || {};\n\t    args.grid = self;\n\t    return evt.notify(args, e, self);\n\t  }\n\t\n\t  function getEditorLock() {\n\t    return options.editorLock;\n\t  }\n\t\n\t  function getEditController() {\n\t    return editController;\n\t  }\n\t\n\t  function getColumnIndex(id) {\n\t    return columnsById[id];\n\t  }\n\t\n\t  function autosizeColumns() {\n\t    var i,\n\t        c,\n\t        widths = [],\n\t        shrinkLeeway = 0,\n\t        total = 0,\n\t        prevTotal,\n\t        availWidth = viewportHasVScroll ? viewportW - scrollbarDimensions.width : viewportW;\n\t\n\t    for (i = 0; i < columns.length; i++) {\n\t      c = columns[i];\n\t      widths.push(c.width);\n\t      total += c.width;\n\t      if (c.resizable) {\n\t        shrinkLeeway += c.width - Math.max(c.minWidth, absoluteColumnMinWidth);\n\t      }\n\t    }\n\t\n\t    // shrink\n\t    prevTotal = total;\n\t    while (total > availWidth && shrinkLeeway) {\n\t      var shrinkProportion = (total - availWidth) / shrinkLeeway;\n\t      for (i = 0; i < columns.length && total > availWidth; i++) {\n\t        c = columns[i];\n\t        var width = widths[i];\n\t        if (!c.resizable || width <= c.minWidth || width <= absoluteColumnMinWidth) {\n\t          continue;\n\t        }\n\t        var absMinWidth = Math.max(c.minWidth, absoluteColumnMinWidth);\n\t        var shrinkSize = Math.floor(shrinkProportion * (width - absMinWidth)) || 1;\n\t        shrinkSize = Math.min(shrinkSize, width - absMinWidth);\n\t        total -= shrinkSize;\n\t        shrinkLeeway -= shrinkSize;\n\t        widths[i] -= shrinkSize;\n\t      }\n\t      if (prevTotal <= total) {\n\t        // avoid infinite loop\n\t        break;\n\t      }\n\t      prevTotal = total;\n\t    }\n\t\n\t    // grow\n\t    prevTotal = total;\n\t    while (total < availWidth) {\n\t      var growProportion = availWidth / total;\n\t      for (i = 0; i < columns.length && total < availWidth; i++) {\n\t        c = columns[i];\n\t        var currentWidth = widths[i];\n\t        var growSize;\n\t\n\t        if (!c.resizable || c.maxWidth <= currentWidth) {\n\t          growSize = 0;\n\t        } else {\n\t          growSize = Math.min(Math.floor(growProportion * currentWidth) - currentWidth, c.maxWidth - currentWidth || 1000000) || 1;\n\t        }\n\t        total += growSize;\n\t        widths[i] += growSize;\n\t      }\n\t      if (prevTotal >= total) {\n\t        // avoid infinite loop\n\t        break;\n\t      }\n\t      prevTotal = total;\n\t    }\n\t\n\t    var reRender = false;\n\t    for (i = 0; i < columns.length; i++) {\n\t      if (columns[i].rerenderOnResize && columns[i].width != widths[i]) {\n\t        reRender = true;\n\t      }\n\t      columns[i].width = widths[i];\n\t    }\n\t\n\t    applyColumnHeaderWidths();\n\t    applyColumnGroupHeaderWidths();\n\t    updateCanvasWidth(true);\n\t    if (reRender) {\n\t      invalidateAllRows();\n\t      render();\n\t    }\n\t  }\n\t\n\t  function applyColumnGroupHeaderWidths() {\n\t    if (!treeColumns.hasDepth()) return;\n\t\n\t    for (var depth = $groupHeadersL.length - 1; depth >= 0; depth--) {\n\t\n\t      var groupColumns = treeColumns.getColumnsInDepth(depth);\n\t\n\t      (0, _jquery2.default)().add($groupHeadersL[depth]).add($groupHeadersR[depth]).each(function (i) {\n\t        var $groupHeader = (0, _jquery2.default)(this),\n\t            currentColumnIndex = 0;\n\t\n\t        $groupHeader.width(i == 0 ? getHeadersWidthL() : getHeadersWidthR());\n\t\n\t        $groupHeader.children().each(function () {\n\t          var $groupHeaderColumn = (0, _jquery2.default)(this);\n\t\n\t          var m = (0, _jquery2.default)(this).data('column');\n\t\n\t          m.width = 0;\n\t\n\t          m.columns.forEach(function () {\n\t            var $headerColumn = $groupHeader.next().children(':eq(' + currentColumnIndex++ + ')');\n\t            m.width += $headerColumn.outerWidth();\n\t          });\n\t\n\t          $groupHeaderColumn.width(m.width - headerColumnWidthDiff);\n\t        });\n\t      });\n\t    }\n\t  }\n\t\n\t  function applyColumnHeaderWidths() {\n\t    if (!initialized) {\n\t      return;\n\t    }\n\t    var h;\n\t    for (var i = 0, headers = $headers.children(), ii = headers.length; i < ii; i++) {\n\t      h = (0, _jquery2.default)(headers[i]);\n\t      if (h.width() !== columns[i].width - headerColumnWidthDiff) {\n\t        h.width(columns[i].width - headerColumnWidthDiff);\n\t      }\n\t    }\n\t\n\t    updateColumnCaches();\n\t  }\n\t\n\t  function applyColumnWidths() {\n\t    var x = 0,\n\t        w,\n\t        rule;\n\t    for (var i = 0; i < columns.length; i++) {\n\t      w = columns[i].width;\n\t\n\t      rule = getColumnCssRules(i);\n\t      rule.left.style.left = x + \"px\";\n\t      rule.right.style.right = (options.frozenColumn != -1 && i > options.frozenColumn ? canvasWidthR : canvasWidthL) - x - w + \"px\";\n\t\n\t      // If this column is frozen, reset the css left value since the\n\t      // column starts in a new viewport.\n\t      if (options.frozenColumn == i) {\n\t        x = 0;\n\t      } else {\n\t        x += columns[i].width;\n\t      }\n\t    }\n\t  }\n\t\n\t  function setSortColumn(columnId, ascending) {\n\t    setSortColumns([{\n\t      columnId: columnId,\n\t      sortAsc: ascending\n\t    }]);\n\t  }\n\t\n\t  function setSortColumns(cols) {\n\t    sortColumns = cols;\n\t\n\t    var headerColumnEls = $headers.children();\n\t    headerColumnEls.removeClass(\"slick-header-column-sorted\").find(\".slick-sort-indicator\").removeClass(\"slick-sort-indicator-asc slick-sort-indicator-desc\");\n\t\n\t    _jquery2.default.each(sortColumns, function (i, col) {\n\t      if (col.sortAsc == null) {\n\t        col.sortAsc = true;\n\t      }\n\t      var columnIndex = getColumnIndex(col.columnId);\n\t      if (columnIndex != null) {\n\t        headerColumnEls.eq(columnIndex).addClass(\"slick-header-column-sorted\").find(\".slick-sort-indicator\").addClass(col.sortAsc ? \"slick-sort-indicator-asc\" : \"slick-sort-indicator-desc\");\n\t      }\n\t    });\n\t  }\n\t\n\t  function getSortColumns() {\n\t    return sortColumns;\n\t  }\n\t\n\t  function handleSelectedRangesChanged(e, ranges) {\n\t    selectedRows = [];\n\t    var hash = {};\n\t    for (var i = 0; i < ranges.length; i++) {\n\t      for (var j = ranges[i].fromRow; j <= ranges[i].toRow; j++) {\n\t        if (!hash[j]) {\n\t          // prevent duplicates\n\t          selectedRows.push(j);\n\t          hash[j] = {};\n\t        }\n\t        for (var k = ranges[i].fromCell; k <= ranges[i].toCell; k++) {\n\t          if (canCellBeSelected(j, k)) {\n\t            hash[j][columns[k].id] = options.selectedCellCssClass;\n\t          }\n\t        }\n\t      }\n\t    }\n\t\n\t    setCellCssStyles(options.selectedCellCssClass, hash);\n\t\n\t    trigger(self.onSelectedRowsChanged, {\n\t      rows: getSelectedRows()\n\t    }, e);\n\t  }\n\t\n\t  function getColumns() {\n\t    return columns;\n\t  }\n\t\n\t  function updateColumnCaches() {\n\t    // Pre-calculate cell boundaries.\n\t    columnPosLeft = [];\n\t    columnPosRight = [];\n\t    var x = 0;\n\t    for (var i = 0, ii = columns.length; i < ii; i++) {\n\t      columnPosLeft[i] = x;\n\t      columnPosRight[i] = x + columns[i].width;\n\t\n\t      if (options.frozenColumn == i) {\n\t        x = 0;\n\t      } else {\n\t        x += columns[i].width;\n\t      }\n\t    }\n\t  }\n\t\n\t  function setColumns(columnDefinitions) {\n\t    var _treeColumns = new _slick2.default.TreeColumns(columnDefinitions);\n\t    if (_treeColumns.hasDepth()) {\n\t      treeColumns = _treeColumns;\n\t      columns = treeColumns.extractColumns();\n\t    } else {\n\t      columns = columnDefinitions;\n\t    }\n\t\n\t    columnsById = {};\n\t    for (var i = 0; i < columns.length; i++) {\n\t      var m = columns[i] = _jquery2.default.extend({}, columnDefaults, columns[i]);\n\t      columnsById[m.id] = i;\n\t      if (m.minWidth && m.width < m.minWidth) {\n\t        m.width = m.minWidth;\n\t      }\n\t      if (m.maxWidth && m.width > m.maxWidth) {\n\t        m.width = m.maxWidth;\n\t      }\n\t    }\n\t\n\t    updateColumnCaches();\n\t\n\t    if (initialized) {\n\t      setPaneVisibility();\n\t      setOverflow();\n\t\n\t      invalidateAllRows();\n\t      createColumnHeaders();\n\t      createColumnGroupHeaders();\n\t      createColumnFooter();\n\t      removeCssRules();\n\t      createCssRules();\n\t      resizeCanvas();\n\t      updateCanvasWidth();\n\t      applyColumnWidths();\n\t      handleScroll();\n\t    }\n\t  }\n\t\n\t  function getOptions() {\n\t    return options;\n\t  }\n\t\n\t  function setOptions(args) {\n\t    if (!getEditorLock().commitCurrentEdit()) {\n\t      return;\n\t    }\n\t\n\t    makeActiveCellNormal();\n\t\n\t    if (options.enableAddRow !== args.enableAddRow) {\n\t      invalidateRow(getDataLength());\n\t    }\n\t\n\t    options = _jquery2.default.extend(options, args);\n\t    validateAndEnforceOptions();\n\t\n\t    setFrozenOptions();\n\t    setScroller();\n\t    zombieRowNodeFromLastMouseWheelEvent = null;\n\t\n\t    setColumns(treeColumns.extractColumns());\n\t    render();\n\t  }\n\t\n\t  function validateAndEnforceOptions() {\n\t    if (options.autoHeight) {\n\t      options.leaveSpaceForNewRows = false;\n\t    }\n\t  }\n\t\n\t  function setData(newData, scrollToTop) {\n\t    data = newData;\n\t    invalidateAllRows();\n\t    updateRowCount();\n\t    if (scrollToTop) {\n\t      scrollTo(0);\n\t    }\n\t  }\n\t\n\t  function getData() {\n\t    return data;\n\t  }\n\t\n\t  function getDataLength() {\n\t    if (data.getLength) {\n\t      return data.getLength();\n\t    } else {\n\t      return data.length;\n\t    }\n\t  }\n\t\n\t  function getDataLengthIncludingAddNew() {\n\t    return getDataLength() + (options.enableAddRow ? 1 : 0);\n\t  }\n\t\n\t  function getDataItem(i) {\n\t    if (data.getItem) {\n\t      return data.getItem(i);\n\t    } else {\n\t      return data[i];\n\t    }\n\t  }\n\t\n\t  function getTopPanel() {\n\t    return $topPanel[0];\n\t  }\n\t\n\t  function setTopPanelVisibility(visible) {\n\t    if (options.showTopPanel != visible) {\n\t      options.showTopPanel = visible;\n\t      if (visible) {\n\t        $topPanelScroller.slideDown(\"fast\", resizeCanvas);\n\t      } else {\n\t        $topPanelScroller.slideUp(\"fast\", resizeCanvas);\n\t      }\n\t    }\n\t  }\n\t\n\t  function setHeaderRowVisibility(visible) {\n\t    if (options.showHeaderRow != visible) {\n\t      options.showHeaderRow = visible;\n\t      if (visible) {\n\t        $headerRowScroller.slideDown(\"fast\", resizeCanvas);\n\t      } else {\n\t        $headerRowScroller.slideUp(\"fast\", resizeCanvas);\n\t      }\n\t    }\n\t  }\n\t\n\t  function setFooterRowVisibility(visible) {\n\t    if (options.showFooterRow != visible) {\n\t      options.showFooterRow = visible;\n\t      if (visible) {\n\t        $footerRowScroller.fadeIn(\"fast\", resizeCanvas);\n\t      } else {\n\t        $footerRowScroller.slideDown(\"fast\", resizeCanvas);\n\t      }\n\t    }\n\t  }\n\t\n\t  function getContainerNode() {\n\t    return $container.get(0);\n\t  }\n\t\n\t  //////////////////////////////////////////////////////////////////////////////////////////////\n\t  // Rendering / Scrolling\n\t\n\t  function getRowTop(row) {\n\t    return options.rowHeight * row - offset;\n\t  }\n\t\n\t  function getRowFromPosition(y) {\n\t    return Math.floor((y + offset) / options.rowHeight);\n\t  }\n\t\n\t  function scrollTo(y) {\n\t    y = Math.max(y, 0);\n\t    y = Math.min(y, th - $viewportScrollContainerY.height() + (viewportHasHScroll || hasFrozenColumns() ? scrollbarDimensions.height : 0));\n\t\n\t    var oldOffset = offset;\n\t\n\t    page = Math.min(n - 1, Math.floor(y / ph));\n\t    offset = Math.round(page * cj);\n\t    var newScrollTop = y - offset;\n\t\n\t    if (offset != oldOffset) {\n\t      var range = getVisibleRange(newScrollTop);\n\t      cleanupRows(range);\n\t      updateRowPositions();\n\t    }\n\t\n\t    if (prevScrollTop != newScrollTop) {\n\t      vScrollDir = prevScrollTop + oldOffset < newScrollTop + offset ? 1 : -1;\n\t\n\t      lastRenderedScrollTop = scrollTop = prevScrollTop = newScrollTop;\n\t\n\t      if (hasFrozenColumns()) {\n\t        $viewportTopL[0].scrollTop = newScrollTop;\n\t      }\n\t\n\t      if (hasFrozenRows) {\n\t        $viewportBottomL[0].scrollTop = $viewportBottomR[0].scrollTop = newScrollTop;\n\t      }\n\t\n\t      $viewportScrollContainerY[0].scrollTop = newScrollTop;\n\t\n\t      trigger(self.onViewportChanged, {});\n\t    }\n\t  }\n\t\n\t  function defaultFormatter(row, cell, value, columnDef, dataContext) {\n\t    if (value == null) {\n\t      return \"\";\n\t    } else {\n\t      return (value + \"\").replace(/&/g, \"&\").replace(/</g, \"<\").replace(/>/g, \">\");\n\t    }\n\t  }\n\t\n\t  function getFormatter(row, column) {\n\t    var rowMetadata = data.getItemMetadata && data.getItemMetadata(row);\n\t\n\t    // look up by id, then index\n\t    var columnOverrides = rowMetadata && rowMetadata.columns && (rowMetadata.columns[column.id] || rowMetadata.columns[getColumnIndex(column.id)]);\n\t\n\t    return columnOverrides && columnOverrides.formatter || rowMetadata && rowMetadata.formatter || column.formatter || options.formatterFactory && options.formatterFactory.getFormatter(column) || options.defaultFormatter;\n\t  }\n\t\n\t  function callFormatter(row, cell, value, m, item) {\n\t\n\t    var result;\n\t\n\t    // pass metadata to formatter\n\t    var metadata = data.getItemMetadata && data.getItemMetadata(row);\n\t    metadata = metadata && metadata.columns;\n\t\n\t    if (metadata) {\n\t      var columnData = metadata[m.id] || metadata[cell];\n\t      result = getFormatter(row, m)(row, cell, value, m, item, columnData);\n\t    } else {\n\t      result = getFormatter(row, m)(row, cell, value, m, item);\n\t    }\n\t\n\t    return result;\n\t  }\n\t\n\t  function getEditor(row, cell) {\n\t    var column = columns[cell];\n\t    var rowMetadata = data.getItemMetadata && data.getItemMetadata(row);\n\t    var columnMetadata = rowMetadata && rowMetadata.columns;\n\t\n\t    if (columnMetadata && columnMetadata[column.id] && columnMetadata[column.id].editor !== undefined) {\n\t      return columnMetadata[column.id].editor;\n\t    }\n\t    if (columnMetadata && columnMetadata[cell] && columnMetadata[cell].editor !== undefined) {\n\t      return columnMetadata[cell].editor;\n\t    }\n\t\n\t    return column.editor || options.editorFactory && options.editorFactory.getEditor(column);\n\t  }\n\t\n\t  function getDataItemValueForColumn(item, columnDef) {\n\t    if (options.dataItemColumnValueExtractor) {\n\t      return options.dataItemColumnValueExtractor(item, columnDef);\n\t    }\n\t    return item[columnDef.field];\n\t  }\n\t\n\t  function appendRowHtml(stringArrayL, stringArrayR, row, range, dataLength) {\n\t    var d = getDataItem(row);\n\t    var dataLoading = row < dataLength && !d;\n\t    var rowCss = \"slick-row\" + (hasFrozenRows && row < options.frozenRow ? ' frozen' : '') + (dataLoading ? \" loading\" : \"\") + (row === activeRow ? \" active\" : \"\") + (row % 2 == 1 ? \" odd\" : \" even\");\n\t\n\t    if (!d) {\n\t      rowCss += \" \" + options.addNewRowCssClass;\n\t    }\n\t\n\t    var metadata = data.getItemMetadata && data.getItemMetadata(row);\n\t\n\t    if (metadata && metadata.cssClasses) {\n\t      rowCss += \" \" + metadata.cssClasses;\n\t    }\n\t\n\t    var frozenRowOffset = getFrozenRowOffset(row);\n\t\n\t    var rowHtml = \"<div class='ui-widget-content \" + rowCss + \"' style='top:\" + (getRowTop(row) - frozenRowOffset) + \"px'>\";\n\t\n\t    stringArrayL.push(rowHtml);\n\t\n\t    if (hasFrozenColumns()) {\n\t      stringArrayR.push(rowHtml);\n\t    }\n\t\n\t    var colspan, m;\n\t    for (var i = 0, ii = columns.length; i < ii; i++) {\n\t      m = columns[i];\n\t      colspan = 1;\n\t      if (metadata && metadata.columns) {\n\t        var columnData = metadata.columns[m.id] || metadata.columns[i];\n\t        colspan = columnData && columnData.colspan || 1;\n\t        if (colspan === \"*\") {\n\t          colspan = ii - i;\n\t        }\n\t      }\n\t\n\t      // Do not render cells outside of the viewport.\n\t      if (columnPosRight[Math.min(ii - 1, i + colspan - 1)] > range.leftPx) {\n\t        if (columnPosLeft[i] > range.rightPx) {\n\t          // All columns to the right are outside the range.\n\t          break;\n\t        }\n\t\n\t        if (hasFrozenColumns() && i > options.frozenColumn) {\n\t          appendCellHtml(stringArrayR, row, i, colspan, d);\n\t        } else {\n\t          appendCellHtml(stringArrayL, row, i, colspan, d);\n\t        }\n\t      } else if (hasFrozenColumns() && i <= options.frozenColumn) {\n\t        appendCellHtml(stringArrayL, row, i, colspan, d);\n\t      }\n\t\n\t      if (colspan > 1) {\n\t        i += colspan - 1;\n\t      }\n\t    }\n\t\n\t    stringArrayL.push(\"</div>\");\n\t\n\t    if (hasFrozenColumns()) {\n\t      stringArrayR.push(\"</div>\");\n\t    }\n\t  }\n\t\n\t  function appendCellHtml(stringArray, row, cell, colspan, item) {\n\t    var m = columns[cell];\n\t    var cellCss = \"slick-cell l\" + cell + \" r\" + Math.min(columns.length - 1, cell + colspan - 1) + (m.cssClass ? \" \" + m.cssClass : \"\");\n\t\n\t    if (hasFrozenColumns() && cell <= options.frozenColumn) cellCss += ' frozen';\n\t\n\t    if (row === activeRow && cell === activeCell) cellCss += \" active\";\n\t\n\t    // TODO:  merge them together in the setter\n\t    for (var key in cellCssClasses) {\n\t      if (cellCssClasses[key][row] && cellCssClasses[key][row][m.id]) {\n\t        cellCss += \" \" + cellCssClasses[key][row][m.id];\n\t      }\n\t    }\n\t\n\t    stringArray.push(\"<div class='\" + cellCss + \"'>\");\n\t\n\t    // if there is a corresponding row (if not, this is the Add New row or this data hasn't been loaded yet)\n\t    if (item) {\n\t      var value = getDataItemValueForColumn(item, m);\n\t      stringArray.push(callFormatter(row, cell, value, m, item));\n\t    }\n\t\n\t    stringArray.push(\"</div>\");\n\t\n\t    rowsCache[row].cellRenderQueue.push(cell);\n\t    rowsCache[row].cellColSpans[cell] = colspan;\n\t  }\n\t\n\t  function cleanupRows(rangeToKeep) {\n\t    for (var i in rowsCache) {\n\t      var removeFrozenRow = true;\n\t\n\t      if (hasFrozenRows && (options.frozenBottom && i >= actualFrozenRow || // Frozen bottom rows\n\t      !options.frozenBottom && i <= actualFrozenRow // Frozen top rows\n\t      )) {\n\t        removeFrozenRow = false;\n\t      }\n\t\n\t      if ((i = parseInt(i, 10)) !== activeRow && (i < rangeToKeep.top || i > rangeToKeep.bottom) && removeFrozenRow) {\n\t        removeRowFromCache(i);\n\t      }\n\t    }\n\t  }\n\t\n\t  function invalidate() {\n\t    updateRowCount();\n\t    invalidateAllRows();\n\t    render();\n\t  }\n\t\n\t  function invalidateAllRows() {\n\t    if (currentEditor) {\n\t      makeActiveCellNormal();\n\t    }\n\t    for (var row in rowsCache) {\n\t      removeRowFromCache(row);\n\t    }\n\t  }\n\t\n\t  function removeRowFromCache(row) {\n\t    var cacheEntry = rowsCache[row];\n\t    if (!cacheEntry) {\n\t      return;\n\t    }\n\t\n\t    if (rowNodeFromLastMouseWheelEvent == cacheEntry.rowNode[0] || hasFrozenColumns() && rowNodeFromLastMouseWheelEvent == cacheEntry.rowNode[1]) {\n\t\n\t      cacheEntry.rowNode.hide();\n\t\n\t      zombieRowNodeFromLastMouseWheelEvent = cacheEntry.rowNode;\n\t    } else {\n\t\n\t      cacheEntry.rowNode.each(function () {\n\t        this.parentElement.removeChild(this);\n\t      });\n\t    }\n\t\n\t    delete rowsCache[row];\n\t    delete postProcessedRows[row];\n\t    renderedRows--;\n\t    counter_rows_removed++;\n\t  }\n\t\n\t  function invalidateRows(rows) {\n\t    var i, rl;\n\t    if (!rows || !rows.length) {\n\t      return;\n\t    }\n\t    vScrollDir = 0;\n\t    for (i = 0, rl = rows.length; i < rl; i++) {\n\t      if (currentEditor && activeRow === rows[i]) {\n\t        makeActiveCellNormal();\n\t      }\n\t      if (rowsCache[rows[i]]) {\n\t        removeRowFromCache(rows[i]);\n\t      }\n\t    }\n\t  }\n\t\n\t  function invalidateRow(row) {\n\t    invalidateRows([row]);\n\t  }\n\t\n\t  function updateCell(row, cell) {\n\t    var cellNode = getCellNode(row, cell);\n\t    if (!cellNode) {\n\t      return;\n\t    }\n\t\n\t    var m = columns[cell],\n\t        d = getDataItem(row);\n\t    if (currentEditor && activeRow === row && activeCell === cell) {\n\t      currentEditor.loadValue(d);\n\t    } else {\n\t      cellNode.innerHTML = d ? callFormatter(row, cell, getDataItemValueForColumn(d, m), m, d) : \"\";\n\t      invalidatePostProcessingResults(row);\n\t    }\n\t  }\n\t\n\t  function updateRow(row) {\n\t    var cacheEntry = rowsCache[row];\n\t    if (!cacheEntry) {\n\t      return;\n\t    }\n\t\n\t    ensureCellNodesInRowsCache(row);\n\t\n\t    var d = getDataItem(row);\n\t\n\t    for (var columnIdx in cacheEntry.cellNodesByColumnIdx) {\n\t      if (!cacheEntry.cellNodesByColumnIdx.hasOwnProperty(columnIdx)) {\n\t        continue;\n\t      }\n\t\n\t      columnIdx = columnIdx | 0;\n\t      var m = columns[columnIdx],\n\t          node = cacheEntry.cellNodesByColumnIdx[columnIdx][0];\n\t\n\t      if (row === activeRow && columnIdx === activeCell && currentEditor) {\n\t        currentEditor.loadValue(d);\n\t      } else if (d) {\n\t        node.innerHTML = callFormatter(row, columnIdx, getDataItemValueForColumn(d, m), m, d);\n\t      } else {\n\t        node.innerHTML = \"\";\n\t      }\n\t    }\n\t\n\t    invalidatePostProcessingResults(row);\n\t  }\n\t\n\t  function getViewportHeight() {\n\t    if (options.autoHeight) {\n\t      viewportH = options.rowHeight * getDataLengthIncludingAddNew() + (options.frozenColumn == -1 ? $headers.outerHeight() : 0);\n\t    } else {\n\t      topPanelH = options.showTopPanel ? options.topPanelHeight + getVBoxDelta($topPanelScroller) : 0;\n\t\n\t      headerRowH = options.showHeaderRow ? options.headerRowHeight + getVBoxDelta($headerRowScroller) : 0;\n\t\n\t      footerRowH = options.showFooterRow ? options.footerRowHeight + getVBoxDelta($footerRowScroller) : 0;\n\t\n\t      viewportH = parseFloat(_jquery2.default.css($container[0], \"height\", true)) - parseFloat(_jquery2.default.css($container[0], \"paddingTop\", true)) - parseFloat(_jquery2.default.css($container[0], \"paddingBottom\", true)) - parseFloat(_jquery2.default.css($headerScroller[0], \"height\")) - getVBoxDelta($headerScroller) - topPanelH - headerRowH - footerRowH;\n\t    }\n\t\n\t    numVisibleRows = Math.ceil(viewportH / options.rowHeight);\n\t  }\n\t\n\t  function getViewportWidth() {\n\t    viewportW = parseFloat(_jquery2.default.css($container[0], \"width\", true));\n\t  }\n\t\n\t  function resizeCanvas() {\n\t    if (!initialized) {\n\t      return;\n\t    }\n\t\n\t    paneTopH = 0;\n\t    paneBottomH = 0;\n\t    viewportTopH = 0;\n\t    viewportBottomH = 0;\n\t\n\t    getViewportWidth();\n\t    getViewportHeight();\n\t\n\t    // Account for Frozen Rows\n\t    if (hasFrozenRows) {\n\t      if (options.frozenBottom) {\n\t        paneTopH = viewportH - frozenRowsHeight - scrollbarDimensions.height;\n\t\n\t        paneBottomH = frozenRowsHeight + scrollbarDimensions.height;\n\t      } else {\n\t        paneTopH = frozenRowsHeight;\n\t        paneBottomH = viewportH - frozenRowsHeight;\n\t      }\n\t    } else {\n\t      paneTopH = viewportH;\n\t    }\n\t\n\t    // The top pane includes the top panel and the header row\n\t    paneTopH += topPanelH + headerRowH + footerRowH;\n\t\n\t    if (hasFrozenColumns() && options.autoHeight) {\n\t      paneTopH += scrollbarDimensions.height;\n\t    }\n\t\n\t    // The top viewport does not contain the top panel or header row\n\t    viewportTopH = paneTopH - topPanelH - headerRowH - footerRowH;\n\t\n\t    if (options.autoHeight) {\n\t      if (hasFrozenColumns()) {\n\t        $container.height(paneTopH + parseFloat(_jquery2.default.css($headerScrollerL[0], \"height\")));\n\t      }\n\t\n\t      $paneTopL.css('position', 'relative');\n\t    }\n\t\n\t    $paneTopL.css({\n\t      'top': $paneHeaderL.height(),\n\t      'height': paneTopH\n\t    });\n\t\n\t    var paneBottomTop = $paneTopL.position().top + paneTopH;\n\t\n\t    $viewportTopL.height(viewportTopH);\n\t\n\t    if (hasFrozenColumns()) {\n\t      $paneTopR.css({\n\t        'top': $paneHeaderL.height(),\n\t        'height': paneTopH\n\t      });\n\t\n\t      $viewportTopR.height(viewportTopH);\n\t\n\t      if (hasFrozenRows) {\n\t        $paneBottomL.css({\n\t          'top': paneBottomTop,\n\t          'height': paneBottomH\n\t        });\n\t\n\t        $paneBottomR.css({\n\t          'top': paneBottomTop,\n\t          'height': paneBottomH\n\t        });\n\t\n\t        $viewportBottomR.height(paneBottomH);\n\t      }\n\t    } else {\n\t      if (hasFrozenRows) {\n\t        $paneBottomL.css({\n\t          'width': '100%',\n\t          'height': paneBottomH\n\t        });\n\t\n\t        $paneBottomL.css('top', paneBottomTop);\n\t      }\n\t    }\n\t\n\t    if (hasFrozenRows) {\n\t      $viewportBottomL.height(paneBottomH);\n\t\n\t      if (options.frozenBottom) {\n\t        $canvasBottomL.height(frozenRowsHeight);\n\t\n\t        if (hasFrozenColumns()) {\n\t          $canvasBottomR.height(frozenRowsHeight);\n\t        }\n\t      } else {\n\t        $canvasTopL.height(frozenRowsHeight);\n\t\n\t        if (hasFrozenColumns()) {\n\t          $canvasTopR.height(frozenRowsHeight);\n\t        }\n\t      }\n\t    } else {\n\t      $viewportTopR.height(viewportTopH);\n\t    }\n\t\n\t    if (options.forceFitColumns) {\n\t      autosizeColumns();\n\t    }\n\t\n\t    updateRowCount();\n\t    handleScroll();\n\t    // Since the width has changed, force the render() to reevaluate virtually rendered cells.\n\t    lastRenderedScrollLeft = -1;\n\t    render();\n\t  }\n\t\n\t  function updateRowCount() {\n\t    if (!initialized) {\n\t      return;\n\t    }\n\t\n\t    var dataLengthIncludingAddNew = getDataLengthIncludingAddNew();\n\t    var numberOfRows = 0;\n\t    var oldH = hasFrozenRows && !options.frozenBottom ? $canvasBottomL.height() : $canvasTopL.height();\n\t\n\t    if (hasFrozenRows) {\n\t      var numberOfRows = getDataLength() - options.frozenRow;\n\t    } else {\n\t      var numberOfRows = dataLengthIncludingAddNew + (options.leaveSpaceForNewRows ? numVisibleRows - 1 : 0);\n\t    }\n\t\n\t    var tempViewportH = $viewportScrollContainerY.height();\n\t    var oldViewportHasVScroll = viewportHasVScroll;\n\t    // with autoHeight, we do not need to accommodate the vertical scroll bar\n\t    viewportHasVScroll = !options.autoHeight && numberOfRows * options.rowHeight > tempViewportH;\n\t\n\t    makeActiveCellNormal();\n\t\n\t    // remove the rows that are now outside of the data range\n\t    // this helps avoid redundant calls to .removeRow() when the size of the data decreased by thousands of rows\n\t    var l = dataLengthIncludingAddNew - 1;\n\t    for (var i in rowsCache) {\n\t      if (i >= l) {\n\t        removeRowFromCache(i);\n\t      }\n\t    }\n\t\n\t    th = Math.max(options.rowHeight * numberOfRows, tempViewportH - scrollbarDimensions.height);\n\t\n\t    if (activeCellNode && activeRow > l) {\n\t      resetActiveCell();\n\t    }\n\t\n\t    if (th < maxSupportedCssHeight) {\n\t      // just one page\n\t      h = ph = th;\n\t      n = 1;\n\t      cj = 0;\n\t    } else {\n\t      // break into pages\n\t      h = maxSupportedCssHeight;\n\t      ph = h / 100;\n\t      n = Math.floor(th / ph);\n\t      cj = (th - h) / (n - 1);\n\t    }\n\t\n\t    if (h !== oldH) {\n\t      if (hasFrozenRows && !options.frozenBottom) {\n\t        $canvasBottomL.css(\"height\", h);\n\t\n\t        if (hasFrozenColumns()) {\n\t          $canvasBottomR.css(\"height\", h);\n\t        }\n\t      } else {\n\t        $canvasTopL.css(\"height\", h);\n\t        $canvasTopR.css(\"height\", h);\n\t      }\n\t\n\t      scrollTop = $viewportScrollContainerY[0].scrollTop;\n\t    }\n\t\n\t    var oldScrollTopInRange = scrollTop + offset <= th - tempViewportH;\n\t\n\t    if (th == 0 || scrollTop == 0) {\n\t      page = offset = 0;\n\t    } else if (oldScrollTopInRange) {\n\t      // maintain virtual position\n\t      scrollTo(scrollTop + offset);\n\t    } else {\n\t      // scroll to bottom\n\t      scrollTo(th - tempViewportH);\n\t    }\n\t\n\t    if (h != oldH && options.autoHeight) {\n\t      resizeCanvas();\n\t    }\n\t\n\t    if (options.forceFitColumns && oldViewportHasVScroll != viewportHasVScroll) {\n\t      autosizeColumns();\n\t    }\n\t    updateCanvasWidth(false);\n\t  }\n\t\n\t  function getVisibleRange(viewportTop, viewportLeft) {\n\t    if (viewportTop == null) {\n\t      viewportTop = scrollTop;\n\t    }\n\t    if (viewportLeft == null) {\n\t      viewportLeft = scrollLeft;\n\t    }\n\t\n\t    return {\n\t      top: getRowFromPosition(viewportTop),\n\t      bottom: getRowFromPosition(viewportTop + viewportH) + 1,\n\t      leftPx: viewportLeft,\n\t      rightPx: viewportLeft + viewportW\n\t    };\n\t  }\n\t\n\t  function getRenderedRange(viewportTop, viewportLeft) {\n\t    var range = getVisibleRange(viewportTop, viewportLeft);\n\t    var buffer = Math.round(viewportH / options.rowHeight);\n\t    var minBuffer = 3;\n\t\n\t    if (vScrollDir == -1) {\n\t      range.top -= buffer;\n\t      range.bottom += minBuffer;\n\t    } else if (vScrollDir == 1) {\n\t      range.top -= minBuffer;\n\t      range.bottom += buffer;\n\t    } else {\n\t      range.top -= minBuffer;\n\t      range.bottom += minBuffer;\n\t    }\n\t\n\t    range.top = Math.max(0, range.top);\n\t    range.bottom = Math.min(getDataLengthIncludingAddNew() - 1, range.bottom);\n\t\n\t    range.leftPx -= viewportW;\n\t    range.rightPx += viewportW;\n\t\n\t    range.leftPx = Math.max(0, range.leftPx);\n\t    range.rightPx = Math.min(canvasWidth, range.rightPx);\n\t\n\t    return range;\n\t  }\n\t\n\t  function ensureCellNodesInRowsCache(row) {\n\t    var cacheEntry = rowsCache[row];\n\t    if (cacheEntry) {\n\t      if (cacheEntry.cellRenderQueue.length) {\n\t        var $lastNode = cacheEntry.rowNode.children().last();\n\t        while (cacheEntry.cellRenderQueue.length) {\n\t          var columnIdx = cacheEntry.cellRenderQueue.pop();\n\t\n\t          cacheEntry.cellNodesByColumnIdx[columnIdx] = $lastNode;\n\t          $lastNode = $lastNode.prev();\n\t\n\t          // Hack to retrieve the frozen columns because\n\t          if ($lastNode.length == 0) {\n\t            $lastNode = (0, _jquery2.default)(cacheEntry.rowNode[0]).children().last();\n\t          }\n\t        }\n\t      }\n\t    }\n\t  }\n\t\n\t  function cleanUpCells(range, row) {\n\t    // Ignore frozen rows\n\t    if (hasFrozenRows && (options.frozenBottom && row > actualFrozenRow || // Frozen bottom rows\n\t    row <= actualFrozenRow // Frozen top rows\n\t    )) {\n\t      return;\n\t    }\n\t\n\t    var totalCellsRemoved = 0;\n\t    var cacheEntry = rowsCache[row];\n\t\n\t    // Remove cells outside the range.\n\t    var cellsToRemove = [];\n\t    for (var i in cacheEntry.cellNodesByColumnIdx) {\n\t      // I really hate it when people mess with Array.prototype.\n\t      if (!cacheEntry.cellNodesByColumnIdx.hasOwnProperty(i)) {\n\t        continue;\n\t      }\n\t\n\t      // This is a string, so it needs to be cast back to a number.\n\t      i = i | 0;\n\t\n\t      // Ignore frozen columns\n\t      if (i <= options.frozenColumn) {\n\t        continue;\n\t      }\n\t\n\t      var colspan = cacheEntry.cellColSpans[i];\n\t      if (columnPosLeft[i] > range.rightPx || columnPosRight[Math.min(columns.length - 1, i + colspan - 1)] < range.leftPx) {\n\t        if (!(row == activeRow && i == activeCell)) {\n\t          cellsToRemove.push(i);\n\t        }\n\t      }\n\t    }\n\t\n\t    var cellToRemove;\n\t    while ((cellToRemove = cellsToRemove.pop()) != null) {\n\t      cacheEntry.cellNodesByColumnIdx[cellToRemove][0].parentElement.removeChild(cacheEntry.cellNodesByColumnIdx[cellToRemove][0]);\n\t      delete cacheEntry.cellColSpans[cellToRemove];\n\t      delete cacheEntry.cellNodesByColumnIdx[cellToRemove];\n\t      if (postProcessedRows[row]) {\n\t        delete postProcessedRows[row][cellToRemove];\n\t      }\n\t      totalCellsRemoved++;\n\t    }\n\t  }\n\t\n\t  function cleanUpAndRenderCells(range) {\n\t    var cacheEntry;\n\t    var stringArray = [];\n\t    var processedRows = [];\n\t    var cellsAdded;\n\t    var totalCellsAdded = 0;\n\t    var colspan;\n\t\n\t    for (var row = range.top, btm = range.bottom; row <= btm; row++) {\n\t      cacheEntry = rowsCache[row];\n\t      if (!cacheEntry) {\n\t        continue;\n\t      }\n\t\n\t      // cellRenderQueue populated in renderRows() needs to be cleared first\n\t      ensureCellNodesInRowsCache(row);\n\t\n\t      cleanUpCells(range, row);\n\t\n\t      // Render missing cells.\n\t      cellsAdded = 0;\n\t\n\t      var metadata = data.getItemMetadata && data.getItemMetadata(row);\n\t      metadata = metadata && metadata.columns;\n\t\n\t      var d = getDataItem(row);\n\t\n\t      // TODO:  shorten this loop (index? heuristics? binary search?)\n\t      for (var i = 0, ii = columns.length; i < ii; i++) {\n\t        // Cells to the right are outside the range.\n\t        if (columnPosLeft[i] > range.rightPx) {\n\t          break;\n\t        }\n\t\n\t        // Already rendered.\n\t        if ((colspan = cacheEntry.cellColSpans[i]) != null) {\n\t          i += colspan > 1 ? colspan - 1 : 0;\n\t          continue;\n\t        }\n\t\n\t        colspan = 1;\n\t        if (metadata) {\n\t          var columnData = metadata[columns[i].id] || metadata[i];\n\t          colspan = columnData && columnData.colspan || 1;\n\t          if (colspan === \"*\") {\n\t            colspan = ii - i;\n\t          }\n\t        }\n\t\n\t        if (columnPosRight[Math.min(ii - 1, i + colspan - 1)] > range.leftPx) {\n\t          appendCellHtml(stringArray, row, i, colspan, d);\n\t          cellsAdded++;\n\t        }\n\t\n\t        i += colspan > 1 ? colspan - 1 : 0;\n\t      }\n\t\n\t      if (cellsAdded) {\n\t        totalCellsAdded += cellsAdded;\n\t        processedRows.push(row);\n\t      }\n\t    }\n\t\n\t    if (!stringArray.length) {\n\t      return;\n\t    }\n\t\n\t    var x = document.createElement(\"div\");\n\t    x.innerHTML = stringArray.join(\"\");\n\t\n\t    var processedRow;\n\t    var $node;\n\t    while ((processedRow = processedRows.pop()) != null) {\n\t      cacheEntry = rowsCache[processedRow];\n\t      var columnIdx;\n\t      while ((columnIdx = cacheEntry.cellRenderQueue.pop()) != null) {\n\t        $node = (0, _jquery2.default)(x).children().last();\n\t\n\t        if (hasFrozenColumns() && columnIdx > options.frozenColumn) {\n\t          (0, _jquery2.default)(cacheEntry.rowNode[1]).append($node);\n\t        } else {\n\t          (0, _jquery2.default)(cacheEntry.rowNode[0]).append($node);\n\t        }\n\t\n\t        cacheEntry.cellNodesByColumnIdx[columnIdx] = $node;\n\t      }\n\t    }\n\t  }\n\t\n\t  function renderRows(range) {\n\t    var stringArrayL = [],\n\t        stringArrayR = [],\n\t        rows = [],\n\t        needToReselectCell = false,\n\t        dataLength = getDataLength();\n\t\n\t    for (var i = range.top, ii = range.bottom; i <= ii; i++) {\n\t      if (rowsCache[i] || hasFrozenRows && options.frozenBottom && i == getDataLength()) {\n\t        continue;\n\t      }\n\t      renderedRows++;\n\t      rows.push(i);\n\t\n\t      // Create an entry right away so that appendRowHtml() can\n\t      // start populatating it.\n\t      rowsCache[i] = {\n\t        \"rowNode\": null,\n\t\n\t        // ColSpans of rendered cells (by column idx).\n\t        // Can also be used for checking whether a cell has been rendered.\n\t        \"cellColSpans\": [],\n\t\n\t        // Cell nodes (by column idx).  Lazy-populated by ensureCellNodesInRowsCache().\n\t        \"cellNodesByColumnIdx\": [],\n\t\n\t        // Column indices of cell nodes that have been rendered, but not yet indexed in\n\t        // cellNodesByColumnIdx.  These are in the same order as cell nodes added at the\n\t        // end of the row.\n\t        \"cellRenderQueue\": []\n\t      };\n\t\n\t      appendRowHtml(stringArrayL, stringArrayR, i, range, dataLength);\n\t      if (activeCellNode && activeRow === i) {\n\t        needToReselectCell = true;\n\t      }\n\t      counter_rows_rendered++;\n\t    }\n\t\n\t    if (!rows.length) {\n\t      return;\n\t    }\n\t\n\t    var x = document.createElement(\"div\"),\n\t        xRight = document.createElement(\"div\");\n\t\n\t    x.innerHTML = stringArrayL.join(\"\");\n\t    xRight.innerHTML = stringArrayR.join(\"\");\n\t\n\t    for (var i = 0, ii = rows.length; i < ii; i++) {\n\t      if (hasFrozenRows && rows[i] >= actualFrozenRow) {\n\t        if (hasFrozenColumns()) {\n\t          rowsCache[rows[i]].rowNode = (0, _jquery2.default)().add((0, _jquery2.default)(x.firstChild).appendTo($canvasBottomL)).add((0, _jquery2.default)(xRight.firstChild).appendTo($canvasBottomR));\n\t        } else {\n\t          rowsCache[rows[i]].rowNode = (0, _jquery2.default)().add((0, _jquery2.default)(x.firstChild).appendTo($canvasBottomL));\n\t        }\n\t      } else if (hasFrozenColumns()) {\n\t        rowsCache[rows[i]].rowNode = (0, _jquery2.default)().add((0, _jquery2.default)(x.firstChild).appendTo($canvasTopL)).add((0, _jquery2.default)(xRight.firstChild).appendTo($canvasTopR));\n\t      } else {\n\t        rowsCache[rows[i]].rowNode = (0, _jquery2.default)().add((0, _jquery2.default)(x.firstChild).appendTo($canvasTopL));\n\t      }\n\t    }\n\t\n\t    if (needToReselectCell) {\n\t      activeCellNode = getCellNode(activeRow, activeCell);\n\t    }\n\t  }\n\t\n\t  function startPostProcessing() {\n\t    if (!options.enableAsyncPostRender) {\n\t      return;\n\t    }\n\t    clearTimeout(h_postrender);\n\t    h_postrender = setTimeout(asyncPostProcessRows, options.asyncPostRenderDelay);\n\t  }\n\t\n\t  function invalidatePostProcessingResults(row) {\n\t    delete postProcessedRows[row];\n\t    postProcessFromRow = Math.min(postProcessFromRow, row);\n\t    postProcessToRow = Math.max(postProcessToRow, row);\n\t    startPostProcessing();\n\t  }\n\t\n\t  function updateRowPositions() {\n\t    for (var row in rowsCache) {\n\t      rowsCache[row].rowNode.css('top', getRowTop(row) + \"px\");\n\t    }\n\t  }\n\t\n\t  function render() {\n\t    if (!initialized) {\n\t      return;\n\t    }\n\t    var visible = getVisibleRange();\n\t    var rendered = getRenderedRange();\n\t\n\t    // remove rows no longer in the viewport\n\t    cleanupRows(rendered);\n\t\n\t    // add new rows & missing cells in existing rows\n\t    if (lastRenderedScrollLeft != scrollLeft) {\n\t\n\t      if (hasFrozenRows) {\n\t\n\t        var renderedFrozenRows = _jquery2.default.extend(true, {}, rendered);\n\t\n\t        if (options.frozenBottom) {\n\t\n\t          renderedFrozenRows.top = actualFrozenRow;\n\t          renderedFrozenRows.bottom = getDataLength();\n\t        } else {\n\t\n\t          renderedFrozenRows.top = 0;\n\t          renderedFrozenRows.bottom = options.frozenRow;\n\t        }\n\t\n\t        cleanUpAndRenderCells(renderedFrozenRows);\n\t      }\n\t\n\t      cleanUpAndRenderCells(rendered);\n\t    }\n\t\n\t    // render missing rows\n\t    renderRows(rendered);\n\t\n\t    // Render frozen rows\n\t    if (hasFrozenRows) {\n\t      if (options.frozenBottom) {\n\t        renderRows({\n\t          top: actualFrozenRow,\n\t          bottom: getDataLength() - 1,\n\t          leftPx: rendered.leftPx,\n\t          rightPx: rendered.rightPx\n\t        });\n\t      } else {\n\t        renderRows({\n\t          top: 0,\n\t          bottom: options.frozenRow - 1,\n\t          leftPx: rendered.leftPx,\n\t          rightPx: rendered.rightPx\n\t        });\n\t      }\n\t    }\n\t\n\t    postProcessFromRow = visible.top;\n\t    postProcessToRow = Math.min(getDataLengthIncludingAddNew() - 1, visible.bottom);\n\t    startPostProcessing();\n\t\n\t    lastRenderedScrollTop = scrollTop;\n\t    lastRenderedScrollLeft = scrollLeft;\n\t    h_render = null;\n\t  }\n\t\n\t  function handleHeaderRowScroll() {\n\t    var scrollLeft = $headerRowScrollContainer[0].scrollLeft;\n\t    if (scrollLeft != $viewportScrollContainerX[0].scrollLeft) {\n\t      $viewportScrollContainerX[0].scrollLeft = scrollLeft;\n\t    }\n\t  }\n\t\n\t  function handleFooterRowScroll() {\n\t    var scrollLeft = $footerRowScrollContainer[0].scrollLeft;\n\t    if (scrollLeft != $viewportScrollContainerX[0].scrollLeft) {\n\t      $viewportScrollContainerX[0].scrollLeft = scrollLeft;\n\t    }\n\t  }\n\t\n\t  function handleMouseWheel(e, delta, deltaX, deltaY) {\n\t    var $rowNode = (0, _jquery2.default)(e.target).closest(\".slick-row\");\n\t    var rowNode = $rowNode[0];\n\t\n\t    if (rowNode != rowNodeFromLastMouseWheelEvent) {\n\t\n\t      var $gridCanvas = $rowNode.parents('.grid-canvas');\n\t      var left = $gridCanvas.hasClass('grid-canvas-left');\n\t\n\t      if (zombieRowNodeFromLastMouseWheelEvent && zombieRowNodeFromLastMouseWheelEvent[left ? 0 : 1] != rowNode) {\n\t        var zombieRow = zombieRowNodeFromLastMouseWheelEvent[left || zombieRowNodeFromLastMouseWheelEvent.length == 1 ? 0 : 1];\n\t        zombieRow.parentElement.removeChild(zombieRow);\n\t\n\t        zombieRowNodeFromLastMouseWheelEvent = null;\n\t      }\n\t\n\t      rowNodeFromLastMouseWheelEvent = rowNode;\n\t    }\n\t\n\t    scrollTop = Math.max(0, $viewportScrollContainerY[0].scrollTop - deltaY * options.rowHeight);\n\t    scrollLeft = $viewportScrollContainerX[0].scrollLeft + deltaX * 10;\n\t    var handled = _handleScroll(true);\n\t    if (handled) e.preventDefault();\n\t  }\n\t\n\t  function handleScroll() {\n\t    scrollTop = $viewportScrollContainerY[0].scrollTop;\n\t    scrollLeft = $viewportScrollContainerX[0].scrollLeft;\n\t    return _handleScroll(false);\n\t  }\n\t\n\t  function _handleScroll(isMouseWheel) {\n\t    var maxScrollDistanceY = $viewportScrollContainerY[0].scrollHeight - $viewportScrollContainerY[0].clientHeight;\n\t    var maxScrollDistanceX = $viewportScrollContainerY[0].scrollWidth - $viewportScrollContainerY[0].clientWidth;\n\t    var hasFrozenCols = hasFrozenColumns();\n\t\n\t    // Ceiling the max scroll values\n\t    if (scrollTop > maxScrollDistanceY) {\n\t      scrollTop = maxScrollDistanceY;\n\t    }\n\t    if (scrollLeft > maxScrollDistanceX) {\n\t      scrollLeft = maxScrollDistanceX;\n\t    }\n\t\n\t    var vScrollDist = Math.abs(scrollTop - prevScrollTop);\n\t    var hScrollDist = Math.abs(scrollLeft - prevScrollLeft);\n\t\n\t    if (hScrollDist) {\n\t      prevScrollLeft = scrollLeft;\n\t\n\t      $viewportScrollContainerX[0].scrollLeft = scrollLeft;\n\t      $headerScrollContainer[0].scrollLeft = scrollLeft;\n\t      $topPanelScroller[0].scrollLeft = scrollLeft;\n\t      $headerRowScrollContainer[0].scrollLeft = scrollLeft;\n\t      $footerRowScrollContainer[0].scrollLeft = scrollLeft;\n\t\n\t      if (hasFrozenCols) {\n\t        if (hasFrozenRows) {\n\t          $viewportTopR[0].scrollLeft = scrollLeft;\n\t        }\n\t      } else {\n\t        if (hasFrozenRows) {\n\t          $viewportTopL[0].scrollLeft = scrollLeft;\n\t        }\n\t      }\n\t    }\n\t\n\t    if (vScrollDist) {\n\t      vScrollDir = prevScrollTop < scrollTop ? 1 : -1;\n\t      prevScrollTop = scrollTop;\n\t\n\t      if (isMouseWheel) {\n\t        $viewportScrollContainerY[0].scrollTop = scrollTop;\n\t      }\n\t\n\t      if (hasFrozenCols) {\n\t        if (hasFrozenRows && !options.frozenBottom) {\n\t          $viewportBottomL[0].scrollTop = scrollTop;\n\t        } else {\n\t          $viewportTopL[0].scrollTop = scrollTop;\n\t        }\n\t      }\n\t\n\t      // switch virtual pages if needed\n\t      if (vScrollDist < viewportH) {\n\t        scrollTo(scrollTop + offset);\n\t      } else {\n\t        var oldOffset = offset;\n\t        if (h == viewportH) {\n\t          page = 0;\n\t        } else {\n\t          page = Math.min(n - 1, Math.floor(scrollTop * ((th - viewportH) / (h - viewportH)) * (1 / ph)));\n\t        }\n\t        offset = Math.round(page * cj);\n\t        if (oldOffset != offset) {\n\t          invalidateAllRows();\n\t        }\n\t      }\n\t    }\n\t\n\t    if (hScrollDist || vScrollDist) {\n\t      if (h_render) {\n\t        clearTimeout(h_render);\n\t      }\n\t\n\t      if (Math.abs(lastRenderedScrollTop - scrollTop) > 20 || Math.abs(lastRenderedScrollLeft - scrollLeft) > 20) {\n\t        if (options.forceSyncScrolling || Math.abs(lastRenderedScrollTop - scrollTop) < viewportH && Math.abs(lastRenderedScrollLeft - scrollLeft) < viewportW) {\n\t          render();\n\t        } else {\n\t          h_render = setTimeout(render, 50);\n\t        }\n\t\n\t        trigger(self.onViewportChanged, {});\n\t      }\n\t    }\n\t\n\t    trigger(self.onScroll, {\n\t      scrollLeft: scrollLeft,\n\t      scrollTop: scrollTop\n\t    });\n\t\n\t    if (hScrollDist || vScrollDist) return true;\n\t    return false;\n\t  }\n\t\n\t  function asyncPostProcessRows() {\n\t    var dataLength = getDataLength();\n\t    while (postProcessFromRow <= postProcessToRow) {\n\t      var row = vScrollDir >= 0 ? postProcessFromRow++ : postProcessToRow--;\n\t      var cacheEntry = rowsCache[row];\n\t      if (!cacheEntry || row >= dataLength) {\n\t        continue;\n\t      }\n\t\n\t      if (!postProcessedRows[row]) {\n\t        postProcessedRows[row] = {};\n\t      }\n\t\n\t      ensureCellNodesInRowsCache(row);\n\t      for (var columnIdx in cacheEntry.cellNodesByColumnIdx) {\n\t        if (!cacheEntry.cellNodesByColumnIdx.hasOwnProperty(columnIdx)) {\n\t          continue;\n\t        }\n\t\n\t        columnIdx = columnIdx | 0;\n\t\n\t        var m = columns[columnIdx];\n\t        if (m.asyncPostRender && !postProcessedRows[row][columnIdx]) {\n\t          var node = cacheEntry.cellNodesByColumnIdx[columnIdx];\n\t          if (node) {\n\t            m.asyncPostRender(node, row, getDataItem(row), m);\n\t          }\n\t          postProcessedRows[row][columnIdx] = true;\n\t        }\n\t      }\n\t\n\t      h_postrender = setTimeout(asyncPostProcessRows, options.asyncPostRenderDelay);\n\t      return;\n\t    }\n\t  }\n\t\n\t  function updateCellCssStylesOnRenderedRows(addedHash, removedHash) {\n\t    var node, columnId, addedRowHash, removedRowHash;\n\t    for (var row in rowsCache) {\n\t      removedRowHash = removedHash && removedHash[row];\n\t      addedRowHash = addedHash && addedHash[row];\n\t\n\t      if (removedRowHash) {\n\t        for (columnId in removedRowHash) {\n\t          if (!addedRowHash || removedRowHash[columnId] != addedRowHash[columnId]) {\n\t            node = getCellNode(row, getColumnIndex(columnId));\n\t            if (node) {\n\t              (0, _jquery2.default)(node).removeClass(removedRowHash[columnId]);\n\t            }\n\t          }\n\t        }\n\t      }\n\t\n\t      if (addedRowHash) {\n\t        for (columnId in addedRowHash) {\n\t          if (!removedRowHash || removedRowHash[columnId] != addedRowHash[columnId]) {\n\t            node = getCellNode(row, getColumnIndex(columnId));\n\t            if (node) {\n\t              (0, _jquery2.default)(node).addClass(addedRowHash[columnId]);\n\t            }\n\t          }\n\t        }\n\t      }\n\t    }\n\t  }\n\t\n\t  function addCellCssStyles(key, hash) {\n\t    if (cellCssClasses[key]) {\n\t      throw \"addCellCssStyles: cell CSS hash with key '\" + key + \"' already exists.\";\n\t    }\n\t\n\t    cellCssClasses[key] = hash;\n\t    updateCellCssStylesOnRenderedRows(hash, null);\n\t\n\t    trigger(self.onCellCssStylesChanged, {\n\t      \"key\": key,\n\t      \"hash\": hash\n\t    });\n\t  }\n\t\n\t  function removeCellCssStyles(key) {\n\t    if (!cellCssClasses[key]) {\n\t      return;\n\t    }\n\t\n\t    updateCellCssStylesOnRenderedRows(null, cellCssClasses[key]);\n\t    delete cellCssClasses[key];\n\t\n\t    trigger(self.onCellCssStylesChanged, {\n\t      \"key\": key,\n\t      \"hash\": null\n\t    });\n\t  }\n\t\n\t  function setCellCssStyles(key, hash) {\n\t    var prevHash = cellCssClasses[key];\n\t\n\t    cellCssClasses[key] = hash;\n\t    updateCellCssStylesOnRenderedRows(hash, prevHash);\n\t\n\t    trigger(self.onCellCssStylesChanged, {\n\t      \"key\": key,\n\t      \"hash\": hash\n\t    });\n\t  }\n\t\n\t  function getCellCssStyles(key) {\n\t    return cellCssClasses[key];\n\t  }\n\t\n\t  function flashCell(row, cell, speed) {\n\t    speed = speed || 100;\n\t    if (rowsCache[row]) {\n\t      var toggleCellClass = function toggleCellClass(times) {\n\t        if (!times) {\n\t          return;\n\t        }\n\t        setTimeout(function () {\n\t          $cell.queue(function () {\n\t            $cell.toggleClass(options.cellFlashingCssClass).dequeue();\n\t            toggleCellClass(times - 1);\n\t          });\n\t        }, speed);\n\t      };\n\t\n\t      var $cell = (0, _jquery2.default)(getCellNode(row, cell));\n\t\n\t      toggleCellClass(4);\n\t    }\n\t  }\n\t\n\t  //////////////////////////////////////////////////////////////////////////////////////////////\n\t  // Interactivity\n\t\n\t  function handleDragInit(e, dd) {\n\t    var cell = getCellFromEvent(e);\n\t    if (!cell || !cellExists(cell.row, cell.cell)) {\n\t      return false;\n\t    }\n\t\n\t    var retval = trigger(self.onDragInit, dd, e);\n\t    if (e.isImmediatePropagationStopped()) {\n\t      return retval;\n\t    }\n\t\n\t    // if nobody claims to be handling drag'n'drop by stopping immediate propagation,\n\t    // cancel out of it\n\t    return false;\n\t  }\n\t\n\t  function handleDragStart(interactEvent) {\n\t    var event = _jquery2.default.Event(interactEvent.originalEvent.type, interactEvent.originalEvent);\n\t    var cell = getCellFromEvent(event);\n\t    if (!cell || !cellExists(cell.row, cell.cell)) {\n\t      return false;\n\t    }\n\t\n\t    var retval = trigger(self.onDragStart, interactEvent, event);\n\t    if (event.isImmediatePropagationStopped()) {\n\t      return retval;\n\t    }\n\t\n\t    return false;\n\t  }\n\t\n\t  function handleDrag(interactEvent) {\n\t    var event = _jquery2.default.Event(interactEvent.originalEvent.type, interactEvent.originalEvent);\n\t    return trigger(self.onDrag, interactEvent, event);\n\t  }\n\t\n\t  function handleDragEnd(interactEvent) {\n\t    trigger(self.onDragEnd, interactEvent, _jquery2.default.Event('mousedown'));\n\t  }\n\t\n\t  function handleKeyDown(e) {\n\t    trigger(self.onKeyDown, {\n\t      row: activeRow,\n\t      cell: activeCell\n\t    }, e);\n\t    var handled = e.isImmediatePropagationStopped();\n\t\n\t    if (!handled) {\n\t      if (!e.shiftKey && !e.altKey && !e.ctrlKey) {\n\t        if (e.which == 27) {\n\t          if (!getEditorLock().isActive()) {\n\t            return; // no editing mode to cancel, allow bubbling and default processing (exit without cancelling the event)\n\t          }\n\t          cancelEditAndSetFocus();\n\t        } else if (e.which == 34) {\n\t          navigatePageDown();\n\t          handled = true;\n\t        } else if (e.which == 33) {\n\t          navigatePageUp();\n\t          handled = true;\n\t        } else if (e.which == 37) {\n\t          handled = navigateLeft();\n\t        } else if (e.which == 39) {\n\t          handled = navigateRight();\n\t        } else if (e.which == 38) {\n\t          handled = navigateUp();\n\t        } else if (e.which == 40) {\n\t          handled = navigateDown();\n\t        } else if (e.which == 9) {\n\t          handled = navigateNext();\n\t        } else if (e.which == 13) {\n\t          if (options.editable) {\n\t            if (currentEditor) {\n\t              // adding new row\n\t              if (activeRow === getDataLength()) {\n\t                navigateDown();\n\t              } else {\n\t                commitEditAndSetFocus();\n\t              }\n\t            } else {\n\t              if (getEditorLock().commitCurrentEdit()) {\n\t                makeActiveCellEditable();\n\t              }\n\t            }\n\t          }\n\t          handled = true;\n\t        }\n\t      } else if (e.which == 9 && e.shiftKey && !e.ctrlKey && !e.altKey) {\n\t        handled = navigatePrev();\n\t      }\n\t    }\n\t\n\t    if (handled) {\n\t      // the event has been handled so don't let parent element (bubbling/propagation) or browser (default) handle it\n\t      e.stopPropagation();\n\t      e.preventDefault();\n\t      try {\n\t        e.originalEvent.keyCode = 0; // prevent default behaviour for special keys in IE browsers (F3, F5, etc.)\n\t      }\n\t      // ignore exceptions - setting the original event's keycode throws access denied exception for \"Ctrl\"\n\t      // (hitting control key only, nothing else), \"Shift\" (maybe others)\n\t      catch (error) {}\n\t    }\n\t  }\n\t\n\t  function handleClick(e) {\n\t    if (!currentEditor) {\n\t      // if this click resulted in some cell child node getting focus,\n\t      // don't steal it back - keyboard events will still bubble up\n\t      // IE9+ seems to default DIVs to tabIndex=0 instead of -1, so check for cell clicks directly.\n\t      if (e.target != document.activeElement || (0, _jquery2.default)(e.target).hasClass(\"slick-cell\")) {\n\t        setFocus();\n\t      }\n\t    }\n\t\n\t    var cell = getCellFromEvent(e);\n\t    if (!cell || currentEditor !== null && activeRow == cell.row && activeCell == cell.cell) {\n\t      return;\n\t    }\n\t\n\t    trigger(self.onClick, {\n\t      row: cell.row,\n\t      cell: cell.cell\n\t    }, e);\n\t    if (e.isImmediatePropagationStopped()) {\n\t      return;\n\t    }\n\t\n\t    if ((activeCell != cell.cell || activeRow != cell.row) && canCellBeActive(cell.row, cell.cell)) {\n\t      if (!getEditorLock().isActive() || getEditorLock().commitCurrentEdit()) {\n\t\n\t        scrollRowIntoView(cell.row, false);\n\t        setActiveCellInternal(getCellNode(cell.row, cell.cell));\n\t      }\n\t    }\n\t  }\n\t\n\t  function handleContextMenu(e) {\n\t    var $cell = (0, _jquery2.default)(e.target).closest(\".slick-cell\", $canvas);\n\t    if ($cell.length === 0) {\n\t      return;\n\t    }\n\t\n\t    // are we editing this cell?\n\t    if (activeCellNode === $cell[0] && currentEditor !== null) {\n\t      return;\n\t    }\n\t\n\t    trigger(self.onContextMenu, {}, e);\n\t  }\n\t\n\t  function handleDblClick(e) {\n\t    var cell = getCellFromEvent(e);\n\t    if (!cell || currentEditor !== null && activeRow == cell.row && activeCell == cell.cell) {\n\t      return;\n\t    }\n\t\n\t    trigger(self.onDblClick, {\n\t      row: cell.row,\n\t      cell: cell.cell\n\t    }, e);\n\t    if (e.isImmediatePropagationStopped()) {\n\t      return;\n\t    }\n\t\n\t    if (options.editable) {\n\t      gotoCell(cell.row, cell.cell, true);\n\t    }\n\t  }\n\t\n\t  function handleHeaderMouseEnter(e) {\n\t    trigger(self.onHeaderMouseEnter, {\n\t      \"column\": (0, _jquery2.default)(this).data(\"column\")\n\t    }, e);\n\t  }\n\t\n\t  function handleHeaderMouseLeave(e) {\n\t    trigger(self.onHeaderMouseLeave, {\n\t      \"column\": (0, _jquery2.default)(this).data(\"column\")\n\t    }, e);\n\t  }\n\t\n\t  function handleHeaderContextMenu(e) {\n\t    var $header = (0, _jquery2.default)(e.target).closest(\".slick-header-column\", \".slick-header-columns\");\n\t    var column = $header && $header.data(\"column\");\n\t    trigger(self.onHeaderContextMenu, {\n\t      column: column\n\t    }, e);\n\t  }\n\t\n\t  function handleHeaderClick(e) {\n\t    var $header = (0, _jquery2.default)(e.target).closest(\".slick-header-column\", \".slick-header-columns\");\n\t    var column = $header && $header.data(\"column\");\n\t    if (column) {\n\t      trigger(self.onHeaderClick, {\n\t        column: column\n\t      }, e);\n\t    }\n\t  }\n\t\n\t  function handleMouseEnter(e) {\n\t    trigger(self.onMouseEnter, {}, e);\n\t  }\n\t\n\t  function handleMouseLeave(e) {\n\t    trigger(self.onMouseLeave, {}, e);\n\t  }\n\t\n\t  function cellExists(row, cell) {\n\t    return !(row < 0 || row >= getDataLength() || cell < 0 || cell >= columns.length);\n\t  }\n\t\n\t  function getCellFromPoint(x, y) {\n\t    var row = getRowFromPosition(y);\n\t    var cell = 0;\n\t\n\t    var w = 0;\n\t    for (var i = 0; i < columns.length && w < x; i++) {\n\t      w += columns[i].width;\n\t      cell++;\n\t    }\n\t\n\t    if (cell < 0) {\n\t      cell = 0;\n\t    }\n\t\n\t    return {\n\t      row: row,\n\t      cell: cell - 1\n\t    };\n\t  }\n\t\n\t  function getCellFromNode(cellNode) {\n\t    // read column number from .l<columnNumber> CSS class\n\t    var cls = /l\\d+/.exec(cellNode.className);\n\t    if (!cls) {\n\t      throw \"getCellFromNode: cannot get cell - \" + cellNode.className;\n\t    }\n\t    return parseInt(cls[0].substr(1, cls[0].length - 1), 10);\n\t  }\n\t\n\t  function getRowFromNode(rowNode) {\n\t    for (var row in rowsCache) {\n\t      for (var i in rowsCache[row].rowNode) {\n\t        if (rowsCache[row].rowNode[i] === rowNode) return row | 0;\n\t      }\n\t    }return null;\n\t  }\n\t\n\t  function getFrozenRowOffset(row) {\n\t    var offset = hasFrozenRows ? options.frozenBottom ? row >= actualFrozenRow ? h < viewportTopH ? actualFrozenRow * options.rowHeight : h : 0 : row >= actualFrozenRow ? frozenRowsHeight : 0 : 0;\n\t\n\t    return offset;\n\t  }\n\t\n\t  function getCellFromEvent(e) {\n\t    var row, cell;\n\t    var $cell = (0, _jquery2.default)(e.target).closest(\".slick-cell\", $canvas);\n\t    if (!$cell.length) {\n\t      return null;\n\t    }\n\t\n\t    row = getRowFromNode($cell[0].parentNode);\n\t\n\t    if (hasFrozenRows) {\n\t\n\t      var c = $cell.parents('.grid-canvas').offset();\n\t\n\t      var rowOffset = 0;\n\t      var isBottom = $cell.parents('.grid-canvas-bottom').length;\n\t\n\t      if (isBottom) {\n\t        rowOffset = options.frozenBottom ? $canvasTopL.height() : frozenRowsHeight;\n\t      }\n\t\n\t      row = getCellFromPoint(e.clientX - c.left, e.clientY - c.top + rowOffset + (0, _jquery2.default)(document).scrollTop()).row;\n\t    }\n\t\n\t    cell = getCellFromNode($cell[0]);\n\t\n\t    if (row == null || cell == null) {\n\t      return null;\n\t    } else {\n\t      return {\n\t        \"row\": row,\n\t        \"cell\": cell\n\t      };\n\t    }\n\t  }\n\t\n\t  function getCellNodeBox(row, cell) {\n\t    if (!cellExists(row, cell)) {\n\t      return null;\n\t    }\n\t\n\t    var frozenRowOffset = getFrozenRowOffset(row);\n\t\n\t    var y1 = getRowTop(row) - frozenRowOffset;\n\t    var y2 = y1 + options.rowHeight - 1;\n\t    var x1 = 0;\n\t    for (var i = 0; i < cell; i++) {\n\t      x1 += columns[i].width;\n\t\n\t      if (options.frozenColumn == i) {\n\t        x1 = 0;\n\t      }\n\t    }\n\t    var x2 = x1 + columns[cell].width;\n\t\n\t    return {\n\t      top: y1,\n\t      left: x1,\n\t      bottom: y2,\n\t      right: x2\n\t    };\n\t  }\n\t\n\t  //////////////////////////////////////////////////////////////////////////////////////////////\n\t  // Cell switching\n\t\n\t  function resetActiveCell() {\n\t    setActiveCellInternal(null, false);\n\t  }\n\t\n\t  function setFocus() {\n\t    if (tabbingDirection == -1) {\n\t      $focusSink[0].focus();\n\t    } else {\n\t      $focusSink2[0].focus();\n\t    }\n\t  }\n\t\n\t  function scrollCellIntoView(row, cell, doPaging) {\n\t    // Don't scroll to frozen cells\n\t    if (cell < options.frozenColumn) {\n\t      return;\n\t    }\n\t\n\t    if (options.frozenRow > 0 && row < actualFrozenRow) {\n\t      scrollRowIntoView(row, doPaging);\n\t    } else {\n\t      // always scroll like normal slickgrid.\n\t      scrollRowIntoView(row, doPaging);\n\t    }\n\t\n\t    var colspan = getColspan(row, cell);\n\t    var left = columnPosLeft[cell],\n\t        right = columnPosRight[cell + (colspan > 1 ? colspan - 1 : 0)],\n\t        scrollRight = scrollLeft + $viewportScrollContainerX.width();\n\t\n\t    if (left < scrollLeft) {\n\t      $viewportScrollContainerX.scrollLeft(left);\n\t      handleScroll();\n\t      render();\n\t    } else if (right > scrollRight) {\n\t      $viewportScrollContainerX.scrollLeft(Math.min(left, right - $viewportScrollContainerX[0].clientWidth));\n\t      handleScroll();\n\t      render();\n\t    }\n\t  }\n\t\n\t  function setActiveCellInternal(newCell, opt_editMode) {\n\t    if (activeCellNode !== null) {\n\t      makeActiveCellNormal();\n\t      (0, _jquery2.default)(activeCellNode).removeClass(\"active\");\n\t      if (rowsCache[activeRow]) {\n\t        (0, _jquery2.default)(rowsCache[activeRow].rowNode).removeClass(\"active\");\n\t      }\n\t    }\n\t\n\t    var activeCellChanged = activeCellNode !== newCell;\n\t    activeCellNode = newCell;\n\t\n\t    if (activeCellNode != null) {\n\t      var $activeCellNode = (0, _jquery2.default)(activeCellNode);\n\t      var $activeCellOffset = $activeCellNode.offset();\n\t\n\t      var rowOffset = Math.floor($activeCellNode.parents('.grid-canvas').offset().top);\n\t      var isBottom = $activeCellNode.parents('.grid-canvas-bottom').length;\n\t\n\t      if (hasFrozenRows && isBottom) {\n\t        rowOffset -= options.frozenBottom ? $canvasTopL.height() : frozenRowsHeight;\n\t      }\n\t\n\t      var cell = getCellFromPoint($activeCellOffset.left, Math.ceil($activeCellOffset.top) - rowOffset);\n\t\n\t      activeRow = cell.row;\n\t      activeCell = activePosX = activeCell = activePosX = getCellFromNode(activeCellNode[0]);\n\t\n\t      $activeCellNode.addClass(\"active\");\n\t      if (rowsCache[activeRow]) {\n\t        (0, _jquery2.default)(rowsCache[activeRow].rowNode).addClass('active');\n\t      }\n\t\n\t      if (opt_editMode == null) {\n\t        opt_editMode = activeRow == getDataLength() || options.autoEdit;\n\t      }\n\t\n\t      if (options.editable && opt_editMode && isCellPotentiallyEditable(activeRow, activeCell)) {\n\t        clearTimeout(h_editorLoader);\n\t\n\t        if (options.asyncEditorLoading) {\n\t          h_editorLoader = setTimeout(function () {\n\t            makeActiveCellEditable();\n\t          }, options.asyncEditorLoadDelay);\n\t        } else {\n\t          makeActiveCellEditable();\n\t        }\n\t      }\n\t    } else {\n\t      activeRow = activeCell = null;\n\t    }\n\t\n\t    if (activeCellChanged) {\n\t      setTimeout(scrollActiveCellIntoView, 50);\n\t      trigger(self.onActiveCellChanged, getActiveCell());\n\t    }\n\t  }\n\t\n\t  function clearTextSelection() {\n\t    if (document.selection && document.selection.empty) {\n\t      try {\n\t        //IE fails here if selected element is not in dom\n\t        document.selection.empty();\n\t      } catch (e) {}\n\t    } else if (window.getSelection) {\n\t      var sel = window.getSelection();\n\t      if (sel && sel.removeAllRanges) {\n\t        sel.removeAllRanges();\n\t      }\n\t    }\n\t  }\n\t\n\t  function isCellPotentiallyEditable(row, cell) {\n\t    var dataLength = getDataLength();\n\t    // is the data for this row loaded?\n\t    if (row < dataLength && !getDataItem(row)) {\n\t      return false;\n\t    }\n\t\n\t    // are we in the Add New row?  can we create new from this cell?\n\t    if (columns[cell].cannotTriggerInsert && row >= dataLength) {\n\t      return false;\n\t    }\n\t\n\t    // does this cell have an editor?\n\t    if (!getEditor(row, cell)) {\n\t      return false;\n\t    }\n\t\n\t    return true;\n\t  }\n\t\n\t  function makeActiveCellNormal() {\n\t    if (!currentEditor) {\n\t      return;\n\t    }\n\t    trigger(self.onBeforeCellEditorDestroy, {\n\t      editor: currentEditor\n\t    });\n\t    currentEditor.destroy();\n\t    currentEditor = null;\n\t\n\t    if (activeCellNode) {\n\t      var d = getDataItem(activeRow);\n\t      (0, _jquery2.default)(activeCellNode).removeClass(\"editable invalid\");\n\t      if (d) {\n\t        var column = columns[activeCell];\n\t        activeCellNode[0].innerHTML = callFormatter(activeRow, activeCell, getDataItemValueForColumn(d, column), column, d);\n\t        invalidatePostProcessingResults(activeRow);\n\t      }\n\t    }\n\t\n\t    // if there previously was text selected on a page (such as selected text in the edit cell just removed),\n\t    // IE can't set focus to anything else correctly\n\t    if (navigator.userAgent.toLowerCase().match(/msie/)) {\n\t      clearTextSelection();\n\t    }\n\t\n\t    getEditorLock().deactivate(editController);\n\t  }\n\t\n\t  function makeActiveCellEditable(editor) {\n\t    if (!activeCellNode) {\n\t      return;\n\t    }\n\t    if (!options.editable) {\n\t      throw \"Grid : makeActiveCellEditable : should never get called when options.editable is false\";\n\t    }\n\t\n\t    // cancel pending async call if there is one\n\t    clearTimeout(h_editorLoader);\n\t\n\t    if (!isCellPotentiallyEditable(activeRow, activeCell)) {\n\t      return;\n\t    }\n\t\n\t    var columnDef = columns[activeCell];\n\t    var item = getDataItem(activeRow);\n\t\n\t    if (trigger(self.onBeforeEditCell, {\n\t      row: activeRow,\n\t      cell: activeCell,\n\t      item: item,\n\t      column: columnDef\n\t    }) === false) {\n\t      setFocus();\n\t      return;\n\t    }\n\t\n\t    getEditorLock().activate(editController);\n\t    (0, _jquery2.default)(activeCellNode).addClass(\"editable\");\n\t\n\t    // don't clear the cell if a custom editor is passed through\n\t    if (!editor) {\n\t      activeCellNode[0].innerHTML = \"\";\n\t    }\n\t\n\t    currentEditor = new (editor || getEditor(activeRow, activeCell))({\n\t      grid: self,\n\t      gridPosition: absBox($container[0]),\n\t      position: absBox(activeCellNode[0]),\n\t      container: activeCellNode,\n\t      column: columnDef,\n\t      item: item || {},\n\t      commitChanges: commitEditAndSetFocus,\n\t      cancelChanges: cancelEditAndSetFocus\n\t    });\n\t\n\t    if (item) {\n\t      currentEditor.loadValue(item);\n\t    }\n\t\n\t    serializedEditorValue = currentEditor.serializeValue();\n\t\n\t    if (currentEditor.position) {\n\t      handleActiveCellPositionChange();\n\t    }\n\t  }\n\t\n\t  function commitEditAndSetFocus() {\n\t    // if the commit fails, it would do so due to a validation error\n\t    // if so, do not steal the focus from the editor\n\t    if (getEditorLock().commitCurrentEdit()) {\n\t      setFocus();\n\t      if (options.autoEdit) {\n\t        navigateDown();\n\t      }\n\t    }\n\t  }\n\t\n\t  function cancelEditAndSetFocus() {\n\t    if (getEditorLock().cancelCurrentEdit()) {\n\t      setFocus();\n\t    }\n\t  }\n\t\n\t  function absBox(elem) {\n\t    var box = {\n\t      top: elem.offsetTop,\n\t      left: elem.offsetLeft,\n\t      bottom: 0,\n\t      right: 0,\n\t      width: (0, _jquery2.default)(elem).outerWidth(),\n\t      height: (0, _jquery2.default)(elem).outerHeight(),\n\t      visible: true\n\t    };\n\t    box.bottom = box.top + box.height;\n\t    box.right = box.left + box.width;\n\t\n\t    // walk up the tree\n\t    var offsetParent = elem.offsetParent;\n\t    while ((elem = elem.parentNode) != document.body) {\n\t      if (box.visible && elem.scrollHeight != elem.offsetHeight && (0, _jquery2.default)(elem).css(\"overflowY\") != \"visible\") {\n\t        box.visible = box.bottom > elem.scrollTop && box.top < elem.scrollTop + elem.clientHeight;\n\t      }\n\t\n\t      if (box.visible && elem.scrollWidth != elem.offsetWidth && (0, _jquery2.default)(elem).css(\"overflowX\") != \"visible\") {\n\t        box.visible = box.right > elem.scrollLeft && box.left < elem.scrollLeft + elem.clientWidth;\n\t      }\n\t\n\t      box.left -= elem.scrollLeft;\n\t      box.top -= elem.scrollTop;\n\t\n\t      if (elem === offsetParent) {\n\t        box.left += elem.offsetLeft;\n\t        box.top += elem.offsetTop;\n\t        offsetParent = elem.offsetParent;\n\t      }\n\t\n\t      box.bottom = box.top + box.height;\n\t      box.right = box.left + box.width;\n\t    }\n\t\n\t    return box;\n\t  }\n\t\n\t  function getActiveCellPosition() {\n\t    return absBox(activeCellNode[0]);\n\t  }\n\t\n\t  function getGridPosition() {\n\t    return absBox($container[0]);\n\t  }\n\t\n\t  function handleActiveCellPositionChange() {\n\t    if (!activeCellNode) {\n\t      return;\n\t    }\n\t\n\t    trigger(self.onActiveCellPositionChanged, {});\n\t\n\t    if (currentEditor) {\n\t      var cellBox = getActiveCellPosition();\n\t      if (currentEditor.show && currentEditor.hide) {\n\t        if (!cellBox.visible) {\n\t          currentEditor.hide();\n\t        } else {\n\t          currentEditor.show();\n\t        }\n\t      }\n\t\n\t      if (currentEditor.position) {\n\t        currentEditor.position(cellBox);\n\t      }\n\t    }\n\t  }\n\t\n\t  function getCellEditor() {\n\t    return currentEditor;\n\t  }\n\t\n\t  function getActiveCell() {\n\t    if (!activeCellNode) {\n\t      return null;\n\t    } else {\n\t      return {\n\t        row: activeRow,\n\t        cell: activeCell\n\t      };\n\t    }\n\t  }\n\t\n\t  function getActiveCellNode() {\n\t    return activeCellNode;\n\t  }\n\t\n\t  function scrollActiveCellIntoView() {\n\t    if (activeRow != null && activeCell != null) {\n\t      scrollCellIntoView(activeRow, activeCell);\n\t    }\n\t  }\n\t\n\t  function scrollRowIntoView(row, doPaging) {\n\t\n\t    if (!hasFrozenRows || !options.frozenBottom && row > actualFrozenRow - 1 || options.frozenBottom && row < actualFrozenRow - 1) {\n\t\n\t      var viewportScrollH = $viewportScrollContainerY.height();\n\t\n\t      var rowAtTop = row * options.rowHeight;\n\t      var rowAtBottom = (row + 1) * options.rowHeight - viewportScrollH + (viewportHasHScroll ? scrollbarDimensions.height : 0);\n\t\n\t      // need to page down?\n\t      if ((row + 1) * options.rowHeight > scrollTop + viewportScrollH + offset) {\n\t        scrollTo(doPaging ? rowAtTop : rowAtBottom);\n\t        render();\n\t      }\n\t      // or page up?\n\t      else if (row * options.rowHeight < scrollTop + offset) {\n\t          scrollTo(doPaging ? rowAtBottom : rowAtTop);\n\t          render();\n\t        }\n\t    }\n\t  }\n\t\n\t  function scrollRowToTop(row) {\n\t    scrollTo(row * options.rowHeight);\n\t    render();\n\t  }\n\t\n\t  function scrollPage(dir) {\n\t    var deltaRows = dir * numVisibleRows;\n\t    scrollTo((getRowFromPosition(scrollTop) + deltaRows) * options.rowHeight);\n\t    render();\n\t\n\t    if (options.enableCellNavigation && activeRow != null) {\n\t      var row = activeRow + deltaRows;\n\t      var dataLengthIncludingAddNew = getDataLengthIncludingAddNew();\n\t      if (row >= dataLengthIncludingAddNew) {\n\t        row = dataLengthIncludingAddNew - 1;\n\t      }\n\t      if (row < 0) {\n\t        row = 0;\n\t      }\n\t\n\t      var cell = 0,\n\t          prevCell = null;\n\t      var prevActivePosX = activePosX;\n\t      while (cell <= activePosX) {\n\t        if (canCellBeActive(row, cell)) {\n\t          prevCell = cell;\n\t        }\n\t        cell += getColspan(row, cell);\n\t      }\n\t\n\t      if (prevCell !== null) {\n\t        setActiveCellInternal(getCellNode(row, prevCell));\n\t        activePosX = prevActivePosX;\n\t      } else {\n\t        resetActiveCell();\n\t      }\n\t    }\n\t  }\n\t\n\t  function navigatePageDown() {\n\t    scrollPage(1);\n\t  }\n\t\n\t  function navigatePageUp() {\n\t    scrollPage(-1);\n\t  }\n\t\n\t  function getColspan(row, cell) {\n\t    var metadata = data.getItemMetadata && data.getItemMetadata(row);\n\t    if (!metadata || !metadata.columns) {\n\t      return 1;\n\t    }\n\t\n\t    var columnData = columns[cell] && (metadata.columns[columns[cell].id] || metadata.columns[cell]);\n\t    var colspan = columnData && columnData.colspan;\n\t    if (colspan === \"*\") {\n\t      colspan = columns.length - cell;\n\t    } else {\n\t      colspan = colspan || 1;\n\t    }\n\t\n\t    return colspan;\n\t  }\n\t\n\t  function findFirstFocusableCell(row) {\n\t    var cell = 0;\n\t    while (cell < columns.length) {\n\t      if (canCellBeActive(row, cell)) {\n\t        return cell;\n\t      }\n\t      cell += getColspan(row, cell);\n\t    }\n\t    return null;\n\t  }\n\t\n\t  function findLastFocusableCell(row) {\n\t    var cell = 0;\n\t    var lastFocusableCell = null;\n\t    while (cell < columns.length) {\n\t      if (canCellBeActive(row, cell)) {\n\t        lastFocusableCell = cell;\n\t      }\n\t      cell += getColspan(row, cell);\n\t    }\n\t    return lastFocusableCell;\n\t  }\n\t\n\t  function gotoRight(row, cell, posX) {\n\t    if (cell >= columns.length) {\n\t      return null;\n\t    }\n\t\n\t    do {\n\t      cell += getColspan(row, cell);\n\t    } while (cell < columns.length && !canCellBeActive(row, cell));\n\t\n\t    if (cell < columns.length) {\n\t      return {\n\t        \"row\": row,\n\t        \"cell\": cell,\n\t        \"posX\": cell\n\t      };\n\t    }\n\t    return null;\n\t  }\n\t\n\t  function gotoLeft(row, cell, posX) {\n\t    if (cell <= 0) {\n\t      return null;\n\t    }\n\t\n\t    var firstFocusableCell = findFirstFocusableCell(row);\n\t    if (firstFocusableCell === null || firstFocusableCell >= cell) {\n\t      return null;\n\t    }\n\t\n\t    var prev = {\n\t      \"row\": row,\n\t      \"cell\": firstFocusableCell,\n\t      \"posX\": firstFocusableCell\n\t    };\n\t    var pos;\n\t    while (true) {\n\t      pos = gotoRight(prev.row, prev.cell, prev.posX);\n\t      if (!pos) {\n\t        return null;\n\t      }\n\t      if (pos.cell >= cell) {\n\t        return prev;\n\t      }\n\t      prev = pos;\n\t    }\n\t  }\n\t\n\t  function gotoDown(row, cell, posX) {\n\t    var prevCell;\n\t    var dataLengthIncludingAddNew = getDataLengthIncludingAddNew();\n\t    while (true) {\n\t      if (++row >= dataLengthIncludingAddNew) {\n\t        return null;\n\t      }\n\t\n\t      prevCell = cell = 0;\n\t      while (cell <= posX) {\n\t        prevCell = cell;\n\t        cell += getColspan(row, cell);\n\t      }\n\t\n\t      if (canCellBeActive(row, prevCell)) {\n\t        return {\n\t          \"row\": row,\n\t          \"cell\": prevCell,\n\t          \"posX\": posX\n\t        };\n\t      }\n\t    }\n\t  }\n\t\n\t  function gotoUp(row, cell, posX) {\n\t    var prevCell;\n\t    while (true) {\n\t      if (--row < 0) {\n\t        return null;\n\t      }\n\t\n\t      prevCell = cell = 0;\n\t      while (cell <= posX) {\n\t        prevCell = cell;\n\t        cell += getColspan(row, cell);\n\t      }\n\t\n\t      if (canCellBeActive(row, prevCell)) {\n\t        return {\n\t          \"row\": row,\n\t          \"cell\": prevCell,\n\t          \"posX\": posX\n\t        };\n\t      }\n\t    }\n\t  }\n\t\n\t  function gotoNext(row, cell, posX) {\n\t    if (row == null && cell == null) {\n\t      row = cell = posX = 0;\n\t      if (canCellBeActive(row, cell)) {\n\t        return {\n\t          \"row\": row,\n\t          \"cell\": cell,\n\t          \"posX\": cell\n\t        };\n\t      }\n\t    }\n\t\n\t    var pos = gotoRight(row, cell, posX);\n\t    if (pos) {\n\t      return pos;\n\t    }\n\t\n\t    var firstFocusableCell = null;\n\t    var dataLengthIncludingAddNew = getDataLengthIncludingAddNew();\n\t    while (++row < dataLengthIncludingAddNew) {\n\t      firstFocusableCell = findFirstFocusableCell(row);\n\t      if (firstFocusableCell !== null) {\n\t        return {\n\t          \"row\": row,\n\t          \"cell\": firstFocusableCell,\n\t          \"posX\": firstFocusableCell\n\t        };\n\t      }\n\t    }\n\t    return null;\n\t  }\n\t\n\t  function gotoPrev(row, cell, posX) {\n\t    if (row == null && cell == null) {\n\t      row = getDataLengthIncludingAddNew() - 1;\n\t      cell = posX = columns.length - 1;\n\t      if (canCellBeActive(row, cell)) {\n\t        return {\n\t          \"row\": row,\n\t          \"cell\": cell,\n\t          \"posX\": cell\n\t        };\n\t      }\n\t    }\n\t\n\t    var pos;\n\t    var lastSelectableCell;\n\t    while (!pos) {\n\t      pos = gotoLeft(row, cell, posX);\n\t      if (pos) {\n\t        break;\n\t      }\n\t      if (--row < 0) {\n\t        return null;\n\t      }\n\t\n\t      cell = 0;\n\t      lastSelectableCell = findLastFocusableCell(row);\n\t      if (lastSelectableCell !== null) {\n\t        pos = {\n\t          \"row\": row,\n\t          \"cell\": lastSelectableCell,\n\t          \"posX\": lastSelectableCell\n\t        };\n\t      }\n\t    }\n\t    return pos;\n\t  }\n\t\n\t  function navigateRight() {\n\t    return navigate(\"right\");\n\t  }\n\t\n\t  function navigateLeft() {\n\t    return navigate(\"left\");\n\t  }\n\t\n\t  function navigateDown() {\n\t    console.log('down');\n\t    return navigate(\"down\");\n\t  }\n\t\n\t  function navigateUp() {\n\t    return navigate(\"up\");\n\t  }\n\t\n\t  function navigateNext() {\n\t    return navigate(\"next\");\n\t  }\n\t\n\t  function navigatePrev() {\n\t    return navigate(\"prev\");\n\t  }\n\t\n\t  /**\n\t   * @param {string} dir Navigation direction.\n\t   * @return {boolean} Whether navigation resulted in a change of active cell.\n\t   */\n\t  function navigate(dir) {\n\t    if (!options.enableCellNavigation) {\n\t      return false;\n\t    }\n\t\n\t    if (!activeCellNode && dir != \"prev\" && dir != \"next\") {\n\t      return false;\n\t    }\n\t\n\t    if (!getEditorLock().commitCurrentEdit()) {\n\t      return true;\n\t    }\n\t    setFocus();\n\t\n\t    var tabbingDirections = {\n\t      \"up\": -1,\n\t      \"down\": 1,\n\t      \"left\": -1,\n\t      \"right\": 1,\n\t      \"prev\": -1,\n\t      \"next\": 1\n\t    };\n\t    tabbingDirection = tabbingDirections[dir];\n\t\n\t    var stepFunctions = {\n\t      \"up\": gotoUp,\n\t      \"down\": gotoDown,\n\t      \"left\": gotoLeft,\n\t      \"right\": gotoRight,\n\t      \"prev\": gotoPrev,\n\t      \"next\": gotoNext\n\t    };\n\t    var stepFn = stepFunctions[dir];\n\t    var pos = stepFn(activeRow, activeCell, activePosX);\n\t    if (pos) {\n\t      if (hasFrozenRows && options.frozenBottom & pos.row == getDataLength()) {\n\t        return;\n\t      }\n\t\n\t      var isAddNewRow = pos.row == getDataLength();\n\t\n\t      if (!options.frozenBottom && pos.row >= actualFrozenRow || options.frozenBottom && pos.row < actualFrozenRow) {\n\t        scrollCellIntoView(pos.row, pos.cell, !isAddNewRow);\n\t      }\n\t\n\t      setActiveCellInternal(getCellNode(pos.row, pos.cell));\n\t      activePosX = pos.posX;\n\t      return true;\n\t    } else {\n\t      setActiveCellInternal(getCellNode(activeRow, activeCell));\n\t      return false;\n\t    }\n\t  }\n\t\n\t  function getCellNode(row, cell) {\n\t    if (rowsCache[row]) {\n\t      ensureCellNodesInRowsCache(row);\n\t      return rowsCache[row].cellNodesByColumnIdx[cell];\n\t    }\n\t    return null;\n\t  }\n\t\n\t  function setActiveCell(row, cell) {\n\t    if (!initialized) {\n\t      return;\n\t    }\n\t    if (row > getDataLength() || row < 0 || cell >= columns.length || cell < 0) {\n\t      return;\n\t    }\n\t\n\t    if (!options.enableCellNavigation) {\n\t      return;\n\t    }\n\t\n\t    scrollCellIntoView(row, cell, false);\n\t    setActiveCellInternal(getCellNode(row, cell), false);\n\t  }\n\t\n\t  function canCellBeActive(row, cell) {\n\t    if (!options.enableCellNavigation || row >= getDataLengthIncludingAddNew() || row < 0 || cell >= columns.length || cell < 0) {\n\t      return false;\n\t    }\n\t\n\t    var rowMetadata = data.getItemMetadata && data.getItemMetadata(row);\n\t    if (rowMetadata && typeof rowMetadata.focusable === \"boolean\") {\n\t      return rowMetadata.focusable;\n\t    }\n\t\n\t    var columnMetadata = rowMetadata && rowMetadata.columns;\n\t    if (columnMetadata && columns[cell] && columnMetadata[columns[cell].id] && typeof columnMetadata[columns[cell].id].focusable === \"boolean\") {\n\t      return columnMetadata[columns[cell].id].focusable;\n\t    }\n\t    if (columnMetadata && columnMetadata[cell] && typeof columnMetadata[cell].focusable === \"boolean\") {\n\t      return columnMetadata[cell].focusable;\n\t    }\n\t\n\t    return columns[cell] && columns[cell].focusable;\n\t  }\n\t\n\t  function canCellBeSelected(row, cell) {\n\t    if (row >= getDataLength() || row < 0 || cell >= columns.length || cell < 0) {\n\t      return false;\n\t    }\n\t\n\t    var rowMetadata = data.getItemMetadata && data.getItemMetadata(row);\n\t    if (rowMetadata && typeof rowMetadata.selectable === \"boolean\") {\n\t      return rowMetadata.selectable;\n\t    }\n\t\n\t    var columnMetadata = rowMetadata && rowMetadata.columns && (rowMetadata.columns[columns[cell].id] || rowMetadata.columns[cell]);\n\t    if (columnMetadata && typeof columnMetadata.selectable === \"boolean\") {\n\t      return columnMetadata.selectable;\n\t    }\n\t\n\t    return columns[cell].selectable;\n\t  }\n\t\n\t  function gotoCell(row, cell, forceEdit) {\n\t    if (!initialized) {\n\t      return;\n\t    }\n\t    if (!canCellBeActive(row, cell)) {\n\t      return;\n\t    }\n\t\n\t    if (!getEditorLock().commitCurrentEdit()) {\n\t      return;\n\t    }\n\t\n\t    scrollCellIntoView(row, cell, false);\n\t\n\t    var newCell = getCellNode(row, cell);\n\t\n\t    // if selecting the 'add new' row, start editing right away\n\t    setActiveCellInternal(newCell, forceEdit || row === getDataLength() || options.autoEdit);\n\t\n\t    // if no editor was created, set the focus back on the grid\n\t    if (!currentEditor) {\n\t      setFocus();\n\t    }\n\t  }\n\t\n\t  //////////////////////////////////////////////////////////////////////////////////////////////\n\t  // IEditor implementation for the editor lock\n\t\n\t  function commitCurrentEdit() {\n\t    var item = getDataItem(activeRow);\n\t    var column = columns[activeCell];\n\t\n\t    if (currentEditor) {\n\t      if (currentEditor.isValueChanged()) {\n\t        var validationResults = currentEditor.validate();\n\t\n\t        if (validationResults.valid) {\n\t          if (activeRow < getDataLength()) {\n\t            var editCommand = {\n\t              row: activeRow,\n\t              cell: activeCell,\n\t              editor: currentEditor,\n\t              serializedValue: currentEditor.serializeValue(),\n\t              prevSerializedValue: serializedEditorValue,\n\t              execute: function execute() {\n\t                this.editor.applyValue(item, this.serializedValue);\n\t                updateRow(this.row);\n\t                trigger(self.onCellChange, {\n\t                  row: activeRow,\n\t                  cell: activeCell,\n\t                  item: item\n\t                });\n\t              },\n\t              undo: function undo() {\n\t                this.editor.applyValue(item, this.prevSerializedValue);\n\t                updateRow(this.row);\n\t                trigger(self.onCellChange, {\n\t                  row: activeRow,\n\t                  cell: activeCell,\n\t                  item: item\n\t                });\n\t              }\n\t            };\n\t\n\t            if (options.editCommandHandler) {\n\t              makeActiveCellNormal();\n\t              options.editCommandHandler(item, column, editCommand);\n\t            } else {\n\t              editCommand.execute();\n\t              makeActiveCellNormal();\n\t            }\n\t          } else {\n\t            var newItem = {};\n\t            currentEditor.applyValue(newItem, currentEditor.serializeValue());\n\t            makeActiveCellNormal();\n\t            trigger(self.onAddNewRow, {\n\t              item: newItem,\n\t              column: column\n\t            });\n\t          }\n\t\n\t          // check whether the lock has been re-acquired by event handlers\n\t          return !getEditorLock().isActive();\n\t        } else {\n\t          // Re-add the CSS class to trigger transitions, if any.\n\t          (0, _jquery2.default)(activeCellNode).removeClass(\"invalid\");\n\t          (0, _jquery2.default)(activeCellNode).width(); // force layout\n\t          (0, _jquery2.default)(activeCellNode).addClass(\"invalid\");\n\t\n\t          trigger(self.onValidationError, {\n\t            editor: currentEditor,\n\t            cellNode: activeCellNode,\n\t            validationResults: validationResults,\n\t            row: activeRow,\n\t            cell: activeCell,\n\t            column: column\n\t          });\n\t\n\t          currentEditor.focus();\n\t          return false;\n\t        }\n\t      }\n\t\n\t      makeActiveCellNormal();\n\t    }\n\t    return true;\n\t  }\n\t\n\t  function cancelCurrentEdit() {\n\t    makeActiveCellNormal();\n\t    return true;\n\t  }\n\t\n\t  function rowsToRanges(rows) {\n\t    var ranges = [];\n\t    var lastCell = columns.length - 1;\n\t    for (var i = 0; i < rows.length; i++) {\n\t      ranges.push(new _slick2.default.Range(rows[i], 0, rows[i], lastCell));\n\t    }\n\t    return ranges;\n\t  }\n\t\n\t  function getSelectedRows() {\n\t    if (!selectionModel) {\n\t      throw \"Selection model is not set\";\n\t    }\n\t    return selectedRows;\n\t  }\n\t\n\t  function setSelectedRows(rows) {\n\t    if (!selectionModel) {\n\t      throw \"Selection model is not set\";\n\t    }\n\t    selectionModel.setSelectedRanges(rowsToRanges(rows));\n\t  }\n\t\n\t  //////////////////////////////////////////////////////////////////////////////////////////////\n\t  // Debug\n\t\n\t  this.debug = function () {\n\t    var s = \"\";\n\t\n\t    s += \"\\n\" + \"counter_rows_rendered:  \" + counter_rows_rendered;\n\t    s += \"\\n\" + \"counter_rows_removed:  \" + counter_rows_removed;\n\t    s += \"\\n\" + \"renderedRows:  \" + renderedRows;\n\t    s += \"\\n\" + \"numVisibleRows:  \" + numVisibleRows;\n\t    s += \"\\n\" + \"maxSupportedCssHeight:  \" + maxSupportedCssHeight;\n\t    s += \"\\n\" + \"n(umber of pages):  \" + n;\n\t    s += \"\\n\" + \"(current) page:  \" + page;\n\t    s += \"\\n\" + \"page height (ph):  \" + ph;\n\t    s += \"\\n\" + \"vScrollDir:  \" + vScrollDir;\n\t\n\t    alert(s);\n\t  };\n\t\n\t  // a debug helper to be able to access private members\n\t  this.eval = function (expr) {\n\t    return eval(expr);\n\t  };\n\t\n\t  //////////////////////////////////////////////////////////////////////////////////////////////\n\t  // Public API\n\t\n\t  _jquery2.default.extend(this, {\n\t    \"slickGridVersion\": \"2.1\",\n\t\n\t    // Events\n\t    \"onScroll\": new _slick2.default.Event(),\n\t    \"onSort\": new _slick2.default.Event(),\n\t    \"onHeaderMouseEnter\": new _slick2.default.Event(),\n\t    \"onHeaderMouseLeave\": new _slick2.default.Event(),\n\t    \"onHeaderContextMenu\": new _slick2.default.Event(),\n\t    \"onHeaderClick\": new _slick2.default.Event(),\n\t    \"onHeaderCellRendered\": new _slick2.default.Event(),\n\t    \"onBeforeHeaderCellDestroy\": new _slick2.default.Event(),\n\t    \"onHeaderRowCellRendered\": new _slick2.default.Event(),\n\t    \"onFooterRowCellRendered\": new _slick2.default.Event(),\n\t    \"onBeforeHeaderRowCellDestroy\": new _slick2.default.Event(),\n\t    \"onBeforeFooterRowCellDestroy\": new _slick2.default.Event(),\n\t    \"onMouseEnter\": new _slick2.default.Event(),\n\t    \"onMouseLeave\": new _slick2.default.Event(),\n\t    \"onClick\": new _slick2.default.Event(),\n\t    \"onDblClick\": new _slick2.default.Event(),\n\t    \"onContextMenu\": new _slick2.default.Event(),\n\t    \"onKeyDown\": new _slick2.default.Event(),\n\t    \"onAddNewRow\": new _slick2.default.Event(),\n\t    \"onValidationError\": new _slick2.default.Event(),\n\t    \"onViewportChanged\": new _slick2.default.Event(),\n\t    \"onColumnsReordered\": new _slick2.default.Event(),\n\t    \"onColumnsResized\": new _slick2.default.Event(),\n\t    \"onCellChange\": new _slick2.default.Event(),\n\t    \"onBeforeEditCell\": new _slick2.default.Event(),\n\t    \"onBeforeCellEditorDestroy\": new _slick2.default.Event(),\n\t    \"onBeforeDestroy\": new _slick2.default.Event(),\n\t    \"onActiveCellChanged\": new _slick2.default.Event(),\n\t    \"onActiveCellPositionChanged\": new _slick2.default.Event(),\n\t    \"onDragInit\": new _slick2.default.Event(),\n\t    \"onDragStart\": new _slick2.default.Event(),\n\t    \"onDrag\": new _slick2.default.Event(),\n\t    \"onDragEnd\": new _slick2.default.Event(),\n\t    \"onSelectedRowsChanged\": new _slick2.default.Event(),\n\t    \"onCellCssStylesChanged\": new _slick2.default.Event(),\n\t\n\t    // Methods\n\t    \"registerPlugin\": registerPlugin,\n\t    \"unregisterPlugin\": unregisterPlugin,\n\t    \"getColumns\": getColumns,\n\t    \"setColumns\": setColumns,\n\t    \"getColumnIndex\": getColumnIndex,\n\t    \"updateColumnHeader\": updateColumnHeader,\n\t    \"setSortColumn\": setSortColumn,\n\t    \"setSortColumns\": setSortColumns,\n\t    \"getSortColumns\": getSortColumns,\n\t    \"autosizeColumns\": autosizeColumns,\n\t    \"getOptions\": getOptions,\n\t    \"setOptions\": setOptions,\n\t    \"getData\": getData,\n\t    \"getDataLength\": getDataLength,\n\t    \"getDataItem\": getDataItem,\n\t    \"setData\": setData,\n\t    \"getSelectionModel\": getSelectionModel,\n\t    \"setSelectionModel\": setSelectionModel,\n\t    \"getSelectedRows\": getSelectedRows,\n\t    \"setSelectedRows\": setSelectedRows,\n\t    \"getContainerNode\": getContainerNode,\n\t\n\t    \"render\": render,\n\t    \"invalidate\": invalidate,\n\t    \"invalidateRow\": invalidateRow,\n\t    \"invalidateRows\": invalidateRows,\n\t    \"invalidateAllRows\": invalidateAllRows,\n\t    \"updateCell\": updateCell,\n\t    \"updateRow\": updateRow,\n\t    \"getViewport\": getVisibleRange,\n\t    \"getRenderedRange\": getRenderedRange,\n\t    \"resizeCanvas\": resizeCanvas,\n\t    \"updateRowCount\": updateRowCount,\n\t    \"scrollRowIntoView\": scrollRowIntoView,\n\t    \"scrollRowToTop\": scrollRowToTop,\n\t    \"scrollCellIntoView\": scrollCellIntoView,\n\t    \"getCanvasNode\": getCanvasNode,\n\t    \"getCanvases\": getCanvases,\n\t    \"getActiveCanvasNode\": getActiveCanvasNode,\n\t    \"setActiveCanvasNode\": setActiveCanvasNode,\n\t    \"getViewportNode\": getViewportNode,\n\t    \"getActiveViewportNode\": getActiveViewportNode,\n\t    \"setActiveViewportNode\": setActiveViewportNode,\n\t    \"focus\": setFocus,\n\t\n\t    \"getCellFromPoint\": getCellFromPoint,\n\t    \"getCellFromEvent\": getCellFromEvent,\n\t    \"getActiveCell\": getActiveCell,\n\t    \"setActiveCell\": setActiveCell,\n\t    \"getActiveCellNode\": getActiveCellNode,\n\t    \"getActiveCellPosition\": getActiveCellPosition,\n\t    \"resetActiveCell\": resetActiveCell,\n\t    \"editActiveCell\": makeActiveCellEditable,\n\t    \"getCellEditor\": getCellEditor,\n\t    \"getCellNode\": getCellNode,\n\t    \"getCellNodeBox\": getCellNodeBox,\n\t    \"canCellBeSelected\": canCellBeSelected,\n\t    \"canCellBeActive\": canCellBeActive,\n\t    \"navigatePrev\": navigatePrev,\n\t    \"navigateNext\": navigateNext,\n\t    \"navigateUp\": navigateUp,\n\t    \"navigateDown\": navigateDown,\n\t    \"navigateLeft\": navigateLeft,\n\t    \"navigateRight\": navigateRight,\n\t    \"navigatePageUp\": navigatePageUp,\n\t    \"navigatePageDown\": navigatePageDown,\n\t    \"gotoCell\": gotoCell,\n\t    \"getTopPanel\": getTopPanel,\n\t    \"setTopPanelVisibility\": setTopPanelVisibility,\n\t    \"setHeaderRowVisibility\": setHeaderRowVisibility,\n\t    \"getHeaderRow\": getHeaderRow,\n\t    \"getHeaderRowColumn\": getHeaderRowColumn,\n\t    \"setFooterRowVisibility\": setFooterRowVisibility,\n\t    \"getFooterRow\": getFooterRow,\n\t    \"getFooterRowColumn\": getFooterRowColumn,\n\t    \"getGridPosition\": getGridPosition,\n\t    \"flashCell\": flashCell,\n\t    \"addCellCssStyles\": addCellCssStyles,\n\t    \"setCellCssStyles\": setCellCssStyles,\n\t    \"removeCellCssStyles\": removeCellCssStyles,\n\t    \"getCellCssStyles\": getCellCssStyles,\n\t    \"getFrozenRowOffset\": getFrozenRowOffset,\n\t\n\t    \"init\": finishInitialization,\n\t    \"destroy\": destroy,\n\t\n\t    // IEditor implementation\n\t    \"getEditorLock\": getEditorLock,\n\t    \"getEditController\": getEditController\n\t  });\n\t\n\t  init();\n\t}\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _slick = __webpack_require__(1);\n\t\n\tvar _slick2 = _interopRequireDefault(_slick);\n\t\n\tvar _jquery = __webpack_require__(2);\n\t\n\tvar _jquery2 = _interopRequireDefault(_jquery);\n\t\n\tvar _slick3 = __webpack_require__(7);\n\t\n\tvar _slick4 = _interopRequireDefault(_slick3);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tvar Aggregators = {\n\t  Avg: AvgAggregator,\n\t  Min: MinAggregator,\n\t  Max: MaxAggregator,\n\t  Sum: SumAggregator\n\t};\n\t\n\tvar Data = {\n\t  DataView: DataView,\n\t  GroupMetaDataProvider: _slick4.default,\n\t  Aggregators: Aggregators\n\t};\n\t\n\texports.default = Data;\n\t\n\t/** *\n\t * A sample Model implementation.\n\t * Provides a filtered view of the underlying data.\n\t *\n\t * Relies on the data item having an \"id\" property uniquely identifying it.\n\t */\n\t\n\tfunction DataView(options) {\n\t  var self = this;\n\t\n\t  var defaults = {\n\t    groupItemMetadataProvider: null,\n\t    inlineFilters: false\n\t  };\n\t\n\t  // private\n\t  var idProperty = 'id'; // property holding a unique row id\n\t  var items = []; // data by index\n\t  var rows = []; // data by row\n\t  var idxById = {}; // indexes by id\n\t  var rowsById = null; // rows by id; lazy-calculated\n\t  var filter = null; // filter function\n\t  var updated = null; // updated item ids\n\t  var suspend = false; // suspends the recalculation\n\t  var sortAsc = true;\n\t  var fastSortField = void 0;\n\t  var sortComparer = void 0;\n\t  var refreshHints = {};\n\t  var prevRefreshHints = {};\n\t  var filterArgs = void 0;\n\t  var filteredItems = [];\n\t  var compiledFilter = void 0;\n\t  var compiledFilterWithCaching = void 0;\n\t  var filterCache = [];\n\t\n\t  // grouping\n\t  var groupingInfoDefaults = {\n\t    getter: null,\n\t    formatter: null,\n\t    comparer: function comparer(a, b) {\n\t      return a.value === b.value ? 0 : a.value > b.value ? 1 : -1;\n\t    },\n\t    predefinedValues: [],\n\t    aggregators: [],\n\t    aggregateEmpty: false,\n\t    aggregateCollapsed: false,\n\t    aggregateChildGroups: false,\n\t    collapsed: false,\n\t    displayTotalsRow: true,\n\t    lazyTotalsCalculation: false\n\t  };\n\t  var groupingInfos = [];\n\t  var groups = [];\n\t  var toggledGroupsByLevel = [];\n\t  var groupingDelimiter = ':|:';\n\t\n\t  var pagesize = 0;\n\t  var pagenum = 0;\n\t  var totalRows = 0;\n\t\n\t  // events\n\t  var onRowCountChanged = new _slick2.default.Event();\n\t  var onRowsChanged = new _slick2.default.Event();\n\t  var onPagingInfoChanged = new _slick2.default.Event();\n\t\n\t  options = _jquery2.default.extend(true, {}, defaults, options);\n\t\n\t  function beginUpdate() {\n\t    suspend = true;\n\t  }\n\t\n\t  function endUpdate() {\n\t    suspend = false;\n\t    refresh();\n\t  }\n\t\n\t  function setRefreshHints(hints) {\n\t    refreshHints = hints;\n\t  }\n\t\n\t  function setFilterArgs(args) {\n\t    filterArgs = args;\n\t  }\n\t\n\t  function updateIdxById(startingIndex) {\n\t    startingIndex = startingIndex || 0;\n\t    var id = void 0;\n\t    for (var i = startingIndex, l = items.length; i < l; i++) {\n\t      id = items[i][idProperty];\n\t      if (id === undefined) {\n\t        throw \"Each data element must implement a unique 'id' property\";\n\t      }\n\t      idxById[id] = i;\n\t    }\n\t  }\n\t\n\t  function ensureIdUniqueness() {\n\t    var id = void 0;\n\t    for (var i = 0, l = items.length; i < l; i++) {\n\t      id = items[i][idProperty];\n\t      if (id === undefined || idxById[id] !== i) {\n\t        throw \"Each data element must implement a unique 'id' property\";\n\t      }\n\t    }\n\t  }\n\t\n\t  function getItems() {\n\t    return items;\n\t  }\n\t\n\t  function setItems(data, objectIdProperty) {\n\t    if (objectIdProperty !== undefined) {\n\t      idProperty = objectIdProperty;\n\t    }\n\t    items = filteredItems = data;\n\t    idxById = {};\n\t    updateIdxById();\n\t    ensureIdUniqueness();\n\t    refresh();\n\t  }\n\t\n\t  function setPagingOptions(args) {\n\t    if (args.pageSize != undefined) {\n\t      pagesize = args.pageSize;\n\t      pagenum = pagesize ? Math.min(pagenum, Math.max(0, Math.ceil(totalRows / pagesize) - 1)) : 0;\n\t    }\n\t\n\t    if (args.pageNum != undefined) {\n\t      pagenum = Math.min(args.pageNum, Math.max(0, Math.ceil(totalRows / pagesize) - 1));\n\t    }\n\t\n\t    onPagingInfoChanged.notify(getPagingInfo(), null, self);\n\t\n\t    refresh();\n\t  }\n\t\n\t  function getPagingInfo() {\n\t    var totalPages = pagesize ? Math.max(1, Math.ceil(totalRows / pagesize)) : 1;\n\t    return { pageSize: pagesize, pageNum: pagenum, totalRows: totalRows, totalPages: totalPages, dataView: self };\n\t  }\n\t\n\t  function sort(comparer, ascending) {\n\t    sortAsc = ascending;\n\t    sortComparer = comparer;\n\t    fastSortField = null;\n\t    if (ascending === false) {\n\t      items.reverse();\n\t    }\n\t    items.sort(comparer);\n\t    if (ascending === false) {\n\t      items.reverse();\n\t    }\n\t    idxById = {};\n\t    updateIdxById();\n\t    refresh();\n\t  }\n\t\n\t  /** *\n\t   * Provides a workaround for the extremely slow sorting in IE.\n\t   * Does a [lexicographic] sort on a give column by temporarily overriding Object.prototype.toString\n\t   * to return the value of that field and then doing a native Array.sort().\n\t   */\n\t  function fastSort(field, ascending) {\n\t    sortAsc = ascending;\n\t    fastSortField = field;\n\t    sortComparer = null;\n\t    var oldToString = Object.prototype.toString;\n\t    Object.prototype.toString = typeof field == 'function' ? field : function () {\n\t      return this[field];\n\t    };\n\t    // an extra reversal for descending sort keeps the sort stable\n\t    // (assuming a stable native sort implementation, which isn't true in some cases)\n\t    if (ascending === false) {\n\t      items.reverse();\n\t    }\n\t    items.sort();\n\t    Object.prototype.toString = oldToString;\n\t    if (ascending === false) {\n\t      items.reverse();\n\t    }\n\t    idxById = {};\n\t    updateIdxById();\n\t    refresh();\n\t  }\n\t\n\t  function reSort() {\n\t    if (sortComparer) {\n\t      sort(sortComparer, sortAsc);\n\t    } else if (fastSortField) {\n\t      fastSort(fastSortField, sortAsc);\n\t    }\n\t  }\n\t\n\t  function setFilter(filterFn) {\n\t    filter = filterFn;\n\t    if (options.inlineFilters) {\n\t      compiledFilter = compileFilter();\n\t      compiledFilterWithCaching = compileFilterWithCaching();\n\t    }\n\t    refresh();\n\t  }\n\t\n\t  function getGrouping() {\n\t    return groupingInfos;\n\t  }\n\t\n\t  function setGrouping(groupingInfo) {\n\t    if (!options.groupItemMetadataProvider) {\n\t      options.groupItemMetadataProvider = GroupItemMetadataProvider();\n\t    }\n\t\n\t    groups = [];\n\t    toggledGroupsByLevel = [];\n\t    groupingInfo = groupingInfo || [];\n\t    groupingInfos = groupingInfo instanceof Array ? groupingInfo : [groupingInfo];\n\t\n\t    for (var i = 0; i < groupingInfos.length; i++) {\n\t      var gi = groupingInfos[i] = _jquery2.default.extend(true, {}, groupingInfoDefaults, groupingInfos[i]);\n\t      gi.getterIsAFn = typeof gi.getter === 'function';\n\t\n\t      // pre-compile accumulator loops\n\t      gi.compiledAccumulators = [];\n\t      var idx = gi.aggregators.length;\n\t      while (idx--) {\n\t        gi.compiledAccumulators[idx] = compileAccumulatorLoop(gi.aggregators[idx]);\n\t      }\n\t\n\t      toggledGroupsByLevel[i] = {};\n\t    }\n\t\n\t    refresh();\n\t  }\n\t\n\t  /**\n\t   * @deprecated Please use {@link setGrouping}.\n\t   */\n\t  function groupBy(valueGetter, valueFormatter, sortComparer) {\n\t    if (valueGetter == null) {\n\t      setGrouping([]);\n\t      return;\n\t    }\n\t\n\t    setGrouping({\n\t      getter: valueGetter,\n\t      formatter: valueFormatter,\n\t      comparer: sortComparer\n\t    });\n\t  }\n\t\n\t  /**\n\t   * @deprecated Please use {@link setGrouping}.\n\t   */\n\t  function setAggregators(groupAggregators, includeCollapsed) {\n\t    if (!groupingInfos.length) {\n\t      throw new Error('At least one grouping must be specified before calling setAggregators().');\n\t    }\n\t\n\t    groupingInfos[0].aggregators = groupAggregators;\n\t    groupingInfos[0].aggregateCollapsed = includeCollapsed;\n\t\n\t    setGrouping(groupingInfos);\n\t  }\n\t\n\t  function getItemByIdx(i) {\n\t    return items[i];\n\t  }\n\t\n\t  function getIdxById(id) {\n\t    return idxById[id];\n\t  }\n\t\n\t  function ensureRowsByIdCache() {\n\t    if (!rowsById) {\n\t      rowsById = {};\n\t      for (var i = 0, l = rows.length; i < l; i++) {\n\t        rowsById[rows[i][idProperty]] = i;\n\t      }\n\t    }\n\t  }\n\t\n\t  function getRowById(id) {\n\t    ensureRowsByIdCache();\n\t    return rowsById[id];\n\t  }\n\t\n\t  function getItemById(id) {\n\t    return items[idxById[id]];\n\t  }\n\t\n\t  function mapIdsToRows(idArray) {\n\t    var rows = [];\n\t    ensureRowsByIdCache();\n\t    for (var i = 0, l = idArray.length; i < l; i++) {\n\t      var row = rowsById[idArray[i]];\n\t      if (row != null) {\n\t        rows[rows.length] = row;\n\t      }\n\t    }\n\t    return rows;\n\t  }\n\t\n\t  function mapRowsToIds(rowArray) {\n\t    var ids = [];\n\t    for (var i = 0, l = rowArray.length; i < l; i++) {\n\t      if (rowArray[i] < rows.length) {\n\t        ids[ids.length] = rows[rowArray[i]][idProperty];\n\t      }\n\t    }\n\t    return ids;\n\t  }\n\t\n\t  function updateItem(id, item) {\n\t    if (idxById[id] === undefined || id !== item[idProperty]) {\n\t      throw 'Invalid or non-matching id';\n\t    }\n\t    items[idxById[id]] = item;\n\t    if (!updated) {\n\t      updated = {};\n\t    }\n\t    updated[id] = true;\n\t    refresh();\n\t  }\n\t\n\t  function insertItem(insertBefore, item) {\n\t    items.splice(insertBefore, 0, item);\n\t    updateIdxById(insertBefore);\n\t    refresh();\n\t  }\n\t\n\t  function addItem(item) {\n\t    items.push(item);\n\t    updateIdxById(items.length - 1);\n\t    refresh();\n\t  }\n\t\n\t  function deleteItem(id) {\n\t    var idx = idxById[id];\n\t    if (idx === undefined) {\n\t      throw 'Invalid id';\n\t    }\n\t    delete idxById[id];\n\t    items.splice(idx, 1);\n\t    updateIdxById(idx);\n\t    refresh();\n\t  }\n\t\n\t  function getLength() {\n\t    return rows.length;\n\t  }\n\t\n\t  function getItem(i) {\n\t    var item = rows[i];\n\t\n\t    // if this is a group row, make sure totals are calculated and update the title\n\t    if (item && item.__group && item.totals && !item.totals.initialized) {\n\t      var gi = groupingInfos[item.level];\n\t      if (!gi.displayTotalsRow) {\n\t        calculateTotals(item.totals);\n\t        item.title = gi.formatter ? gi.formatter(item) : item.value;\n\t      }\n\t    }\n\t    // if this is a totals row, make sure it's calculated\n\t    else if (item && item.__groupTotals && !item.initialized) {\n\t        calculateTotals(item);\n\t      }\n\t\n\t    return item;\n\t  }\n\t\n\t  function getItemMetadata(i) {\n\t    var item = rows[i];\n\t    if (item === undefined) {\n\t      return null;\n\t    }\n\t\n\t    // overrides for grouping rows\n\t    if (item.__group) {\n\t      return options.groupItemMetadataProvider.getGroupRowMetadata(item);\n\t    }\n\t\n\t    // overrides for totals rows\n\t    if (item.__groupTotals) {\n\t      return options.groupItemMetadataProvider.getTotalsRowMetadata(item);\n\t    }\n\t\n\t    return null;\n\t  }\n\t\n\t  function expandCollapseAllGroups(level, collapse) {\n\t    if (level == null) {\n\t      for (var i = 0; i < groupingInfos.length; i++) {\n\t        toggledGroupsByLevel[i] = {};\n\t        groupingInfos[i].collapsed = collapse;\n\t      }\n\t    } else {\n\t      toggledGroupsByLevel[level] = {};\n\t      groupingInfos[level].collapsed = collapse;\n\t    }\n\t    refresh();\n\t  }\n\t\n\t  /**\n\t   * @param level {Number} Optional level to collapse.  If not specified, applies to all levels.\n\t   */\n\t  function collapseAllGroups(level) {\n\t    expandCollapseAllGroups(level, true);\n\t  }\n\t\n\t  /**\n\t   * @param level {Number} Optional level to expand.  If not specified, applies to all levels.\n\t   */\n\t  function expandAllGroups(level) {\n\t    expandCollapseAllGroups(level, false);\n\t  }\n\t\n\t  function expandCollapseGroup(level, groupingKey, collapse) {\n\t    toggledGroupsByLevel[level][groupingKey] = groupingInfos[level].collapsed ^ collapse;\n\t    refresh();\n\t  }\n\t\n\t  /**\n\t   * @param letArgs Either a Slick.Group's \"groupingKey\" property, or a\n\t   *     letiable argument list of grouping values denoting a unique path to the row.  For\n\t   *     example, calling collapseGroup('high', '10%') will collapse the '10%' subgroup of\n\t   *     the 'high' group.\n\t   */\n\t  function collapseGroup(letArgs) {\n\t    var args = Array.prototype.slice.call(arguments);\n\t    var arg0 = args[0];\n\t    if (args.length == 1 && arg0.indexOf(groupingDelimiter) != -1) {\n\t      expandCollapseGroup(arg0.split(groupingDelimiter).length - 1, arg0, true);\n\t    } else {\n\t      expandCollapseGroup(args.length - 1, args.join(groupingDelimiter), true);\n\t    }\n\t  }\n\t\n\t  /**\n\t   * @param letArgs Either a Slick.Group's \"groupingKey\" property, or a\n\t   *     letiable argument list of grouping values denoting a unique path to the row.  For\n\t   *     example, calling expandGroup('high', '10%') will expand the '10%' subgroup of\n\t   *     the 'high' group.\n\t   */\n\t  function expandGroup(letArgs) {\n\t    var args = Array.prototype.slice.call(arguments);\n\t    var arg0 = args[0];\n\t    if (args.length == 1 && arg0.indexOf(groupingDelimiter) != -1) {\n\t      expandCollapseGroup(arg0.split(groupingDelimiter).length - 1, arg0, false);\n\t    } else {\n\t      expandCollapseGroup(args.length - 1, args.join(groupingDelimiter), false);\n\t    }\n\t  }\n\t\n\t  function getGroups() {\n\t    return groups;\n\t  }\n\t\n\t  function extractGroups(rows, parentGroup) {\n\t    var group = void 0;\n\t    var val = void 0;\n\t    var groups = [];\n\t    var groupsByVal = {};\n\t    var r = void 0;\n\t    var level = parentGroup ? parentGroup.level + 1 : 0;\n\t    var gi = groupingInfos[level];\n\t\n\t    for (var i = 0, l = gi.predefinedValues.length; i < l; i++) {\n\t      val = gi.predefinedValues[i];\n\t      group = groupsByVal[val];\n\t      if (!group) {\n\t        group = new _slick2.default.Group();\n\t        group.value = val;\n\t        group.level = level;\n\t        group.groupingKey = (parentGroup ? parentGroup.groupingKey + groupingDelimiter : '') + val;\n\t        groups[groups.length] = group;\n\t        groupsByVal[val] = group;\n\t      }\n\t    }\n\t\n\t    for (var _i = 0, _l = rows.length; _i < _l; _i++) {\n\t      r = rows[_i];\n\t      val = gi.getterIsAFn ? gi.getter(r) : r[gi.getter];\n\t      group = groupsByVal[val];\n\t      if (!group) {\n\t        group = new _slick2.default.Group();\n\t        group.value = val;\n\t        group.level = level;\n\t        group.groupingKey = (parentGroup ? parentGroup.groupingKey + groupingDelimiter : '') + val;\n\t        groups[groups.length] = group;\n\t        groupsByVal[val] = group;\n\t      }\n\t\n\t      group.rows[group.count++] = r;\n\t    }\n\t\n\t    if (level < groupingInfos.length - 1) {\n\t      for (var _i2 = 0; _i2 < groups.length; _i2++) {\n\t        group = groups[_i2];\n\t        group.groups = extractGroups(group.rows, group);\n\t      }\n\t    }\n\t\n\t    groups.sort(groupingInfos[level].comparer);\n\t\n\t    return groups;\n\t  }\n\t\n\t  function calculateTotals(totals) {\n\t    var group = totals.group;\n\t    var gi = groupingInfos[group.level];\n\t    var isLeafLevel = group.level == groupingInfos.length;\n\t    var agg = void 0,\n\t        idx = gi.aggregators.length;\n\t\n\t    if (!isLeafLevel && gi.aggregateChildGroups) {\n\t      // make sure all the subgroups are calculated\n\t      var i = group.groups.length;\n\t      while (i--) {\n\t        if (!group.groups[i].totals.initialized) {\n\t          calculateTotals(group.groups[i].totals);\n\t        }\n\t      }\n\t    }\n\t\n\t    while (idx--) {\n\t      agg = gi.aggregators[idx];\n\t      agg.init();\n\t      if (!isLeafLevel && gi.aggregateChildGroups) {\n\t        gi.compiledAccumulators[idx].call(agg, group.groups);\n\t      } else {\n\t        gi.compiledAccumulators[idx].call(agg, group.rows);\n\t      }\n\t      agg.storeResult(totals);\n\t    }\n\t    totals.initialized = true;\n\t  }\n\t\n\t  function addGroupTotals(group) {\n\t    var gi = groupingInfos[group.level];\n\t    var totals = new _slick2.default.GroupTotals();\n\t    totals.group = group;\n\t    group.totals = totals;\n\t    if (!gi.lazyTotalsCalculation) {\n\t      calculateTotals(totals);\n\t    }\n\t  }\n\t\n\t  function addTotals(groups, level) {\n\t    level = level || 0;\n\t    var gi = groupingInfos[level];\n\t    var groupCollapsed = gi.collapsed;\n\t    var toggledGroups = toggledGroupsByLevel[level];\n\t    var idx = groups.length,\n\t        g = void 0;\n\t    while (idx--) {\n\t      g = groups[idx];\n\t\n\t      if (g.collapsed && !gi.aggregateCollapsed) {\n\t        continue;\n\t      }\n\t\n\t      // Do a depth-first aggregation so that parent group aggregators can access subgroup totals.\n\t      if (g.groups) {\n\t        addTotals(g.groups, level + 1);\n\t      }\n\t\n\t      if (gi.aggregators.length && (gi.aggregateEmpty || g.rows.length || g.groups && g.groups.length)) {\n\t        addGroupTotals(g);\n\t      }\n\t\n\t      g.collapsed = groupCollapsed ^ toggledGroups[g.groupingKey];\n\t      g.title = gi.formatter ? gi.formatter(g) : g.value;\n\t    }\n\t  }\n\t\n\t  function flattenGroupedRows(groups, level) {\n\t    level = level || 0;\n\t    var gi = groupingInfos[level];\n\t    var groupedRows = [],\n\t        rows = void 0,\n\t        gl = 0,\n\t        g = void 0;\n\t    for (var i = 0, l = groups.length; i < l; i++) {\n\t      g = groups[i];\n\t      groupedRows[gl++] = g;\n\t\n\t      if (!g.collapsed) {\n\t        rows = g.groups ? flattenGroupedRows(g.groups, level + 1) : g.rows;\n\t        for (var j = 0, jj = rows.length; j < jj; j++) {\n\t          groupedRows[gl++] = rows[j];\n\t        }\n\t      }\n\t\n\t      if (g.totals && gi.displayTotalsRow && (!g.collapsed || gi.aggregateCollapsed)) {\n\t        groupedRows[gl++] = g.totals;\n\t      }\n\t    }\n\t    return groupedRows;\n\t  }\n\t\n\t  function getFunctionInfo(fn) {\n\t    var fnRegex = /^function[^(]*\\(([^)]*)\\)\\s*{([\\s\\S]*)}$/;\n\t    var matches = fn.toString().match(fnRegex);\n\t    return {\n\t      params: matches[1].split(','),\n\t      body: matches[2]\n\t    };\n\t  }\n\t\n\t  function compileAccumulatorLoop(aggregator) {\n\t    var accumulatorInfo = getFunctionInfo(aggregator.accumulate);\n\t    var fn = new Function('_items', 'for (let ' + accumulatorInfo.params[0] + ', _i=0, _il=_items.length; _i<_il; _i++) {' + accumulatorInfo.params[0] + ' = _items[_i]; ' + accumulatorInfo.body + '}');\n\t    fn.displayName = 'compiledAccumulatorLoop';\n\t    return fn;\n\t  }\n\t\n\t  function compileFilter() {\n\t    var filterInfo = getFunctionInfo(filter);\n\t\n\t    var filterPath1 = '{ continue _coreloop; }$1';\n\t    var filterPath2 = '{ _retval[_idx++] = $item$; continue _coreloop; }$1';\n\t    // make some allowances for minification - there's only so far we can go with RegEx\n\t    var filterBody = filterInfo.body.replace(/return false\\s*([;}]|\\}|$)/gi, filterPath1).replace(/return!1([;}]|\\}|$)/gi, filterPath1).replace(/return true\\s*([;}]|\\}|$)/gi, filterPath2).replace(/return!0([;}]|\\}|$)/gi, filterPath2).replace(/return ([^;}]+?)\\s*([;}]|$)/gi, '{ if ($1) { _retval[_idx++] = $item$; }; continue _coreloop; }$2');\n\t\n\t    // This preserves the function template code after JS compression,\n\t    // so that replace() commands still work as expected.\n\t    var tpl = [\n\t    // \"function(_items, _args) { \",\n\t    'let _retval = [], _idx = 0; ', 'let $item$, $args$ = _args; ', '_coreloop: ', 'for (let _i = 0, _il = _items.length; _i < _il; _i++) { ', '$item$ = _items[_i]; ', '$filter$; ', '} ', 'return _retval; '\n\t    // \"}\"\n\t    ].join('');\n\t    tpl = tpl.replace(/\\$filter\\$/gi, filterBody);\n\t    tpl = tpl.replace(/\\$item\\$/gi, filterInfo.params[0]);\n\t    tpl = tpl.replace(/\\$args\\$/gi, filterInfo.params[1]);\n\t\n\t    var fn = new Function('_items,_args', tpl);\n\t    fn.displayName = 'compiledFilter';\n\t\n\t    return fn;\n\t  }\n\t\n\t  function compileFilterWithCaching() {\n\t    var filterInfo = getFunctionInfo(filter);\n\t\n\t    var filterPath1 = '{ continue _coreloop; }$1';\n\t    var filterPath2 = '{ _cache[_i] = true;_retval[_idx++] = $item$; continue _coreloop; }$1';\n\t    // make some allowances for minification - there's only so far we can go with RegEx\n\t    var filterBody = filterInfo.body.replace(/return false\\s*([;}]|\\}|$)/gi, filterPath1).replace(/return!1([;}]|\\}|$)/gi, filterPath1).replace(/return true\\s*([;}]|\\}|$)/gi, filterPath2).replace(/return!0([;}]|\\}|$)/gi, filterPath2).replace(/return ([^;}]+?)\\s*([;}]|$)/gi, '{ if ((_cache[_i] = $1)) { _retval[_idx++] = $item$; }; continue _coreloop; }$2');\n\t\n\t    // This preserves the function template code after JS compression,\n\t    // so that replace() commands still work as expected.\n\t    var tpl = [\n\t    // \"function(_items, _args, _cache) { \",\n\t    'let _retval = [], _idx = 0; ', 'let $item$, $args$ = _args; ', '_coreloop: ', 'for (let _i = 0, _il = _items.length; _i < _il; _i++) { ', '$item$ = _items[_i]; ', 'if (_cache[_i]) { ', '_retval[_idx++] = $item$; ', 'continue _coreloop; ', '} ', '$filter$; ', '} ', 'return _retval; '\n\t    // \"}\"\n\t    ].join('');\n\t    tpl = tpl.replace(/\\$filter\\$/gi, filterBody);\n\t    tpl = tpl.replace(/\\$item\\$/gi, filterInfo.params[0]);\n\t    tpl = tpl.replace(/\\$args\\$/gi, filterInfo.params[1]);\n\t\n\t    var fn = new Function('_items,_args,_cache', tpl);\n\t    fn.displayName = 'compiledFilterWithCaching';\n\t    return fn;\n\t  }\n\t\n\t  function uncompiledFilter(items, args) {\n\t    var retval = [],\n\t        idx = 0;\n\t\n\t    for (var i = 0, ii = items.length; i < ii; i++) {\n\t      if (filter(items[i], args)) {\n\t        retval[idx++] = items[i];\n\t      }\n\t    }\n\t\n\t    return retval;\n\t  }\n\t\n\t  function uncompiledFilterWithCaching(items, args, cache) {\n\t    var retval = [],\n\t        idx = 0,\n\t        item = void 0;\n\t\n\t    for (var i = 0, ii = items.length; i < ii; i++) {\n\t      item = items[i];\n\t      if (cache[i]) {\n\t        retval[idx++] = item;\n\t      } else if (filter(item, args)) {\n\t        retval[idx++] = item;\n\t        cache[i] = true;\n\t      }\n\t    }\n\t\n\t    return retval;\n\t  }\n\t\n\t  function getFilteredAndPagedItems(items) {\n\t    if (filter) {\n\t      var batchFilter = options.inlineFilters ? compiledFilter : uncompiledFilter;\n\t      var batchFilterWithCaching = options.inlineFilters ? compiledFilterWithCaching : uncompiledFilterWithCaching;\n\t\n\t      if (refreshHints.isFilterNarrowing) {\n\t        filteredItems = batchFilter(filteredItems, filterArgs);\n\t      } else if (refreshHints.isFilterExpanding) {\n\t        filteredItems = batchFilterWithCaching(items, filterArgs, filterCache);\n\t      } else if (!refreshHints.isFilterUnchanged) {\n\t        filteredItems = batchFilter(items, filterArgs);\n\t      }\n\t    } else {\n\t      // special case:  if not filtering and not paging, the resulting\n\t      // rows collection needs to be a copy so that changes due to sort\n\t      // can be caught\n\t      filteredItems = pagesize ? items : items.concat();\n\t    }\n\t\n\t    // get the current page\n\t    var paged = void 0;\n\t    if (pagesize) {\n\t      if (filteredItems.length < pagenum * pagesize) {\n\t        pagenum = Math.floor(filteredItems.length / pagesize);\n\t      }\n\t      paged = filteredItems.slice(pagesize * pagenum, pagesize * pagenum + pagesize);\n\t    } else {\n\t      paged = filteredItems;\n\t    }\n\t\n\t    return { totalRows: filteredItems.length, rows: paged };\n\t  }\n\t\n\t  function getRowDiffs(rows, newRows) {\n\t    var item = void 0,\n\t        r = void 0,\n\t        eitherIsNonData = void 0,\n\t        diff = [];\n\t    var from = 0,\n\t        to = newRows.length;\n\t\n\t    if (refreshHints && refreshHints.ignoreDiffsBefore) {\n\t      from = Math.max(0, Math.min(newRows.length, refreshHints.ignoreDiffsBefore));\n\t    }\n\t\n\t    if (refreshHints && refreshHints.ignoreDiffsAfter) {\n\t      to = Math.min(newRows.length, Math.max(0, refreshHints.ignoreDiffsAfter));\n\t    }\n\t\n\t    for (var i = from, rl = rows.length; i < to; i++) {\n\t      if (i >= rl) {\n\t        diff[diff.length] = i;\n\t      } else {\n\t        item = newRows[i];\n\t        r = rows[i];\n\t\n\t        if (groupingInfos.length && (eitherIsNonData = item.__nonDataRow || r.__nonDataRow) && item.__group !== r.__group || item.__group && !item.equals(r) || eitherIsNonData && (\n\t        // no good way to compare totals since they are arbitrary DTOs\n\t        // deep object comparison is pretty expensive\n\t        // always considering them 'dirty' seems easier for the time being\n\t        item.__groupTotals || r.__groupTotals) || item[idProperty] != r[idProperty] || updated && updated[item[idProperty]]) {\n\t          diff[diff.length] = i;\n\t        }\n\t      }\n\t    }\n\t    return diff;\n\t  }\n\t\n\t  function recalc(_items) {\n\t    rowsById = null;\n\t\n\t    if (refreshHints.isFilterNarrowing != prevRefreshHints.isFilterNarrowing || refreshHints.isFilterExpanding != prevRefreshHints.isFilterExpanding) {\n\t      filterCache = [];\n\t    }\n\t\n\t    var filteredItems = getFilteredAndPagedItems(_items);\n\t    totalRows = filteredItems.totalRows;\n\t    var newRows = filteredItems.rows;\n\t\n\t    groups = [];\n\t    if (groupingInfos.length) {\n\t      groups = extractGroups(newRows);\n\t      if (groups.length) {\n\t        addTotals(groups);\n\t        newRows = flattenGroupedRows(groups);\n\t      }\n\t    }\n\t\n\t    var diff = getRowDiffs(rows, newRows);\n\t\n\t    rows = newRows;\n\t\n\t    return diff;\n\t  }\n\t\n\t  function refresh() {\n\t    if (suspend) {\n\t      return;\n\t    }\n\t\n\t    var countBefore = rows.length;\n\t    var totalRowsBefore = totalRows;\n\t\n\t    var diff = recalc(items, filter); // pass as direct refs to avoid closure perf hit\n\t\n\t    // if the current page is no longer valid, go to last page and recalc\n\t    // we suffer a performance penalty here, but the main loop (recalc) remains highly optimized\n\t    if (pagesize && totalRows < pagenum * pagesize) {\n\t      pagenum = Math.max(0, Math.ceil(totalRows / pagesize) - 1);\n\t      diff = recalc(items, filter);\n\t    }\n\t\n\t    updated = null;\n\t    prevRefreshHints = refreshHints;\n\t    refreshHints = {};\n\t\n\t    if (totalRowsBefore !== totalRows) {\n\t      onPagingInfoChanged.notify(getPagingInfo(), null, self);\n\t    }\n\t    if (countBefore !== rows.length) {\n\t      onRowCountChanged.notify({ previous: countBefore, current: rows.length, dataView: self }, null, self);\n\t    }\n\t    if (diff.length > 0) {\n\t      onRowsChanged.notify({ rows: diff, dataView: self }, null, self);\n\t    }\n\t  }\n\t\n\t  /** *\n\t   * Wires the grid and the DataView together to keep row selection tied to item ids.\n\t   * This is useful since, without it, the grid only knows about rows, so if the items\n\t   * move around, the same rows stay selected instead of the selection moving along\n\t   * with the items.\n\t   *\n\t   * NOTE:  This doesn't work with cell selection model.\n\t   *\n\t   * @param grid {Slick.Grid} The grid to sync selection with.\n\t   * @param preserveHidden {Boolean} Whether to keep selected items that go out of the\n\t   *     view due to them getting filtered out.\n\t   * @param preserveHiddenOnSelectionChange {Boolean} Whether to keep selected items\n\t   *     that are currently out of the view (see preserveHidden) as selected when selection\n\t   *     changes.\n\t   * @return {Slick.Event} An event that notifies when an internal list of selected row ids\n\t   *     changes.  This is useful since, in combination with the above two options, it allows\n\t   *     access to the full list selected row ids, and not just the ones visible to the grid.\n\t   * @method syncGridSelection\n\t   */\n\t  function syncGridSelection(grid, preserveHidden, preserveHiddenOnSelectionChange) {\n\t    var self = this;\n\t    var inHandler = void 0;\n\t    var selectedRowIds = self.mapRowsToIds(grid.getSelectedRows());\n\t    var onSelectedRowIdsChanged = new _slick2.default.Event();\n\t\n\t    function setSelectedRowIds(rowIds) {\n\t      if (selectedRowIds.join(',') == rowIds.join(',')) {\n\t        return;\n\t      }\n\t\n\t      selectedRowIds = rowIds;\n\t\n\t      onSelectedRowIdsChanged.notify({\n\t        'grid': grid,\n\t        'ids': selectedRowIds,\n\t        'dataView': self\n\t      }, new _slick2.default.EventData(), self);\n\t    }\n\t\n\t    function update() {\n\t      if (selectedRowIds.length > 0) {\n\t        inHandler = true;\n\t        var selectedRows = self.mapIdsToRows(selectedRowIds);\n\t        if (!preserveHidden) {\n\t          setSelectedRowIds(self.mapRowsToIds(selectedRows));\n\t        }\n\t        grid.setSelectedRows(selectedRows);\n\t        inHandler = false;\n\t      }\n\t    }\n\t\n\t    grid.onSelectedRowsChanged.subscribe(function (e, args) {\n\t      if (inHandler) {\n\t        return;\n\t      }\n\t      var newSelectedRowIds = self.mapRowsToIds(grid.getSelectedRows());\n\t      if (!preserveHiddenOnSelectionChange || !grid.getOptions().multiSelect) {\n\t        setSelectedRowIds(newSelectedRowIds);\n\t      } else {\n\t        // keep the ones that are hidden\n\t        var existing = _jquery2.default.grep(selectedRowIds, function (id) {\n\t          return self.getRowById(id) === undefined;\n\t        });\n\t        // add the newly selected ones\n\t        setSelectedRowIds(existing.concat(newSelectedRowIds));\n\t      }\n\t    });\n\t\n\t    this.onRowsChanged.subscribe(update);\n\t\n\t    this.onRowCountChanged.subscribe(update);\n\t\n\t    return onSelectedRowIdsChanged;\n\t  }\n\t\n\t  function syncGridCellCssStyles(grid, key) {\n\t    var hashById = void 0;\n\t    var inHandler = void 0;\n\t\n\t    // since this method can be called after the cell styles have been set,\n\t    // get the existing ones right away\n\t    storeCellCssStyles(grid.getCellCssStyles(key));\n\t\n\t    function storeCellCssStyles(hash) {\n\t      hashById = {};\n\t      for (var row in hash) {\n\t        var id = rows[row][idProperty];\n\t        hashById[id] = hash[row];\n\t      }\n\t    }\n\t\n\t    function update() {\n\t      if (hashById) {\n\t        inHandler = true;\n\t        ensureRowsByIdCache();\n\t        var newHash = {};\n\t        for (var id in hashById) {\n\t          var row = rowsById[id];\n\t          if (row != undefined) {\n\t            newHash[row] = hashById[id];\n\t          }\n\t        }\n\t        grid.setCellCssStyles(key, newHash);\n\t        inHandler = false;\n\t      }\n\t    }\n\t\n\t    grid.onCellCssStylesChanged.subscribe(function (e, args) {\n\t      if (inHandler) {\n\t        return;\n\t      }\n\t      if (key != args.key) {\n\t        return;\n\t      }\n\t      if (args.hash) {\n\t        storeCellCssStyles(args.hash);\n\t      }\n\t    });\n\t\n\t    this.onRowsChanged.subscribe(update);\n\t\n\t    this.onRowCountChanged.subscribe(update);\n\t  }\n\t\n\t  _jquery2.default.extend(this, {\n\t    // methods\n\t    'beginUpdate': beginUpdate,\n\t    'endUpdate': endUpdate,\n\t    'setPagingOptions': setPagingOptions,\n\t    'getPagingInfo': getPagingInfo,\n\t    'getItems': getItems,\n\t    'setItems': setItems,\n\t    'setFilter': setFilter,\n\t    'sort': sort,\n\t    'fastSort': fastSort,\n\t    'reSort': reSort,\n\t    'setGrouping': setGrouping,\n\t    'getGrouping': getGrouping,\n\t    'groupBy': groupBy,\n\t    'setAggregators': setAggregators,\n\t    'collapseAllGroups': collapseAllGroups,\n\t    'expandAllGroups': expandAllGroups,\n\t    'collapseGroup': collapseGroup,\n\t    'expandGroup': expandGroup,\n\t    'getGroups': getGroups,\n\t    'getIdxById': getIdxById,\n\t    'getRowById': getRowById,\n\t    'getItemById': getItemById,\n\t    'getItemByIdx': getItemByIdx,\n\t    'mapRowsToIds': mapRowsToIds,\n\t    'mapIdsToRows': mapIdsToRows,\n\t    'setRefreshHints': setRefreshHints,\n\t    'setFilterArgs': setFilterArgs,\n\t    'refresh': refresh,\n\t    'updateItem': updateItem,\n\t    'insertItem': insertItem,\n\t    'addItem': addItem,\n\t    'deleteItem': deleteItem,\n\t    'syncGridSelection': syncGridSelection,\n\t    'syncGridCellCssStyles': syncGridCellCssStyles,\n\t\n\t    // data provider methods\n\t    'getLength': getLength,\n\t    'getItem': getItem,\n\t    'getItemMetadata': getItemMetadata,\n\t\n\t    // events\n\t    'onRowCountChanged': onRowCountChanged,\n\t    'onRowsChanged': onRowsChanged,\n\t    'onPagingInfoChanged': onPagingInfoChanged\n\t  });\n\t}\n\t\n\tfunction AvgAggregator(field) {\n\t  this.field_ = field;\n\t\n\t  this.init = function () {\n\t    this.count_ = 0;\n\t    this.nonNullCount_ = 0;\n\t    this.sum_ = 0;\n\t  };\n\t\n\t  this.accumulate = function (item) {\n\t    var val = item[this.field_];\n\t    this.count_++;\n\t    if (val != null && val !== '' && !isNaN(val)) {\n\t      this.nonNullCount_++;\n\t      this.sum_ += parseFloat(val);\n\t    }\n\t  };\n\t\n\t  this.storeResult = function (groupTotals) {\n\t    if (!groupTotals.avg) {\n\t      groupTotals.avg = {};\n\t    }\n\t    if (this.nonNullCount_ != 0) {\n\t      groupTotals.avg[this.field_] = this.sum_ / this.nonNullCount_;\n\t    }\n\t  };\n\t}\n\t\n\tfunction MinAggregator(field) {\n\t  this.field_ = field;\n\t\n\t  this.init = function () {\n\t    this.min_ = null;\n\t  };\n\t\n\t  this.accumulate = function (item) {\n\t    var val = item[this.field_];\n\t    if (val != null && val !== '' && !isNaN(val)) {\n\t      if (this.min_ == null || val < this.min_) {\n\t        this.min_ = val;\n\t      }\n\t    }\n\t  };\n\t\n\t  this.storeResult = function (groupTotals) {\n\t    if (!groupTotals.min) {\n\t      groupTotals.min = {};\n\t    }\n\t    groupTotals.min[this.field_] = this.min_;\n\t  };\n\t}\n\t\n\tfunction MaxAggregator(field) {\n\t  this.field_ = field;\n\t\n\t  this.init = function () {\n\t    this.max_ = null;\n\t  };\n\t\n\t  this.accumulate = function (item) {\n\t    var val = item[this.field_];\n\t    if (val != null && val !== '' && !isNaN(val)) {\n\t      if (this.max_ == null || val > this.max_) {\n\t        this.max_ = val;\n\t      }\n\t    }\n\t  };\n\t\n\t  this.storeResult = function (groupTotals) {\n\t    if (!groupTotals.max) {\n\t      groupTotals.max = {};\n\t    }\n\t    groupTotals.max[this.field_] = this.max_;\n\t  };\n\t}\n\t\n\tfunction SumAggregator(field) {\n\t  this.field_ = field;\n\t\n\t  this.init = function () {\n\t    this.sum_ = null;\n\t  };\n\t\n\t  this.accumulate = function (item) {\n\t    var val = item[this.field_];\n\t    if (val != null && val !== '' && !isNaN(val)) {\n\t      this.sum_ += parseFloat(val);\n\t    }\n\t  };\n\t\n\t  this.storeResult = function (groupTotals) {\n\t    if (!groupTotals.sum) {\n\t      groupTotals.sum = {};\n\t    }\n\t    groupTotals.sum[this.field_] = this.sum_;\n\t  };\n\t}\n\n/***/ }),\n/* 7 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _jquery = __webpack_require__(2);\n\t\n\tvar _jquery2 = _interopRequireDefault(_jquery);\n\t\n\tvar _slick = __webpack_require__(1);\n\t\n\tvar _slick2 = _interopRequireDefault(_slick);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\texports.default = GroupItemMetadataProvider;\n\t\n\t/***\n\t * Provides item metadata for group (Slick.Group) and totals (Slick.Totals) rows produced by the DataView.\n\t * This metadata overrides the default behavior and formatting of those rows so that they appear and function\n\t * correctly when processed by the grid.\n\t *\n\t * This class also acts as a grid plugin providing event handlers to expand & collapse groups.\n\t * If \"grid.registerPlugin(...)\" is not called, expand & collapse will not work.\n\t *\n\t * @class GroupItemMetadataProvider\n\t * @module Data\n\t * @namespace Slick.Data\n\t * @constructor\n\t * @param options\n\t */\n\t\n\tfunction GroupItemMetadataProvider(options) {\n\t  var _grid = void 0;\n\t  var _defaults = {\n\t    groupCssClass: \"slick-group\",\n\t    groupTitleCssClass: \"slick-group-title\",\n\t    totalsCssClass: \"slick-group-totals\",\n\t    groupFocusable: true,\n\t    totalsFocusable: false,\n\t    toggleCssClass: \"slick-group-toggle\",\n\t    toggleExpandedCssClass: \"expanded\",\n\t    toggleCollapsedCssClass: \"collapsed\",\n\t    enableExpandCollapse: true,\n\t    groupFormatter: defaultGroupCellFormatter,\n\t    totalsFormatter: defaultTotalsCellFormatter\n\t  };\n\t\n\t  options = _jquery2.default.extend(true, {}, _defaults, options);\n\t\n\t  function defaultGroupCellFormatter(row, cell, value, columnDef, item) {\n\t    if (!options.enableExpandCollapse) {\n\t      return item.title;\n\t    }\n\t\n\t    var indentation = item.level * 15 + \"px\";\n\t\n\t    return \"<span class='\" + options.toggleCssClass + \" \" + (item.collapsed ? options.toggleCollapsedCssClass : options.toggleExpandedCssClass) + \"' style='margin-left:\" + indentation + \"'>\" + \"</span>\" + \"<span class='\" + options.groupTitleCssClass + \"' level='\" + item.level + \"'>\" + item.title + \"</span>\";\n\t  }\n\t\n\t  function defaultTotalsCellFormatter(row, cell, value, columnDef, item) {\n\t    return columnDef.groupTotalsFormatter && columnDef.groupTotalsFormatter(item, columnDef) || \"\";\n\t  }\n\t\n\t  function init(grid) {\n\t    _grid = grid;\n\t    _grid.onClick.subscribe(handleGridClick);\n\t    _grid.onKeyDown.subscribe(handleGridKeyDown);\n\t  }\n\t\n\t  function destroy() {\n\t    if (_grid) {\n\t      _grid.onClick.unsubscribe(handleGridClick);\n\t      _grid.onKeyDown.unsubscribe(handleGridKeyDown);\n\t    }\n\t  }\n\t\n\t  function handleGridClick(e, args) {\n\t    var item = this.getDataItem(args.row);\n\t    if (item && item instanceof _slick2.default.Group && (0, _jquery2.default)(e.target).hasClass(options.toggleCssClass)) {\n\t      var range = _grid.getRenderedRange();\n\t      this.getData().setRefreshHints({\n\t        ignoreDiffsBefore: range.top,\n\t        ignoreDiffsAfter: range.bottom + 1\n\t      });\n\t\n\t      if (item.collapsed) {\n\t        this.getData().expandGroup(item.groupingKey);\n\t      } else {\n\t        this.getData().collapseGroup(item.groupingKey);\n\t      }\n\t\n\t      e.stopImmediatePropagation();\n\t      e.preventDefault();\n\t    }\n\t  }\n\t\n\t  // TODO:  add -/+ handling\n\t  function handleGridKeyDown(e) {\n\t    if (options.enableExpandCollapse && e.which == _slick2.default.keyCode.SPACE) {\n\t      var activeCell = this.getActiveCell();\n\t      if (activeCell) {\n\t        var item = this.getDataItem(activeCell.row);\n\t        if (item && item instanceof _slick2.default.Group) {\n\t          var range = _grid.getRenderedRange();\n\t          this.getData().setRefreshHints({\n\t            ignoreDiffsBefore: range.top,\n\t            ignoreDiffsAfter: range.bottom + 1\n\t          });\n\t\n\t          if (item.collapsed) {\n\t            this.getData().expandGroup(item.groupingKey);\n\t          } else {\n\t            this.getData().collapseGroup(item.groupingKey);\n\t          }\n\t\n\t          e.stopImmediatePropagation();\n\t          e.preventDefault();\n\t        }\n\t      }\n\t    }\n\t  }\n\t\n\t  function getGroupRowMetadata(item) {\n\t    return {\n\t      selectable: false,\n\t      focusable: options.groupFocusable,\n\t      cssClasses: options.groupCssClass,\n\t      columns: {\n\t        0: {\n\t          colspan: \"*\",\n\t          formatter: options.groupFormatter,\n\t          editor: null\n\t        }\n\t      }\n\t    };\n\t  }\n\t\n\t  function getTotalsRowMetadata(item) {\n\t    return {\n\t      selectable: false,\n\t      focusable: options.totalsFocusable,\n\t      cssClasses: options.totalsCssClass,\n\t      formatter: options.totalsFormatter,\n\t      editor: null\n\t    };\n\t  }\n\t\n\t  return {\n\t    init: init,\n\t    destroy: destroy,\n\t    getGroupRowMetadata: getGroupRowMetadata,\n\t    getTotalsRowMetadata: getTotalsRowMetadata\n\t  };\n\t}\n\n/***/ })\n/******/ ])));\n\n\n// WEBPACK FOOTER //\n// slick.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 1005c1f30a5451707e1a","/** *\n * Contains core SlickGrid classes.\n * @module Core\n * @namespace Slick\n */\nconst Slick = {\n  Event: Event,\n  EventData: EventData,\n  EventHandler: EventHandler,\n  Range: Range,\n  NonDataRow: NonDataItem,\n  Group: Group,\n  GroupTotals: GroupTotals,\n  EditorLock: EditorLock,\n  /** *\n   * A global singleton editor lock.\n   * @class GlobalEditorLock\n   * @static\n   * @constructor\n   */\n  GlobalEditorLock: new EditorLock(),\n  TreeColumns: TreeColumns,\n\n  keyCode: {\n    BACKSPACE: 8,\n    DELETE: 46,\n    DOWN: 40,\n    END: 35,\n    ENTER: 13,\n    ESCAPE: 27,\n    HOME: 36,\n    INSERT: 45,\n    LEFT: 37,\n    PAGE_DOWN: 34,\n    PAGE_UP: 33,\n    RIGHT: 39,\n    TAB: 9,\n    UP: 38,\n    SPACE: 32\n  }\n};\n\nexport default Slick;\n\n/***\n * An event object for passing data to event handlers and letting them control propagation.\n * <p>This is pretty much identical to how W3C and jQuery implement events.</p>\n * @class EventData\n * @constructor\n */\nfunction EventData() {\n  var isPropagationStopped = false;\n  var isImmediatePropagationStopped = false;\n\n  /***\n   * Stops event from propagating up the DOM tree.\n   * @method stopPropagation\n   */\n  this.stopPropagation = function() {\n    isPropagationStopped = true;\n  };\n\n  /***\n   * Returns whether stopPropagation was called on this event object.\n   * @method isPropagationStopped\n   * @return {Boolean}\n   */\n  this.isPropagationStopped = function() {\n    return isPropagationStopped;\n  };\n\n  /***\n   * Prevents the rest of the handlers from being executed.\n   * @method stopImmediatePropagation\n   */\n  this.stopImmediatePropagation = function() {\n    isImmediatePropagationStopped = true;\n  };\n\n  /***\n   * Returns whether stopImmediatePropagation was called on this event object.\\\n   * @method isImmediatePropagationStopped\n   * @return {Boolean}\n   */\n  this.isImmediatePropagationStopped = function() {\n    return isImmediatePropagationStopped;\n  }\n}\n\n/***\n * A simple publisher-subscriber implementation.\n * @class Event\n * @constructor\n */\nfunction Event() {\n  var handlers = [];\n\n  /***\n   * Adds an event handler to be called when the event is fired.\n   * <p>Event handler will receive two arguments - an <code>EventData</code> and the <code>data</code>\n   * object the event was fired with.<p>\n   * @method subscribe\n   * @param fn {Function} Event handler.\n   */\n  this.subscribe = function(fn) {\n    handlers.push(fn);\n  };\n\n  /***\n   * Removes an event handler added with <code>subscribe(fn)</code>.\n   * @method unsubscribe\n   * @param fn {Function} Event handler to be removed.\n   */\n  this.unsubscribe = function(fn) {\n    for (var i = handlers.length - 1; i >= 0; i--) {\n      if (handlers[i] === fn) {\n        handlers.splice(i, 1);\n      }\n    }\n  };\n\n  /***\n   * Fires an event notifying all subscribers.\n   * @method notify\n   * @param args {Object} Additional data object to be passed to all handlers.\n   * @param e {EventData}\n   *      Optional.\n   *      An <code>EventData</code> object to be passed to all handlers.\n   *      For DOM events, an existing W3C/jQuery event object can be passed in.\n   * @param scope {Object}\n   *      Optional.\n   *      The scope (\"this\") within which the handler will be executed.\n   *      If not specified, the scope will be set to the <code>Event</code> instance.\n   */\n  this.notify = function(args, e, scope) {\n    e = e || new EventData();\n    scope = scope || this;\n\n    var returnValue;\n    for (var i = 0; i < handlers.length && !(e.isPropagationStopped() || e.isImmediatePropagationStopped()); i++) {\n      returnValue = handlers[i].call(scope, e, args);\n    }\n\n    return returnValue;\n  };\n}\n\nfunction EventHandler() {\n  var handlers = [];\n\n  this.subscribe = function(event, handler) {\n    handlers.push({\n      event: event,\n      handler: handler\n    });\n    event.subscribe(handler);\n\n    return this; // allow chaining\n  };\n\n  this.unsubscribe = function(event, handler) {\n    var i = handlers.length;\n    while (i--) {\n      if (handlers[i].event === event && handlers[i].handler === handler) {\n        handlers.splice(i, 1);\n        event.unsubscribe(handler);\n        return;\n      }\n    }\n\n    return this; // allow chaining\n  };\n\n  this.unsubscribeAll = function() {\n    var i = handlers.length;\n    while (i--) {\n      handlers[i].event.unsubscribe(handlers[i].handler);\n    }\n    handlers = [];\n\n    return this; // allow chaining\n  }\n}\n\n/***\n * A structure containing a range of cells.\n * @class Range\n * @constructor\n * @param fromRow {Integer} Starting row.\n * @param fromCell {Integer} Starting cell.\n * @param toRow {Integer} Optional. Ending row. Defaults to <code>fromRow</code>.\n * @param toCell {Integer} Optional. Ending cell. Defaults to <code>fromCell</code>.\n */\nfunction Range(fromRow, fromCell, toRow, toCell) {\n  if (toRow === undefined && toCell === undefined) {\n    toRow = fromRow;\n    toCell = fromCell;\n  }\n\n  /***\n   * @property fromRow\n   * @type {Integer}\n   */\n  this.fromRow = Math.min(fromRow, toRow);\n\n  /***\n   * @property fromCell\n   * @type {Integer}\n   */\n  this.fromCell = Math.min(fromCell, toCell);\n\n  /***\n   * @property toRow\n   * @type {Integer}\n   */\n  this.toRow = Math.max(fromRow, toRow);\n\n  /***\n   * @property toCell\n   * @type {Integer}\n   */\n  this.toCell = Math.max(fromCell, toCell);\n\n  /***\n   * Returns whether a range represents a single row.\n   * @method isSingleRow\n   * @return {Boolean}\n   */\n  this.isSingleRow = function() {\n    return this.fromRow == this.toRow;\n  };\n\n  /***\n   * Returns whether a range represents a single cell.\n   * @method isSingleCell\n   * @return {Boolean}\n   */\n  this.isSingleCell = function() {\n    return this.fromRow == this.toRow && this.fromCell == this.toCell;\n  };\n\n  /***\n   * Returns whether a range contains a given cell.\n   * @method contains\n   * @param row {Integer}\n   * @param cell {Integer}\n   * @return {Boolean}\n   */\n  this.contains = function(row, cell) {\n    return row >= this.fromRow && row <= this.toRow && cell >= this.fromCell && cell <= this.toCell;\n  };\n\n  /***\n   * Returns a readable representation of a range.\n   * @method toString\n   * @return {String}\n   */\n  this.toString = function() {\n    if (this.isSingleCell()) {\n      return \"(\" + this.fromRow + \":\" + this.fromCell + \")\";\n    } else {\n      return \"(\" + this.fromRow + \":\" + this.fromCell + \" - \" + this.toRow + \":\" + this.toCell + \")\";\n    }\n  }\n}\n\n\n/***\n * A base class that all special / non-data rows (like Group and GroupTotals) derive from.\n * @class NonDataItem\n * @constructor\n */\nfunction NonDataItem() {\n  this.__nonDataRow = true;\n}\n\n\n/***\n * Information about a group of rows.\n * @class Group\n * @extends Slick.NonDataItem\n * @constructor\n */\nfunction Group() {\n  this.__group = true;\n\n  /**\n   * Grouping level, starting with 0.\n   * @property level\n   * @type {Number}\n   */\n  this.level = 0;\n\n  /***\n   * Number of rows in the group.\n   * @property count\n   * @type {Integer}\n   */\n  this.count = 0;\n\n  /***\n   * Grouping value.\n   * @property value\n   * @type {Object}\n   */\n  this.value = null;\n\n  /***\n   * Formatted display value of the group.\n   * @property title\n   * @type {String}\n   */\n  this.title = null;\n\n  /***\n   * Whether a group is collapsed.\n   * @property collapsed\n   * @type {Boolean}\n   */\n  this.collapsed = false;\n\n  /***\n   * GroupTotals, if any.\n   * @property totals\n   * @type {GroupTotals}\n   */\n  this.totals = null;\n\n  /**\n   * Rows that are part of the group.\n   * @property rows\n   * @type {Array}\n   */\n  this.rows = [];\n\n  /**\n   * Sub-groups that are part of the group.\n   * @property groups\n   * @type {Array}\n   */\n  this.groups = null;\n\n  /**\n   * A unique key used to identify the group.  This key can be used in calls to DataView\n   * collapseGroup() or expandGroup().\n   * @property groupingKey\n   * @type {Object}\n   */\n  this.groupingKey = null;\n}\n\nGroup.prototype = new NonDataItem();\n\n/***\n * Compares two Group instances.\n * @method equals\n * @return {Boolean}\n * @param group {Group} Group instance to compare to.\n */\nGroup.prototype.equals = function(group) {\n  return this.value === group.value && this.count === group.count && this.collapsed === group.collapsed && this.title === group.title;\n};\n\n/***\n * Information about group totals.\n * An instance of GroupTotals will be created for each totals row and passed to the aggregators\n * so that they can store arbitrary data in it.  That data can later be accessed by group totals\n * formatters during the display.\n * @class GroupTotals\n * @extends Slick.NonDataItem\n * @constructor\n */\nfunction GroupTotals() {\n  this.__groupTotals = true;\n\n  /***\n   * Parent Group.\n   * @param group\n   * @type {Group}\n   */\n  this.group = null;\n\n  /***\n   * Whether the totals have been fully initialized / calculated.\n   * Will be set to false for lazy-calculated group totals.\n   * @param initialized\n   * @type {Boolean}\n   */\n  this.initialized = false;\n}\n\nGroupTotals.prototype = new NonDataItem();\n\n/***\n * A locking helper to track the active edit controller and ensure that only a single controller\n * can be active at a time.  This prevents a whole class of state and validation synchronization\n * issues.  An edit controller (such as SlickGrid) can query if an active edit is in progress\n * and attempt a commit or cancel before proceeding.\n * @class EditorLock\n * @constructor\n */\nfunction EditorLock() {\n  var activeEditController = null;\n\n  /***\n   * Returns true if a specified edit controller is active (has the edit lock).\n   * If the parameter is not specified, returns true if any edit controller is active.\n   * @method isActive\n   * @param editController {EditController}\n   * @return {Boolean}\n   */\n  this.isActive = function(editController) {\n    return (editController ? activeEditController === editController : activeEditController !== null);\n  };\n\n  /***\n   * Sets the specified edit controller as the active edit controller (acquire edit lock).\n   * If another edit controller is already active, and exception will be thrown.\n   * @method activate\n   * @param editController {EditController} edit controller acquiring the lock\n   */\n  this.activate = function(editController) {\n    if (editController === activeEditController) { // already activated?\n      return;\n    }\n    if (activeEditController !== null) {\n      throw \"SlickGrid.EditorLock.activate: an editController is still active, can't activate another editController\";\n    }\n    if (!editController.commitCurrentEdit) {\n      throw \"SlickGrid.EditorLock.activate: editController must implement .commitCurrentEdit()\";\n    }\n    if (!editController.cancelCurrentEdit) {\n      throw \"SlickGrid.EditorLock.activate: editController must implement .cancelCurrentEdit()\";\n    }\n    activeEditController = editController;\n  };\n\n  /***\n   * Unsets the specified edit controller as the active edit controller (release edit lock).\n   * If the specified edit controller is not the active one, an exception will be thrown.\n   * @method deactivate\n   * @param editController {EditController} edit controller releasing the lock\n   */\n  this.deactivate = function(editController) {\n    if (activeEditController !== editController) {\n      throw \"SlickGrid.EditorLock.deactivate: specified editController is not the currently active one\";\n    }\n    activeEditController = null;\n  };\n\n  /***\n   * Attempts to commit the current edit by calling \"commitCurrentEdit\" method on the active edit\n   * controller and returns whether the commit attempt was successful (commit may fail due to validation\n   * errors, etc.).  Edit controller's \"commitCurrentEdit\" must return true if the commit has succeeded\n   * and false otherwise.  If no edit controller is active, returns true.\n   * @method commitCurrentEdit\n   * @return {Boolean}\n   */\n  this.commitCurrentEdit = function() {\n    return (activeEditController ? activeEditController.commitCurrentEdit() : true);\n  };\n\n  /***\n   * Attempts to cancel the current edit by calling \"cancelCurrentEdit\" method on the active edit\n   * controller and returns whether the edit was successfully cancelled.  If no edit controller is\n   * active, returns true.\n   * @method cancelCurrentEdit\n   * @return {Boolean}\n   */\n  this.cancelCurrentEdit = function cancelCurrentEdit() {\n    return (activeEditController ? activeEditController.cancelCurrentEdit() : true);\n  };\n}\n\n/**\n *\n * @param {Array} treeColumns Array com levels of columns\n * @returns {{hasDepth: 'hasDepth', getTreeColumns: 'getTreeColumns', extractColumns: 'extractColumns', getDepth: 'getDepth', getColumnsInDepth: 'getColumnsInDepth', getColumnsInGroup: 'getColumnsInGroup', visibleColumns: 'visibleColumns', filter: 'filter', reOrder: reOrder}}\n * @constructor\n */\nfunction TreeColumns(treeColumns) {\n\n  var columnsById = {};\n\n  function init() {\n    mapToId(treeColumns);\n  }\n\n  function mapToId(columns) {\n    columns.forEach(function(column) {\n      columnsById[column.id] = column;\n\n      if (column.columns) mapToId(column.columns);\n    });\n  }\n\n  function filter(node, condition) {\n\n    return node.filter(function(column) {\n\n      var valid = condition.call(column);\n\n      if (valid && column.columns) column.columns = filter(column.columns, condition);\n\n      return valid && (!column.columns || column.columns.length);\n    });\n\n  }\n\n  function sort(columns, grid) {\n    columns.sort(function(a, b) {\n      var indexA = getOrDefault(grid.getColumnIndex(a.id)),\n        indexB = getOrDefault(grid.getColumnIndex(b.id));\n\n      return indexA - indexB;\n    })\n      .forEach(function(column) {\n        if (column.columns) sort(column.columns, grid);\n      });\n  }\n\n  function getOrDefault(value) {\n    return typeof value === 'undefined' ? -1 : value;\n  }\n\n  function getDepth(node) {\n    if (node.length) for (var i in node)\n      return getDepth(node[i]);\n    else if (node.columns) return 1 + getDepth(node.columns);\n    else return 1;\n  }\n\n  function getColumnsInDepth(node, depth, current) {\n    var columns = [];\n    current = current || 0;\n\n    if (depth == current) {\n\n      if (node.length) node.forEach(function(n) {\n        if (n.columns) n.extractColumns = function() {\n          return extractColumns(n);\n        };\n      });\n\n      return node;\n    } else for (var i in node)\n      if (node[i].columns) {\n        columns = columns.concat(getColumnsInDepth(node[i].columns, depth, current + 1));\n      }\n\n    return columns;\n  }\n\n  function extractColumns(node) {\n    var result = [];\n\n    if (node.hasOwnProperty('length')) {\n\n      for (var i = 0; i < node.length; i++)\n        result = result.concat(extractColumns(node[i]));\n\n    } else {\n\n      if (node.hasOwnProperty('columns'))\n\n        result = result.concat(extractColumns(node.columns));\n\n      else return node;\n\n    }\n\n    return result;\n  }\n\n  function cloneTreeColumns() {\n    return $.extend(true, [], treeColumns);\n  }\n\n  init();\n\n  this.hasDepth = function() {\n\n    for (var i in treeColumns)\n      if (treeColumns[i].hasOwnProperty('columns')) return true;\n\n    return false;\n  };\n\n  this.getTreeColumns = function() {\n    return treeColumns;\n  };\n\n  this.extractColumns = function() {\n    return this.hasDepth() ? extractColumns(treeColumns) : treeColumns;\n  };\n\n  this.getDepth = function() {\n    return getDepth(treeColumns);\n  };\n\n  this.getColumnsInDepth = function(depth) {\n    return getColumnsInDepth(treeColumns, depth);\n  };\n\n  this.getColumnsInGroup = function(groups) {\n    return extractColumns(groups);\n  };\n\n  this.visibleColumns = function() {\n    return filter(cloneTreeColumns(), function() {\n      return this.visible;\n    });\n  };\n\n  this.filter = function(condition) {\n    return filter(cloneTreeColumns(), condition);\n  };\n\n  this.reOrder = function(grid) {\n    return sort(treeColumns, grid);\n  };\n\n  this.getById = function(id) {\n    return columnsById[id];\n  };\n\n  this.getInIds = function(ids) {\n    return ids.map(function(id) {\n      return columnsById[id];\n    });\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ../src/slick.core.js","module.exports = require(\"jquery\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"jquery\"\n// module id = 2\n// module chunks = 0","export {default as Slick} from './slick.core';\nexport {default as Data} from './slick.dataview';\nexport {default as Grid} from './slick-frozen.grid';\n\n\n\n// WEBPACK FOOTER //\n// ../src/index.js","/**\n * interact.js v1.2.6\n *\n * Copyright (c) 2012-2015 Taye Adeyemi <dev@taye.me>\n * Open source under the MIT License.\n * https://raw.github.com/taye/interact.js/master/LICENSE\n *\n * This file has been monkey patched to pass the originalEvent on to drag events\n */\n(function (realWindow) {\n  'use strict';\n\n  // return early if there's no window to work with (eg. Node.js)\n  if (!realWindow) { return; }\n\n  var // get wrapped window if using Shadow DOM polyfill\n    window = (function () {\n      // create a TextNode\n      var el = realWindow.document.createTextNode('');\n\n      // check if it's wrapped by a polyfill\n      if (el.ownerDocument !== realWindow.document\n        && typeof realWindow.wrap === 'function'\n        && realWindow.wrap(el) === el) {\n        // return wrapped window\n        return realWindow.wrap(realWindow);\n      }\n\n      // no Shadow DOM polyfil or native implementation\n      return realWindow;\n    }()),\n\n    document           = window.document,\n    DocumentFragment   = window.DocumentFragment   || blank,\n    SVGElement         = window.SVGElement         || blank,\n    SVGSVGElement      = window.SVGSVGElement      || blank,\n    SVGElementInstance = window.SVGElementInstance || blank,\n    HTMLElement        = window.HTMLElement        || window.Element,\n\n    PointerEvent = (window.PointerEvent || window.MSPointerEvent),\n    pEventTypes,\n\n    hypot = Math.hypot || function (x, y) { return Math.sqrt(x * x + y * y); },\n\n    tmpXY = {},     // reduce object creation in getXY()\n\n    documents       = [],   // all documents being listened to\n\n    interactables   = [],   // all set interactables\n    interactions    = [],   // all interactions\n\n    dynamicDrop     = false,\n\n    // {\n    //      type: {\n    //          selectors: ['selector', ...],\n    //          contexts : [document, ...],\n    //          listeners: [[listener, useCapture], ...]\n    //      }\n    //  }\n    delegatedEvents = {},\n\n    defaultOptions = {\n      base: {\n        accept        : null,\n        actionChecker : null,\n        styleCursor   : true,\n        preventDefault: 'auto',\n        origin        : { x: 0, y: 0 },\n        deltaSource   : 'page',\n        allowFrom     : null,\n        ignoreFrom    : null,\n        _context      : document,\n        dropChecker   : null\n      },\n\n      drag: {\n        enabled: false,\n        manualStart: true,\n        max: Infinity,\n        maxPerElement: 1,\n\n        snap: null,\n        restrict: null,\n        inertia: null,\n        autoScroll: null,\n\n        axis: 'xy'\n      },\n\n      drop: {\n        enabled: false,\n        accept: null,\n        overlap: 'pointer'\n      },\n\n      resize: {\n        enabled: false,\n        manualStart: false,\n        max: Infinity,\n        maxPerElement: 1,\n\n        snap: null,\n        restrict: null,\n        inertia: null,\n        autoScroll: null,\n\n        square: false,\n        preserveAspectRatio: false,\n        axis: 'xy',\n\n        // use default margin\n        margin: NaN,\n\n        // object with props left, right, top, bottom which are\n        // true/false values to resize when the pointer is over that edge,\n        // CSS selectors to match the handles for each direction\n        // or the Elements for each handle\n        edges: null,\n\n        // a value of 'none' will limit the resize rect to a minimum of 0x0\n        // 'negate' will alow the rect to have negative width/height\n        // 'reposition' will keep the width/height positive by swapping\n        // the top and bottom edges and/or swapping the left and right edges\n        invert: 'none'\n      },\n\n      gesture: {\n        manualStart: false,\n        enabled: false,\n        max: Infinity,\n        maxPerElement: 1,\n\n        restrict: null\n      },\n\n      perAction: {\n        manualStart: false,\n        max: Infinity,\n        maxPerElement: 1,\n\n        snap: {\n          enabled     : false,\n          endOnly     : false,\n          range       : Infinity,\n          targets     : null,\n          offsets     : null,\n\n          relativePoints: null\n        },\n\n        restrict: {\n          enabled: false,\n          endOnly: false\n        },\n\n        autoScroll: {\n          enabled     : false,\n          container   : null,     // the item that is scrolled (Window or HTMLElement)\n          margin      : 60,\n          speed       : 300       // the scroll speed in pixels per second\n        },\n\n        inertia: {\n          enabled          : false,\n          resistance       : 10,    // the lambda in exponential decay\n          minSpeed         : 100,   // target speed must be above this for inertia to start\n          endSpeed         : 10,    // the speed at which inertia is slow enough to stop\n          allowResume      : true,  // allow resuming an action in inertia phase\n          zeroResumeDelta  : true,  // if an action is resumed after launch, set dx/dy to 0\n          smoothEndDuration: 300    // animate to snap/restrict endOnly if there's no inertia\n        }\n      },\n\n      _holdDuration: 600\n    },\n\n    // Things related to autoScroll\n    autoScroll = {\n      interaction: null,\n      i: null,    // the handle returned by window.setInterval\n      x: 0, y: 0, // Direction each pulse is to scroll in\n\n      // scroll the window by the values in scroll.x/y\n      scroll: function () {\n        var options = autoScroll.interaction.target.options[autoScroll.interaction.prepared.name].autoScroll,\n          container = options.container || getWindow(autoScroll.interaction.element),\n          now = new Date().getTime(),\n          // change in time in seconds\n          dtx = (now - autoScroll.prevTimeX) / 1000,\n          dty = (now - autoScroll.prevTimeY) / 1000,\n          vx, vy, sx, sy;\n\n        // displacement\n        if (options.velocity) {\n          vx = options.velocity.x;\n          vy = options.velocity.y;\n        }\n        else {\n          vx = vy = options.speed\n        }\n\n        sx = vx * dtx;\n        sy = vy * dty;\n\n        if (sx >= 1 || sy >= 1) {\n          if (isWindow(container)) {\n            container.scrollBy(autoScroll.x * sx, autoScroll.y * sy);\n          }\n          else if (container) {\n            container.scrollLeft += autoScroll.x * sx;\n            container.scrollTop  += autoScroll.y * sy;\n          }\n\n          if (sx >=1) autoScroll.prevTimeX = now;\n          if (sy >= 1) autoScroll.prevTimeY = now;\n        }\n\n        if (autoScroll.isScrolling) {\n          cancelFrame(autoScroll.i);\n          autoScroll.i = reqFrame(autoScroll.scroll);\n        }\n      },\n\n      isScrolling: false,\n      prevTimeX: 0,\n      prevTimeY: 0,\n\n      start: function (interaction) {\n        autoScroll.isScrolling = true;\n        cancelFrame(autoScroll.i);\n\n        autoScroll.interaction = interaction;\n        autoScroll.prevTimeX = new Date().getTime();\n        autoScroll.prevTimeY = new Date().getTime();\n        autoScroll.i = reqFrame(autoScroll.scroll);\n      },\n\n      stop: function () {\n        autoScroll.isScrolling = false;\n        cancelFrame(autoScroll.i);\n      }\n    },\n\n    // Does the browser support touch input?\n    supportsTouch = (('ontouchstart' in window) || window.DocumentTouch && document instanceof window.DocumentTouch),\n\n    // Does the browser support PointerEvents\n    // Avoid PointerEvent bugs introduced in Chrome 55\n    supportsPointerEvent = PointerEvent && !/Chrome/.test(navigator.userAgent),\n\n    // Less Precision with touch input\n    margin = supportsTouch || supportsPointerEvent? 20: 10,\n\n    pointerMoveTolerance = 1,\n\n    // for ignoring browser's simulated mouse events\n    prevTouchTime = 0,\n\n    // Allow this many interactions to happen simultaneously\n    maxInteractions = Infinity,\n\n    // Check if is IE9 or older\n    actionCursors = (document.all && !window.atob) ? {\n      drag    : 'move',\n      resizex : 'e-resize',\n      resizey : 's-resize',\n      resizexy: 'se-resize',\n\n      resizetop        : 'n-resize',\n      resizeleft       : 'w-resize',\n      resizebottom     : 's-resize',\n      resizeright      : 'e-resize',\n      resizetopleft    : 'se-resize',\n      resizebottomright: 'se-resize',\n      resizetopright   : 'ne-resize',\n      resizebottomleft : 'ne-resize',\n\n      gesture : ''\n    } : {\n      drag    : 'move',\n      resizex : 'ew-resize',\n      resizey : 'ns-resize',\n      resizexy: 'nwse-resize',\n\n      resizetop        : 'ns-resize',\n      resizeleft       : 'ew-resize',\n      resizebottom     : 'ns-resize',\n      resizeright      : 'ew-resize',\n      resizetopleft    : 'nwse-resize',\n      resizebottomright: 'nwse-resize',\n      resizetopright   : 'nesw-resize',\n      resizebottomleft : 'nesw-resize',\n\n      gesture : ''\n    },\n\n    actionIsEnabled = {\n      drag   : true,\n      resize : true,\n      gesture: true\n    },\n\n    // because Webkit and Opera still use 'mousewheel' event type\n    wheelEvent = 'onmousewheel' in document? 'mousewheel': 'wheel',\n\n    eventTypes = [\n      'dragstart',\n      'dragmove',\n      'draginertiastart',\n      'dragend',\n      'dragenter',\n      'dragleave',\n      'dropactivate',\n      'dropdeactivate',\n      'dropmove',\n      'drop',\n      'resizestart',\n      'resizemove',\n      'resizeinertiastart',\n      'resizeend',\n      'gesturestart',\n      'gesturemove',\n      'gestureinertiastart',\n      'gestureend',\n\n      'down',\n      'move',\n      'up',\n      'cancel',\n      'tap',\n      'doubletap',\n      'hold'\n    ],\n\n    globalEvents = {},\n\n    // Opera Mobile must be handled differently\n    isOperaMobile = navigator.appName == 'Opera' &&\n      supportsTouch &&\n      navigator.userAgent.match('Presto'),\n\n    // scrolling doesn't change the result of getClientRects on iOS 7\n    isIOS7 = (/iP(hone|od|ad)/.test(navigator.platform)\n      && /OS 7[^\\d]/.test(navigator.appVersion)),\n\n    // prefix matchesSelector\n    prefixedMatchesSelector = 'matches' in Element.prototype?\n      'matches': 'webkitMatchesSelector' in Element.prototype?\n        'webkitMatchesSelector': 'mozMatchesSelector' in Element.prototype?\n          'mozMatchesSelector': 'oMatchesSelector' in Element.prototype?\n            'oMatchesSelector': 'msMatchesSelector',\n\n    // will be polyfill function if browser is IE8\n    ie8MatchesSelector,\n\n    // native requestAnimationFrame or polyfill\n    reqFrame = realWindow.requestAnimationFrame,\n    cancelFrame = realWindow.cancelAnimationFrame,\n\n    // Events wrapper\n    events = (function () {\n      var useAttachEvent = ('attachEvent' in window) && !('addEventListener' in window),\n        addEvent       = useAttachEvent?  'attachEvent': 'addEventListener',\n        removeEvent    = useAttachEvent?  'detachEvent': 'removeEventListener',\n        on             = useAttachEvent? 'on': '',\n\n        elements          = [],\n        targets           = [],\n        attachedListeners = [];\n\n      function add (element, type, listener, useCapture) {\n        var elementIndex = indexOf(elements, element),\n          target = targets[elementIndex];\n\n        if (!target) {\n          target = {\n            events: {},\n            typeCount: 0\n          };\n\n          elementIndex = elements.push(element) - 1;\n          targets.push(target);\n\n          attachedListeners.push((useAttachEvent ? {\n            supplied: [],\n            wrapped : [],\n            useCount: []\n          } : null));\n        }\n\n        if (!target.events[type]) {\n          target.events[type] = [];\n          target.typeCount++;\n        }\n\n        if (!contains(target.events[type], listener)) {\n          var ret;\n\n          if (useAttachEvent) {\n            var listeners = attachedListeners[elementIndex],\n              listenerIndex = indexOf(listeners.supplied, listener);\n\n            var wrapped = listeners.wrapped[listenerIndex] || function (event) {\n              if (!event.immediatePropagationStopped) {\n                event.target = event.srcElement;\n                event.currentTarget = element;\n\n                event.preventDefault = event.preventDefault || preventDef;\n                event.stopPropagation = event.stopPropagation || stopProp;\n                event.stopImmediatePropagation = event.stopImmediatePropagation || stopImmProp;\n\n                if (/mouse|click/.test(event.type)) {\n                  event.pageX = event.clientX + getWindow(element).document.documentElement.scrollLeft;\n                  event.pageY = event.clientY + getWindow(element).document.documentElement.scrollTop;\n                }\n\n                listener(event);\n              }\n            };\n\n            ret = element[addEvent](on + type, wrapped, Boolean(useCapture));\n\n            if (listenerIndex === -1) {\n              listeners.supplied.push(listener);\n              listeners.wrapped.push(wrapped);\n              listeners.useCount.push(1);\n            }\n            else {\n              listeners.useCount[listenerIndex]++;\n            }\n          }\n          else {\n            ret = element[addEvent](type, listener, useCapture || false);\n          }\n          target.events[type].push(listener);\n\n          return ret;\n        }\n      }\n\n      function remove (element, type, listener, useCapture) {\n        var i,\n          elementIndex = indexOf(elements, element),\n          target = targets[elementIndex],\n          listeners,\n          listenerIndex,\n          wrapped = listener;\n\n        if (!target || !target.events) {\n          return;\n        }\n\n        if (useAttachEvent) {\n          listeners = attachedListeners[elementIndex];\n          listenerIndex = indexOf(listeners.supplied, listener);\n          wrapped = listeners.wrapped[listenerIndex];\n        }\n\n        if (type === 'all') {\n          for (type in target.events) {\n            if (target.events.hasOwnProperty(type)) {\n              remove(element, type, 'all');\n            }\n          }\n          return;\n        }\n\n        if (target.events[type]) {\n          var len = target.events[type].length;\n\n          if (listener === 'all') {\n            for (i = 0; i < len; i++) {\n              remove(element, type, target.events[type][i], Boolean(useCapture));\n            }\n            return;\n          } else {\n            for (i = 0; i < len; i++) {\n              if (target.events[type][i] === listener) {\n                element[removeEvent](on + type, wrapped, useCapture || false);\n                target.events[type].splice(i, 1);\n\n                if (useAttachEvent && listeners) {\n                  listeners.useCount[listenerIndex]--;\n                  if (listeners.useCount[listenerIndex] === 0) {\n                    listeners.supplied.splice(listenerIndex, 1);\n                    listeners.wrapped.splice(listenerIndex, 1);\n                    listeners.useCount.splice(listenerIndex, 1);\n                  }\n                }\n\n                break;\n              }\n            }\n          }\n\n          if (target.events[type] && target.events[type].length === 0) {\n            target.events[type] = null;\n            target.typeCount--;\n          }\n        }\n\n        if (!target.typeCount) {\n          targets.splice(elementIndex, 1);\n          elements.splice(elementIndex, 1);\n          attachedListeners.splice(elementIndex, 1);\n        }\n      }\n\n      function preventDef () {\n        this.returnValue = false;\n      }\n\n      function stopProp () {\n        this.cancelBubble = true;\n      }\n\n      function stopImmProp () {\n        this.cancelBubble = true;\n        this.immediatePropagationStopped = true;\n      }\n\n      return {\n        add: add,\n        remove: remove,\n        useAttachEvent: useAttachEvent,\n\n        _elements: elements,\n        _targets: targets,\n        _attachedListeners: attachedListeners\n      };\n    }());\n\n  function blank () {}\n\n  function isElement (o) {\n    if (!o || (typeof o !== 'object')) { return false; }\n\n    var _window = getWindow(o) || window;\n\n    return (/object|function/.test(typeof _window.Element)\n      ? o instanceof _window.Element //DOM2\n      : o.nodeType === 1 && typeof o.nodeName === \"string\");\n  }\n  function isWindow (thing) { return thing === window || !!(thing && thing.Window) && (thing instanceof thing.Window); }\n  function isDocFrag (thing) { return !!thing && thing instanceof DocumentFragment; }\n  function isArray (thing) {\n    return isObject(thing)\n      && (typeof thing.length !== undefined)\n      && isFunction(thing.splice);\n  }\n  function isObject   (thing) { return !!thing && (typeof thing === 'object'); }\n  function isFunction (thing) { return typeof thing === 'function'; }\n  function isNumber   (thing) { return typeof thing === 'number'  ; }\n  function isBool     (thing) { return typeof thing === 'boolean' ; }\n  function isString   (thing) { return typeof thing === 'string'  ; }\n\n  function trySelector (value) {\n    if (!isString(value)) { return false; }\n\n    // an exception will be raised if it is invalid\n    document.querySelector(value);\n    return true;\n  }\n\n  function extend (dest, source) {\n    for (var prop in source) {\n      dest[prop] = source[prop];\n    }\n    return dest;\n  }\n\n  var prefixedPropREs = {\n    webkit: /(Movement[XY]|Radius[XY]|RotationAngle|Force)$/\n  };\n\n  function pointerExtend (dest, source) {\n    for (var prop in source) {\n      var deprecated = false;\n\n      // skip deprecated prefixed properties\n      for (var vendor in prefixedPropREs) {\n        if (prop.indexOf(vendor) === 0 && prefixedPropREs[vendor].test(prop)) {\n          deprecated = true;\n          break;\n        }\n      }\n\n      if (!deprecated) {\n        dest[prop] = source[prop];\n      }\n    }\n    return dest;\n  }\n\n  function copyCoords (dest, src) {\n    dest.page = dest.page || {};\n    dest.page.x = src.page.x;\n    dest.page.y = src.page.y;\n\n    dest.client = dest.client || {};\n    dest.client.x = src.client.x;\n    dest.client.y = src.client.y;\n\n    dest.timeStamp = src.timeStamp;\n  }\n\n  function setEventXY (targetObj, pointers, interaction) {\n    var pointer = (pointers.length > 1\n      ? pointerAverage(pointers)\n      : pointers[0]);\n\n    getPageXY(pointer, tmpXY, interaction);\n    targetObj.page.x = tmpXY.x;\n    targetObj.page.y = tmpXY.y;\n\n    getClientXY(pointer, tmpXY, interaction);\n    targetObj.client.x = tmpXY.x;\n    targetObj.client.y = tmpXY.y;\n\n    targetObj.timeStamp = new Date().getTime();\n  }\n\n  function setEventDeltas (targetObj, prev, cur) {\n    targetObj.page.x     = cur.page.x      - prev.page.x;\n    targetObj.page.y     = cur.page.y      - prev.page.y;\n    targetObj.client.x   = cur.client.x    - prev.client.x;\n    targetObj.client.y   = cur.client.y    - prev.client.y;\n    targetObj.timeStamp = new Date().getTime() - prev.timeStamp;\n\n    // set pointer velocity\n    var dt = Math.max(targetObj.timeStamp / 1000, 0.001);\n    targetObj.page.speed   = hypot(targetObj.page.x, targetObj.page.y) / dt;\n    targetObj.page.vx      = targetObj.page.x / dt;\n    targetObj.page.vy      = targetObj.page.y / dt;\n\n    targetObj.client.speed = hypot(targetObj.client.x, targetObj.page.y) / dt;\n    targetObj.client.vx    = targetObj.client.x / dt;\n    targetObj.client.vy    = targetObj.client.y / dt;\n  }\n\n  function isNativePointer (pointer) {\n    return (pointer instanceof window.Event\n      || (supportsTouch && window.Touch && pointer instanceof window.Touch));\n  }\n\n  // Get specified X/Y coords for mouse or event.touches[0]\n  function getXY (type, pointer, xy) {\n    xy = xy || {};\n    type = type || 'page';\n\n    xy.x = pointer[type + 'X'];\n    xy.y = pointer[type + 'Y'];\n\n    return xy;\n  }\n\n  function getPageXY (pointer, page) {\n    page = page || {};\n\n    // Opera Mobile handles the viewport and scrolling oddly\n    if (isOperaMobile && isNativePointer(pointer)) {\n      getXY('screen', pointer, page);\n\n      page.x += window.scrollX;\n      page.y += window.scrollY;\n    }\n    else {\n      getXY('page', pointer, page);\n    }\n\n    return page;\n  }\n\n  function getClientXY (pointer, client) {\n    client = client || {};\n\n    if (isOperaMobile && isNativePointer(pointer)) {\n      // Opera Mobile handles the viewport and scrolling oddly\n      getXY('screen', pointer, client);\n    }\n    else {\n      getXY('client', pointer, client);\n    }\n\n    return client;\n  }\n\n  function getScrollXY (win) {\n    win = win || window;\n    return {\n      x: win.scrollX || win.document.documentElement.scrollLeft,\n      y: win.scrollY || win.document.documentElement.scrollTop\n    };\n  }\n\n  function getPointerId (pointer) {\n    return isNumber(pointer.pointerId)? pointer.pointerId : pointer.identifier;\n  }\n\n  function getActualElement (element) {\n    return (element instanceof SVGElementInstance\n      ? element.correspondingUseElement\n      : element);\n  }\n\n  function getWindow (node) {\n    if (isWindow(node)) {\n      return node;\n    }\n\n    var rootNode = (node.ownerDocument || node);\n\n    return rootNode.defaultView || rootNode.parentWindow || window;\n  }\n\n  function getElementClientRect (element) {\n    var clientRect = (element instanceof SVGElement\n      ? element.getBoundingClientRect()\n      : element.getClientRects()[0]);\n\n    return clientRect && {\n      left  : clientRect.left,\n      right : clientRect.right,\n      top   : clientRect.top,\n      bottom: clientRect.bottom,\n      width : clientRect.width || clientRect.right - clientRect.left,\n      height: clientRect.height || clientRect.bottom - clientRect.top\n    };\n  }\n\n  function getElementRect (element) {\n    var clientRect = getElementClientRect(element);\n\n    if (!isIOS7 && clientRect) {\n      var scroll = getScrollXY(getWindow(element));\n\n      clientRect.left   += scroll.x;\n      clientRect.right  += scroll.x;\n      clientRect.top    += scroll.y;\n      clientRect.bottom += scroll.y;\n    }\n\n    return clientRect;\n  }\n\n  function getTouchPair (event) {\n    var touches = [];\n\n    // array of touches is supplied\n    if (isArray(event)) {\n      touches[0] = event[0];\n      touches[1] = event[1];\n    }\n    // an event\n    else {\n      if (event.type === 'touchend') {\n        if (event.touches.length === 1) {\n          touches[0] = event.touches[0];\n          touches[1] = event.changedTouches[0];\n        }\n        else if (event.touches.length === 0) {\n          touches[0] = event.changedTouches[0];\n          touches[1] = event.changedTouches[1];\n        }\n      }\n      else {\n        touches[0] = event.touches[0];\n        touches[1] = event.touches[1];\n      }\n    }\n\n    return touches;\n  }\n\n  function pointerAverage (pointers) {\n    var average = {\n      pageX  : 0,\n      pageY  : 0,\n      clientX: 0,\n      clientY: 0,\n      screenX: 0,\n      screenY: 0\n    };\n    var prop;\n\n    for (var i = 0; i < pointers.length; i++) {\n      for (prop in average) {\n        average[prop] += pointers[i][prop];\n      }\n    }\n    for (prop in average) {\n      average[prop] /= pointers.length;\n    }\n\n    return average;\n  }\n\n  function touchBBox (event) {\n    if (!event.length && !(event.touches && event.touches.length > 1)) {\n      return;\n    }\n\n    var touches = getTouchPair(event),\n      minX = Math.min(touches[0].pageX, touches[1].pageX),\n      minY = Math.min(touches[0].pageY, touches[1].pageY),\n      maxX = Math.max(touches[0].pageX, touches[1].pageX),\n      maxY = Math.max(touches[0].pageY, touches[1].pageY);\n\n    return {\n      x: minX,\n      y: minY,\n      left: minX,\n      top: minY,\n      width: maxX - minX,\n      height: maxY - minY\n    };\n  }\n\n  function touchDistance (event, deltaSource) {\n    deltaSource = deltaSource || defaultOptions.deltaSource;\n\n    var sourceX = deltaSource + 'X',\n      sourceY = deltaSource + 'Y',\n      touches = getTouchPair(event);\n\n\n    var dx = touches[0][sourceX] - touches[1][sourceX],\n      dy = touches[0][sourceY] - touches[1][sourceY];\n\n    return hypot(dx, dy);\n  }\n\n  function touchAngle (event, prevAngle, deltaSource) {\n    deltaSource = deltaSource || defaultOptions.deltaSource;\n\n    var sourceX = deltaSource + 'X',\n      sourceY = deltaSource + 'Y',\n      touches = getTouchPair(event),\n      dx = touches[0][sourceX] - touches[1][sourceX],\n      dy = touches[0][sourceY] - touches[1][sourceY],\n      angle = 180 * Math.atan(dy / dx) / Math.PI;\n\n    if (isNumber(prevAngle)) {\n      var dr = angle - prevAngle,\n        drClamped = dr % 360;\n\n      if (drClamped > 315) {\n        angle -= 360 + (angle / 360)|0 * 360;\n      }\n      else if (drClamped > 135) {\n        angle -= 180 + (angle / 360)|0 * 360;\n      }\n      else if (drClamped < -315) {\n        angle += 360 + (angle / 360)|0 * 360;\n      }\n      else if (drClamped < -135) {\n        angle += 180 + (angle / 360)|0 * 360;\n      }\n    }\n\n    return  angle;\n  }\n\n  function getOriginXY (interactable, element) {\n    var origin = interactable\n      ? interactable.options.origin\n      : defaultOptions.origin;\n\n    if (origin === 'parent') {\n      origin = parentElement(element);\n    }\n    else if (origin === 'self') {\n      origin = interactable.getRect(element);\n    }\n    else if (trySelector(origin)) {\n      origin = closest(element, origin) || { x: 0, y: 0 };\n    }\n\n    if (isFunction(origin)) {\n      origin = origin(interactable && element);\n    }\n\n    if (isElement(origin))  {\n      origin = getElementRect(origin);\n    }\n\n    origin.x = ('x' in origin)? origin.x : origin.left;\n    origin.y = ('y' in origin)? origin.y : origin.top;\n\n    return origin;\n  }\n\n  // http://stackoverflow.com/a/5634528/2280888\n  function _getQBezierValue(t, p1, p2, p3) {\n    var iT = 1 - t;\n    return iT * iT * p1 + 2 * iT * t * p2 + t * t * p3;\n  }\n\n  function getQuadraticCurvePoint(startX, startY, cpX, cpY, endX, endY, position) {\n    return {\n      x:  _getQBezierValue(position, startX, cpX, endX),\n      y:  _getQBezierValue(position, startY, cpY, endY)\n    };\n  }\n\n  // http://gizma.com/easing/\n  function easeOutQuad (t, b, c, d) {\n    t /= d;\n    return -c * t*(t-2) + b;\n  }\n\n  function nodeContains (parent, child) {\n    while (child) {\n      if (child === parent) {\n        return true;\n      }\n\n      child = child.parentNode;\n    }\n\n    return false;\n  }\n\n  function closest (child, selector) {\n    var parent = parentElement(child);\n\n    while (isElement(parent)) {\n      if (matchesSelector(parent, selector)) { return parent; }\n\n      parent = parentElement(parent);\n    }\n\n    return null;\n  }\n\n  function parentElement (node) {\n    var parent = node.parentNode;\n\n    if (isDocFrag(parent)) {\n      // skip past #shado-root fragments\n      while ((parent = parent.host) && isDocFrag(parent)) {}\n\n      return parent;\n    }\n\n    return parent;\n  }\n\n  function inContext (interactable, element) {\n    return interactable._context === element.ownerDocument\n      || nodeContains(interactable._context, element);\n  }\n\n  function testIgnore (interactable, interactableElement, element) {\n    var ignoreFrom = interactable.options.ignoreFrom;\n\n    if (!ignoreFrom || !isElement(element)) { return false; }\n\n    if (isString(ignoreFrom)) {\n      return matchesUpTo(element, ignoreFrom, interactableElement);\n    }\n    else if (isElement(ignoreFrom)) {\n      return nodeContains(ignoreFrom, element);\n    }\n\n    return false;\n  }\n\n  function testAllow (interactable, interactableElement, element) {\n    var allowFrom = interactable.options.allowFrom;\n\n    if (!allowFrom) { return true; }\n\n    if (!isElement(element)) { return false; }\n\n    if (isString(allowFrom)) {\n      return matchesUpTo(element, allowFrom, interactableElement);\n    }\n    else if (isElement(allowFrom)) {\n      return nodeContains(allowFrom, element);\n    }\n\n    return false;\n  }\n\n  function checkAxis (axis, interactable) {\n    if (!interactable) { return false; }\n\n    var thisAxis = interactable.options.drag.axis;\n\n    return (axis === 'xy' || thisAxis === 'xy' || thisAxis === axis);\n  }\n\n  function checkSnap (interactable, action) {\n    var options = interactable.options;\n\n    if (/^resize/.test(action)) {\n      action = 'resize';\n    }\n\n    return options[action].snap && options[action].snap.enabled;\n  }\n\n  function checkRestrict (interactable, action) {\n    var options = interactable.options;\n\n    if (/^resize/.test(action)) {\n      action = 'resize';\n    }\n\n    return  options[action].restrict && options[action].restrict.enabled;\n  }\n\n  function checkAutoScroll (interactable, action) {\n    var options = interactable.options;\n\n    if (/^resize/.test(action)) {\n      action = 'resize';\n    }\n\n    return  options[action].autoScroll && options[action].autoScroll.enabled;\n  }\n\n  function withinInteractionLimit (interactable, element, action) {\n    var options = interactable.options,\n      maxActions = options[action.name].max,\n      maxPerElement = options[action.name].maxPerElement,\n      activeInteractions = 0,\n      targetCount = 0,\n      targetElementCount = 0;\n\n    for (var i = 0, len = interactions.length; i < len; i++) {\n      var interaction = interactions[i],\n        otherAction = interaction.prepared.name,\n        active = interaction.interacting();\n\n      if (!active) { continue; }\n\n      activeInteractions++;\n\n      if (activeInteractions >= maxInteractions) {\n        return false;\n      }\n\n      if (interaction.target !== interactable) { continue; }\n\n      targetCount += (otherAction === action.name)|0;\n\n      if (targetCount >= maxActions) {\n        return false;\n      }\n\n      if (interaction.element === element) {\n        targetElementCount++;\n\n        if (otherAction !== action.name || targetElementCount >= maxPerElement) {\n          return false;\n        }\n      }\n    }\n\n    return maxInteractions > 0;\n  }\n\n  // Test for the element that's \"above\" all other qualifiers\n  function indexOfDeepestElement (elements) {\n    var dropzone,\n      deepestZone = elements[0],\n      index = deepestZone? 0: -1,\n      parent,\n      deepestZoneParents = [],\n      dropzoneParents = [],\n      child,\n      i,\n      n;\n\n    for (i = 1; i < elements.length; i++) {\n      dropzone = elements[i];\n\n      // an element might belong to multiple selector dropzones\n      if (!dropzone || dropzone === deepestZone) {\n        continue;\n      }\n\n      if (!deepestZone) {\n        deepestZone = dropzone;\n        index = i;\n        continue;\n      }\n\n      // check if the deepest or current are document.documentElement or document.rootElement\n      // - if the current dropzone is, do nothing and continue\n      if (dropzone.parentNode === dropzone.ownerDocument) {\n        continue;\n      }\n      // - if deepest is, update with the current dropzone and continue to next\n      else if (deepestZone.parentNode === dropzone.ownerDocument) {\n        deepestZone = dropzone;\n        index = i;\n        continue;\n      }\n\n      if (!deepestZoneParents.length) {\n        parent = deepestZone;\n        while (parent.parentNode && parent.parentNode !== parent.ownerDocument) {\n          deepestZoneParents.unshift(parent);\n          parent = parent.parentNode;\n        }\n      }\n\n      // if this element is an svg element and the current deepest is\n      // an HTMLElement\n      if (deepestZone instanceof HTMLElement\n        && dropzone instanceof SVGElement\n        && !(dropzone instanceof SVGSVGElement)) {\n\n        if (dropzone === deepestZone.parentNode) {\n          continue;\n        }\n\n        parent = dropzone.ownerSVGElement;\n      }\n      else {\n        parent = dropzone;\n      }\n\n      dropzoneParents = [];\n\n      while (parent.parentNode !== parent.ownerDocument) {\n        dropzoneParents.unshift(parent);\n        parent = parent.parentNode;\n      }\n\n      n = 0;\n\n      // get (position of last common ancestor) + 1\n      while (dropzoneParents[n] && dropzoneParents[n] === deepestZoneParents[n]) {\n        n++;\n      }\n\n      var parents = [\n        dropzoneParents[n - 1],\n        dropzoneParents[n],\n        deepestZoneParents[n]\n      ];\n\n      child = parents[0].lastChild;\n\n      while (child) {\n        if (child === parents[1]) {\n          deepestZone = dropzone;\n          index = i;\n          deepestZoneParents = [];\n\n          break;\n        }\n        else if (child === parents[2]) {\n          break;\n        }\n\n        child = child.previousSibling;\n      }\n    }\n\n    return index;\n  }\n\n  function Interaction () {\n    this.target          = null; // current interactable being interacted with\n    this.element         = null; // the target element of the interactable\n    this.dropTarget      = null; // the dropzone a drag target might be dropped into\n    this.dropElement     = null; // the element at the time of checking\n    this.prevDropTarget  = null; // the dropzone that was recently dragged away from\n    this.prevDropElement = null; // the element at the time of checking\n\n    this.prepared        = {     // action that's ready to be fired on next move event\n      name : null,\n      axis : null,\n      edges: null\n    };\n\n    this.matches         = [];   // all selectors that are matched by target element\n    this.matchElements   = [];   // corresponding elements\n\n    this.inertiaStatus = {\n      active       : false,\n      smoothEnd    : false,\n      ending       : false,\n\n      startEvent: null,\n      upCoords: {},\n\n      xe: 0, ye: 0,\n      sx: 0, sy: 0,\n\n      t0: 0,\n      vx0: 0, vys: 0,\n      duration: 0,\n\n      resumeDx: 0,\n      resumeDy: 0,\n\n      lambda_v0: 0,\n      one_ve_v0: 0,\n      i  : null\n    };\n\n    if (isFunction(Function.prototype.bind)) {\n      this.boundInertiaFrame = this.inertiaFrame.bind(this);\n      this.boundSmoothEndFrame = this.smoothEndFrame.bind(this);\n    }\n    else {\n      var that = this;\n\n      this.boundInertiaFrame = function () { return that.inertiaFrame(); };\n      this.boundSmoothEndFrame = function () { return that.smoothEndFrame(); };\n    }\n\n    this.activeDrops = {\n      dropzones: [],      // the dropzones that are mentioned below\n      elements : [],      // elements of dropzones that accept the target draggable\n      rects    : []       // the rects of the elements mentioned above\n    };\n\n    // keep track of added pointers\n    this.pointers    = [];\n    this.pointerIds  = [];\n    this.downTargets = [];\n    this.downTimes   = [];\n    this.holdTimers  = [];\n\n    // Previous native pointer move event coordinates\n    this.prevCoords = {\n      page     : { x: 0, y: 0 },\n      client   : { x: 0, y: 0 },\n      timeStamp: 0\n    };\n    // current native pointer move event coordinates\n    this.curCoords = {\n      page     : { x: 0, y: 0 },\n      client   : { x: 0, y: 0 },\n      timeStamp: 0\n    };\n\n    // Starting InteractEvent pointer coordinates\n    this.startCoords = {\n      page     : { x: 0, y: 0 },\n      client   : { x: 0, y: 0 },\n      timeStamp: 0\n    };\n\n    // Change in coordinates and time of the pointer\n    this.pointerDelta = {\n      page     : { x: 0, y: 0, vx: 0, vy: 0, speed: 0 },\n      client   : { x: 0, y: 0, vx: 0, vy: 0, speed: 0 },\n      timeStamp: 0\n    };\n\n    this.downEvent   = null;    // pointerdown/mousedown/touchstart event\n    this.downPointer = {};\n\n    this._eventTarget    = null;\n    this._curEventTarget = null;\n\n    this.prevEvent = null;      // previous action event\n    this.tapTime   = 0;         // time of the most recent tap event\n    this.prevTap   = null;\n\n    this.startOffset    = { left: 0, right: 0, top: 0, bottom: 0 };\n    this.restrictOffset = { left: 0, right: 0, top: 0, bottom: 0 };\n    this.snapOffsets    = [];\n\n    this.gesture = {\n      start: { x: 0, y: 0 },\n\n      startDistance: 0,   // distance between two touches of touchStart\n      prevDistance : 0,\n      distance     : 0,\n\n      scale: 1,           // gesture.distance / gesture.startDistance\n\n      startAngle: 0,      // angle of line joining two touches\n      prevAngle : 0       // angle of the previous gesture event\n    };\n\n    this.snapStatus = {\n      x       : 0, y       : 0,\n      dx      : 0, dy      : 0,\n      realX   : 0, realY   : 0,\n      snappedX: 0, snappedY: 0,\n      targets : [],\n      locked  : false,\n      changed : false\n    };\n\n    this.restrictStatus = {\n      dx         : 0, dy         : 0,\n      restrictedX: 0, restrictedY: 0,\n      snap       : null,\n      restricted : false,\n      changed    : false\n    };\n\n    this.restrictStatus.snap = this.snapStatus;\n\n    this.pointerIsDown   = false;\n    this.pointerWasMoved = false;\n    this.gesturing       = false;\n    this.dragging        = false;\n    this.resizing        = false;\n    this.resizeAxes      = 'xy';\n\n    this.mouse = false;\n\n    interactions.push(this);\n  }\n\n  Interaction.prototype = {\n    getPageXY  : function (pointer, xy) { return   getPageXY(pointer, xy, this); },\n    getClientXY: function (pointer, xy) { return getClientXY(pointer, xy, this); },\n    setEventXY : function (target, ptr) { return  setEventXY(target, ptr, this); },\n\n    pointerOver: function (pointer, event, eventTarget) {\n      if (this.prepared.name || !this.mouse) { return; }\n\n      var curMatches = [],\n        curMatchElements = [],\n        prevTargetElement = this.element;\n\n      this.addPointer(pointer);\n\n      if (this.target\n        && (testIgnore(this.target, this.element, eventTarget)\n          || !testAllow(this.target, this.element, eventTarget))) {\n        // if the eventTarget should be ignored or shouldn't be allowed\n        // clear the previous target\n        this.target = null;\n        this.element = null;\n        this.matches = [];\n        this.matchElements = [];\n      }\n\n      var elementInteractable = interactables.get(eventTarget),\n        elementAction = (elementInteractable\n          && !testIgnore(elementInteractable, eventTarget, eventTarget)\n          && testAllow(elementInteractable, eventTarget, eventTarget)\n          && validateAction(\n            elementInteractable.getAction(pointer, event, this, eventTarget),\n            elementInteractable));\n\n      if (elementAction && !withinInteractionLimit(elementInteractable, eventTarget, elementAction)) {\n        elementAction = null;\n      }\n\n      function pushCurMatches (interactable, selector) {\n        if (interactable\n          && inContext(interactable, eventTarget)\n          && !testIgnore(interactable, eventTarget, eventTarget)\n          && testAllow(interactable, eventTarget, eventTarget)\n          && matchesSelector(eventTarget, selector)) {\n\n          curMatches.push(interactable);\n          curMatchElements.push(eventTarget);\n        }\n      }\n\n      if (elementAction) {\n        this.target = elementInteractable;\n        this.element = eventTarget;\n        this.matches = [];\n        this.matchElements = [];\n      }\n      else {\n        interactables.forEachSelector(pushCurMatches);\n\n        if (this.validateSelector(pointer, event, curMatches, curMatchElements)) {\n          this.matches = curMatches;\n          this.matchElements = curMatchElements;\n\n          this.pointerHover(pointer, event, this.matches, this.matchElements);\n          events.add(eventTarget,\n            supportsPointerEvent? pEventTypes.move : 'mousemove',\n            listeners.pointerHover);\n        }\n        else if (this.target) {\n          if (nodeContains(prevTargetElement, eventTarget)) {\n            this.pointerHover(pointer, event, this.matches, this.matchElements);\n            events.add(this.element,\n              supportsPointerEvent? pEventTypes.move : 'mousemove',\n              listeners.pointerHover);\n          }\n          else {\n            this.target = null;\n            this.element = null;\n            this.matches = [];\n            this.matchElements = [];\n          }\n        }\n      }\n    },\n\n    // Check what action would be performed on pointerMove target if a mouse\n    // button were pressed and change the cursor accordingly\n    pointerHover: function (pointer, event, eventTarget, curEventTarget, matches, matchElements) {\n      var target = this.target;\n\n      if (!this.prepared.name && this.mouse) {\n\n        var action;\n\n        // update pointer coords for defaultActionChecker to use\n        this.setEventXY(this.curCoords, [pointer]);\n\n        if (matches) {\n          action = this.validateSelector(pointer, event, matches, matchElements);\n        }\n        else if (target) {\n          action = validateAction(target.getAction(this.pointers[0], event, this, this.element), this.target);\n        }\n\n        if (target && target.options.styleCursor) {\n          if (action) {\n            target._doc.documentElement.style.cursor = getActionCursor(action);\n          }\n          else {\n            target._doc.documentElement.style.cursor = '';\n          }\n        }\n      }\n      else if (this.prepared.name) {\n        this.checkAndPreventDefault(event, target, this.element);\n      }\n    },\n\n    pointerOut: function (pointer, event, eventTarget) {\n      if (this.prepared.name) { return; }\n\n      // Remove temporary event listeners for selector Interactables\n      if (!interactables.get(eventTarget)) {\n        events.remove(eventTarget,\n          supportsPointerEvent? pEventTypes.move : 'mousemove',\n          listeners.pointerHover);\n      }\n\n      if (this.target && this.target.options.styleCursor && !this.interacting()) {\n        this.target._doc.documentElement.style.cursor = '';\n      }\n    },\n\n    selectorDown: function (pointer, event, eventTarget, curEventTarget) {\n      var that = this,\n        // copy event to be used in timeout for IE8\n        eventCopy = events.useAttachEvent? extend({}, event) : event,\n        element = eventTarget,\n        pointerIndex = this.addPointer(pointer),\n        action;\n\n      this.holdTimers[pointerIndex] = setTimeout(function () {\n        that.pointerHold(events.useAttachEvent? eventCopy : pointer, eventCopy, eventTarget, curEventTarget);\n      }, defaultOptions._holdDuration);\n\n      this.pointerIsDown = true;\n\n      // Check if the down event hits the current inertia target\n      if (this.inertiaStatus.active && this.target.selector) {\n        // climb up the DOM tree from the event target\n        while (isElement(element)) {\n\n          // if this element is the current inertia target element\n          if (element === this.element\n            // and the prospective action is the same as the ongoing one\n            && validateAction(this.target.getAction(pointer, event, this, this.element), this.target).name === this.prepared.name) {\n\n            // stop inertia so that the next move will be a normal one\n            cancelFrame(this.inertiaStatus.i);\n            this.inertiaStatus.active = false;\n\n            this.collectEventTargets(pointer, event, eventTarget, 'down');\n            return;\n          }\n          element = parentElement(element);\n        }\n      }\n\n      // do nothing if interacting\n      if (this.interacting()) {\n        this.collectEventTargets(pointer, event, eventTarget, 'down');\n        return;\n      }\n\n      function pushMatches (interactable, selector, context) {\n        var elements = ie8MatchesSelector\n          ? context.querySelectorAll(selector)\n          : undefined;\n\n        if (inContext(interactable, element)\n          && !testIgnore(interactable, element, eventTarget)\n          && testAllow(interactable, element, eventTarget)\n          && matchesSelector(element, selector, elements)) {\n\n          that.matches.push(interactable);\n          that.matchElements.push(element);\n        }\n      }\n\n      // update pointer coords for defaultActionChecker to use\n      this.setEventXY(this.curCoords, [pointer]);\n      this.downEvent = event;\n\n      while (isElement(element) && !action) {\n        this.matches = [];\n        this.matchElements = [];\n\n        interactables.forEachSelector(pushMatches);\n\n        action = this.validateSelector(pointer, event, this.matches, this.matchElements);\n        element = parentElement(element);\n      }\n\n      if (action) {\n        this.prepared.name  = action.name;\n        this.prepared.axis  = action.axis;\n        this.prepared.edges = action.edges;\n\n        this.collectEventTargets(pointer, event, eventTarget, 'down');\n\n        return this.pointerDown(pointer, event, eventTarget, curEventTarget, action);\n      }\n      else {\n        // do these now since pointerDown isn't being called from here\n        this.downTimes[pointerIndex] = new Date().getTime();\n        this.downTargets[pointerIndex] = eventTarget;\n        pointerExtend(this.downPointer, pointer);\n\n        copyCoords(this.prevCoords, this.curCoords);\n        this.pointerWasMoved = false;\n      }\n\n      this.collectEventTargets(pointer, event, eventTarget, 'down');\n    },\n\n    // Determine action to be performed on next pointerMove and add appropriate\n    // style and event Listeners\n    pointerDown: function (pointer, event, eventTarget, curEventTarget, forceAction) {\n      if (!forceAction && !this.inertiaStatus.active && this.pointerWasMoved && this.prepared.name) {\n        this.checkAndPreventDefault(event, this.target, this.element);\n\n        return;\n      }\n\n      this.pointerIsDown = true;\n      this.downEvent = event;\n\n      var pointerIndex = this.addPointer(pointer),\n        action;\n\n      // If it is the second touch of a multi-touch gesture, keep the\n      // target the same and get a new action if a target was set by the\n      // first touch\n      if (this.pointerIds.length > 1 && this.target._element === this.element) {\n        var newAction = validateAction(forceAction || this.target.getAction(pointer, event, this, this.element), this.target);\n\n        if (withinInteractionLimit(this.target, this.element, newAction)) {\n          action = newAction;\n        }\n\n        this.prepared.name = null;\n      }\n      // Otherwise, set the target if there is no action prepared\n      else if (!this.prepared.name) {\n        var interactable = interactables.get(curEventTarget);\n\n        if (interactable\n          && !testIgnore(interactable, curEventTarget, eventTarget)\n          && testAllow(interactable, curEventTarget, eventTarget)\n          && (action = validateAction(forceAction || interactable.getAction(pointer, event, this, curEventTarget), interactable, eventTarget))\n          && withinInteractionLimit(interactable, curEventTarget, action)) {\n          this.target = interactable;\n          this.element = curEventTarget;\n        }\n      }\n\n      var target = this.target,\n        options = target && target.options;\n\n      if (target && (forceAction || !this.prepared.name)) {\n        action = action || validateAction(forceAction || target.getAction(pointer, event, this, curEventTarget), target, this.element);\n\n        this.setEventXY(this.startCoords, this.pointers);\n\n        if (!action) { return; }\n\n        if (options.styleCursor) {\n          target._doc.documentElement.style.cursor = getActionCursor(action);\n        }\n\n        this.resizeAxes = action.name === 'resize'? action.axis : null;\n\n        if (action === 'gesture' && this.pointerIds.length < 2) {\n          action = null;\n        }\n\n        this.prepared.name  = action.name;\n        this.prepared.axis  = action.axis;\n        this.prepared.edges = action.edges;\n\n        this.snapStatus.snappedX = this.snapStatus.snappedY =\n          this.restrictStatus.restrictedX = this.restrictStatus.restrictedY = NaN;\n\n        this.downTimes[pointerIndex] = new Date().getTime();\n        this.downTargets[pointerIndex] = eventTarget;\n        pointerExtend(this.downPointer, pointer);\n\n        copyCoords(this.prevCoords, this.startCoords);\n        this.pointerWasMoved = false;\n\n        this.checkAndPreventDefault(event, target, this.element);\n      }\n      // if inertia is active try to resume action\n      else if (this.inertiaStatus.active\n        && curEventTarget === this.element\n        && validateAction(target.getAction(pointer, event, this, this.element), target).name === this.prepared.name) {\n\n        cancelFrame(this.inertiaStatus.i);\n        this.inertiaStatus.active = false;\n\n        this.checkAndPreventDefault(event, target, this.element);\n      }\n    },\n\n    setModifications: function (coords, preEnd) {\n      var target         = this.target,\n        shouldMove     = true,\n        shouldSnap     = checkSnap(target, this.prepared.name)     && (!target.options[this.prepared.name].snap.endOnly     || preEnd),\n        shouldRestrict = checkRestrict(target, this.prepared.name) && (!target.options[this.prepared.name].restrict.endOnly || preEnd);\n\n      if (shouldSnap    ) { this.setSnapping   (coords); } else { this.snapStatus    .locked     = false; }\n      if (shouldRestrict) { this.setRestriction(coords); } else { this.restrictStatus.restricted = false; }\n\n      if (shouldSnap && this.snapStatus.locked && !this.snapStatus.changed) {\n        shouldMove = shouldRestrict && this.restrictStatus.restricted && this.restrictStatus.changed;\n      }\n      else if (shouldRestrict && this.restrictStatus.restricted && !this.restrictStatus.changed) {\n        shouldMove = false;\n      }\n\n      return shouldMove;\n    },\n\n    setStartOffsets: function (action, interactable, element) {\n      var rect = interactable.getRect(element),\n        origin = getOriginXY(interactable, element),\n        snap = interactable.options[this.prepared.name].snap,\n        restrict = interactable.options[this.prepared.name].restrict,\n        width, height;\n\n      if (rect) {\n        this.startOffset.left = this.startCoords.page.x - rect.left;\n        this.startOffset.top  = this.startCoords.page.y - rect.top;\n\n        this.startOffset.right  = rect.right  - this.startCoords.page.x;\n        this.startOffset.bottom = rect.bottom - this.startCoords.page.y;\n\n        if ('width' in rect) { width = rect.width; }\n        else { width = rect.right - rect.left; }\n        if ('height' in rect) { height = rect.height; }\n        else { height = rect.bottom - rect.top; }\n      }\n      else {\n        this.startOffset.left = this.startOffset.top = this.startOffset.right = this.startOffset.bottom = 0;\n      }\n\n      this.snapOffsets.splice(0);\n\n      var snapOffset = snap && snap.offset === 'startCoords'\n        ? {\n          x: this.startCoords.page.x - origin.x,\n          y: this.startCoords.page.y - origin.y\n        }\n        : snap && snap.offset || { x: 0, y: 0 };\n\n      if (rect && snap && snap.relativePoints && snap.relativePoints.length) {\n        for (var i = 0; i < snap.relativePoints.length; i++) {\n          this.snapOffsets.push({\n            x: this.startOffset.left - (width  * snap.relativePoints[i].x) + snapOffset.x,\n            y: this.startOffset.top  - (height * snap.relativePoints[i].y) + snapOffset.y\n          });\n        }\n      }\n      else {\n        this.snapOffsets.push(snapOffset);\n      }\n\n      if (rect && restrict.elementRect) {\n        this.restrictOffset.left = this.startOffset.left - (width  * restrict.elementRect.left);\n        this.restrictOffset.top  = this.startOffset.top  - (height * restrict.elementRect.top);\n\n        this.restrictOffset.right  = this.startOffset.right  - (width  * (1 - restrict.elementRect.right));\n        this.restrictOffset.bottom = this.startOffset.bottom - (height * (1 - restrict.elementRect.bottom));\n      }\n      else {\n        this.restrictOffset.left = this.restrictOffset.top = this.restrictOffset.right = this.restrictOffset.bottom = 0;\n      }\n    },\n\n    /*\\\n         * Interaction.start\n         [ method ]\n         *\n         * Start an action with the given Interactable and Element as tartgets. The\n         * action must be enabled for the target Interactable and an appropriate number\n         * of pointers must be held down  1 for drag/resize, 2 for gesture.\n         *\n         * Use it with `interactable.<action>able({ manualStart: false })` to always\n         * [start actions manually](https://github.com/taye/interact.js/issues/114)\n         *\n         - action       (object)  The action to be performed - drag, resize, etc.\n         - interactable (Interactable) The Interactable to target\n         - element      (Element) The DOM Element to target\n         = (object) interact\n         **\n         | interact(target)\n         |   .draggable({\n         |     // disable the default drag start by down->move\n         |     manualStart: true\n         |   })\n         |   // start dragging after the user holds the pointer down\n         |   .on('hold', function (event) {\n         |     var interaction = event.interaction;\n         |\n         |     if (!interaction.interacting()) {\n         |       interaction.start({ name: 'drag' },\n         |                         event.interactable,\n         |                         event.currentTarget);\n         |     }\n         | });\n        \\*/\n    start: function (action, interactable, element) {\n      if (this.interacting()\n        || !this.pointerIsDown\n        || this.pointerIds.length < (action.name === 'gesture'? 2 : 1)) {\n        return;\n      }\n\n      // if this interaction had been removed after stopping\n      // add it back\n      if (indexOf(interactions, this) === -1) {\n        interactions.push(this);\n      }\n\n      // set the startCoords if there was no prepared action\n      if (!this.prepared.name) {\n        this.setEventXY(this.startCoords, this.pointers);\n      }\n\n      this.prepared.name  = action.name;\n      this.prepared.axis  = action.axis;\n      this.prepared.edges = action.edges;\n      this.target         = interactable;\n      this.element        = element;\n\n      this.setStartOffsets(action.name, interactable, element);\n      this.setModifications(this.startCoords.page);\n\n      this.prevEvent = this[this.prepared.name + 'Start'](this.downEvent);\n    },\n\n    pointerMove: function (pointer, event, eventTarget, curEventTarget, preEnd) {\n      if (this.inertiaStatus.active) {\n        var pageUp   = this.inertiaStatus.upCoords.page;\n        var clientUp = this.inertiaStatus.upCoords.client;\n\n        var inertiaPosition = {\n          pageX  : pageUp.x   + this.inertiaStatus.sx,\n          pageY  : pageUp.y   + this.inertiaStatus.sy,\n          clientX: clientUp.x + this.inertiaStatus.sx,\n          clientY: clientUp.y + this.inertiaStatus.sy\n        };\n\n        this.setEventXY(this.curCoords, [inertiaPosition]);\n      }\n      else {\n        this.recordPointer(pointer);\n        this.setEventXY(this.curCoords, this.pointers);\n      }\n\n      var duplicateMove = (this.curCoords.page.x === this.prevCoords.page.x\n        && this.curCoords.page.y === this.prevCoords.page.y\n        && this.curCoords.client.x === this.prevCoords.client.x\n        && this.curCoords.client.y === this.prevCoords.client.y);\n\n      var dx, dy,\n        pointerIndex = this.mouse? 0 : indexOf(this.pointerIds, getPointerId(pointer));\n\n      // register movement greater than pointerMoveTolerance\n      if (this.pointerIsDown && !this.pointerWasMoved) {\n        dx = this.curCoords.client.x - this.startCoords.client.x;\n        dy = this.curCoords.client.y - this.startCoords.client.y;\n\n        this.pointerWasMoved = hypot(dx, dy) > pointerMoveTolerance;\n      }\n\n      if (!duplicateMove && (!this.pointerIsDown || this.pointerWasMoved)) {\n        if (this.pointerIsDown) {\n          clearTimeout(this.holdTimers[pointerIndex]);\n        }\n\n        this.collectEventTargets(pointer, event, eventTarget, 'move');\n      }\n\n      if (!this.pointerIsDown) { return; }\n\n      if (duplicateMove && this.pointerWasMoved && !preEnd) {\n        this.checkAndPreventDefault(event, this.target, this.element);\n        return;\n      }\n\n      // set pointer coordinate, time changes and speeds\n      setEventDeltas(this.pointerDelta, this.prevCoords, this.curCoords);\n\n      if (!this.prepared.name) { return; }\n\n      if (this.pointerWasMoved\n        // ignore movement while inertia is active\n        && (!this.inertiaStatus.active || (pointer instanceof InteractEvent && /inertiastart/.test(pointer.type)))) {\n\n        // if just starting an action, calculate the pointer speed now\n        if (!this.interacting()) {\n          setEventDeltas(this.pointerDelta, this.prevCoords, this.curCoords);\n\n          // check if a drag is in the correct axis\n          if (this.prepared.name === 'drag') {\n            var absX = Math.abs(dx),\n              absY = Math.abs(dy),\n              targetAxis = this.target.options.drag.axis,\n              axis = (absX > absY ? 'x' : absX < absY ? 'y' : 'xy');\n\n            // if the movement isn't in the axis of the interactable\n            if (axis !== 'xy' && targetAxis !== 'xy' && targetAxis !== axis) {\n              // cancel the prepared action\n              this.prepared.name = null;\n\n              // then try to get a drag from another ineractable\n\n              var element = eventTarget;\n\n              // check element interactables\n              while (isElement(element)) {\n                var elementInteractable = interactables.get(element);\n\n                if (elementInteractable\n                  && elementInteractable !== this.target\n                  && !elementInteractable.options.drag.manualStart\n                  && (elementInteractable.getAction(this.downPointer, this.downEvent, this, element) || {}).name === 'drag'\n                  && checkAxis(axis, elementInteractable)) {\n\n                  this.prepared.name = 'drag';\n                  this.target = elementInteractable;\n                  this.element = element;\n                  break;\n                }\n\n                element = parentElement(element);\n              }\n\n              // if there's no drag from element interactables,\n              // check the selector interactables\n              if (!this.prepared.name) {\n                var thisInteraction = this;\n\n                var getDraggable = function (interactable, selector, context) {\n                  var elements = ie8MatchesSelector\n                    ? context.querySelectorAll(selector)\n                    : undefined;\n\n                  if (interactable === thisInteraction.target) { return; }\n\n                  if (inContext(interactable, eventTarget)\n                    && !interactable.options.drag.manualStart\n                    && !testIgnore(interactable, element, eventTarget)\n                    && testAllow(interactable, element, eventTarget)\n                    && matchesSelector(element, selector, elements)\n                    && interactable.getAction(thisInteraction.downPointer, thisInteraction.downEvent, thisInteraction, element).name === 'drag'\n                    && checkAxis(axis, interactable)\n                    && withinInteractionLimit(interactable, element, 'drag')) {\n\n                    return interactable;\n                  }\n                };\n\n                element = eventTarget;\n\n                while (isElement(element)) {\n                  var selectorInteractable = interactables.forEachSelector(getDraggable);\n\n                  if (selectorInteractable) {\n                    this.prepared.name = 'drag';\n                    this.target = selectorInteractable;\n                    this.element = element;\n                    break;\n                  }\n\n                  element = parentElement(element);\n                }\n              }\n            }\n          }\n        }\n\n        var starting = !!this.prepared.name && !this.interacting();\n\n        if (starting\n          && (this.target.options[this.prepared.name].manualStart\n            || !withinInteractionLimit(this.target, this.element, this.prepared))) {\n          this.stop(event);\n          return;\n        }\n\n        if (this.prepared.name && this.target) {\n          if (starting) {\n            this.start(this.prepared, this.target, this.element);\n          }\n\n          var shouldMove = this.setModifications(this.curCoords.page, preEnd);\n\n          // move if snapping or restriction doesn't prevent it\n          if (shouldMove || starting) {\n            this.prevEvent = this[this.prepared.name + 'Move'](event);\n          }\n\n          this.checkAndPreventDefault(event, this.target, this.element);\n        }\n      }\n\n      copyCoords(this.prevCoords, this.curCoords);\n\n      if (this.dragging || this.resizing) {\n        this.autoScrollMove(pointer);\n      }\n    },\n\n    dragStart: function (event) {\n      var dragEvent = new InteractEvent(this, event, 'drag', 'start', this.element);\n\n      dragEvent.originalEvent = event;\n      this.dragging = true;\n      this.target.fire(dragEvent);\n\n      // reset active dropzones\n      this.activeDrops.dropzones = [];\n      this.activeDrops.elements  = [];\n      this.activeDrops.rects     = [];\n\n      if (!this.dynamicDrop) {\n        this.setActiveDrops(this.element);\n      }\n\n      var dropEvents = this.getDropEvents(event, dragEvent);\n\n      if (dropEvents.activate) {\n        this.fireActiveDrops(dropEvents.activate);\n      }\n\n      return dragEvent;\n    },\n\n    dragMove: function (event) {\n      var target = this.target,\n        dragEvent  = new InteractEvent(this, event, 'drag', 'move', this.element),\n        draggableElement = this.element,\n        drop = this.getDrop(dragEvent, event, draggableElement);\n\n      this.dropTarget = drop.dropzone;\n      this.dropElement = drop.element;\n\n      var dropEvents = this.getDropEvents(event, dragEvent);\n\n      target.fire(dragEvent);\n\n      if (dropEvents.leave) { this.prevDropTarget.fire(dropEvents.leave); }\n      if (dropEvents.enter) {     this.dropTarget.fire(dropEvents.enter); }\n      if (dropEvents.move ) {     this.dropTarget.fire(dropEvents.move ); }\n\n      this.prevDropTarget  = this.dropTarget;\n      this.prevDropElement = this.dropElement;\n\n      return dragEvent;\n    },\n\n    resizeStart: function (event) {\n      var resizeEvent = new InteractEvent(this, event, 'resize', 'start', this.element);\n\n      if (this.prepared.edges) {\n        var startRect = this.target.getRect(this.element);\n\n        /*\n                 * When using the `resizable.square` or `resizable.preserveAspectRatio` options, resizing from one edge\n                 * will affect another. E.g. with `resizable.square`, resizing to make the right edge larger will make\n                 * the bottom edge larger by the same amount. We call these 'linked' edges. Any linked edges will depend\n                 * on the active edges and the edge being interacted with.\n                 */\n        if (this.target.options.resize.square || this.target.options.resize.preserveAspectRatio) {\n          var linkedEdges = extend({}, this.prepared.edges);\n\n          linkedEdges.top    = linkedEdges.top    || (linkedEdges.left   && !linkedEdges.bottom);\n          linkedEdges.left   = linkedEdges.left   || (linkedEdges.top    && !linkedEdges.right );\n          linkedEdges.bottom = linkedEdges.bottom || (linkedEdges.right  && !linkedEdges.top   );\n          linkedEdges.right  = linkedEdges.right  || (linkedEdges.bottom && !linkedEdges.left  );\n\n          this.prepared._linkedEdges = linkedEdges;\n        }\n        else {\n          this.prepared._linkedEdges = null;\n        }\n\n        // if using `resizable.preserveAspectRatio` option, record aspect ratio at the start of the resize\n        if (this.target.options.resize.preserveAspectRatio) {\n          this.resizeStartAspectRatio = startRect.width / startRect.height;\n        }\n\n        this.resizeRects = {\n          start     : startRect,\n          current   : extend({}, startRect),\n          restricted: extend({}, startRect),\n          previous  : extend({}, startRect),\n          delta     : {\n            left: 0, right : 0, width : 0,\n            top : 0, bottom: 0, height: 0\n          }\n        };\n\n        resizeEvent.rect = this.resizeRects.restricted;\n        resizeEvent.deltaRect = this.resizeRects.delta;\n      }\n\n      this.target.fire(resizeEvent);\n\n      this.resizing = true;\n\n      return resizeEvent;\n    },\n\n    resizeMove: function (event) {\n      var resizeEvent = new InteractEvent(this, event, 'resize', 'move', this.element);\n\n      var edges = this.prepared.edges,\n        invert = this.target.options.resize.invert,\n        invertible = invert === 'reposition' || invert === 'negate';\n\n      if (edges) {\n        var dx = resizeEvent.dx,\n          dy = resizeEvent.dy,\n\n          start      = this.resizeRects.start,\n          current    = this.resizeRects.current,\n          restricted = this.resizeRects.restricted,\n          delta      = this.resizeRects.delta,\n          previous   = extend(this.resizeRects.previous, restricted),\n\n          originalEdges = edges;\n\n        // `resize.preserveAspectRatio` takes precedence over `resize.square`\n        if (this.target.options.resize.preserveAspectRatio) {\n          var resizeStartAspectRatio = this.resizeStartAspectRatio;\n\n          edges = this.prepared._linkedEdges;\n\n          if ((originalEdges.left && originalEdges.bottom)\n            || (originalEdges.right && originalEdges.top)) {\n            dy = -dx / resizeStartAspectRatio;\n          }\n          else if (originalEdges.left || originalEdges.right) { dy = dx / resizeStartAspectRatio; }\n          else if (originalEdges.top || originalEdges.bottom) { dx = dy * resizeStartAspectRatio; }\n        }\n        else if (this.target.options.resize.square) {\n          edges = this.prepared._linkedEdges;\n\n          if ((originalEdges.left && originalEdges.bottom)\n            || (originalEdges.right && originalEdges.top)) {\n            dy = -dx;\n          }\n          else if (originalEdges.left || originalEdges.right) { dy = dx; }\n          else if (originalEdges.top || originalEdges.bottom) { dx = dy; }\n        }\n\n        // update the 'current' rect without modifications\n        if (edges.top   ) { current.top    += dy; }\n        if (edges.bottom) { current.bottom += dy; }\n        if (edges.left  ) { current.left   += dx; }\n        if (edges.right ) { current.right  += dx; }\n\n        if (invertible) {\n          // if invertible, copy the current rect\n          extend(restricted, current);\n\n          if (invert === 'reposition') {\n            // swap edge values if necessary to keep width/height positive\n            var swap;\n\n            if (restricted.top > restricted.bottom) {\n              swap = restricted.top;\n\n              restricted.top = restricted.bottom;\n              restricted.bottom = swap;\n            }\n            if (restricted.left > restricted.right) {\n              swap = restricted.left;\n\n              restricted.left = restricted.right;\n              restricted.right = swap;\n            }\n          }\n        }\n        else {\n          // if not invertible, restrict to minimum of 0x0 rect\n          restricted.top    = Math.min(current.top, start.bottom);\n          restricted.bottom = Math.max(current.bottom, start.top);\n          restricted.left   = Math.min(current.left, start.right);\n          restricted.right  = Math.max(current.right, start.left);\n        }\n\n        restricted.width  = restricted.right  - restricted.left;\n        restricted.height = restricted.bottom - restricted.top ;\n\n        for (var edge in restricted) {\n          delta[edge] = restricted[edge] - previous[edge];\n        }\n\n        resizeEvent.edges = this.prepared.edges;\n        resizeEvent.rect = restricted;\n        resizeEvent.deltaRect = delta;\n      }\n\n      this.target.fire(resizeEvent);\n\n      return resizeEvent;\n    },\n\n    gestureStart: function (event) {\n      var gestureEvent = new InteractEvent(this, event, 'gesture', 'start', this.element);\n\n      gestureEvent.ds = 0;\n\n      this.gesture.startDistance = this.gesture.prevDistance = gestureEvent.distance;\n      this.gesture.startAngle = this.gesture.prevAngle = gestureEvent.angle;\n      this.gesture.scale = 1;\n\n      this.gesturing = true;\n\n      this.target.fire(gestureEvent);\n\n      return gestureEvent;\n    },\n\n    gestureMove: function (event) {\n      if (!this.pointerIds.length) {\n        return this.prevEvent;\n      }\n\n      var gestureEvent;\n\n      gestureEvent = new InteractEvent(this, event, 'gesture', 'move', this.element);\n      gestureEvent.ds = gestureEvent.scale - this.gesture.scale;\n\n      this.target.fire(gestureEvent);\n\n      this.gesture.prevAngle = gestureEvent.angle;\n      this.gesture.prevDistance = gestureEvent.distance;\n\n      if (gestureEvent.scale !== Infinity &&\n        gestureEvent.scale !== null &&\n        gestureEvent.scale !== undefined  &&\n        !isNaN(gestureEvent.scale)) {\n\n        this.gesture.scale = gestureEvent.scale;\n      }\n\n      return gestureEvent;\n    },\n\n    pointerHold: function (pointer, event, eventTarget) {\n      this.collectEventTargets(pointer, event, eventTarget, 'hold');\n    },\n\n    pointerUp: function (pointer, event, eventTarget, curEventTarget) {\n      var pointerIndex = this.mouse? 0 : indexOf(this.pointerIds, getPointerId(pointer));\n\n      clearTimeout(this.holdTimers[pointerIndex]);\n\n      this.collectEventTargets(pointer, event, eventTarget, 'up' );\n      this.collectEventTargets(pointer, event, eventTarget, 'tap');\n\n      this.pointerEnd(pointer, event, eventTarget, curEventTarget);\n\n      this.removePointer(pointer);\n    },\n\n    pointerCancel: function (pointer, event, eventTarget, curEventTarget) {\n      var pointerIndex = this.mouse? 0 : indexOf(this.pointerIds, getPointerId(pointer));\n\n      clearTimeout(this.holdTimers[pointerIndex]);\n\n      this.collectEventTargets(pointer, event, eventTarget, 'cancel');\n      this.pointerEnd(pointer, event, eventTarget, curEventTarget);\n\n      this.removePointer(pointer);\n    },\n\n    // http://www.quirksmode.org/dom/events/click.html\n    // >Events leading to dblclick\n    //\n    // IE8 doesn't fire down event before dblclick.\n    // This workaround tries to fire a tap and doubletap after dblclick\n    ie8Dblclick: function (pointer, event, eventTarget) {\n      if (this.prevTap\n        && event.clientX === this.prevTap.clientX\n        && event.clientY === this.prevTap.clientY\n        && eventTarget   === this.prevTap.target) {\n\n        this.downTargets[0] = eventTarget;\n        this.downTimes[0] = new Date().getTime();\n        this.collectEventTargets(pointer, event, eventTarget, 'tap');\n      }\n    },\n\n    // End interact move events and stop auto-scroll unless inertia is enabled\n    pointerEnd: function (pointer, event, eventTarget, curEventTarget) {\n      var endEvent,\n        target = this.target,\n        options = target && target.options,\n        inertiaOptions = options && this.prepared.name && options[this.prepared.name].inertia,\n        inertiaStatus = this.inertiaStatus;\n\n      if (this.interacting()) {\n\n        if (inertiaStatus.active && !inertiaStatus.ending) { return; }\n\n        var pointerSpeed,\n          now = new Date().getTime(),\n          inertiaPossible = false,\n          inertia = false,\n          smoothEnd = false,\n          endSnap = checkSnap(target, this.prepared.name) && options[this.prepared.name].snap.endOnly,\n          endRestrict = checkRestrict(target, this.prepared.name) && options[this.prepared.name].restrict.endOnly,\n          dx = 0,\n          dy = 0,\n          startEvent;\n\n        if (this.dragging) {\n          if      (options.drag.axis === 'x' ) { pointerSpeed = Math.abs(this.pointerDelta.client.vx); }\n          else if (options.drag.axis === 'y' ) { pointerSpeed = Math.abs(this.pointerDelta.client.vy); }\n          else   /*options.drag.axis === 'xy'*/{ pointerSpeed = this.pointerDelta.client.speed; }\n        }\n        else {\n          pointerSpeed = this.pointerDelta.client.speed;\n        }\n\n        // check if inertia should be started\n        inertiaPossible = (inertiaOptions && inertiaOptions.enabled\n          && this.prepared.name !== 'gesture'\n          && event !== inertiaStatus.startEvent);\n\n        inertia = (inertiaPossible\n          && (now - this.curCoords.timeStamp) < 50\n          && pointerSpeed > inertiaOptions.minSpeed\n          && pointerSpeed > inertiaOptions.endSpeed);\n\n        if (inertiaPossible && !inertia && (endSnap || endRestrict)) {\n\n          var snapRestrict = {};\n\n          snapRestrict.snap = snapRestrict.restrict = snapRestrict;\n\n          if (endSnap) {\n            this.setSnapping(this.curCoords.page, snapRestrict);\n            if (snapRestrict.locked) {\n              dx += snapRestrict.dx;\n              dy += snapRestrict.dy;\n            }\n          }\n\n          if (endRestrict) {\n            this.setRestriction(this.curCoords.page, snapRestrict);\n            if (snapRestrict.restricted) {\n              dx += snapRestrict.dx;\n              dy += snapRestrict.dy;\n            }\n          }\n\n          if (dx || dy) {\n            smoothEnd = true;\n          }\n        }\n\n        if (inertia || smoothEnd) {\n          copyCoords(inertiaStatus.upCoords, this.curCoords);\n\n          this.pointers[0] = inertiaStatus.startEvent = startEvent =\n            new InteractEvent(this, event, this.prepared.name, 'inertiastart', this.element);\n\n          inertiaStatus.t0 = now;\n\n          target.fire(inertiaStatus.startEvent);\n\n          if (inertia) {\n            inertiaStatus.vx0 = this.pointerDelta.client.vx;\n            inertiaStatus.vy0 = this.pointerDelta.client.vy;\n            inertiaStatus.v0 = pointerSpeed;\n\n            this.calcInertia(inertiaStatus);\n\n            var page = extend({}, this.curCoords.page),\n              origin = getOriginXY(target, this.element),\n              statusObject;\n\n            page.x = page.x + inertiaStatus.xe - origin.x;\n            page.y = page.y + inertiaStatus.ye - origin.y;\n\n            statusObject = {\n              useStatusXY: true,\n              x: page.x,\n              y: page.y,\n              dx: 0,\n              dy: 0,\n              snap: null\n            };\n\n            statusObject.snap = statusObject;\n\n            dx = dy = 0;\n\n            if (endSnap) {\n              var snap = this.setSnapping(this.curCoords.page, statusObject);\n\n              if (snap.locked) {\n                dx += snap.dx;\n                dy += snap.dy;\n              }\n            }\n\n            if (endRestrict) {\n              var restrict = this.setRestriction(this.curCoords.page, statusObject);\n\n              if (restrict.restricted) {\n                dx += restrict.dx;\n                dy += restrict.dy;\n              }\n            }\n\n            inertiaStatus.modifiedXe += dx;\n            inertiaStatus.modifiedYe += dy;\n\n            inertiaStatus.i = reqFrame(this.boundInertiaFrame);\n          }\n          else {\n            inertiaStatus.smoothEnd = true;\n            inertiaStatus.xe = dx;\n            inertiaStatus.ye = dy;\n\n            inertiaStatus.sx = inertiaStatus.sy = 0;\n\n            inertiaStatus.i = reqFrame(this.boundSmoothEndFrame);\n          }\n\n          inertiaStatus.active = true;\n          return;\n        }\n\n        if (endSnap || endRestrict) {\n          // fire a move event at the snapped coordinates\n          this.pointerMove(pointer, event, eventTarget, curEventTarget, true);\n        }\n      }\n\n      if (this.dragging) {\n        endEvent = new InteractEvent(this, event, 'drag', 'end', this.element);\n\n        var draggableElement = this.element,\n          drop = this.getDrop(endEvent, event, draggableElement);\n\n        this.dropTarget = drop.dropzone;\n        this.dropElement = drop.element;\n\n        var dropEvents = this.getDropEvents(event, endEvent);\n\n        if (dropEvents.leave) { this.prevDropTarget.fire(dropEvents.leave); }\n        if (dropEvents.enter) {     this.dropTarget.fire(dropEvents.enter); }\n        if (dropEvents.drop ) {     this.dropTarget.fire(dropEvents.drop ); }\n        if (dropEvents.deactivate) {\n          this.fireActiveDrops(dropEvents.deactivate);\n        }\n\n        target.fire(endEvent);\n      }\n      else if (this.resizing) {\n        endEvent = new InteractEvent(this, event, 'resize', 'end', this.element);\n        target.fire(endEvent);\n      }\n      else if (this.gesturing) {\n        endEvent = new InteractEvent(this, event, 'gesture', 'end', this.element);\n        target.fire(endEvent);\n      }\n\n      this.stop(event);\n    },\n\n    collectDrops: function (element) {\n      var drops = [],\n        elements = [],\n        i;\n\n      element = element || this.element;\n\n      // collect all dropzones and their elements which qualify for a drop\n      for (i = 0; i < interactables.length; i++) {\n        if (!interactables[i].options.drop.enabled) { continue; }\n\n        var current = interactables[i],\n          accept = current.options.drop.accept;\n\n        // test the draggable element against the dropzone's accept setting\n        if ((isElement(accept) && accept !== element)\n          || (isString(accept)\n            && !matchesSelector(element, accept))) {\n\n          continue;\n        }\n\n        // query for new elements if necessary\n        var dropElements = current.selector? current._context.querySelectorAll(current.selector) : [current._element];\n\n        for (var j = 0, len = dropElements.length; j < len; j++) {\n          var currentElement = dropElements[j];\n\n          if (currentElement === element) {\n            continue;\n          }\n\n          drops.push(current);\n          elements.push(currentElement);\n        }\n      }\n\n      return {\n        dropzones: drops,\n        elements: elements\n      };\n    },\n\n    fireActiveDrops: function (event) {\n      var i,\n        current,\n        currentElement,\n        prevElement;\n\n      // loop through all active dropzones and trigger event\n      for (i = 0; i < this.activeDrops.dropzones.length; i++) {\n        current = this.activeDrops.dropzones[i];\n        currentElement = this.activeDrops.elements [i];\n\n        // prevent trigger of duplicate events on same element\n        if (currentElement !== prevElement) {\n          // set current element as event target\n          event.target = currentElement;\n          current.fire(event);\n        }\n        prevElement = currentElement;\n      }\n    },\n\n    // Collect a new set of possible drops and save them in activeDrops.\n    // setActiveDrops should always be called when a drag has just started or a\n    // drag event happens while dynamicDrop is true\n    setActiveDrops: function (dragElement) {\n      // get dropzones and their elements that could receive the draggable\n      var possibleDrops = this.collectDrops(dragElement, true);\n\n      this.activeDrops.dropzones = possibleDrops.dropzones;\n      this.activeDrops.elements  = possibleDrops.elements;\n      this.activeDrops.rects     = [];\n\n      for (var i = 0; i < this.activeDrops.dropzones.length; i++) {\n        this.activeDrops.rects[i] = this.activeDrops.dropzones[i].getRect(this.activeDrops.elements[i]);\n      }\n    },\n\n    getDrop: function (dragEvent, event, dragElement) {\n      var validDrops = [];\n\n      if (dynamicDrop) {\n        this.setActiveDrops(dragElement);\n      }\n\n      // collect all dropzones and their elements which qualify for a drop\n      for (var j = 0; j < this.activeDrops.dropzones.length; j++) {\n        var current        = this.activeDrops.dropzones[j],\n          currentElement = this.activeDrops.elements [j],\n          rect           = this.activeDrops.rects    [j];\n\n        validDrops.push(current.dropCheck(dragEvent, event, this.target, dragElement, currentElement, rect)\n          ? currentElement\n          : null);\n      }\n\n      // get the most appropriate dropzone based on DOM depth and order\n      var dropIndex = indexOfDeepestElement(validDrops),\n        dropzone  = this.activeDrops.dropzones[dropIndex] || null,\n        element   = this.activeDrops.elements [dropIndex] || null;\n\n      return {\n        dropzone: dropzone,\n        element: element\n      };\n    },\n\n    getDropEvents: function (pointerEvent, dragEvent) {\n      var dropEvents = {\n        enter     : null,\n        leave     : null,\n        activate  : null,\n        deactivate: null,\n        move      : null,\n        drop      : null\n      };\n\n      if (this.dropElement !== this.prevDropElement) {\n        // if there was a prevDropTarget, create a dragleave event\n        if (this.prevDropTarget) {\n          dropEvents.leave = {\n            target       : this.prevDropElement,\n            dropzone     : this.prevDropTarget,\n            relatedTarget: dragEvent.target,\n            draggable    : dragEvent.interactable,\n            dragEvent    : dragEvent,\n            interaction  : this,\n            timeStamp    : dragEvent.timeStamp,\n            type         : 'dragleave'\n          };\n\n          dragEvent.dragLeave = this.prevDropElement;\n          dragEvent.prevDropzone = this.prevDropTarget;\n        }\n        // if the dropTarget is not null, create a dragenter event\n        if (this.dropTarget) {\n          dropEvents.enter = {\n            target       : this.dropElement,\n            dropzone     : this.dropTarget,\n            relatedTarget: dragEvent.target,\n            draggable    : dragEvent.interactable,\n            dragEvent    : dragEvent,\n            interaction  : this,\n            timeStamp    : dragEvent.timeStamp,\n            type         : 'dragenter'\n          };\n\n          dragEvent.dragEnter = this.dropElement;\n          dragEvent.dropzone = this.dropTarget;\n        }\n      }\n\n      if (dragEvent.type === 'dragend' && this.dropTarget) {\n        dropEvents.drop = {\n          target       : this.dropElement,\n          dropzone     : this.dropTarget,\n          relatedTarget: dragEvent.target,\n          draggable    : dragEvent.interactable,\n          dragEvent    : dragEvent,\n          interaction  : this,\n          timeStamp    : dragEvent.timeStamp,\n          type         : 'drop'\n        };\n\n        dragEvent.dropzone = this.dropTarget;\n      }\n      if (dragEvent.type === 'dragstart') {\n        dropEvents.activate = {\n          target       : null,\n          dropzone     : null,\n          relatedTarget: dragEvent.target,\n          draggable    : dragEvent.interactable,\n          dragEvent    : dragEvent,\n          interaction  : this,\n          timeStamp    : dragEvent.timeStamp,\n          type         : 'dropactivate'\n        };\n      }\n      if (dragEvent.type === 'dragend') {\n        dropEvents.deactivate = {\n          target       : null,\n          dropzone     : null,\n          relatedTarget: dragEvent.target,\n          draggable    : dragEvent.interactable,\n          dragEvent    : dragEvent,\n          interaction  : this,\n          timeStamp    : dragEvent.timeStamp,\n          type         : 'dropdeactivate'\n        };\n      }\n      if (dragEvent.type === 'dragmove' && this.dropTarget) {\n        dropEvents.move = {\n          target       : this.dropElement,\n          dropzone     : this.dropTarget,\n          relatedTarget: dragEvent.target,\n          draggable    : dragEvent.interactable,\n          dragEvent    : dragEvent,\n          interaction  : this,\n          dragmove     : dragEvent,\n          timeStamp    : dragEvent.timeStamp,\n          type         : 'dropmove'\n        };\n        dragEvent.dropzone = this.dropTarget;\n      }\n\n      return dropEvents;\n    },\n\n    currentAction: function () {\n      return (this.dragging && 'drag') || (this.resizing && 'resize') || (this.gesturing && 'gesture') || null;\n    },\n\n    interacting: function () {\n      return this.dragging || this.resizing || this.gesturing;\n    },\n\n    clearTargets: function () {\n      this.target = this.element = null;\n\n      this.dropTarget = this.dropElement = this.prevDropTarget = this.prevDropElement = null;\n    },\n\n    stop: function (event) {\n      if (this.interacting()) {\n        autoScroll.stop();\n        this.matches = [];\n        this.matchElements = [];\n\n        var target = this.target;\n\n        if (target.options.styleCursor) {\n          target._doc.documentElement.style.cursor = '';\n        }\n\n        // prevent Default only if were previously interacting\n        if (event && isFunction(event.preventDefault)) {\n          this.checkAndPreventDefault(event, target, this.element);\n        }\n\n        if (this.dragging) {\n          this.activeDrops.dropzones = this.activeDrops.elements = this.activeDrops.rects = null;\n        }\n      }\n\n      this.clearTargets();\n\n      this.pointerIsDown = this.snapStatus.locked = this.dragging = this.resizing = this.gesturing = false;\n      this.prepared.name = this.prevEvent = null;\n      this.inertiaStatus.resumeDx = this.inertiaStatus.resumeDy = 0;\n\n      // remove pointers if their ID isn't in this.pointerIds\n      for (var i = 0; i < this.pointers.length; i++) {\n        if (indexOf(this.pointerIds, getPointerId(this.pointers[i])) === -1) {\n          this.pointers.splice(i, 1);\n        }\n      }\n    },\n\n    inertiaFrame: function () {\n      var inertiaStatus = this.inertiaStatus,\n        options = this.target.options[this.prepared.name].inertia,\n        lambda = options.resistance,\n        t = new Date().getTime() / 1000 - inertiaStatus.t0;\n\n      if (t < inertiaStatus.te) {\n\n        var progress =  1 - (Math.exp(-lambda * t) - inertiaStatus.lambda_v0) / inertiaStatus.one_ve_v0;\n\n        if (inertiaStatus.modifiedXe === inertiaStatus.xe && inertiaStatus.modifiedYe === inertiaStatus.ye) {\n          inertiaStatus.sx = inertiaStatus.xe * progress;\n          inertiaStatus.sy = inertiaStatus.ye * progress;\n        }\n        else {\n          var quadPoint = getQuadraticCurvePoint(\n            0, 0,\n            inertiaStatus.xe, inertiaStatus.ye,\n            inertiaStatus.modifiedXe, inertiaStatus.modifiedYe,\n            progress);\n\n          inertiaStatus.sx = quadPoint.x;\n          inertiaStatus.sy = quadPoint.y;\n        }\n\n        this.pointerMove(inertiaStatus.startEvent, inertiaStatus.startEvent);\n\n        inertiaStatus.i = reqFrame(this.boundInertiaFrame);\n      }\n      else {\n        inertiaStatus.ending = true;\n\n        inertiaStatus.sx = inertiaStatus.modifiedXe;\n        inertiaStatus.sy = inertiaStatus.modifiedYe;\n\n        this.pointerMove(inertiaStatus.startEvent, inertiaStatus.startEvent);\n        this.pointerEnd(inertiaStatus.startEvent, inertiaStatus.startEvent);\n\n        inertiaStatus.active = inertiaStatus.ending = false;\n      }\n    },\n\n    smoothEndFrame: function () {\n      var inertiaStatus = this.inertiaStatus,\n        t = new Date().getTime() - inertiaStatus.t0,\n        duration = this.target.options[this.prepared.name].inertia.smoothEndDuration;\n\n      if (t < duration) {\n        inertiaStatus.sx = easeOutQuad(t, 0, inertiaStatus.xe, duration);\n        inertiaStatus.sy = easeOutQuad(t, 0, inertiaStatus.ye, duration);\n\n        this.pointerMove(inertiaStatus.startEvent, inertiaStatus.startEvent);\n\n        inertiaStatus.i = reqFrame(this.boundSmoothEndFrame);\n      }\n      else {\n        inertiaStatus.ending = true;\n\n        inertiaStatus.sx = inertiaStatus.xe;\n        inertiaStatus.sy = inertiaStatus.ye;\n\n        this.pointerMove(inertiaStatus.startEvent, inertiaStatus.startEvent);\n        this.pointerEnd(inertiaStatus.startEvent, inertiaStatus.startEvent);\n\n        inertiaStatus.smoothEnd =\n          inertiaStatus.active = inertiaStatus.ending = false;\n      }\n    },\n\n    addPointer: function (pointer) {\n      var id = getPointerId(pointer),\n        index = this.mouse? 0 : indexOf(this.pointerIds, id);\n\n      if (index === -1) {\n        index = this.pointerIds.length;\n      }\n\n      this.pointerIds[index] = id;\n      this.pointers[index] = pointer;\n\n      return index;\n    },\n\n    removePointer: function (pointer) {\n      var id = getPointerId(pointer),\n        index = this.mouse? 0 : indexOf(this.pointerIds, id);\n\n      if (index === -1) { return; }\n\n      this.pointers   .splice(index, 1);\n      this.pointerIds .splice(index, 1);\n      this.downTargets.splice(index, 1);\n      this.downTimes  .splice(index, 1);\n      this.holdTimers .splice(index, 1);\n    },\n\n    recordPointer: function (pointer) {\n      var index = this.mouse? 0: indexOf(this.pointerIds, getPointerId(pointer));\n\n      if (index === -1) { return; }\n\n      this.pointers[index] = pointer;\n    },\n\n    collectEventTargets: function (pointer, event, eventTarget, eventType) {\n      var pointerIndex = this.mouse? 0 : indexOf(this.pointerIds, getPointerId(pointer));\n\n      // do not fire a tap event if the pointer was moved before being lifted\n      if (eventType === 'tap' && (this.pointerWasMoved\n        // or if the pointerup target is different to the pointerdown target\n        || !(this.downTargets[pointerIndex] && this.downTargets[pointerIndex] === eventTarget))) {\n        return;\n      }\n\n      var targets = [],\n        elements = [],\n        element = eventTarget;\n\n      function collectSelectors (interactable, selector, context) {\n        var els = ie8MatchesSelector\n          ? context.querySelectorAll(selector)\n          : undefined;\n\n        if (interactable._iEvents[eventType]\n          && isElement(element)\n          && inContext(interactable, element)\n          && !testIgnore(interactable, element, eventTarget)\n          && testAllow(interactable, element, eventTarget)\n          && matchesSelector(element, selector, els)) {\n\n          targets.push(interactable);\n          elements.push(element);\n        }\n      }\n\n      while (element) {\n        if (interact.isSet(element) && interact(element)._iEvents[eventType]) {\n          targets.push(interact(element));\n          elements.push(element);\n        }\n\n        interactables.forEachSelector(collectSelectors);\n\n        element = parentElement(element);\n      }\n\n      // create the tap event even if there are no listeners so that\n      // doubletap can still be created and fired\n      if (targets.length || eventType === 'tap') {\n        this.firePointers(pointer, event, eventTarget, targets, elements, eventType);\n      }\n    },\n\n    firePointers: function (pointer, event, eventTarget, targets, elements, eventType) {\n      var pointerIndex = this.mouse? 0 : indexOf(this.pointerIds, getPointerId(pointer)),\n        pointerEvent = {},\n        i,\n        // for tap events\n        interval, createNewDoubleTap;\n\n      // if it's a doubletap then the event properties would have been\n      // copied from the tap event and provided as the pointer argument\n      if (eventType === 'doubletap') {\n        pointerEvent = pointer;\n      }\n      else {\n        pointerExtend(pointerEvent, event);\n        if (event !== pointer) {\n          pointerExtend(pointerEvent, pointer);\n        }\n\n        pointerEvent.preventDefault           = preventOriginalDefault;\n        pointerEvent.stopPropagation          = InteractEvent.prototype.stopPropagation;\n        pointerEvent.stopImmediatePropagation = InteractEvent.prototype.stopImmediatePropagation;\n        pointerEvent.interaction              = this;\n\n        pointerEvent.timeStamp       = new Date().getTime();\n        pointerEvent.originalEvent   = event;\n        pointerEvent.originalPointer = pointer;\n        pointerEvent.type            = eventType;\n        pointerEvent.pointerId       = getPointerId(pointer);\n        pointerEvent.pointerType     = this.mouse? 'mouse' : !supportsPointerEvent? 'touch'\n          : isString(pointer.pointerType)\n            ? pointer.pointerType\n            : [,,'touch', 'pen', 'mouse'][pointer.pointerType];\n      }\n\n      if (eventType === 'tap') {\n        pointerEvent.dt = pointerEvent.timeStamp - this.downTimes[pointerIndex];\n\n        interval = pointerEvent.timeStamp - this.tapTime;\n        createNewDoubleTap = !!(this.prevTap && this.prevTap.type !== 'doubletap'\n          && this.prevTap.target === pointerEvent.target\n          && interval < 500);\n\n        pointerEvent.double = createNewDoubleTap;\n\n        this.tapTime = pointerEvent.timeStamp;\n      }\n\n      for (i = 0; i < targets.length; i++) {\n        pointerEvent.currentTarget = elements[i];\n        pointerEvent.interactable = targets[i];\n        targets[i].fire(pointerEvent);\n\n        if (pointerEvent.immediatePropagationStopped\n          ||(pointerEvent.propagationStopped && elements[i + 1] !== pointerEvent.currentTarget)) {\n          break;\n        }\n      }\n\n      if (createNewDoubleTap) {\n        var doubleTap = {};\n\n        extend(doubleTap, pointerEvent);\n\n        doubleTap.dt   = interval;\n        doubleTap.type = 'doubletap';\n\n        this.collectEventTargets(doubleTap, event, eventTarget, 'doubletap');\n\n        this.prevTap = doubleTap;\n      }\n      else if (eventType === 'tap') {\n        this.prevTap = pointerEvent;\n      }\n    },\n\n    validateSelector: function (pointer, event, matches, matchElements) {\n      for (var i = 0, len = matches.length; i < len; i++) {\n        var match = matches[i],\n          matchElement = matchElements[i],\n          action = validateAction(match.getAction(pointer, event, this, matchElement), match);\n\n        if (action && withinInteractionLimit(match, matchElement, action)) {\n          this.target = match;\n          this.element = matchElement;\n\n          return action;\n        }\n      }\n    },\n\n    setSnapping: function (pageCoords, status) {\n      var snap = this.target.options[this.prepared.name].snap,\n        targets = [],\n        target,\n        page,\n        i;\n\n      status = status || this.snapStatus;\n\n      if (status.useStatusXY) {\n        page = { x: status.x, y: status.y };\n      }\n      else {\n        var origin = getOriginXY(this.target, this.element);\n\n        page = extend({}, pageCoords);\n\n        page.x -= origin.x;\n        page.y -= origin.y;\n      }\n\n      status.realX = page.x;\n      status.realY = page.y;\n\n      page.x = page.x - this.inertiaStatus.resumeDx;\n      page.y = page.y - this.inertiaStatus.resumeDy;\n\n      var len = snap.targets? snap.targets.length : 0;\n\n      for (var relIndex = 0; relIndex < this.snapOffsets.length; relIndex++) {\n        var relative = {\n          x: page.x - this.snapOffsets[relIndex].x,\n          y: page.y - this.snapOffsets[relIndex].y\n        };\n\n        for (i = 0; i < len; i++) {\n          if (isFunction(snap.targets[i])) {\n            target = snap.targets[i](relative.x, relative.y, this);\n          }\n          else {\n            target = snap.targets[i];\n          }\n\n          if (!target) { continue; }\n\n          targets.push({\n            x: isNumber(target.x) ? (target.x + this.snapOffsets[relIndex].x) : relative.x,\n            y: isNumber(target.y) ? (target.y + this.snapOffsets[relIndex].y) : relative.y,\n\n            range: isNumber(target.range)? target.range: snap.range\n          });\n        }\n      }\n\n      var closest = {\n        target: null,\n        inRange: false,\n        distance: 0,\n        range: 0,\n        dx: 0,\n        dy: 0\n      };\n\n      for (i = 0, len = targets.length; i < len; i++) {\n        target = targets[i];\n\n        var range = target.range,\n          dx = target.x - page.x,\n          dy = target.y - page.y,\n          distance = hypot(dx, dy),\n          inRange = distance <= range;\n\n        // Infinite targets count as being out of range\n        // compared to non infinite ones that are in range\n        if (range === Infinity && closest.inRange && closest.range !== Infinity) {\n          inRange = false;\n        }\n\n        if (!closest.target || (inRange\n          // is the closest target in range?\n          ? (closest.inRange && range !== Infinity\n            // the pointer is relatively deeper in this target\n            ? distance / range < closest.distance / closest.range\n            // this target has Infinite range and the closest doesn't\n            : (range === Infinity && closest.range !== Infinity)\n            // OR this target is closer that the previous closest\n            || distance < closest.distance)\n          // The other is not in range and the pointer is closer to this target\n          : (!closest.inRange && distance < closest.distance))) {\n\n          if (range === Infinity) {\n            inRange = true;\n          }\n\n          closest.target = target;\n          closest.distance = distance;\n          closest.range = range;\n          closest.inRange = inRange;\n          closest.dx = dx;\n          closest.dy = dy;\n\n          status.range = range;\n        }\n      }\n\n      var snapChanged;\n\n      if (closest.target) {\n        snapChanged = (status.snappedX !== closest.target.x || status.snappedY !== closest.target.y);\n\n        status.snappedX = closest.target.x;\n        status.snappedY = closest.target.y;\n      }\n      else {\n        snapChanged = true;\n\n        status.snappedX = NaN;\n        status.snappedY = NaN;\n      }\n\n      status.dx = closest.dx;\n      status.dy = closest.dy;\n\n      status.changed = (snapChanged || (closest.inRange && !status.locked));\n      status.locked = closest.inRange;\n\n      return status;\n    },\n\n    setRestriction: function (pageCoords, status) {\n      var target = this.target,\n        restrict = target && target.options[this.prepared.name].restrict,\n        restriction = restrict && restrict.restriction,\n        page;\n\n      if (!restriction) {\n        return status;\n      }\n\n      status = status || this.restrictStatus;\n\n      page = status.useStatusXY\n        ? page = { x: status.x, y: status.y }\n        : page = extend({}, pageCoords);\n\n      if (status.snap && status.snap.locked) {\n        page.x += status.snap.dx || 0;\n        page.y += status.snap.dy || 0;\n      }\n\n      page.x -= this.inertiaStatus.resumeDx;\n      page.y -= this.inertiaStatus.resumeDy;\n\n      status.dx = 0;\n      status.dy = 0;\n      status.restricted = false;\n\n      var rect, restrictedX, restrictedY;\n\n      if (isString(restriction)) {\n        if (restriction === 'parent') {\n          restriction = parentElement(this.element);\n        }\n        else if (restriction === 'self') {\n          restriction = target.getRect(this.element);\n        }\n        else {\n          restriction = closest(this.element, restriction);\n        }\n\n        if (!restriction) { return status; }\n      }\n\n      if (isFunction(restriction)) {\n        restriction = restriction(page.x, page.y, this.element);\n      }\n\n      if (isElement(restriction)) {\n        restriction = getElementRect(restriction);\n      }\n\n      rect = restriction;\n\n      if (!restriction) {\n        restrictedX = page.x;\n        restrictedY = page.y;\n      }\n      // object is assumed to have\n      // x, y, width, height or\n      // left, top, right, bottom\n      else if ('x' in restriction && 'y' in restriction) {\n        restrictedX = Math.max(Math.min(rect.x + rect.width  - this.restrictOffset.right , page.x), rect.x + this.restrictOffset.left);\n        restrictedY = Math.max(Math.min(rect.y + rect.height - this.restrictOffset.bottom, page.y), rect.y + this.restrictOffset.top );\n      }\n      else {\n        restrictedX = Math.max(Math.min(rect.right  - this.restrictOffset.right , page.x), rect.left + this.restrictOffset.left);\n        restrictedY = Math.max(Math.min(rect.bottom - this.restrictOffset.bottom, page.y), rect.top  + this.restrictOffset.top );\n      }\n\n      status.dx = restrictedX - page.x;\n      status.dy = restrictedY - page.y;\n\n      status.changed = status.restrictedX !== restrictedX || status.restrictedY !== restrictedY;\n      status.restricted = !!(status.dx || status.dy);\n\n      status.restrictedX = restrictedX;\n      status.restrictedY = restrictedY;\n\n      return status;\n    },\n\n    checkAndPreventDefault: function (event, interactable, element) {\n      if (!(interactable = interactable || this.target)) { return; }\n\n      var options = interactable.options,\n        prevent = options.preventDefault;\n\n      if (prevent === 'auto' && element && !/^(input|select|textarea)$/i.test(event.target.nodeName)) {\n        // do not preventDefault on pointerdown if the prepared action is a drag\n        // and dragging can only start from a certain direction - this allows\n        // a touch to pan the viewport if a drag isn't in the right direction\n        if (/down|start/i.test(event.type)\n          && this.prepared.name === 'drag' && options.drag.axis !== 'xy') {\n\n          return;\n        }\n\n        // with manualStart, only preventDefault while interacting\n        if (options[this.prepared.name] && options[this.prepared.name].manualStart\n          && !this.interacting()) {\n          return;\n        }\n\n        event.preventDefault();\n        return;\n      }\n\n      if (prevent === 'always') {\n        event.preventDefault();\n        return;\n      }\n    },\n\n    calcInertia: function (status) {\n      var inertiaOptions = this.target.options[this.prepared.name].inertia,\n        lambda = inertiaOptions.resistance,\n        inertiaDur = -Math.log(inertiaOptions.endSpeed / status.v0) / lambda;\n\n      status.x0 = this.prevEvent.pageX;\n      status.y0 = this.prevEvent.pageY;\n      status.t0 = status.startEvent.timeStamp / 1000;\n      status.sx = status.sy = 0;\n\n      status.modifiedXe = status.xe = (status.vx0 - inertiaDur) / lambda;\n      status.modifiedYe = status.ye = (status.vy0 - inertiaDur) / lambda;\n      status.te = inertiaDur;\n\n      status.lambda_v0 = lambda / status.v0;\n      status.one_ve_v0 = 1 - inertiaOptions.endSpeed / status.v0;\n    },\n\n    autoScrollMove: function (pointer) {\n      if (!(this.interacting()\n        && checkAutoScroll(this.target, this.prepared.name))) {\n        return;\n      }\n\n      if (this.inertiaStatus.active) {\n        autoScroll.x = autoScroll.y = 0;\n        return;\n      }\n\n      var top,\n        right,\n        bottom,\n        left,\n        options = this.target.options[this.prepared.name].autoScroll,\n        container = options.container || getWindow(this.element);\n\n      if (isWindow(container)) {\n        left   = pointer.clientX < autoScroll.margin;\n        top    = pointer.clientY < autoScroll.margin;\n        right  = pointer.clientX > container.innerWidth  - autoScroll.margin;\n        bottom = pointer.clientY > container.innerHeight - autoScroll.margin;\n      }\n      else {\n        var rect = getElementClientRect(container);\n\n        left   = pointer.clientX < rect.left   + autoScroll.margin;\n        top    = pointer.clientY < rect.top    + autoScroll.margin;\n        right  = pointer.clientX > rect.right  - autoScroll.margin;\n        bottom = pointer.clientY > rect.bottom - autoScroll.margin;\n      }\n\n      autoScroll.x = (right ? 1: left? -1: 0);\n      autoScroll.y = (bottom? 1:  top? -1: 0);\n\n      if (!autoScroll.isScrolling) {\n        // set the autoScroll properties to those of the target\n        autoScroll.margin = options.margin;\n        autoScroll.speed  = options.speed;\n\n        autoScroll.start(this);\n      }\n    },\n\n    _updateEventTargets: function (target, currentTarget) {\n      this._eventTarget    = target;\n      this._curEventTarget = currentTarget;\n    }\n\n  };\n\n  function getInteractionFromPointer (pointer, eventType, eventTarget) {\n    var i = 0, len = interactions.length,\n      mouseEvent = (/mouse/i.test(pointer.pointerType || eventType)\n        // MSPointerEvent.MSPOINTER_TYPE_MOUSE\n        || pointer.pointerType === 4),\n      interaction;\n\n    var id = getPointerId(pointer);\n\n    // try to resume inertia with a new pointer\n    if (/down|start/i.test(eventType)) {\n      for (i = 0; i < len; i++) {\n        interaction = interactions[i];\n\n        var element = eventTarget;\n\n        if (interaction.inertiaStatus.active && interaction.target.options[interaction.prepared.name].inertia.allowResume\n          && (interaction.mouse === mouseEvent)) {\n          while (element) {\n            // if the element is the interaction element\n            if (element === interaction.element) {\n              return interaction;\n            }\n            element = parentElement(element);\n          }\n        }\n      }\n    }\n\n    // if it's a mouse interaction\n    if (mouseEvent || !(supportsTouch || supportsPointerEvent)) {\n\n      // find a mouse interaction that's not in inertia phase\n      for (i = 0; i < len; i++) {\n        if (interactions[i].mouse && !interactions[i].inertiaStatus.active) {\n          return interactions[i];\n        }\n      }\n\n      // find any interaction specifically for mouse.\n      // if the eventType is a mousedown, and inertia is active\n      // ignore the interaction\n      for (i = 0; i < len; i++) {\n        if (interactions[i].mouse && !(/down/.test(eventType) && interactions[i].inertiaStatus.active)) {\n          return interaction;\n        }\n      }\n\n      // create a new interaction for mouse\n      interaction = new Interaction();\n      interaction.mouse = true;\n\n      return interaction;\n    }\n\n    // get interaction that has this pointer\n    for (i = 0; i < len; i++) {\n      if (contains(interactions[i].pointerIds, id)) {\n        return interactions[i];\n      }\n    }\n\n    // at this stage, a pointerUp should not return an interaction\n    if (/up|end|out/i.test(eventType)) {\n      return null;\n    }\n\n    // get first idle interaction\n    for (i = 0; i < len; i++) {\n      interaction = interactions[i];\n\n      if ((!interaction.prepared.name || (interaction.target.options.gesture.enabled))\n        && !interaction.interacting()\n        && !(!mouseEvent && interaction.mouse)) {\n\n        return interaction;\n      }\n    }\n\n    return new Interaction();\n  }\n\n  function doOnInteractions (method) {\n    return (function (event) {\n      var interaction,\n        eventTarget = getActualElement(event.path\n          ? event.path[0]\n          : event.target),\n        curEventTarget = getActualElement(event.currentTarget),\n        i;\n\n      if (supportsTouch && /touch/.test(event.type)) {\n        prevTouchTime = new Date().getTime();\n\n        for (i = 0; i < event.changedTouches.length; i++) {\n          var pointer = event.changedTouches[i];\n\n          interaction = getInteractionFromPointer(pointer, event.type, eventTarget);\n\n          if (!interaction) { continue; }\n\n          interaction._updateEventTargets(eventTarget, curEventTarget);\n\n          interaction[method](pointer, event, eventTarget, curEventTarget);\n        }\n      }\n      else {\n        if (!supportsPointerEvent && /mouse/.test(event.type)) {\n          // ignore mouse events while touch interactions are active\n          for (i = 0; i < interactions.length; i++) {\n            if (!interactions[i].mouse && interactions[i].pointerIsDown) {\n              return;\n            }\n          }\n\n          // try to ignore mouse events that are simulated by the browser\n          // after a touch event\n          if (new Date().getTime() - prevTouchTime < 500) {\n            return;\n          }\n        }\n\n        interaction = getInteractionFromPointer(event, event.type, eventTarget);\n\n        if (!interaction) { return; }\n\n        interaction._updateEventTargets(eventTarget, curEventTarget);\n\n        interaction[method](event, event, eventTarget, curEventTarget);\n      }\n    });\n  }\n\n  function InteractEvent (interaction, event, action, phase, element, related) {\n    var client,\n      page,\n      target      = interaction.target,\n      snapStatus  = interaction.snapStatus,\n      restrictStatus  = interaction.restrictStatus,\n      pointers    = interaction.pointers,\n      deltaSource = (target && target.options || defaultOptions).deltaSource,\n      sourceX     = deltaSource + 'X',\n      sourceY     = deltaSource + 'Y',\n      options     = target? target.options: defaultOptions,\n      origin      = getOriginXY(target, element),\n      starting    = phase === 'start',\n      ending      = phase === 'end',\n      coords      = starting? interaction.startCoords : interaction.curCoords;\n\n    element = element || interaction.element;\n\n    page   = extend({}, coords.page);\n    client = extend({}, coords.client);\n\n    page.x -= origin.x;\n    page.y -= origin.y;\n\n    client.x -= origin.x;\n    client.y -= origin.y;\n\n    var relativePoints = options[action].snap && options[action].snap.relativePoints ;\n\n    if (checkSnap(target, action) && !(starting && relativePoints && relativePoints.length)) {\n      this.snap = {\n        range  : snapStatus.range,\n        locked : snapStatus.locked,\n        x      : snapStatus.snappedX,\n        y      : snapStatus.snappedY,\n        realX  : snapStatus.realX,\n        realY  : snapStatus.realY,\n        dx     : snapStatus.dx,\n        dy     : snapStatus.dy\n      };\n\n      if (snapStatus.locked) {\n        page.x += snapStatus.dx;\n        page.y += snapStatus.dy;\n        client.x += snapStatus.dx;\n        client.y += snapStatus.dy;\n      }\n    }\n\n    if (checkRestrict(target, action) && !(starting && options[action].restrict.elementRect) && restrictStatus.restricted) {\n      page.x += restrictStatus.dx;\n      page.y += restrictStatus.dy;\n      client.x += restrictStatus.dx;\n      client.y += restrictStatus.dy;\n\n      this.restrict = {\n        dx: restrictStatus.dx,\n        dy: restrictStatus.dy\n      };\n    }\n\n    this.pageX     = page.x;\n    this.pageY     = page.y;\n    this.clientX   = client.x;\n    this.clientY   = client.y;\n\n    this.x0        = interaction.startCoords.page.x - origin.x;\n    this.y0        = interaction.startCoords.page.y - origin.y;\n    this.clientX0  = interaction.startCoords.client.x - origin.x;\n    this.clientY0  = interaction.startCoords.client.y - origin.y;\n    this.ctrlKey   = event.ctrlKey;\n    this.altKey    = event.altKey;\n    this.shiftKey  = event.shiftKey;\n    this.metaKey   = event.metaKey;\n    this.button    = event.button;\n    this.buttons   = event.buttons;\n    this.target    = element;\n    this.t0        = interaction.downTimes[0];\n    this.type      = action + (phase || '');\n\n    this.interaction = interaction;\n    this.interactable = target;\n\n    var inertiaStatus = interaction.inertiaStatus;\n\n    if (inertiaStatus.active) {\n      this.detail = 'inertia';\n    }\n\n    if (related) {\n      this.relatedTarget = related;\n    }\n\n    // end event dx, dy is difference between start and end points\n    if (ending) {\n      if (deltaSource === 'client') {\n        this.dx = client.x - interaction.startCoords.client.x;\n        this.dy = client.y - interaction.startCoords.client.y;\n      }\n      else {\n        this.dx = page.x - interaction.startCoords.page.x;\n        this.dy = page.y - interaction.startCoords.page.y;\n      }\n    }\n    else if (starting) {\n      this.dx = 0;\n      this.dy = 0;\n    }\n    // copy properties from previousmove if starting inertia\n    else if (phase === 'inertiastart') {\n      this.dx = interaction.prevEvent.dx;\n      this.dy = interaction.prevEvent.dy;\n    }\n    else {\n      if (deltaSource === 'client') {\n        this.dx = client.x - interaction.prevEvent.clientX;\n        this.dy = client.y - interaction.prevEvent.clientY;\n      }\n      else {\n        this.dx = page.x - interaction.prevEvent.pageX;\n        this.dy = page.y - interaction.prevEvent.pageY;\n      }\n    }\n    if (interaction.prevEvent && interaction.prevEvent.detail === 'inertia'\n      && !inertiaStatus.active\n      && options[action].inertia && options[action].inertia.zeroResumeDelta) {\n\n      inertiaStatus.resumeDx += this.dx;\n      inertiaStatus.resumeDy += this.dy;\n\n      this.dx = this.dy = 0;\n    }\n\n    if (action === 'resize' && interaction.resizeAxes) {\n      if (options.resize.square) {\n        if (interaction.resizeAxes === 'y') {\n          this.dx = this.dy;\n        }\n        else {\n          this.dy = this.dx;\n        }\n        this.axes = 'xy';\n      }\n      else {\n        this.axes = interaction.resizeAxes;\n\n        if (interaction.resizeAxes === 'x') {\n          this.dy = 0;\n        }\n        else if (interaction.resizeAxes === 'y') {\n          this.dx = 0;\n        }\n      }\n    }\n    else if (action === 'gesture') {\n      this.touches = [pointers[0], pointers[1]];\n\n      if (starting) {\n        this.distance = touchDistance(pointers, deltaSource);\n        this.box      = touchBBox(pointers);\n        this.scale    = 1;\n        this.ds       = 0;\n        this.angle    = touchAngle(pointers, undefined, deltaSource);\n        this.da       = 0;\n      }\n      else if (ending || event instanceof InteractEvent) {\n        this.distance = interaction.prevEvent.distance;\n        this.box      = interaction.prevEvent.box;\n        this.scale    = interaction.prevEvent.scale;\n        this.ds       = this.scale - 1;\n        this.angle    = interaction.prevEvent.angle;\n        this.da       = this.angle - interaction.gesture.startAngle;\n      }\n      else {\n        this.distance = touchDistance(pointers, deltaSource);\n        this.box      = touchBBox(pointers);\n        this.scale    = this.distance / interaction.gesture.startDistance;\n        this.angle    = touchAngle(pointers, interaction.gesture.prevAngle, deltaSource);\n\n        this.ds = this.scale - interaction.gesture.prevScale;\n        this.da = this.angle - interaction.gesture.prevAngle;\n      }\n    }\n\n    if (starting) {\n      this.timeStamp = interaction.downTimes[0];\n      this.dt        = 0;\n      this.duration  = 0;\n      this.speed     = 0;\n      this.velocityX = 0;\n      this.velocityY = 0;\n    }\n    else if (phase === 'inertiastart') {\n      this.timeStamp = interaction.prevEvent.timeStamp;\n      this.dt        = interaction.prevEvent.dt;\n      this.duration  = interaction.prevEvent.duration;\n      this.speed     = interaction.prevEvent.speed;\n      this.velocityX = interaction.prevEvent.velocityX;\n      this.velocityY = interaction.prevEvent.velocityY;\n    }\n    else {\n      this.timeStamp = new Date().getTime();\n      this.dt        = this.timeStamp - interaction.prevEvent.timeStamp;\n      this.duration  = this.timeStamp - interaction.downTimes[0];\n\n      if (event instanceof InteractEvent) {\n        var dx = this[sourceX] - interaction.prevEvent[sourceX],\n          dy = this[sourceY] - interaction.prevEvent[sourceY],\n          dt = this.dt / 1000;\n\n        this.speed = hypot(dx, dy) / dt;\n        this.velocityX = dx / dt;\n        this.velocityY = dy / dt;\n      }\n      // if normal move or end event, use previous user event coords\n      else {\n        // speed and velocity in pixels per second\n        this.speed = interaction.pointerDelta[deltaSource].speed;\n        this.velocityX = interaction.pointerDelta[deltaSource].vx;\n        this.velocityY = interaction.pointerDelta[deltaSource].vy;\n      }\n    }\n\n    if ((ending || phase === 'inertiastart')\n      && interaction.prevEvent.speed > 600 && this.timeStamp - interaction.prevEvent.timeStamp < 150) {\n\n      var angle = 180 * Math.atan2(interaction.prevEvent.velocityY, interaction.prevEvent.velocityX) / Math.PI,\n        overlap = 22.5;\n\n      if (angle < 0) {\n        angle += 360;\n      }\n\n      var left = 135 - overlap <= angle && angle < 225 + overlap,\n        up   = 225 - overlap <= angle && angle < 315 + overlap,\n\n        right = !left && (315 - overlap <= angle || angle <  45 + overlap),\n        down  = !up   &&   45 - overlap <= angle && angle < 135 + overlap;\n\n      this.swipe = {\n        up   : up,\n        down : down,\n        left : left,\n        right: right,\n        angle: angle,\n        speed: interaction.prevEvent.speed,\n        velocity: {\n          x: interaction.prevEvent.velocityX,\n          y: interaction.prevEvent.velocityY\n        }\n      };\n    }\n  }\n\n  InteractEvent.prototype = {\n    preventDefault: blank,\n    stopImmediatePropagation: function () {\n      this.immediatePropagationStopped = this.propagationStopped = true;\n    },\n    stopPropagation: function () {\n      this.propagationStopped = true;\n    }\n  };\n\n  function preventOriginalDefault () {\n    this.originalEvent.preventDefault();\n  }\n\n  function getActionCursor (action) {\n    var cursor = '';\n\n    if (action.name === 'drag') {\n      cursor =  actionCursors.drag;\n    }\n    if (action.name === 'resize') {\n      if (action.axis) {\n        cursor =  actionCursors[action.name + action.axis];\n      }\n      else if (action.edges) {\n        var cursorKey = 'resize',\n          edgeNames = ['top', 'bottom', 'left', 'right'];\n\n        for (var i = 0; i < 4; i++) {\n          if (action.edges[edgeNames[i]]) {\n            cursorKey += edgeNames[i];\n          }\n        }\n\n        cursor = actionCursors[cursorKey];\n      }\n    }\n\n    return cursor;\n  }\n\n  function checkResizeEdge (name, value, page, element, interactableElement, rect, margin) {\n    // false, '', undefined, null\n    if (!value) { return false; }\n\n    // true value, use pointer coords and element rect\n    if (value === true) {\n      // if dimensions are negative, \"switch\" edges\n      var width = isNumber(rect.width)? rect.width : rect.right - rect.left,\n        height = isNumber(rect.height)? rect.height : rect.bottom - rect.top;\n\n      if (width < 0) {\n        if      (name === 'left' ) { name = 'right'; }\n        else if (name === 'right') { name = 'left' ; }\n      }\n      if (height < 0) {\n        if      (name === 'top'   ) { name = 'bottom'; }\n        else if (name === 'bottom') { name = 'top'   ; }\n      }\n\n      if (name === 'left'  ) { return page.x < ((width  >= 0? rect.left: rect.right ) + margin); }\n      if (name === 'top'   ) { return page.y < ((height >= 0? rect.top : rect.bottom) + margin); }\n\n      if (name === 'right' ) { return page.x > ((width  >= 0? rect.right : rect.left) - margin); }\n      if (name === 'bottom') { return page.y > ((height >= 0? rect.bottom: rect.top ) - margin); }\n    }\n\n    // the remaining checks require an element\n    if (!isElement(element)) { return false; }\n\n    return isElement(value)\n      // the value is an element to use as a resize handle\n      ? value === element\n      // otherwise check if element matches value as selector\n      : matchesUpTo(element, value, interactableElement);\n  }\n\n  function defaultActionChecker (pointer, interaction, element) {\n    var rect = this.getRect(element),\n      shouldResize = false,\n      action = null,\n      resizeAxes = null,\n      resizeEdges,\n      page = extend({}, interaction.curCoords.page),\n      options = this.options;\n\n    if (!rect) { return null; }\n\n    if (actionIsEnabled.resize && options.resize.enabled) {\n      var resizeOptions = options.resize;\n\n      resizeEdges = {\n        left: false, right: false, top: false, bottom: false\n      };\n\n      // if using resize.edges\n      if (isObject(resizeOptions.edges)) {\n        for (var edge in resizeEdges) {\n          resizeEdges[edge] = checkResizeEdge(edge,\n            resizeOptions.edges[edge],\n            page,\n            interaction._eventTarget,\n            element,\n            rect,\n            resizeOptions.margin || margin);\n        }\n\n        resizeEdges.left = resizeEdges.left && !resizeEdges.right;\n        resizeEdges.top  = resizeEdges.top  && !resizeEdges.bottom;\n\n        shouldResize = resizeEdges.left || resizeEdges.right || resizeEdges.top || resizeEdges.bottom;\n      }\n      else {\n        var right  = options.resize.axis !== 'y' && page.x > (rect.right  - margin),\n          bottom = options.resize.axis !== 'x' && page.y > (rect.bottom - margin);\n\n        shouldResize = right || bottom;\n        resizeAxes = (right? 'x' : '') + (bottom? 'y' : '');\n      }\n    }\n\n    action = shouldResize\n      ? 'resize'\n      : actionIsEnabled.drag && options.drag.enabled\n        ? 'drag'\n        : null;\n\n    if (actionIsEnabled.gesture\n      && interaction.pointerIds.length >=2\n      && !(interaction.dragging || interaction.resizing)) {\n      action = 'gesture';\n    }\n\n    if (action) {\n      return {\n        name: action,\n        axis: resizeAxes,\n        edges: resizeEdges\n      };\n    }\n\n    return null;\n  }\n\n  // Check if action is enabled globally and the current target supports it\n  // If so, return the validated action. Otherwise, return null\n  function validateAction (action, interactable) {\n    if (!isObject(action)) { return null; }\n\n    var actionName = action.name,\n      options = interactable.options;\n\n    if ((  (actionName  === 'resize'   && options.resize.enabled )\n      || (actionName      === 'drag'     && options.drag.enabled  )\n      || (actionName      === 'gesture'  && options.gesture.enabled))\n      && actionIsEnabled[actionName]) {\n\n      if (actionName === 'resize' || actionName === 'resizeyx') {\n        actionName = 'resizexy';\n      }\n\n      return action;\n    }\n    return null;\n  }\n\n  var listeners = {},\n    interactionListeners = [\n      'dragStart', 'dragMove', 'resizeStart', 'resizeMove', 'gestureStart', 'gestureMove',\n      'pointerOver', 'pointerOut', 'pointerHover', 'selectorDown',\n      'pointerDown', 'pointerMove', 'pointerUp', 'pointerCancel', 'pointerEnd',\n      'addPointer', 'removePointer', 'recordPointer', 'autoScrollMove'\n    ];\n\n  for (var i = 0, len = interactionListeners.length; i < len; i++) {\n    var name = interactionListeners[i];\n\n    listeners[name] = doOnInteractions(name);\n  }\n\n  // bound to the interactable context when a DOM event\n  // listener is added to a selector interactable\n  function delegateListener (event, useCapture) {\n    var fakeEvent = {},\n      delegated = delegatedEvents[event.type],\n      eventTarget = getActualElement(event.path\n        ? event.path[0]\n        : event.target),\n      element = eventTarget;\n\n    useCapture = useCapture? true: false;\n\n    // duplicate the event so that currentTarget can be changed\n    for (var prop in event) {\n      fakeEvent[prop] = event[prop];\n    }\n\n    fakeEvent.originalEvent = event;\n    fakeEvent.preventDefault = preventOriginalDefault;\n\n    // climb up document tree looking for selector matches\n    while (isElement(element)) {\n      for (var i = 0; i < delegated.selectors.length; i++) {\n        var selector = delegated.selectors[i],\n          context = delegated.contexts[i];\n\n        if (matchesSelector(element, selector)\n          && nodeContains(context, eventTarget)\n          && nodeContains(context, element)) {\n\n          var listeners = delegated.listeners[i];\n\n          fakeEvent.currentTarget = element;\n\n          for (var j = 0; j < listeners.length; j++) {\n            if (listeners[j][1] === useCapture) {\n              listeners[j][0](fakeEvent);\n            }\n          }\n        }\n      }\n\n      element = parentElement(element);\n    }\n  }\n\n  function delegateUseCapture (event) {\n    return delegateListener.call(this, event, true);\n  }\n\n  interactables.indexOfElement = function indexOfElement (element, context) {\n    context = context || document;\n\n    for (var i = 0; i < this.length; i++) {\n      var interactable = this[i];\n\n      if ((interactable.selector === element\n        && (interactable._context === context))\n        || (!interactable.selector && interactable._element === element)) {\n\n        return i;\n      }\n    }\n    return -1;\n  };\n\n  interactables.get = function interactableGet (element, options) {\n    return this[this.indexOfElement(element, options && options.context)];\n  };\n\n  interactables.forEachSelector = function (callback) {\n    for (var i = 0; i < this.length; i++) {\n      var interactable = this[i];\n\n      if (!interactable.selector) {\n        continue;\n      }\n\n      var ret = callback(interactable, interactable.selector, interactable._context, i, this);\n\n      if (ret !== undefined) {\n        return ret;\n      }\n    }\n  };\n\n  /*\\\n     * interact\n     [ method ]\n     *\n     * The methods of this variable can be used to set elements as\n     * interactables and also to change various default settings.\n     *\n     * Calling it as a function and passing an element or a valid CSS selector\n     * string returns an Interactable object which has various methods to\n     * configure it.\n     *\n     - element (Element | string) The HTML or SVG Element to interact with or CSS selector\n     = (object) An @Interactable\n     *\n     > Usage\n     | interact(document.getElementById('draggable')).draggable(true);\n     |\n     | var rectables = interact('rect');\n     | rectables\n     |     .gesturable(true)\n     |     .on('gesturemove', function (event) {\n     |         // something cool...\n     |     })\n     |     .autoScroll(true);\n    \\*/\n  function interact (element, options) {\n    return interactables.get(element, options) || new Interactable(element, options);\n  }\n\n  /*\\\n     * Interactable\n     [ property ]\n     **\n     * Object type returned by @interact\n    \\*/\n  function Interactable (element, options) {\n    this._element = element;\n    this._iEvents = this._iEvents || {};\n\n    var _window;\n\n    if (trySelector(element)) {\n      this.selector = element;\n\n      var context = options && options.context;\n\n      _window = context? getWindow(context) : window;\n\n      if (context && (_window.Node\n        ? context instanceof _window.Node\n        : (isElement(context) || context === _window.document))) {\n\n        this._context = context;\n      }\n    }\n    else {\n      _window = getWindow(element);\n\n      if (isElement(element, _window)) {\n\n        if (supportsPointerEvent) {\n          events.add(this._element, pEventTypes.down, listeners.pointerDown );\n          events.add(this._element, pEventTypes.move, listeners.pointerHover);\n        }\n        else {\n          events.add(this._element, 'mousedown' , listeners.pointerDown );\n          events.add(this._element, 'mousemove' , listeners.pointerHover);\n          events.add(this._element, 'touchstart', listeners.pointerDown );\n          events.add(this._element, 'touchmove' , listeners.pointerHover);\n        }\n      }\n    }\n\n    this._doc = _window.document;\n\n    if (!contains(documents, this._doc)) {\n      listenToDocument(this._doc);\n    }\n\n    interactables.push(this);\n\n    this.set(options);\n  }\n\n  Interactable.prototype = {\n    setOnEvents: function (action, phases) {\n      if (action === 'drop') {\n        if (isFunction(phases.ondrop)          ) { this.ondrop           = phases.ondrop          ; }\n        if (isFunction(phases.ondropactivate)  ) { this.ondropactivate   = phases.ondropactivate  ; }\n        if (isFunction(phases.ondropdeactivate)) { this.ondropdeactivate = phases.ondropdeactivate; }\n        if (isFunction(phases.ondragenter)     ) { this.ondragenter      = phases.ondragenter     ; }\n        if (isFunction(phases.ondragleave)     ) { this.ondragleave      = phases.ondragleave     ; }\n        if (isFunction(phases.ondropmove)      ) { this.ondropmove       = phases.ondropmove      ; }\n      }\n      else {\n        action = 'on' + action;\n\n        if (isFunction(phases.onstart)       ) { this[action + 'start'         ] = phases.onstart         ; }\n        if (isFunction(phases.onmove)        ) { this[action + 'move'          ] = phases.onmove          ; }\n        if (isFunction(phases.onend)         ) { this[action + 'end'           ] = phases.onend           ; }\n        if (isFunction(phases.oninertiastart)) { this[action + 'inertiastart'  ] = phases.oninertiastart  ; }\n      }\n\n      return this;\n    },\n\n    /*\\\n         * Interactable.draggable\n         [ method ]\n         *\n         * Gets or sets whether drag actions can be performed on the\n         * Interactable\n         *\n         = (boolean) Indicates if this can be the target of drag events\n         | var isDraggable = interact('ul li').draggable();\n         * or\n         - options (boolean | object) #optional true/false or An object with event listeners to be fired on drag events (object makes the Interactable draggable)\n         = (object) This Interactable\n         | interact(element).draggable({\n         |     onstart: function (event) {},\n         |     onmove : function (event) {},\n         |     onend  : function (event) {},\n         |\n         |     // the axis in which the first movement must be\n         |     // for the drag sequence to start\n         |     // 'xy' by default - any direction\n         |     axis: 'x' || 'y' || 'xy',\n         |\n         |     // max number of drags that can happen concurrently\n         |     // with elements of this Interactable. Infinity by default\n         |     max: Infinity,\n         |\n         |     // max number of drags that can target the same element+Interactable\n         |     // 1 by default\n         |     maxPerElement: 2\n         | });\n        \\*/\n    draggable: function (options) {\n      if (isObject(options)) {\n        this.options.drag.enabled = options.enabled === false? false: true;\n        this.setPerAction('drag', options);\n        this.setOnEvents('drag', options);\n\n        if (/^x$|^y$|^xy$/.test(options.axis)) {\n          this.options.drag.axis = options.axis;\n        }\n        else if (options.axis === null) {\n          delete this.options.drag.axis;\n        }\n\n        return this;\n      }\n\n      if (isBool(options)) {\n        this.options.drag.enabled = options;\n\n        return this;\n      }\n\n      return this.options.drag;\n    },\n\n    setPerAction: function (action, options) {\n      // for all the default per-action options\n      for (var option in options) {\n        // if this option exists for this action\n        if (option in defaultOptions[action]) {\n          // if the option in the options arg is an object value\n          if (isObject(options[option])) {\n            // duplicate the object\n            this.options[action][option] = extend(this.options[action][option] || {}, options[option]);\n\n            if (isObject(defaultOptions.perAction[option]) && 'enabled' in defaultOptions.perAction[option]) {\n              this.options[action][option].enabled = options[option].enabled === false? false : true;\n            }\n          }\n          else if (isBool(options[option]) && isObject(defaultOptions.perAction[option])) {\n            this.options[action][option].enabled = options[option];\n          }\n          else if (options[option] !== undefined) {\n            // or if it's not undefined, do a plain assignment\n            this.options[action][option] = options[option];\n          }\n        }\n      }\n    },\n\n    /*\\\n         * Interactable.dropzone\n         [ method ]\n         *\n         * Returns or sets whether elements can be dropped onto this\n         * Interactable to trigger drop events\n         *\n         * Dropzones can receive the following events:\n         *  - `dropactivate` and `dropdeactivate` when an acceptable drag starts and ends\n         *  - `dragenter` and `dragleave` when a draggable enters and leaves the dropzone\n         *  - `dragmove` when a draggable that has entered the dropzone is moved\n         *  - `drop` when a draggable is dropped into this dropzone\n         *\n         *  Use the `accept` option to allow only elements that match the given CSS selector or element.\n         *\n         *  Use the `overlap` option to set how drops are checked for. The allowed values are:\n         *   - `'pointer'`, the pointer must be over the dropzone (default)\n         *   - `'center'`, the draggable element's center must be over the dropzone\n         *   - a number from 0-1 which is the `(intersection area) / (draggable area)`.\n         *       e.g. `0.5` for drop to happen when half of the area of the\n         *       draggable is over the dropzone\n         *\n         - options (boolean | object | null) #optional The new value to be set.\n         | interact('.drop').dropzone({\n         |   accept: '.can-drop' || document.getElementById('single-drop'),\n         |   overlap: 'pointer' || 'center' || zeroToOne\n         | }\n         = (boolean | object) The current setting or this Interactable\n        \\*/\n    dropzone: function (options) {\n      if (isObject(options)) {\n        this.options.drop.enabled = options.enabled === false? false: true;\n        this.setOnEvents('drop', options);\n\n        if (/^(pointer|center)$/.test(options.overlap)) {\n          this.options.drop.overlap = options.overlap;\n        }\n        else if (isNumber(options.overlap)) {\n          this.options.drop.overlap = Math.max(Math.min(1, options.overlap), 0);\n        }\n        if ('accept' in options) {\n          this.options.drop.accept = options.accept;\n        }\n        if ('checker' in options) {\n          this.options.drop.checker = options.checker;\n        }\n\n        return this;\n      }\n\n      if (isBool(options)) {\n        this.options.drop.enabled = options;\n\n        return this;\n      }\n\n      return this.options.drop;\n    },\n\n    dropCheck: function (dragEvent, event, draggable, draggableElement, dropElement, rect) {\n      var dropped = false;\n\n      // if the dropzone has no rect (eg. display: none)\n      // call the custom dropChecker or just return false\n      if (!(rect = rect || this.getRect(dropElement))) {\n        return (this.options.drop.checker\n          ? this.options.drop.checker(dragEvent, event, dropped, this, dropElement, draggable, draggableElement)\n          : false);\n      }\n\n      var dropOverlap = this.options.drop.overlap;\n\n      if (dropOverlap === 'pointer') {\n        var page = getPageXY(dragEvent),\n          origin = getOriginXY(draggable, draggableElement),\n          horizontal,\n          vertical;\n\n        page.x += origin.x;\n        page.y += origin.y;\n\n        horizontal = (page.x > rect.left) && (page.x < rect.right);\n        vertical   = (page.y > rect.top ) && (page.y < rect.bottom);\n\n        dropped = horizontal && vertical;\n      }\n\n      var dragRect = draggable.getRect(draggableElement);\n\n      if (dropOverlap === 'center') {\n        var cx = dragRect.left + dragRect.width  / 2,\n          cy = dragRect.top  + dragRect.height / 2;\n\n        dropped = cx >= rect.left && cx <= rect.right && cy >= rect.top && cy <= rect.bottom;\n      }\n\n      if (isNumber(dropOverlap)) {\n        var overlapArea  = (Math.max(0, Math.min(rect.right , dragRect.right ) - Math.max(rect.left, dragRect.left))\n          * Math.max(0, Math.min(rect.bottom, dragRect.bottom) - Math.max(rect.top , dragRect.top ))),\n          overlapRatio = overlapArea / (dragRect.width * dragRect.height);\n\n        dropped = overlapRatio >= dropOverlap;\n      }\n\n      if (this.options.drop.checker) {\n        dropped = this.options.drop.checker(dragEvent, event, dropped, this, dropElement, draggable, draggableElement);\n      }\n\n      return dropped;\n    },\n\n    /*\\\n         * Interactable.dropChecker\n         [ method ]\n         *\n         * DEPRECATED. Use interactable.dropzone({ checker: function... }) instead.\n         *\n         * Gets or sets the function used to check if a dragged element is\n         * over this Interactable.\n         *\n         - checker (function) #optional The function that will be called when checking for a drop\n         = (Function | Interactable) The checker function or this Interactable\n         *\n         * The checker function takes the following arguments:\n         *\n         - dragEvent (InteractEvent) The related dragmove or dragend event\n         - event (TouchEvent | PointerEvent | MouseEvent) The user move/up/end Event related to the dragEvent\n         - dropped (boolean) The value from the default drop checker\n         - dropzone (Interactable) The dropzone interactable\n         - dropElement (Element) The dropzone element\n         - draggable (Interactable) The Interactable being dragged\n         - draggableElement (Element) The actual element that's being dragged\n         *\n         > Usage:\n         | interact(target)\n         | .dropChecker(function(dragEvent,         // related dragmove or dragend event\n         |                       event,             // TouchEvent/PointerEvent/MouseEvent\n         |                       dropped,           // bool result of the default checker\n         |                       dropzone,          // dropzone Interactable\n         |                       dropElement,       // dropzone elemnt\n         |                       draggable,         // draggable Interactable\n         |                       draggableElement) {// draggable element\n         |\n         |   return dropped && event.target.hasAttribute('allow-drop');\n         | }\n        \\*/\n    dropChecker: function (checker) {\n      if (isFunction(checker)) {\n        this.options.drop.checker = checker;\n\n        return this;\n      }\n      if (checker === null) {\n        delete this.options.getRect;\n\n        return this;\n      }\n\n      return this.options.drop.checker;\n    },\n\n    /*\\\n         * Interactable.accept\n         [ method ]\n         *\n         * Deprecated. add an `accept` property to the options object passed to\n         * @Interactable.dropzone instead.\n         *\n         * Gets or sets the Element or CSS selector match that this\n         * Interactable accepts if it is a dropzone.\n         *\n         - newValue (Element | string | null) #optional\n         * If it is an Element, then only that element can be dropped into this dropzone.\n         * If it is a string, the element being dragged must match it as a selector.\n         * If it is null, the accept options is cleared - it accepts any element.\n         *\n         = (string | Element | null | Interactable) The current accept option if given `undefined` or this Interactable\n        \\*/\n    accept: function (newValue) {\n      if (isElement(newValue)) {\n        this.options.drop.accept = newValue;\n\n        return this;\n      }\n\n      // test if it is a valid CSS selector\n      if (trySelector(newValue)) {\n        this.options.drop.accept = newValue;\n\n        return this;\n      }\n\n      if (newValue === null) {\n        delete this.options.drop.accept;\n\n        return this;\n      }\n\n      return this.options.drop.accept;\n    },\n\n    /*\\\n         * Interactable.resizable\n         [ method ]\n         *\n         * Gets or sets whether resize actions can be performed on the\n         * Interactable\n         *\n         = (boolean) Indicates if this can be the target of resize elements\n         | var isResizeable = interact('input[type=text]').resizable();\n         * or\n         - options (boolean | object) #optional true/false or An object with event listeners to be fired on resize events (object makes the Interactable resizable)\n         = (object) This Interactable\n         | interact(element).resizable({\n         |     onstart: function (event) {},\n         |     onmove : function (event) {},\n         |     onend  : function (event) {},\n         |\n         |     edges: {\n         |       top   : true,       // Use pointer coords to check for resize.\n         |       left  : false,      // Disable resizing from left edge.\n         |       bottom: '.resize-s',// Resize if pointer target matches selector\n         |       right : handleEl    // Resize if pointer target is the given Element\n         |     },\n         |\n         |     // Width and height can be adjusted independently. When `true`, width and\n         |     // height are adjusted at a 1:1 ratio.\n         |     square: false,\n         |\n         |     // Width and height can be adjusted independently. When `true`, width and\n         |     // height maintain the aspect ratio they had when resizing started.\n         |     preserveAspectRatio: false,\n         |\n         |     // a value of 'none' will limit the resize rect to a minimum of 0x0\n         |     // 'negate' will allow the rect to have negative width/height\n         |     // 'reposition' will keep the width/height positive by swapping\n         |     // the top and bottom edges and/or swapping the left and right edges\n         |     invert: 'none' || 'negate' || 'reposition'\n         |\n         |     // limit multiple resizes.\n         |     // See the explanation in the @Interactable.draggable example\n         |     max: Infinity,\n         |     maxPerElement: 1,\n         | });\n        \\*/\n    resizable: function (options) {\n      if (isObject(options)) {\n        this.options.resize.enabled = options.enabled === false? false: true;\n        this.setPerAction('resize', options);\n        this.setOnEvents('resize', options);\n\n        if (/^x$|^y$|^xy$/.test(options.axis)) {\n          this.options.resize.axis = options.axis;\n        }\n        else if (options.axis === null) {\n          this.options.resize.axis = defaultOptions.resize.axis;\n        }\n\n        if (isBool(options.preserveAspectRatio)) {\n          this.options.resize.preserveAspectRatio = options.preserveAspectRatio;\n        }\n        else if (isBool(options.square)) {\n          this.options.resize.square = options.square;\n        }\n\n        return this;\n      }\n      if (isBool(options)) {\n        this.options.resize.enabled = options;\n\n        return this;\n      }\n      return this.options.resize;\n    },\n\n    /*\\\n         * Interactable.squareResize\n         [ method ]\n         *\n         * Deprecated. Add a `square: true || false` property to @Interactable.resizable instead\n         *\n         * Gets or sets whether resizing is forced 1:1 aspect\n         *\n         = (boolean) Current setting\n         *\n         * or\n         *\n         - newValue (boolean) #optional\n         = (object) this Interactable\n        \\*/\n    squareResize: function (newValue) {\n      if (isBool(newValue)) {\n        this.options.resize.square = newValue;\n\n        return this;\n      }\n\n      if (newValue === null) {\n        delete this.options.resize.square;\n\n        return this;\n      }\n\n      return this.options.resize.square;\n    },\n\n    /*\\\n         * Interactable.gesturable\n         [ method ]\n         *\n         * Gets or sets whether multitouch gestures can be performed on the\n         * Interactable's element\n         *\n         = (boolean) Indicates if this can be the target of gesture events\n         | var isGestureable = interact(element).gesturable();\n         * or\n         - options (boolean | object) #optional true/false or An object with event listeners to be fired on gesture events (makes the Interactable gesturable)\n         = (object) this Interactable\n         | interact(element).gesturable({\n         |     onstart: function (event) {},\n         |     onmove : function (event) {},\n         |     onend  : function (event) {},\n         |\n         |     // limit multiple gestures.\n         |     // See the explanation in @Interactable.draggable example\n         |     max: Infinity,\n         |     maxPerElement: 1,\n         | });\n        \\*/\n    gesturable: function (options) {\n      if (isObject(options)) {\n        this.options.gesture.enabled = options.enabled === false? false: true;\n        this.setPerAction('gesture', options);\n        this.setOnEvents('gesture', options);\n\n        return this;\n      }\n\n      if (isBool(options)) {\n        this.options.gesture.enabled = options;\n\n        return this;\n      }\n\n      return this.options.gesture;\n    },\n\n    /*\\\n         * Interactable.autoScroll\n         [ method ]\n         **\n         * Deprecated. Add an `autoscroll` property to the options object\n         * passed to @Interactable.draggable or @Interactable.resizable instead.\n         *\n         * Returns or sets whether dragging and resizing near the edges of the\n         * window/container trigger autoScroll for this Interactable\n         *\n         = (object) Object with autoScroll properties\n         *\n         * or\n         *\n         - options (object | boolean) #optional\n         * options can be:\n         * - an object with margin, distance and interval properties,\n         * - true or false to enable or disable autoScroll or\n         = (Interactable) this Interactable\n        \\*/\n    autoScroll: function (options) {\n      if (isObject(options)) {\n        options = extend({ actions: ['drag', 'resize']}, options);\n      }\n      else if (isBool(options)) {\n        options = { actions: ['drag', 'resize'], enabled: options };\n      }\n\n      return this.setOptions('autoScroll', options);\n    },\n\n    /*\\\n         * Interactable.snap\n         [ method ]\n         **\n         * Deprecated. Add a `snap` property to the options object passed\n         * to @Interactable.draggable or @Interactable.resizable instead.\n         *\n         * Returns or sets if and how action coordinates are snapped. By\n         * default, snapping is relative to the pointer coordinates. You can\n         * change this by setting the\n         * [`elementOrigin`](https://github.com/taye/interact.js/pull/72).\n         **\n         = (boolean | object) `false` if snap is disabled; object with snap properties if snap is enabled\n         **\n         * or\n         **\n         - options (object | boolean | null) #optional\n         = (Interactable) this Interactable\n         > Usage\n         | interact(document.querySelector('#thing')).snap({\n         |     targets: [\n         |         // snap to this specific point\n         |         {\n         |             x: 100,\n         |             y: 100,\n         |             range: 25\n         |         },\n         |         // give this function the x and y page coords and snap to the object returned\n         |         function (x, y) {\n         |             return {\n         |                 x: x,\n         |                 y: (75 + 50 * Math.sin(x * 0.04)),\n         |                 range: 40\n         |             };\n         |         },\n         |         // create a function that snaps to a grid\n         |         interact.createSnapGrid({\n         |             x: 50,\n         |             y: 50,\n         |             range: 10,              // optional\n         |             offset: { x: 5, y: 10 } // optional\n         |         })\n         |     ],\n         |     // do not snap during normal movement.\n         |     // Instead, trigger only one snapped move event\n         |     // immediately before the end event.\n         |     endOnly: true,\n         |\n         |     relativePoints: [\n         |         { x: 0, y: 0 },  // snap relative to the top left of the element\n         |         { x: 1, y: 1 },  // and also to the bottom right\n         |     ],\n         |\n         |     // offset the snap target coordinates\n         |     // can be an object with x/y or 'startCoords'\n         |     offset: { x: 50, y: 50 }\n         |   }\n         | });\n        \\*/\n    snap: function (options) {\n      var ret = this.setOptions('snap', options);\n\n      if (ret === this) { return this; }\n\n      return ret.drag;\n    },\n\n    setOptions: function (option, options) {\n      var actions = options && isArray(options.actions)\n        ? options.actions\n        : ['drag'];\n\n      var i;\n\n      if (isObject(options) || isBool(options)) {\n        for (i = 0; i < actions.length; i++) {\n          var action = /resize/.test(actions[i])? 'resize' : actions[i];\n\n          if (!isObject(this.options[action])) { continue; }\n\n          var thisOption = this.options[action][option];\n\n          if (isObject(options)) {\n            extend(thisOption, options);\n            thisOption.enabled = options.enabled === false? false: true;\n\n            if (option === 'snap') {\n              if (thisOption.mode === 'grid') {\n                thisOption.targets = [\n                  interact.createSnapGrid(extend({\n                    offset: thisOption.gridOffset || { x: 0, y: 0 }\n                  }, thisOption.grid || {}))\n                ];\n              }\n              else if (thisOption.mode === 'anchor') {\n                thisOption.targets = thisOption.anchors;\n              }\n              else if (thisOption.mode === 'path') {\n                thisOption.targets = thisOption.paths;\n              }\n\n              if ('elementOrigin' in options) {\n                thisOption.relativePoints = [options.elementOrigin];\n              }\n            }\n          }\n          else if (isBool(options)) {\n            thisOption.enabled = options;\n          }\n        }\n\n        return this;\n      }\n\n      var ret = {},\n        allActions = ['drag', 'resize', 'gesture'];\n\n      for (i = 0; i < allActions.length; i++) {\n        if (option in defaultOptions[allActions[i]]) {\n          ret[allActions[i]] = this.options[allActions[i]][option];\n        }\n      }\n\n      return ret;\n    },\n\n\n    /*\\\n         * Interactable.inertia\n         [ method ]\n         **\n         * Deprecated. Add an `inertia` property to the options object passed\n         * to @Interactable.draggable or @Interactable.resizable instead.\n         *\n         * Returns or sets if and how events continue to run after the pointer is released\n         **\n         = (boolean | object) `false` if inertia is disabled; `object` with inertia properties if inertia is enabled\n         **\n         * or\n         **\n         - options (object | boolean | null) #optional\n         = (Interactable) this Interactable\n         > Usage\n         | // enable and use default settings\n         | interact(element).inertia(true);\n         |\n         | // enable and use custom settings\n         | interact(element).inertia({\n         |     // value greater than 0\n         |     // high values slow the object down more quickly\n         |     resistance     : 16,\n         |\n         |     // the minimum launch speed (pixels per second) that results in inertia start\n         |     minSpeed       : 200,\n         |\n         |     // inertia will stop when the object slows down to this speed\n         |     endSpeed       : 20,\n         |\n         |     // boolean; should actions be resumed when the pointer goes down during inertia\n         |     allowResume    : true,\n         |\n         |     // boolean; should the jump when resuming from inertia be ignored in event.dx/dy\n         |     zeroResumeDelta: false,\n         |\n         |     // if snap/restrict are set to be endOnly and inertia is enabled, releasing\n         |     // the pointer without triggering inertia will animate from the release\n         |     // point to the snaped/restricted point in the given amount of time (ms)\n         |     smoothEndDuration: 300,\n         |\n         |     // an array of action types that can have inertia (no gesture)\n         |     actions        : ['drag', 'resize']\n         | });\n         |\n         | // reset custom settings and use all defaults\n         | interact(element).inertia(null);\n        \\*/\n    inertia: function (options) {\n      var ret = this.setOptions('inertia', options);\n\n      if (ret === this) { return this; }\n\n      return ret.drag;\n    },\n\n    getAction: function (pointer, event, interaction, element) {\n      var action = this.defaultActionChecker(pointer, interaction, element);\n\n      if (this.options.actionChecker) {\n        return this.options.actionChecker(pointer, event, action, this, element, interaction);\n      }\n\n      return action;\n    },\n\n    defaultActionChecker: defaultActionChecker,\n\n    /*\\\n         * Interactable.actionChecker\n         [ method ]\n         *\n         * Gets or sets the function used to check action to be performed on\n         * pointerDown\n         *\n         - checker (function | null) #optional A function which takes a pointer event, defaultAction string, interactable, element and interaction as parameters and returns an object with name property 'drag' 'resize' or 'gesture' and optionally an `edges` object with boolean 'top', 'left', 'bottom' and right props.\n         = (Function | Interactable) The checker function or this Interactable\n         *\n         | interact('.resize-drag')\n         |   .resizable(true)\n         |   .draggable(true)\n         |   .actionChecker(function (pointer, event, action, interactable, element, interaction) {\n         |\n         |   if (interact.matchesSelector(event.target, '.drag-handle') {\n         |     // force drag with handle target\n         |     action.name = drag;\n         |   }\n         |   else {\n         |     // resize from the top and right edges\n         |     action.name  = 'resize';\n         |     action.edges = { top: true, right: true };\n         |   }\n         |\n         |   return action;\n         | });\n        \\*/\n    actionChecker: function (checker) {\n      if (isFunction(checker)) {\n        this.options.actionChecker = checker;\n\n        return this;\n      }\n\n      if (checker === null) {\n        delete this.options.actionChecker;\n\n        return this;\n      }\n\n      return this.options.actionChecker;\n    },\n\n    /*\\\n         * Interactable.getRect\n         [ method ]\n         *\n         * The default function to get an Interactables bounding rect. Can be\n         * overridden using @Interactable.rectChecker.\n         *\n         - element (Element) #optional The element to measure.\n         = (object) The object's bounding rectangle.\n         o {\n         o     top   : 0,\n         o     left  : 0,\n         o     bottom: 0,\n         o     right : 0,\n         o     width : 0,\n         o     height: 0\n         o }\n        \\*/\n    getRect: function rectCheck (element) {\n      element = element || this._element;\n\n      if (this.selector && !(isElement(element))) {\n        element = this._context.querySelector(this.selector);\n      }\n\n      return getElementRect(element);\n    },\n\n    /*\\\n         * Interactable.rectChecker\n         [ method ]\n         *\n         * Returns or sets the function used to calculate the interactable's\n         * element's rectangle\n         *\n         - checker (function) #optional A function which returns this Interactable's bounding rectangle. See @Interactable.getRect\n         = (function | object) The checker function or this Interactable\n        \\*/\n    rectChecker: function (checker) {\n      if (isFunction(checker)) {\n        this.getRect = checker;\n\n        return this;\n      }\n\n      if (checker === null) {\n        delete this.options.getRect;\n\n        return this;\n      }\n\n      return this.getRect;\n    },\n\n    /*\\\n         * Interactable.styleCursor\n         [ method ]\n         *\n         * Returns or sets whether the action that would be performed when the\n         * mouse on the element are checked on `mousemove` so that the cursor\n         * may be styled appropriately\n         *\n         - newValue (boolean) #optional\n         = (boolean | Interactable) The current setting or this Interactable\n        \\*/\n    styleCursor: function (newValue) {\n      if (isBool(newValue)) {\n        this.options.styleCursor = newValue;\n\n        return this;\n      }\n\n      if (newValue === null) {\n        delete this.options.styleCursor;\n\n        return this;\n      }\n\n      return this.options.styleCursor;\n    },\n\n    /*\\\n         * Interactable.preventDefault\n         [ method ]\n         *\n         * Returns or sets whether to prevent the browser's default behaviour\n         * in response to pointer events. Can be set to:\n         *  - `'always'` to always prevent\n         *  - `'never'` to never prevent\n         *  - `'auto'` to let interact.js try to determine what would be best\n         *\n         - newValue (string) #optional `true`, `false` or `'auto'`\n         = (string | Interactable) The current setting or this Interactable\n        \\*/\n    preventDefault: function (newValue) {\n      if (/^(always|never|auto)$/.test(newValue)) {\n        this.options.preventDefault = newValue;\n        return this;\n      }\n\n      if (isBool(newValue)) {\n        this.options.preventDefault = newValue? 'always' : 'never';\n        return this;\n      }\n\n      return this.options.preventDefault;\n    },\n\n    /*\\\n         * Interactable.origin\n         [ method ]\n         *\n         * Gets or sets the origin of the Interactable's element.  The x and y\n         * of the origin will be subtracted from action event coordinates.\n         *\n         - origin (object | string) #optional An object eg. { x: 0, y: 0 } or string 'parent', 'self' or any CSS selector\n         * OR\n         - origin (Element) #optional An HTML or SVG Element whose rect will be used\n         **\n         = (object) The current origin or this Interactable\n        \\*/\n    origin: function (newValue) {\n      if (trySelector(newValue)) {\n        this.options.origin = newValue;\n        return this;\n      }\n      else if (isObject(newValue)) {\n        this.options.origin = newValue;\n        return this;\n      }\n\n      return this.options.origin;\n    },\n\n    /*\\\n         * Interactable.deltaSource\n         [ method ]\n         *\n         * Returns or sets the mouse coordinate types used to calculate the\n         * movement of the pointer.\n         *\n         - newValue (string) #optional Use 'client' if you will be scrolling while interacting; Use 'page' if you want autoScroll to work\n         = (string | object) The current deltaSource or this Interactable\n        \\*/\n    deltaSource: function (newValue) {\n      if (newValue === 'page' || newValue === 'client') {\n        this.options.deltaSource = newValue;\n\n        return this;\n      }\n\n      return this.options.deltaSource;\n    },\n\n    /*\\\n         * Interactable.restrict\n         [ method ]\n         **\n         * Deprecated. Add a `restrict` property to the options object passed to\n         * @Interactable.draggable, @Interactable.resizable or @Interactable.gesturable instead.\n         *\n         * Returns or sets the rectangles within which actions on this\n         * interactable (after snap calculations) are restricted. By default,\n         * restricting is relative to the pointer coordinates. You can change\n         * this by setting the\n         * [`elementRect`](https://github.com/taye/interact.js/pull/72).\n         **\n         - options (object) #optional an object with keys drag, resize, and/or gesture whose values are rects, Elements, CSS selectors, or 'parent' or 'self'\n         = (object) The current restrictions object or this Interactable\n         **\n         | interact(element).restrict({\n         |     // the rect will be `interact.getElementRect(element.parentNode)`\n         |     drag: element.parentNode,\n         |\n         |     // x and y are relative to the the interactable's origin\n         |     resize: { x: 100, y: 100, width: 200, height: 200 }\n         | })\n         |\n         | interact('.draggable').restrict({\n         |     // the rect will be the selected element's parent\n         |     drag: 'parent',\n         |\n         |     // do not restrict during normal movement.\n         |     // Instead, trigger only one restricted move event\n         |     // immediately before the end event.\n         |     endOnly: true,\n         |\n         |     // https://github.com/taye/interact.js/pull/72#issue-41813493\n         |     elementRect: { top: 0, left: 0, bottom: 1, right: 1 }\n         | });\n        \\*/\n    restrict: function (options) {\n      if (!isObject(options)) {\n        return this.setOptions('restrict', options);\n      }\n\n      var actions = ['drag', 'resize', 'gesture'],\n        ret;\n\n      for (var i = 0; i < actions.length; i++) {\n        var action = actions[i];\n\n        if (action in options) {\n          var perAction = extend({\n            actions: [action],\n            restriction: options[action]\n          }, options);\n\n          ret = this.setOptions('restrict', perAction);\n        }\n      }\n\n      return ret;\n    },\n\n    /*\\\n         * Interactable.context\n         [ method ]\n         *\n         * Gets the selector context Node of the Interactable. The default is `window.document`.\n         *\n         = (Node) The context Node of this Interactable\n         **\n        \\*/\n    context: function () {\n      return this._context;\n    },\n\n    _context: document,\n\n    /*\\\n         * Interactable.ignoreFrom\n         [ method ]\n         *\n         * If the target of the `mousedown`, `pointerdown` or `touchstart`\n         * event or any of it's parents match the given CSS selector or\n         * Element, no drag/resize/gesture is started.\n         *\n         - newValue (string | Element | null) #optional a CSS selector string, an Element or `null` to not ignore any elements\n         = (string | Element | object) The current ignoreFrom value or this Interactable\n         **\n         | interact(element, { ignoreFrom: document.getElementById('no-action') });\n         | // or\n         | interact(element).ignoreFrom('input, textarea, a');\n        \\*/\n    ignoreFrom: function (newValue) {\n      if (trySelector(newValue)) {            // CSS selector to match event.target\n        this.options.ignoreFrom = newValue;\n        return this;\n      }\n\n      if (isElement(newValue)) {              // specific element\n        this.options.ignoreFrom = newValue;\n        return this;\n      }\n\n      return this.options.ignoreFrom;\n    },\n\n    /*\\\n         * Interactable.allowFrom\n         [ method ]\n         *\n         * A drag/resize/gesture is started only If the target of the\n         * `mousedown`, `pointerdown` or `touchstart` event or any of it's\n         * parents match the given CSS selector or Element.\n         *\n         - newValue (string | Element | null) #optional a CSS selector string, an Element or `null` to allow from any element\n         = (string | Element | object) The current allowFrom value or this Interactable\n         **\n         | interact(element, { allowFrom: document.getElementById('drag-handle') });\n         | // or\n         | interact(element).allowFrom('.handle');\n        \\*/\n    allowFrom: function (newValue) {\n      if (trySelector(newValue)) {            // CSS selector to match event.target\n        this.options.allowFrom = newValue;\n        return this;\n      }\n\n      if (isElement(newValue)) {              // specific element\n        this.options.allowFrom = newValue;\n        return this;\n      }\n\n      return this.options.allowFrom;\n    },\n\n    /*\\\n         * Interactable.element\n         [ method ]\n         *\n         * If this is not a selector Interactable, it returns the element this\n         * interactable represents\n         *\n         = (Element) HTML / SVG Element\n        \\*/\n    element: function () {\n      return this._element;\n    },\n\n    /*\\\n         * Interactable.fire\n         [ method ]\n         *\n         * Calls listeners for the given InteractEvent type bound globally\n         * and directly to this Interactable\n         *\n         - iEvent (InteractEvent) The InteractEvent object to be fired on this Interactable\n         = (Interactable) this Interactable\n        \\*/\n    fire: function (iEvent) {\n      if (!(iEvent && iEvent.type) || !contains(eventTypes, iEvent.type)) {\n        return this;\n      }\n\n      var listeners,\n        i,\n        len,\n        onEvent = 'on' + iEvent.type,\n        funcName = '';\n\n      // Interactable#on() listeners\n      if (iEvent.type in this._iEvents) {\n        listeners = this._iEvents[iEvent.type];\n\n        for (i = 0, len = listeners.length; i < len && !iEvent.immediatePropagationStopped; i++) {\n          funcName = listeners[i].name;\n          listeners[i](iEvent);\n        }\n      }\n\n      // interactable.onevent listener\n      if (isFunction(this[onEvent])) {\n        funcName = this[onEvent].name;\n        this[onEvent](iEvent);\n      }\n\n      // interact.on() listeners\n      if (iEvent.type in globalEvents && (listeners = globalEvents[iEvent.type]))  {\n\n        for (i = 0, len = listeners.length; i < len && !iEvent.immediatePropagationStopped; i++) {\n          funcName = listeners[i].name;\n          listeners[i](iEvent);\n        }\n      }\n\n      return this;\n    },\n\n    /*\\\n         * Interactable.on\n         [ method ]\n         *\n         * Binds a listener for an InteractEvent or DOM event.\n         *\n         - eventType  (string | array | object) The types of events to listen for\n         - listener   (function) The function to be called on the given event(s)\n         - useCapture (boolean) #optional useCapture flag for addEventListener\n         = (object) This Interactable\n        \\*/\n    on: function (eventType, listener, useCapture) {\n      var i;\n\n      if (isString(eventType) && eventType.search(' ') !== -1) {\n        eventType = eventType.trim().split(/ +/);\n      }\n\n      if (isArray(eventType)) {\n        for (i = 0; i < eventType.length; i++) {\n          this.on(eventType[i], listener, useCapture);\n        }\n\n        return this;\n      }\n\n      if (isObject(eventType)) {\n        for (var prop in eventType) {\n          this.on(prop, eventType[prop], listener);\n        }\n\n        return this;\n      }\n\n      if (eventType === 'wheel') {\n        eventType = wheelEvent;\n      }\n\n      // convert to boolean\n      useCapture = useCapture? true: false;\n\n      if (contains(eventTypes, eventType)) {\n        // if this type of event was never bound to this Interactable\n        if (!(eventType in this._iEvents)) {\n          this._iEvents[eventType] = [listener];\n        }\n        else {\n          this._iEvents[eventType].push(listener);\n        }\n      }\n      // delegated event for selector\n      else if (this.selector) {\n        if (!delegatedEvents[eventType]) {\n          delegatedEvents[eventType] = {\n            selectors: [],\n            contexts : [],\n            listeners: []\n          };\n\n          // add delegate listener functions\n          for (i = 0; i < documents.length; i++) {\n            events.add(documents[i], eventType, delegateListener);\n            events.add(documents[i], eventType, delegateUseCapture, true);\n          }\n        }\n\n        var delegated = delegatedEvents[eventType],\n          index;\n\n        for (index = delegated.selectors.length - 1; index >= 0; index--) {\n          if (delegated.selectors[index] === this.selector\n            && delegated.contexts[index] === this._context) {\n            break;\n          }\n        }\n\n        if (index === -1) {\n          index = delegated.selectors.length;\n\n          delegated.selectors.push(this.selector);\n          delegated.contexts .push(this._context);\n          delegated.listeners.push([]);\n        }\n\n        // keep listener and useCapture flag\n        delegated.listeners[index].push([listener, useCapture]);\n      }\n      else {\n        events.add(this._element, eventType, listener, useCapture);\n      }\n\n      return this;\n    },\n\n    /*\\\n         * Interactable.off\n         [ method ]\n         *\n         * Removes an InteractEvent or DOM event listener\n         *\n         - eventType  (string | array | object) The types of events that were listened for\n         - listener   (function) The listener function to be removed\n         - useCapture (boolean) #optional useCapture flag for removeEventListener\n         = (object) This Interactable\n        \\*/\n    off: function (eventType, listener, useCapture) {\n      var i;\n\n      if (isString(eventType) && eventType.search(' ') !== -1) {\n        eventType = eventType.trim().split(/ +/);\n      }\n\n      if (isArray(eventType)) {\n        for (i = 0; i < eventType.length; i++) {\n          this.off(eventType[i], listener, useCapture);\n        }\n\n        return this;\n      }\n\n      if (isObject(eventType)) {\n        for (var prop in eventType) {\n          this.off(prop, eventType[prop], listener);\n        }\n\n        return this;\n      }\n\n      var eventList,\n        index = -1;\n\n      // convert to boolean\n      useCapture = useCapture? true: false;\n\n      if (eventType === 'wheel') {\n        eventType = wheelEvent;\n      }\n\n      // if it is an action event type\n      if (contains(eventTypes, eventType)) {\n        eventList = this._iEvents[eventType];\n\n        if (eventList && (index = indexOf(eventList, listener)) !== -1) {\n          this._iEvents[eventType].splice(index, 1);\n        }\n      }\n      // delegated event\n      else if (this.selector) {\n        var delegated = delegatedEvents[eventType],\n          matchFound = false;\n\n        if (!delegated) { return this; }\n\n        // count from last index of delegated to 0\n        for (index = delegated.selectors.length - 1; index >= 0; index--) {\n          // look for matching selector and context Node\n          if (delegated.selectors[index] === this.selector\n            && delegated.contexts[index] === this._context) {\n\n            var listeners = delegated.listeners[index];\n\n            // each item of the listeners array is an array: [function, useCaptureFlag]\n            for (i = listeners.length - 1; i >= 0; i--) {\n              var fn = listeners[i][0],\n                useCap = listeners[i][1];\n\n              // check if the listener functions and useCapture flags match\n              if (fn === listener && useCap === useCapture) {\n                // remove the listener from the array of listeners\n                listeners.splice(i, 1);\n\n                // if all listeners for this interactable have been removed\n                // remove the interactable from the delegated arrays\n                if (!listeners.length) {\n                  delegated.selectors.splice(index, 1);\n                  delegated.contexts .splice(index, 1);\n                  delegated.listeners.splice(index, 1);\n\n                  // remove delegate function from context\n                  events.remove(this._context, eventType, delegateListener);\n                  events.remove(this._context, eventType, delegateUseCapture, true);\n\n                  // remove the arrays if they are empty\n                  if (!delegated.selectors.length) {\n                    delegatedEvents[eventType] = null;\n                  }\n                }\n\n                // only remove one listener\n                matchFound = true;\n                break;\n              }\n            }\n\n            if (matchFound) { break; }\n          }\n        }\n      }\n      // remove listener from this Interatable's element\n      else {\n        events.remove(this._element, eventType, listener, useCapture);\n      }\n\n      return this;\n    },\n\n    /*\\\n         * Interactable.set\n         [ method ]\n         *\n         * Reset the options of this Interactable\n         - options (object) The new settings to apply\n         = (object) This Interactable\n        \\*/\n    set: function (options) {\n      if (!isObject(options)) {\n        options = {};\n      }\n\n      this.options = extend({}, defaultOptions.base);\n\n      var i,\n        actions = ['drag', 'drop', 'resize', 'gesture'],\n        methods = ['draggable', 'dropzone', 'resizable', 'gesturable'],\n        perActions = extend(extend({}, defaultOptions.perAction), options[action] || {});\n\n      for (i = 0; i < actions.length; i++) {\n        var action = actions[i];\n\n        this.options[action] = extend({}, defaultOptions[action]);\n\n        this.setPerAction(action, perActions);\n\n        this[methods[i]](options[action]);\n      }\n\n      var settings = [\n        'accept', 'actionChecker', 'allowFrom', 'deltaSource',\n        'dropChecker', 'ignoreFrom', 'origin', 'preventDefault',\n        'rectChecker', 'styleCursor'\n      ];\n\n      for (i = 0, len = settings.length; i < len; i++) {\n        var setting = settings[i];\n\n        this.options[setting] = defaultOptions.base[setting];\n\n        if (setting in options) {\n          this[setting](options[setting]);\n        }\n      }\n\n      return this;\n    },\n\n    /*\\\n         * Interactable.unset\n         [ method ]\n         *\n         * Remove this interactable from the list of interactables and remove\n         * it's drag, drop, resize and gesture capabilities\n         *\n         = (object) @interact\n        \\*/\n    unset: function () {\n      events.remove(this._element, 'all');\n\n      if (!isString(this.selector)) {\n        events.remove(this, 'all');\n        if (this.options.styleCursor) {\n          this._element.style.cursor = '';\n        }\n      }\n      else {\n        // remove delegated events\n        for (var type in delegatedEvents) {\n          var delegated = delegatedEvents[type];\n\n          for (var i = 0; i < delegated.selectors.length; i++) {\n            if (delegated.selectors[i] === this.selector\n              && delegated.contexts[i] === this._context) {\n\n              delegated.selectors.splice(i, 1);\n              delegated.contexts .splice(i, 1);\n              delegated.listeners.splice(i, 1);\n\n              // remove the arrays if they are empty\n              if (!delegated.selectors.length) {\n                delegatedEvents[type] = null;\n              }\n            }\n\n            events.remove(this._context, type, delegateListener);\n            events.remove(this._context, type, delegateUseCapture, true);\n\n            break;\n          }\n        }\n      }\n\n      this.dropzone(false);\n\n      interactables.splice(indexOf(interactables, this), 1);\n\n      return interact;\n    }\n  };\n\n  function warnOnce (method, message) {\n    var warned = false;\n\n    return function () {\n      if (!warned) {\n        window.console.warn(message);\n        warned = true;\n      }\n\n      return method.apply(this, arguments);\n    };\n  }\n\n  Interactable.prototype.snap = warnOnce(Interactable.prototype.snap,\n    'Interactable#snap is deprecated. See the new documentation for snapping at http://interactjs.io/docs/snapping');\n  Interactable.prototype.restrict = warnOnce(Interactable.prototype.restrict,\n    'Interactable#restrict is deprecated. See the new documentation for resticting at http://interactjs.io/docs/restriction');\n  Interactable.prototype.inertia = warnOnce(Interactable.prototype.inertia,\n    'Interactable#inertia is deprecated. See the new documentation for inertia at http://interactjs.io/docs/inertia');\n  Interactable.prototype.autoScroll = warnOnce(Interactable.prototype.autoScroll,\n    'Interactable#autoScroll is deprecated. See the new documentation for autoScroll at http://interactjs.io/docs/#autoscroll');\n  Interactable.prototype.squareResize = warnOnce(Interactable.prototype.squareResize,\n    'Interactable#squareResize is deprecated. See http://interactjs.io/docs/#resize-square');\n\n  Interactable.prototype.accept = warnOnce(Interactable.prototype.accept,\n    'Interactable#accept is deprecated. use Interactable#dropzone({ accept: target }) instead');\n  Interactable.prototype.dropChecker = warnOnce(Interactable.prototype.dropChecker,\n    'Interactable#dropChecker is deprecated. use Interactable#dropzone({ dropChecker: checkerFunction }) instead');\n  Interactable.prototype.context = warnOnce(Interactable.prototype.context,\n    'Interactable#context as a method is deprecated. It will soon be a DOM Node instead');\n\n  /*\\\n     * interact.isSet\n     [ method ]\n     *\n     * Check if an element has been set\n     - element (Element) The Element being searched for\n     = (boolean) Indicates if the element or CSS selector was previously passed to interact\n    \\*/\n  interact.isSet = function(element, options) {\n    return interactables.indexOfElement(element, options && options.context) !== -1;\n  };\n\n  /*\\\n     * interact.on\n     [ method ]\n     *\n     * Adds a global listener for an InteractEvent or adds a DOM event to\n     * `document`\n     *\n     - type       (string | array | object) The types of events to listen for\n     - listener   (function) The function to be called on the given event(s)\n     - useCapture (boolean) #optional useCapture flag for addEventListener\n     = (object) interact\n    \\*/\n  interact.on = function (type, listener, useCapture) {\n    if (isString(type) && type.search(' ') !== -1) {\n      type = type.trim().split(/ +/);\n    }\n\n    if (isArray(type)) {\n      for (var i = 0; i < type.length; i++) {\n        interact.on(type[i], listener, useCapture);\n      }\n\n      return interact;\n    }\n\n    if (isObject(type)) {\n      for (var prop in type) {\n        interact.on(prop, type[prop], listener);\n      }\n\n      return interact;\n    }\n\n    // if it is an InteractEvent type, add listener to globalEvents\n    if (contains(eventTypes, type)) {\n      // if this type of event was never bound\n      if (!globalEvents[type]) {\n        globalEvents[type] = [listener];\n      }\n      else {\n        globalEvents[type].push(listener);\n      }\n    }\n    // If non InteractEvent type, addEventListener to document\n    else {\n      events.add(document, type, listener, useCapture);\n    }\n\n    return interact;\n  };\n\n  /*\\\n     * interact.off\n     [ method ]\n     *\n     * Removes a global InteractEvent listener or DOM event from `document`\n     *\n     - type       (string | array | object) The types of events that were listened for\n     - listener   (function) The listener function to be removed\n     - useCapture (boolean) #optional useCapture flag for removeEventListener\n     = (object) interact\n     \\*/\n  interact.off = function (type, listener, useCapture) {\n    if (isString(type) && type.search(' ') !== -1) {\n      type = type.trim().split(/ +/);\n    }\n\n    if (isArray(type)) {\n      for (var i = 0; i < type.length; i++) {\n        interact.off(type[i], listener, useCapture);\n      }\n\n      return interact;\n    }\n\n    if (isObject(type)) {\n      for (var prop in type) {\n        interact.off(prop, type[prop], listener);\n      }\n\n      return interact;\n    }\n\n    if (!contains(eventTypes, type)) {\n      events.remove(document, type, listener, useCapture);\n    }\n    else {\n      var index;\n\n      if (type in globalEvents\n        && (index = indexOf(globalEvents[type], listener)) !== -1) {\n        globalEvents[type].splice(index, 1);\n      }\n    }\n\n    return interact;\n  };\n\n  /*\\\n     * interact.enableDragging\n     [ method ]\n     *\n     * Deprecated.\n     *\n     * Returns or sets whether dragging is enabled for any Interactables\n     *\n     - newValue (boolean) #optional `true` to allow the action; `false` to disable action for all Interactables\n     = (boolean | object) The current setting or interact\n    \\*/\n  interact.enableDragging = warnOnce(function (newValue) {\n    if (newValue !== null && newValue !== undefined) {\n      actionIsEnabled.drag = newValue;\n\n      return interact;\n    }\n    return actionIsEnabled.drag;\n  }, 'interact.enableDragging is deprecated and will soon be removed.');\n\n  /*\\\n     * interact.enableResizing\n     [ method ]\n     *\n     * Deprecated.\n     *\n     * Returns or sets whether resizing is enabled for any Interactables\n     *\n     - newValue (boolean) #optional `true` to allow the action; `false` to disable action for all Interactables\n     = (boolean | object) The current setting or interact\n    \\*/\n  interact.enableResizing = warnOnce(function (newValue) {\n    if (newValue !== null && newValue !== undefined) {\n      actionIsEnabled.resize = newValue;\n\n      return interact;\n    }\n    return actionIsEnabled.resize;\n  }, 'interact.enableResizing is deprecated and will soon be removed.');\n\n  /*\\\n     * interact.enableGesturing\n     [ method ]\n     *\n     * Deprecated.\n     *\n     * Returns or sets whether gesturing is enabled for any Interactables\n     *\n     - newValue (boolean) #optional `true` to allow the action; `false` to disable action for all Interactables\n     = (boolean | object) The current setting or interact\n    \\*/\n  interact.enableGesturing = warnOnce(function (newValue) {\n    if (newValue !== null && newValue !== undefined) {\n      actionIsEnabled.gesture = newValue;\n\n      return interact;\n    }\n    return actionIsEnabled.gesture;\n  }, 'interact.enableGesturing is deprecated and will soon be removed.');\n\n  interact.eventTypes = eventTypes;\n\n  /*\\\n     * interact.debug\n     [ method ]\n     *\n     * Returns debugging data\n     = (object) An object with properties that outline the current state and expose internal functions and variables\n    \\*/\n  interact.debug = function () {\n    var interaction = interactions[0] || new Interaction();\n\n    return {\n      interactions          : interactions,\n      target                : interaction.target,\n      dragging              : interaction.dragging,\n      resizing              : interaction.resizing,\n      gesturing             : interaction.gesturing,\n      prepared              : interaction.prepared,\n      matches               : interaction.matches,\n      matchElements         : interaction.matchElements,\n\n      prevCoords            : interaction.prevCoords,\n      startCoords           : interaction.startCoords,\n\n      pointerIds            : interaction.pointerIds,\n      pointers              : interaction.pointers,\n      addPointer            : listeners.addPointer,\n      removePointer         : listeners.removePointer,\n      recordPointer        : listeners.recordPointer,\n\n      snap                  : interaction.snapStatus,\n      restrict              : interaction.restrictStatus,\n      inertia               : interaction.inertiaStatus,\n\n      downTime              : interaction.downTimes[0],\n      downEvent             : interaction.downEvent,\n      downPointer           : interaction.downPointer,\n      prevEvent             : interaction.prevEvent,\n\n      Interactable          : Interactable,\n      interactables         : interactables,\n      pointerIsDown         : interaction.pointerIsDown,\n      defaultOptions        : defaultOptions,\n      defaultActionChecker  : defaultActionChecker,\n\n      actionCursors         : actionCursors,\n      dragMove              : listeners.dragMove,\n      resizeMove            : listeners.resizeMove,\n      gestureMove           : listeners.gestureMove,\n      pointerUp             : listeners.pointerUp,\n      pointerDown           : listeners.pointerDown,\n      pointerMove           : listeners.pointerMove,\n      pointerHover          : listeners.pointerHover,\n\n      eventTypes            : eventTypes,\n\n      events                : events,\n      globalEvents          : globalEvents,\n      delegatedEvents       : delegatedEvents,\n\n      prefixedPropREs       : prefixedPropREs\n    };\n  };\n\n  // expose the functions used to calculate multi-touch properties\n  interact.getPointerAverage = pointerAverage;\n  interact.getTouchBBox     = touchBBox;\n  interact.getTouchDistance = touchDistance;\n  interact.getTouchAngle    = touchAngle;\n\n  interact.getElementRect         = getElementRect;\n  interact.getElementClientRect   = getElementClientRect;\n  interact.matchesSelector        = matchesSelector;\n  interact.closest                = closest;\n\n  /*\\\n     * interact.margin\n     [ method ]\n     *\n     * Deprecated. Use `interact(target).resizable({ margin: number });` instead.\n     * Returns or sets the margin for autocheck resizing used in\n     * @Interactable.getAction. That is the distance from the bottom and right\n     * edges of an element clicking in which will start resizing\n     *\n     - newValue (number) #optional\n     = (number | interact) The current margin value or interact\n    \\*/\n  interact.margin = warnOnce(function (newvalue) {\n      if (isNumber(newvalue)) {\n        margin = newvalue;\n\n        return interact;\n      }\n      return margin;\n    },\n    'interact.margin is deprecated. Use interact(target).resizable({ margin: number }); instead.') ;\n\n  /*\\\n     * interact.supportsTouch\n     [ method ]\n     *\n     = (boolean) Whether or not the browser supports touch input\n    \\*/\n  interact.supportsTouch = function () {\n    return supportsTouch;\n  };\n\n  /*\\\n     * interact.supportsPointerEvent\n     [ method ]\n     *\n     = (boolean) Whether or not the browser supports PointerEvents\n    \\*/\n  interact.supportsPointerEvent = function () {\n    return supportsPointerEvent;\n  };\n\n  /*\\\n     * interact.stop\n     [ method ]\n     *\n     * Cancels all interactions (end events are not fired)\n     *\n     - event (Event) An event on which to call preventDefault()\n     = (object) interact\n    \\*/\n  interact.stop = function (event) {\n    for (var i = interactions.length - 1; i >= 0; i--) {\n      interactions[i].stop(event);\n    }\n\n    return interact;\n  };\n\n  /*\\\n     * interact.dynamicDrop\n     [ method ]\n     *\n     * Returns or sets whether the dimensions of dropzone elements are\n     * calculated on every dragmove or only on dragstart for the default\n     * dropChecker\n     *\n     - newValue (boolean) #optional True to check on each move. False to check only before start\n     = (boolean | interact) The current setting or interact\n    \\*/\n  interact.dynamicDrop = function (newValue) {\n    if (isBool(newValue)) {\n      //if (dragging && dynamicDrop !== newValue && !newValue) {\n      //calcRects(dropzones);\n      //}\n\n      dynamicDrop = newValue;\n\n      return interact;\n    }\n    return dynamicDrop;\n  };\n\n  /*\\\n     * interact.pointerMoveTolerance\n     [ method ]\n     * Returns or sets the distance the pointer must be moved before an action\n     * sequence occurs. This also affects tolerance for tap events.\n     *\n     - newValue (number) #optional The movement from the start position must be greater than this value\n     = (number | Interactable) The current setting or interact\n    \\*/\n  interact.pointerMoveTolerance = function (newValue) {\n    if (isNumber(newValue)) {\n      pointerMoveTolerance = newValue;\n\n      return this;\n    }\n\n    return pointerMoveTolerance;\n  };\n\n  /*\\\n     * interact.maxInteractions\n     [ method ]\n     **\n     * Returns or sets the maximum number of concurrent interactions allowed.\n     * By default only 1 interaction is allowed at a time (for backwards\n     * compatibility). To allow multiple interactions on the same Interactables\n     * and elements, you need to enable it in the draggable, resizable and\n     * gesturable `'max'` and `'maxPerElement'` options.\n     **\n     - newValue (number) #optional Any number. newValue <= 0 means no interactions.\n    \\*/\n  interact.maxInteractions = function (newValue) {\n    if (isNumber(newValue)) {\n      maxInteractions = newValue;\n\n      return this;\n    }\n\n    return maxInteractions;\n  };\n\n  interact.createSnapGrid = function (grid) {\n    return function (x, y) {\n      var offsetX = 0,\n        offsetY = 0;\n\n      if (isObject(grid.offset)) {\n        offsetX = grid.offset.x;\n        offsetY = grid.offset.y;\n      }\n\n      var gridx = Math.round((x - offsetX) / grid.x),\n        gridy = Math.round((y - offsetY) / grid.y),\n\n        newX = gridx * grid.x + offsetX,\n        newY = gridy * grid.y + offsetY;\n\n      return {\n        x: newX,\n        y: newY,\n        range: grid.range\n      };\n    };\n  };\n\n  function endAllInteractions (event) {\n    for (var i = 0; i < interactions.length; i++) {\n      interactions[i].pointerEnd(event, event);\n    }\n  }\n\n  function listenToDocument (doc) {\n    if (contains(documents, doc)) { return; }\n\n    var win = doc.defaultView || doc.parentWindow;\n\n    // add delegate event listener\n    for (var eventType in delegatedEvents) {\n      events.add(doc, eventType, delegateListener);\n      events.add(doc, eventType, delegateUseCapture, true);\n    }\n\n    if (supportsPointerEvent) {\n      if (PointerEvent === win.MSPointerEvent) {\n        pEventTypes = {\n          up: 'MSPointerUp', down: 'MSPointerDown', over: 'mouseover',\n          out: 'mouseout', move: 'MSPointerMove', cancel: 'MSPointerCancel' };\n      }\n      else {\n        pEventTypes = {\n          up: 'pointerup', down: 'pointerdown', over: 'pointerover',\n          out: 'pointerout', move: 'pointermove', cancel: 'pointercancel' };\n      }\n\n      events.add(doc, pEventTypes.down  , listeners.selectorDown );\n      events.add(doc, pEventTypes.move  , listeners.pointerMove  );\n      events.add(doc, pEventTypes.over  , listeners.pointerOver  );\n      events.add(doc, pEventTypes.out   , listeners.pointerOut   );\n      events.add(doc, pEventTypes.up    , listeners.pointerUp    );\n      events.add(doc, pEventTypes.cancel, listeners.pointerCancel);\n\n      // autoscroll\n      events.add(doc, pEventTypes.move, listeners.autoScrollMove);\n    }\n    else {\n      events.add(doc, 'mousedown', listeners.selectorDown);\n      events.add(doc, 'mousemove', listeners.pointerMove );\n      events.add(doc, 'mouseup'  , listeners.pointerUp   );\n      events.add(doc, 'mouseover', listeners.pointerOver );\n      events.add(doc, 'mouseout' , listeners.pointerOut  );\n\n      events.add(doc, 'touchstart' , listeners.selectorDown );\n      events.add(doc, 'touchmove'  , listeners.pointerMove  );\n      events.add(doc, 'touchend'   , listeners.pointerUp    );\n      events.add(doc, 'touchcancel', listeners.pointerCancel);\n\n      // autoscroll\n      events.add(doc, 'mousemove', listeners.autoScrollMove);\n      events.add(doc, 'touchmove', listeners.autoScrollMove);\n    }\n\n    events.add(win, 'blur', endAllInteractions);\n\n    try {\n      if (win.frameElement) {\n        var parentDoc = win.frameElement.ownerDocument,\n          parentWindow = parentDoc.defaultView;\n\n        events.add(parentDoc   , 'mouseup'      , listeners.pointerEnd);\n        events.add(parentDoc   , 'touchend'     , listeners.pointerEnd);\n        events.add(parentDoc   , 'touchcancel'  , listeners.pointerEnd);\n        events.add(parentDoc   , 'pointerup'    , listeners.pointerEnd);\n        events.add(parentDoc   , 'MSPointerUp'  , listeners.pointerEnd);\n        events.add(parentWindow, 'blur'         , endAllInteractions );\n      }\n    }\n    catch (error) {\n      interact.windowParentError = error;\n    }\n\n    // prevent native HTML5 drag on interact.js target elements\n    events.add(doc, 'dragstart', function (event) {\n      for (var i = 0; i < interactions.length; i++) {\n        var interaction = interactions[i];\n\n        if (interaction.element\n          && (interaction.element === event.target\n            || nodeContains(interaction.element, event.target))) {\n\n          interaction.checkAndPreventDefault(event, interaction.target, interaction.element);\n          return;\n        }\n      }\n    });\n\n    if (events.useAttachEvent) {\n      // For IE's lack of Event#preventDefault\n      events.add(doc, 'selectstart', function (event) {\n        var interaction = interactions[0];\n\n        if (interaction.currentAction()) {\n          interaction.checkAndPreventDefault(event);\n        }\n      });\n\n      // For IE's bad dblclick event sequence\n      events.add(doc, 'dblclick', doOnInteractions('ie8Dblclick'));\n    }\n\n    documents.push(doc);\n  }\n\n  listenToDocument(document);\n\n  function indexOf (array, target) {\n    for (var i = 0, len = array.length; i < len; i++) {\n      if (array[i] === target) {\n        return i;\n      }\n    }\n\n    return -1;\n  }\n\n  function contains (array, target) {\n    return indexOf(array, target) !== -1;\n  }\n\n  function matchesSelector (element, selector, nodeList) {\n    if (ie8MatchesSelector) {\n      return ie8MatchesSelector(element, selector, nodeList);\n    }\n\n    // remove /deep/ from selectors if shadowDOM polyfill is used\n    if (window !== realWindow) {\n      selector = selector.replace(/\\/deep\\//g, ' ');\n    }\n\n    return element[prefixedMatchesSelector](selector);\n  }\n\n  function matchesUpTo (element, selector, limit) {\n    while (isElement(element)) {\n      if (matchesSelector(element, selector)) {\n        return true;\n      }\n\n      element = parentElement(element);\n\n      if (element === limit) {\n        return matchesSelector(element, selector);\n      }\n    }\n\n    return false;\n  }\n\n  // For IE8's lack of an Element#matchesSelector\n  // taken from http://tanalin.com/en/blog/2012/12/matches-selector-ie8/ and modified\n  if (!(prefixedMatchesSelector in Element.prototype) || !isFunction(Element.prototype[prefixedMatchesSelector])) {\n    ie8MatchesSelector = function (element, selector, elems) {\n      elems = elems || element.parentNode.querySelectorAll(selector);\n\n      for (var i = 0, len = elems.length; i < len; i++) {\n        if (elems[i] === element) {\n          return true;\n        }\n      }\n\n      return false;\n    };\n  }\n\n  // requestAnimationFrame polyfill\n  (function() {\n    var lastTime = 0,\n      vendors = ['ms', 'moz', 'webkit', 'o'];\n\n    for(var x = 0; x < vendors.length && !realWindow.requestAnimationFrame; ++x) {\n      reqFrame = realWindow[vendors[x]+'RequestAnimationFrame'];\n      cancelFrame = realWindow[vendors[x]+'CancelAnimationFrame'] || realWindow[vendors[x]+'CancelRequestAnimationFrame'];\n    }\n\n    if (!reqFrame) {\n      reqFrame = function(callback) {\n        var currTime = new Date().getTime(),\n          timeToCall = Math.max(0, 16 - (currTime - lastTime)),\n          id = setTimeout(function() { callback(currTime + timeToCall); },\n            timeToCall);\n        lastTime = currTime + timeToCall;\n        return id;\n      };\n    }\n\n    if (!cancelFrame) {\n      cancelFrame = function(id) {\n        clearTimeout(id);\n      };\n    }\n  }());\n\n  /* global exports: true, module, define */\n\n  // http://documentcloud.github.io/underscore/docs/underscore.html#section-11\n  if (typeof exports !== 'undefined') {\n    if (typeof module !== 'undefined' && module.exports) {\n      exports = module.exports = interact;\n    }\n    exports.interact = interact;\n  }\n  // AMD\n  else if (typeof define === 'function' && define.amd) {\n    define('interact', function() {\n      return interact;\n    });\n  }\n  else {\n    realWindow.interact = interact;\n  }\n\n} (typeof window === 'undefined'? undefined : window));\n\n\n\n// WEBPACK FOOTER //\n// ../src/interact.js","/**\n * @license\n * (c) 2009-2013 Michael Leibman\n * michael{dot}leibman{at}gmail{dot}com\n * http://github.com/mleibman/slickgrid\n *\n * Distributed under MIT license.\n * All rights reserved.\n *\n * SlickGrid v2.2\n *\n * NOTES:\n *     Cell/row DOM manipulations are done directly bypassing jQuery's DOM manipulation methods.\n *     This increases the speed dramatically, but can only be done safely because there are no event handlers\n *     or data associated with any cell/row DOM nodes.  Cell editors must make sure they implement .destroy()\n *     and do proper cleanup.\n */\n\nimport $ from 'jquery';\nimport interact from './interact.js';\n\nimport Slick from './slick.core';\n\n// Slick.Grid globals pretense\nSlick.FrozenGrid = SlickGrid;\n\nexport default SlickGrid;\n\n// shared across all grids on the page\nvar scrollbarDimensions;\nvar maxSupportedCssHeight; // browser's breaking point\n\n//////////////////////////////////////////////////////////////////////////////////////////////\n// SlickGrid class implementation (available as Slick.Grid)\n\n/**\n * Creates a new instance of the grid.\n * @class SlickGrid\n * @constructor\n * @param {Node}              container   Container node to create the grid in.\n * @param {Array,Object}      data        An array of objects for databinding.\n * @param {Array}             columns     An array of column definitions.\n * @param {Object}            options     Grid options.\n **/\nfunction SlickGrid(container, data, columns, options){\n  // settings\n  var defaults = {\n    explicitInitialization: false,\n    rowHeight: 25,\n    defaultColumnWidth: 80,\n    enableAddRow: false,\n    leaveSpaceForNewRows: false,\n    editable: false,\n    autoEdit: true,\n    enableCellNavigation: true,\n    enableColumnReorder: true,\n    asyncEditorLoading: false,\n    asyncEditorLoadDelay: 100,\n    forceFitColumns: false,\n    enableAsyncPostRender: false,\n    asyncPostRenderDelay: 50,\n    autoHeight: false,\n    editorLock: Slick.GlobalEditorLock,\n    showHeaderRow: false,\n    headerRowHeight: 25,\n    showFooterRow: false,\n    footerRowHeight: 25,\n    showTopPanel: false,\n    topPanelHeight: 25,\n    formatterFactory: null,\n    editorFactory: null,\n    cellFlashingCssClass: \"flashing\",\n    selectedCellCssClass: \"selected\",\n    multiSelect: true,\n    enableTextSelectionOnCells: false,\n    dataItemColumnValueExtractor: null,\n    frozenBottom: false,\n    frozenColumn: -1,\n    frozenRow: -1,\n    fullWidthRows: false,\n    multiColumnSort: false,\n    defaultFormatter: defaultFormatter,\n    forceSyncScrolling: false,\n    addNewRowCssClass: \"new-row\"\n  };\n\n  var columnDefaults = {\n    name: \"\",\n    resizable: true,\n    sortable: false,\n    minWidth: 30,\n    rerenderOnResize: false,\n    headerCssClass: null,\n    defaultSortAsc: true,\n    focusable: true,\n    selectable: true\n  };\n\n  // scroller\n  var th; // virtual height\n  var h; // real scrollable height\n  var ph; // page height\n  var n; // number of pages\n  var cj; // \"jumpiness\" coefficient\n\n  var page = 0; // current page\n  var offset = 0; // current page offset\n  var vScrollDir = 1;\n\n  // private\n  var initialized = false;\n  var $container;\n  var uid = \"slickgrid_\" + Math.round(1000000 * Math.random());\n  var self = this;\n  var $focusSink, $focusSink2;\n  var $groupHeaders = $();\n  var $headerScroller;\n  var $headers;\n  var $headerRow, $headerRowScroller, $headerRowSpacerL, $headerRowSpacerR;\n  var $footerRow, $footerRowScroller, $footerRowSpacerL, $footerRowSpacerR;\n  var $topPanelScroller;\n  var $topPanel;\n  var $viewport;\n  var $canvas;\n  var $style;\n  var $boundAncestors;\n  var treeColumns;\n  var stylesheet, columnCssRulesL, columnCssRulesR;\n  var viewportH, viewportW;\n  var canvasWidth, canvasWidthL, canvasWidthR;\n  var headersWidth, headersWidthL, headersWidthR;\n  var viewportHasHScroll, viewportHasVScroll;\n  var headerColumnWidthDiff = 0,\n    headerColumnHeightDiff = 0, // border+padding\n    cellWidthDiff = 0,\n    cellHeightDiff = 0;\n  var absoluteColumnMinWidth;\n  var hasFrozenRows = false;\n  var frozenRowsHeight = 0;\n  var actualFrozenRow = -1;\n  var paneTopH = 0;\n  var paneBottomH = 0;\n  var viewportTopH = 0;\n  var viewportBottomH = 0;\n  var topPanelH = 0;\n  var headerRowH = 0;\n  var footerRowH = 0;\n\n  var tabbingDirection = 1;\n  var $activeCanvasNode;\n  var $activeViewportNode;\n  var activePosX;\n  var activeRow, activeCell;\n  var activeCellNode = null;\n  var currentEditor = null;\n  var serializedEditorValue;\n  var editController;\n\n  var rowsCache = {};\n  var renderedRows = 0;\n  var numVisibleRows = 0;\n  var prevScrollTop = 0;\n  var scrollTop = 0;\n  var lastRenderedScrollTop = 0;\n  var lastRenderedScrollLeft = 0;\n  var prevScrollLeft = 0;\n  var scrollLeft = 0;\n\n  var selectionModel;\n  var selectedRows = [];\n\n  var plugins = [];\n  var cellCssClasses = {};\n\n  var columnsById = {};\n  var sortColumns = [];\n  var columnPosLeft = [];\n  var columnPosRight = [];\n\n  // async call handles\n  var h_editorLoader = null;\n  var h_render = null;\n  var h_postrender = null;\n  var postProcessedRows = {};\n  var postProcessToRow = null;\n  var postProcessFromRow = null;\n\n  // perf counters\n  var counter_rows_rendered = 0;\n  var counter_rows_removed = 0;\n\n  // These two variables work around a bug with inertial scrolling in Webkit/Blink on Mac.\n  // See http://crbug.com/312427.\n  var rowNodeFromLastMouseWheelEvent; // this node must not be deleted while inertial scrolling\n  var zombieRowNodeFromLastMouseWheelEvent; // node that was hidden instead of getting deleted\n\n  var $paneHeaderL;\n  var $paneHeaderR;\n  var $paneTopL;\n  var $paneTopR;\n  var $paneBottomL;\n  var $paneBottomR;\n\n  var $headerScrollerL;\n  var $headerScrollerR;\n\n  var $headerL;\n  var $headerR;\n\n  var $groupHeadersL;\n  var $groupHeadersR;\n\n  var $headerRowScrollerL;\n  var $headerRowScrollerR;\n\n  var $footerRowScrollerL;\n  var $footerRowScrollerR;\n\n  var $headerRowL;\n  var $headerRowR;\n\n  var $footerRowL;\n  var $footerRowR;\n\n  var $topPanelScrollerL;\n  var $topPanelScrollerR;\n\n  var $topPanelL;\n  var $topPanelR;\n\n  var $viewportTopL;\n  var $viewportTopR;\n  var $viewportBottomL;\n  var $viewportBottomR;\n\n  var $canvasTopL;\n  var $canvasTopR;\n  var $canvasBottomL;\n  var $canvasBottomR;\n\n  var $viewportScrollContainerX;\n  var $viewportScrollContainerY;\n  var $headerScrollContainer;\n  var $headerRowScrollContainer;\n  var $footerRowScrollContainer;\n\n  //////////////////////////////////////////////////////////////////////////////////////////////\n  // Initialization\n\n  function init(){\n    $container = $(container);\n    if ($container.length < 1){\n      throw new Error(\"SlickGrid requires a valid container, \" + container + \" does not exist in the DOM.\");\n    }\n\n    // calculate these only once and share between grid instances\n    maxSupportedCssHeight = maxSupportedCssHeight || getMaxSupportedCssHeight();\n    scrollbarDimensions = scrollbarDimensions || measureScrollbar();\n\n    options = $.extend({}, defaults, options);\n    validateAndEnforceOptions();\n    columnDefaults.width = options.defaultColumnWidth;\n\n    treeColumns = new Slick.TreeColumns(columns);\n    columns = treeColumns.extractColumns();\n\n    columnsById = {};\n    for (var i = 0; i < columns.length; i++){\n      var m = columns[i] = $.extend({}, columnDefaults, columns[i]);\n      columnsById[m.id] = i;\n      if (m.minWidth && m.width < m.minWidth){\n        m.width = m.minWidth;\n      }\n      if (m.maxWidth && m.width > m.maxWidth){\n        m.width = m.maxWidth;\n      }\n    }\n\n    editController = {\n      \"commitCurrentEdit\": commitCurrentEdit,\n      \"cancelCurrentEdit\": cancelCurrentEdit\n    };\n\n    $container.empty()\n      .css(\"overflow\", \"hidden\")\n      .css(\"outline\", 0)\n      .addClass(uid)\n      .addClass(\"ui-widget\");\n\n    // set up a positioning container if needed\n    if (!/relative|absolute|fixed/.test($container.css(\"position\"))){\n      $container.css(\"position\", \"relative\");\n    }\n\n    $focusSink = $(\"<div tabIndex='0' hideFocus style='position:fixed;width:0;height:0;top:0;left:0;outline:0;'></div>\").appendTo($container);\n\n    // Containers used for scrolling frozen columns and rows\n    $paneHeaderL = $(\"<div class='slick-pane slick-pane-header slick-pane-left' tabIndex='0' />\").appendTo($container);\n    $paneHeaderR = $(\"<div class='slick-pane slick-pane-header slick-pane-right' tabIndex='0' />\").appendTo($container);\n    $paneTopL = $(\"<div class='slick-pane slick-pane-top slick-pane-left' tabIndex='0' />\").appendTo($container);\n    $paneTopR = $(\"<div class='slick-pane slick-pane-top slick-pane-right' tabIndex='0' />\").appendTo($container);\n    $paneBottomL = $(\"<div class='slick-pane slick-pane-bottom slick-pane-left' tabIndex='0' />\").appendTo($container);\n    $paneBottomR = $(\"<div class='slick-pane slick-pane-bottom slick-pane-right' tabIndex='0' />\").appendTo($container);\n\n    // Append the header scroller containers\n    $headerScrollerL = $(\"<div class='ui-state-default slick-header slick-header-left' />\").appendTo($paneHeaderL);\n    $headerScrollerR = $(\"<div class='ui-state-default slick-header slick-header-right' />\").appendTo($paneHeaderR);\n\n    // Cache the header scroller containers\n    $headerScroller = $().add($headerScrollerL).add($headerScrollerR);\n\n    if (treeColumns.hasDepth()){\n      $groupHeadersL = [], $groupHeadersR = [];\n      for (var index = 0; index < treeColumns.getDepth() - 1; index++){\n        $groupHeadersL[index] = $(\"<div class='slick-group-header-columns slick-group-header-columns-left' style='left:-1000px' />\").appendTo($headerScrollerL);\n        $groupHeadersR[index] = $(\"<div class='slick-group-header-columns slick-group-header-columns-right' style='left:-1000px' />\").appendTo($headerScrollerR);\n      }\n\n      $groupHeaders = $().add($groupHeadersL).add($groupHeadersR);\n    }\n\n    // Append the columnn containers to the headers\n    $headerL = $(\"<div class='slick-header-columns slick-header-columns-left' style='left:-1000px' />\").appendTo($headerScrollerL);\n    $headerR = $(\"<div class='slick-header-columns slick-header-columns-right' style='left:-1000px' />\").appendTo($headerScrollerR);\n\n    // Cache the header columns\n    $headers = $().add($headerL).add($headerR);\n\n    $headerRowScrollerL = $(\"<div class='ui-state-default slick-headerrow' />\").appendTo($paneTopL);\n    $headerRowScrollerR = $(\"<div class='ui-state-default slick-headerrow' />\").appendTo($paneTopR);\n\n    $headerRowScroller = $().add($headerRowScrollerL).add($headerRowScrollerR);\n\n    $headerRowSpacerL = $(\"<div style='display:block;height:1px;position:absolute;top:0;left:0;'></div>\")\n      .css(\"width\", getCanvasWidth() + scrollbarDimensions.width + \"px\")\n      .appendTo($headerRowScrollerL);\n    $headerRowSpacerR = $(\"<div style='display:block;height:1px;position:absolute;top:0;left:0;'></div>\")\n      .css(\"width\", getCanvasWidth() + scrollbarDimensions.width + \"px\")\n      .appendTo($headerRowScrollerR);\n\n    $headerRowL = $(\"<div class='slick-headerrow-columns slick-headerrow-columns-left' />\").appendTo($headerRowScrollerL);\n    $headerRowR = $(\"<div class='slick-headerrow-columns slick-headerrow-columns-right' />\").appendTo($headerRowScrollerR);\n\n    $headerRow = $().add($headerRowL).add($headerRowR);\n\n    // Append the top panel scroller\n    $topPanelScrollerL = $(\"<div class='ui-state-default slick-top-panel-scroller' />\").appendTo($paneTopL);\n    $topPanelScrollerR = $(\"<div class='ui-state-default slick-top-panel-scroller' />\").appendTo($paneTopR);\n\n    $topPanelScroller = $().add($topPanelScrollerL).add($topPanelScrollerR);\n\n    // Append the top panel\n    $topPanelL = $(\"<div class='slick-top-panel' style='width:10000px' />\").appendTo($topPanelScrollerL);\n    $topPanelR = $(\"<div class='slick-top-panel' style='width:10000px' />\").appendTo($topPanelScrollerR);\n\n    $topPanel = $().add($topPanelL).add($topPanelR);\n\n    if (!options.showTopPanel){\n      $topPanelScroller.hide();\n    }\n\n    if (!options.showHeaderRow){\n      $headerRowScroller.hide();\n    }\n\n    // Append the viewport containers\n    $viewportTopL = $(\"<div class='slick-viewport slick-viewport-top slick-viewport-left' tabIndex='0' hideFocus />\").appendTo($paneTopL);\n    $viewportTopR = $(\"<div class='slick-viewport slick-viewport-top slick-viewport-right' tabIndex='0' hideFocus />\").appendTo($paneTopR);\n    $viewportBottomL = $(\"<div class='slick-viewport slick-viewport-bottom slick-viewport-left' tabIndex='0' hideFocus />\").appendTo($paneBottomL);\n    $viewportBottomR = $(\"<div class='slick-viewport slick-viewport-bottom slick-viewport-right' tabIndex='0' hideFocus />\").appendTo($paneBottomR);\n\n    // Cache the viewports\n    $viewport = $().add($viewportTopL).add($viewportTopR).add($viewportBottomL).add($viewportBottomR);\n\n    // Default the active viewport to the top left\n    $activeViewportNode = $viewportTopL;\n\n    // Append the canvas containers\n    $canvasTopL = $(\"<div class='grid-canvas grid-canvas-top grid-canvas-left' tabIndex='0' hideFocus />\").appendTo($viewportTopL);\n    $canvasTopR = $(\"<div class='grid-canvas grid-canvas-top grid-canvas-right' tabIndex='0' hideFocus />\").appendTo($viewportTopR);\n    $canvasBottomL = $(\"<div class='grid-canvas grid-canvas-bottom grid-canvas-left' tabIndex='0' hideFocus />\").appendTo($viewportBottomL);\n    $canvasBottomR = $(\"<div class='grid-canvas grid-canvas-bottom grid-canvas-right' tabIndex='0' hideFocus />\").appendTo($viewportBottomR);\n\n    // Cache the canvases\n    $canvas = $().add($canvasTopL).add($canvasTopR).add($canvasBottomL).add($canvasBottomR);\n\n    // Default the active canvas to the top left\n    $activeCanvasNode = $canvasTopL;\n\n    // footer Row\n    $footerRowScrollerR = $(\"<div class='ui-state-default slick-footerrow' />\").appendTo($paneTopR);\n    $footerRowScrollerL = $(\"<div class='ui-state-default slick-footerrow' />\").appendTo($paneTopL);\n\n    $footerRowScroller = $().add($footerRowScrollerL).add($footerRowScrollerR);\n\n    $footerRowSpacerL = $(\"<div style='display:block;height:1px;position:absolute;top:0;left:0;'></div>\")\n      .css(\"width\", getCanvasWidth() + scrollbarDimensions.width + \"px\")\n      .appendTo($footerRowScrollerL);\n    $footerRowSpacerR = $(\"<div style='display:block;height:1px;position:absolute;top:0;left:0;'></div>\")\n      .css(\"width\", getCanvasWidth() + scrollbarDimensions.width + \"px\")\n      .appendTo($footerRowScrollerR);\n\n    $footerRowL = $(\"<div class='slick-footerrow-columns slick-footerrow-columns-left' />\").appendTo($footerRowScrollerL);\n    $footerRowR = $(\"<div class='slick-footerrow-columns slick-footerrow-columns-right' />\").appendTo($footerRowScrollerR);\n\n    $footerRow = $().add($footerRowL).add($footerRowR);\n\n    if (!options.showFooterRow){\n      $footerRowScroller.hide();\n    }\n\n    $focusSink2 = $focusSink.clone().appendTo($container);\n\n    if (!options.explicitInitialization){\n      finishInitialization();\n    }\n  }\n\n  function finishInitialization(){\n    if (!initialized){\n      initialized = true;\n\n      getViewportWidth();\n      getViewportHeight();\n\n      // header columns and cells may have different padding/border skewing width calculations (box-sizing, hello?)\n      // calculate the diff so we can set consistent sizes\n      measureCellPaddingAndBorder();\n\n      // for usability reasons, all text selection in SlickGrid is disabled\n      // with the exception of input and textarea elements (selection must\n      // be enabled there so that editors work as expected); note that\n      // selection in grid cells (grid body) is already unavailable in\n      // all browsers except IE\n      disableSelection($headers); // disable all text selection in header (including input and textarea)\n\n      if (!options.enableTextSelectionOnCells){\n        // disable text selection in grid cells except in input and textarea elements\n        // (this is IE-specific, because selectstart event will only fire in IE)\n        $viewport.bind(\"selectstart.ui\", function(event){\n          return $(event.target).is(\"input,textarea\");\n        });\n      }\n\n      setFrozenOptions();\n      setPaneVisibility();\n      setScroller();\n      setOverflow();\n\n      updateColumnCaches();\n      createColumnHeaders();\n      createColumnGroupHeaders();\n      createColumnFooter();\n      setupColumnSort();\n      createCssRules();\n      resizeCanvas();\n      bindAncestorScrollEvents();\n\n      $container.bind(\"resize.slickgrid\", resizeCanvas);\n      $viewport.on(\"scroll\", handleScroll);\n\n      if ($.fn.mousewheel && (options.frozenColumn > -1 || hasFrozenRows)){\n        $viewport.on(\"mousewheel\", handleMouseWheel);\n      }\n\n      $headerScroller.bind(\"contextmenu\", handleHeaderContextMenu)\n        .bind(\"click\", handleHeaderClick)\n        .delegate(\".slick-header-column\", \"mouseenter\", handleHeaderMouseEnter)\n        .delegate(\".slick-header-column\", \"mouseleave\", handleHeaderMouseLeave);\n      $headerRowScroller.bind(\"scroll\", handleHeaderRowScroll);\n\n      $footerRowScroller.bind(\"scroll\", handleFooterRowScroll);\n\n      $focusSink.add($focusSink2)\n        .bind(\"keydown\", handleKeyDown);\n      $canvas.bind(\"keydown\", handleKeyDown)\n        .bind(\"click\", handleClick)\n        .bind(\"dblclick\", handleDblClick)\n        .bind(\"contextmenu\", handleContextMenu)\n        .delegate(\".slick-cell\", \"mouseenter\", handleMouseEnter)\n        .delegate(\".slick-cell\", \"mouseleave\", handleMouseLeave);\n\n      // legacy support for drag events\n      interact($canvas[0]).allowFrom('div.slick-cell').draggable({\n        onmove: handleDrag,\n        onstart: handleDragStart,\n        onend: handleDragEnd\n      }).styleCursor(false);\n\n      // Work around http://crbug.com/312427.\n      if (navigator.userAgent.toLowerCase().match(/webkit/) && navigator.userAgent.toLowerCase().match(/macintosh/)){\n        $canvas.on(\"mousewheel\", handleMouseWheel);\n      }\n    }\n  }\n\n  function hasFrozenColumns(){\n    return options.frozenColumn > -1;\n  }\n\n  function registerPlugin(plugin){\n    plugins.unshift(plugin);\n    plugin.init(self);\n  }\n\n  function unregisterPlugin(plugin){\n    for (var i = plugins.length; i >= 0; i--){\n      if (plugins[i] === plugin){\n        if (plugins[i].destroy){\n          plugins[i].destroy();\n        }\n        plugins.splice(i, 1);\n        break;\n      }\n    }\n  }\n\n  function setSelectionModel(model){\n    if (selectionModel){\n      selectionModel.onSelectedRangesChanged.unsubscribe(handleSelectedRangesChanged);\n      if (selectionModel.destroy){\n        selectionModel.destroy();\n      }\n    }\n\n    selectionModel = model;\n    if (selectionModel){\n      selectionModel.init(self);\n      selectionModel.onSelectedRangesChanged.subscribe(handleSelectedRangesChanged);\n    }\n  }\n\n  function getSelectionModel(){\n    return selectionModel;\n  }\n\n  function getCanvasNode(){\n    return $canvas[0];\n  }\n\n  function getActiveCanvasNode(element){\n    setActiveCanvasNode(element);\n\n    return $activeCanvasNode[0];\n  }\n\n  function getCanvases(){\n    return $canvas;\n  }\n\n  function setActiveCanvasNode(element){\n    if (element){\n      $activeCanvasNode = $(element.target).closest('.grid-canvas');\n    }\n  }\n\n  function getViewportNode(){\n    return $viewport[0];\n  }\n\n  function getActiveViewportNode(element){\n    setActiveViewportNode(element);\n\n    return $activeViewportNode[0];\n  }\n\n  function setActiveViewportNode(element){\n    if (element){\n      $activeViewportNode = $(element.target).closest('.slick-viewport');\n    }\n  }\n\n  function measureScrollbar(){\n    var $c = $(\"<div class='scrollbar-fix' style='position:absolute; top:-10000px; left:-10000px; width:100px; height:100px; overflow:scroll;'></div>\").appendTo(document.body);\n    var dim = {\n      width: $c.width() - $c[0].clientWidth,\n      height: $c.height() - $c[0].clientHeight\n    };\n    $c.remove();\n    return dim;\n  }\n\n  function getHeadersWidth(){\n    headersWidth = headersWidthL = headersWidthR = 0;\n\n    for (var i = 0, ii = columns.length; i < ii; i++){\n      var width = columns[i].width;\n\n      if ((options.frozenColumn) > -1 && (i > options.frozenColumn)){\n        headersWidthR += width;\n      } else {\n        headersWidthL += width;\n      }\n    }\n\n    if (hasFrozenColumns()){\n      headersWidthL = headersWidthL + 1000;\n\n      headersWidthR = Math.max(headersWidthR, viewportW) + headersWidthL;\n      headersWidthR += scrollbarDimensions.width;\n    } else {\n      headersWidthL += scrollbarDimensions.width;\n      headersWidthL = Math.max(headersWidthL, viewportW) + 1000;\n    }\n\n    headersWidth = headersWidthL + headersWidthR;\n  }\n\n  function getHeadersWidthL(){\n    headersWidthL = 0;\n\n    columns.forEach(function(column, i){\n      if (!((options.frozenColumn) > -1 && (i > options.frozenColumn))) headersWidthL += column.width;\n    });\n\n    if (hasFrozenColumns()){\n      headersWidthL += 1000;\n    } else {\n      headersWidthL += scrollbarDimensions.width;\n      headersWidthL = Math.max(headersWidthL, viewportW) + 1000;\n    }\n\n    return headersWidthL;\n  }\n\n  function getHeadersWidthR(){\n    headersWidthR = 0;\n\n    columns.forEach(function(column, i){\n      if ((options.frozenColumn) > -1 && (i > options.frozenColumn)) headersWidthR += column.width;\n    });\n\n    if (hasFrozenColumns()){\n      headersWidthR = Math.max(headersWidthR, viewportW) + getHeadersWidthL();\n      headersWidthR += scrollbarDimensions.width;\n    }\n\n    return headersWidthR;\n  }\n\n  function getCanvasWidth(){\n    var availableWidth = viewportHasVScroll ? viewportW - scrollbarDimensions.width : viewportW;\n\n    var i = columns.length;\n\n    canvasWidthL = canvasWidthR = 0;\n\n    while (i--){\n      if (hasFrozenColumns() && (i > options.frozenColumn)){\n        canvasWidthR += columns[i].width;\n      } else {\n        canvasWidthL += columns[i].width;\n      }\n    }\n\n    var totalRowWidth = canvasWidthL + canvasWidthR;\n\n    return options.fullWidthRows ? Math.max(totalRowWidth, availableWidth) : totalRowWidth;\n  }\n\n  function updateCanvasWidth(forceColumnWidthsUpdate){\n    var oldCanvasWidth = canvasWidth;\n    var oldCanvasWidthL = canvasWidthL;\n    var oldCanvasWidthR = canvasWidthR;\n    var widthChanged;\n    canvasWidth = getCanvasWidth();\n\n    widthChanged = canvasWidth !== oldCanvasWidth || canvasWidthL !== oldCanvasWidthL || canvasWidthR !== oldCanvasWidthR;\n\n    if (widthChanged || hasFrozenColumns() || hasFrozenRows){\n      $canvasTopL.width(canvasWidthL);\n\n      getHeadersWidth();\n\n      $headerL.width(headersWidthL);\n      $headerR.width(headersWidthR);\n\n      if (hasFrozenColumns()){\n        $canvasTopR.width(canvasWidthR);\n\n        $paneHeaderL.width(canvasWidthL);\n        $paneHeaderR.css('left', canvasWidthL);\n        $paneHeaderR.css('width', viewportW - canvasWidthL);\n\n        $paneTopL.width(canvasWidthL);\n        $paneTopR.css('left', canvasWidthL);\n        $paneTopR.css('width', viewportW - canvasWidthL);\n\n        $headerRowScrollerL.width(canvasWidthL);\n        $headerRowScrollerR.width(viewportW - canvasWidthL);\n\n        $headerRowL.width(canvasWidthL);\n        $headerRowR.width(canvasWidthR);\n\n        $footerRowScrollerL.width(canvasWidthL);\n        $footerRowScrollerR.width(viewportW - canvasWidthL);\n\n        $footerRowL.width(canvasWidthL);\n        $footerRowR.width(canvasWidthR);\n\n        $viewportTopL.width(canvasWidthL);\n        $viewportTopR.width(viewportW - canvasWidthL);\n\n        if (hasFrozenRows){\n          $paneBottomL.width(canvasWidthL);\n          $paneBottomR.css('left', canvasWidthL);\n\n          $viewportBottomL.width(canvasWidthL);\n          $viewportBottomR.width(viewportW - canvasWidthL);\n\n          $canvasBottomL.width(canvasWidthL);\n          $canvasBottomR.width(canvasWidthR);\n        }\n      } else {\n        $paneHeaderL.width('100%');\n\n        $paneTopL.width('100%');\n\n        $headerRowScrollerL.width('100%');\n\n        $headerRowL.width(canvasWidth);\n\n        $footerRowScrollerL.width('100%');\n\n        $footerRowL.width(canvasWidth);\n\n        $viewportTopL.width('100%');\n\n        if (hasFrozenRows){\n          $viewportBottomL.width('100%');\n          $canvasBottomL.width(canvasWidthL);\n        }\n      }\n\n      viewportHasHScroll = (canvasWidth > viewportW - scrollbarDimensions.width);\n    }\n\n    $headerRowSpacerL.width(canvasWidth + (viewportHasVScroll ? scrollbarDimensions.width : 0));\n    $headerRowSpacerR.width(canvasWidth + (viewportHasVScroll ? scrollbarDimensions.width : 0));\n\n    $footerRowSpacerL.width(canvasWidth + (viewportHasVScroll ? scrollbarDimensions.width : 0));\n    $footerRowSpacerR.width(canvasWidth + (viewportHasVScroll ? scrollbarDimensions.width : 0));\n\n    if (widthChanged || forceColumnWidthsUpdate){\n      applyColumnWidths();\n    }\n  }\n\n  function disableSelection($target){\n    if ($target && $target.jquery){\n      $target.attr(\"unselectable\", \"on\")\n        .css(\"MozUserSelect\", \"none\")\n        .bind(\"selectstart.ui\", function(){\n          return false;\n        }); // from jquery:ui.core.js 1.7.2\n    }\n  }\n\n  function getMaxSupportedCssHeight(){\n    var supportedHeight = 1000000;\n    // FF reports the height back but still renders blank after ~6M px\n    var testUpTo = navigator.userAgent.toLowerCase().match(/firefox/) ? 6000000 : 1000000000;\n    var div = $(\"<div style='display:none' />\").appendTo(document.body);\n\n    while (true){\n      var test = supportedHeight * 2;\n      div.css(\"height\", test);\n      if (test > testUpTo || div.height() !== test){\n        break;\n      } else {\n        supportedHeight = test;\n      }\n    }\n\n    div.remove();\n    return supportedHeight;\n  }\n\n  // TODO:  this is static.  need to handle page mutation.\n  function bindAncestorScrollEvents(){\n    var elem = (hasFrozenRows && !options.frozenBottom) ? $canvasBottomL[0] : $canvasTopL[0];\n    while ((elem = elem.parentNode) != document.body && elem != null){\n      // bind to scroll containers only\n      if (elem == $viewportTopL[0] || elem.scrollWidth != elem.clientWidth || elem.scrollHeight != elem.clientHeight){\n        var $elem = $(elem);\n        if (!$boundAncestors){\n          $boundAncestors = $elem;\n        } else {\n          $boundAncestors = $boundAncestors.add($elem);\n        }\n        $elem.bind(\"scroll.\" + uid, handleActiveCellPositionChange);\n      }\n    }\n  }\n\n  function unbindAncestorScrollEvents(){\n    if (!$boundAncestors){\n      return;\n    }\n    $boundAncestors.unbind(\"scroll.\" + uid);\n    $boundAncestors = null;\n  }\n\n  function updateColumnHeader(columnId, title, toolTip){\n    if (!initialized){\n      return;\n    }\n    var idx = getColumnIndex(columnId);\n    if (idx == null){\n      return;\n    }\n\n    var columnDef = columns[idx];\n    var $header = $headers.children().eq(idx);\n    if ($header){\n      if (title !== undefined){\n        columns[idx].name = title;\n      }\n      if (toolTip !== undefined){\n        columns[idx].toolTip = toolTip;\n      }\n\n      trigger(self.onBeforeHeaderCellDestroy, {\n        \"node\": $header[0],\n        \"column\": columnDef\n      });\n\n      $header.attr(\"title\", toolTip || \"\")\n        .children().eq(0).html(title);\n\n      trigger(self.onHeaderCellRendered, {\n        \"node\": $header[0],\n        \"column\": columnDef\n      });\n    }\n  }\n\n  function getHeaderRow(){\n    return hasFrozenColumns() ? $headerRow : $headerRow[0];\n  }\n\n  function getHeaderRowColumn(columnId){\n    var idx = getColumnIndex(columnId);\n\n    var $headerRowTarget;\n\n    if (hasFrozenColumns()){\n      if (idx <= options.frozenColumn){\n        $headerRowTarget = $headerRowL;\n      } else {\n        $headerRowTarget = $headerRowR;\n\n        idx -= options.frozenColumn + 1;\n      }\n    } else {\n      $headerRowTarget = $headerRowL;\n    }\n\n    var $header = $headerRowTarget.children().eq(idx);\n    return $header && $header[0];\n  }\n\n  function getFooterRow(){\n    return hasFrozenColumns() ? $footerRow : $footerRow[0];\n  }\n\n  function getFooterRowColumn(columnId){\n    var idx = getColumnIndex(columnId);\n\n    var $footerRowTarget;\n\n    if (hasFrozenColumns()){\n      if (idx <= options.frozenColumn){\n        $footerRowTarget = $footerRowL;\n      } else {\n        $footerRowTarget = $footerRowR;\n\n        idx -= options.frozenColumn + 1;\n      }\n    } else {\n      $footerRowTarget = $footerRowL;\n    }\n\n    var $footer = $footerRowTarget.children().eq(idx);\n    return $footer && $footer[0];\n  }\n\n  function createColumnFooter(){\n    $footerRow.find(\".slick-footerrow-column\")\n      .each(function(){\n        var columnDef = $(this).data(\"column\");\n        if (columnDef){\n          trigger(self.onBeforeFooterRowCellDestroy, {\n            \"node\": this,\n            \"column\": columnDef\n          });\n        }\n      });\n\n    $footerRowL.empty();\n    $footerRowR.empty();\n\n    for (var i = 0; i < columns.length; i++){\n      var m = columns[i];\n\n      var footerRowCell = $(\"<div class='ui-state-default slick-footerrow-column l\" + i + \" r\" + i + \"'></div>\")\n        .data(\"column\", m)\n        .addClass(hasFrozenColumns() && i <= options.frozenColumn ? 'frozen' : '')\n        .appendTo(hasFrozenColumns() && (i > options.frozenColumn) ? $footerRowR : $footerRowL);\n\n      trigger(self.onFooterRowCellRendered, {\n        \"node\": footerRowCell[0],\n        \"column\": m\n      });\n    }\n  }\n\n  function createColumnGroupHeaders(){\n    var columnsLength = 0;\n    var frozenColumnsValid = false;\n\n    if (!treeColumns.hasDepth()) return;\n\n    for (var index = 0; index < $groupHeadersL.length; index++){\n\n      $groupHeadersL[index].empty();\n      $groupHeadersR[index].empty();\n\n      var groupColumns = treeColumns.getColumnsInDepth(index);\n\n      for (var indexGroup in groupColumns){\n        var m = groupColumns[indexGroup];\n\n        columnsLength += m.extractColumns().length;\n\n        if (hasFrozenColumns() && index == 0 && (columnsLength - 1) === options.frozenColumn) frozenColumnsValid = true;\n\n        $(\"<div class='ui-state-default slick-group-header-column' />\")\n          .html(\"<span class='slick-column-name'>\" + m.name + \"</span>\")\n          .attr(\"id\", \"\" + uid + m.id)\n          .attr(\"title\", m.toolTip || \"\")\n          .data(\"column\", m)\n          .addClass(m.headerCssClass || \"\")\n          .addClass(hasFrozenColumns() && (columnsLength - 1) <= options.frozenColumn ? 'frozen' : '')\n          .appendTo(hasFrozenColumns() && (columnsLength - 1) > options.frozenColumn ? $groupHeadersR[index] : $groupHeadersL[index]);\n      }\n\n      if (hasFrozenColumns() && index == 0 && !frozenColumnsValid){\n        $groupHeadersL[index].empty();\n        $groupHeadersR[index].empty();\n        alert(\"All columns of group should to be grouped!\");\n        break;\n      }\n    }\n\n    applyColumnGroupHeaderWidths();\n  }\n\n  function createColumnHeaders(){\n    function onMouseEnter(){\n      $(this).addClass(\"ui-state-hover\");\n    }\n\n    function onMouseLeave(){\n      $(this).removeClass(\"ui-state-hover\");\n    }\n\n    $headers.find(\".slick-header-column\")\n      .each(function(){\n        var columnDef = $(this).data(\"column\");\n        if (columnDef){\n          trigger(self.onBeforeHeaderCellDestroy, {\n            \"node\": this,\n            \"column\": columnDef\n          });\n        }\n      });\n\n    $headerL.empty();\n    $headerR.empty();\n\n    getHeadersWidth();\n\n    $headerL.width(headersWidthL);\n    $headerR.width(headersWidthR);\n\n    $headerRow.find(\".slick-headerrow-column\")\n      .each(function(){\n        var columnDef = $(this).data(\"column\");\n        if (columnDef){\n          trigger(self.onBeforeHeaderRowCellDestroy, {\n            \"node\": this,\n            \"column\": columnDef\n          });\n        }\n      });\n\n    $headerRowL.empty();\n    $headerRowR.empty();\n\n    for (var i = 0; i < columns.length; i++){\n      var m = columns[i];\n\n      var $headerTarget = hasFrozenColumns() ? ((i <= options.frozenColumn) ? $headerL : $headerR) : $headerL;\n      var $headerRowTarget = hasFrozenColumns() ? ((i <= options.frozenColumn) ? $headerRowL : $headerRowR) : $headerRowL;\n\n      var header = $(\"<div class='ui-state-default slick-header-column' />\")\n        .html(\"<span class='slick-column-name'>\" + m.name + \"</span>\")\n        .width(m.width - headerColumnWidthDiff)\n        .attr(\"id\", \"\" + uid + m.id)\n        .attr(\"title\", m.toolTip || \"\")\n        .data(\"column\", m)\n        .addClass(m.headerCssClass || \"\")\n        .addClass(hasFrozenColumns() && i <= options.frozenColumn ? 'frozen' : '')\n        .appendTo($headerTarget);\n\n      if (options.enableColumnReorder || m.sortable){\n        header.on('mouseenter', onMouseEnter)\n          .on('mouseleave', onMouseLeave);\n      }\n\n      if (m.sortable){\n        header.addClass(\"slick-header-sortable\");\n        header.append(\"<span class='slick-sort-indicator' />\");\n      }\n\n      trigger(self.onHeaderCellRendered, {\n        \"node\": header[0],\n        \"column\": m\n      });\n\n      if (options.showHeaderRow){\n        var headerRowCell = $(\"<div class='ui-state-default slick-headerrow-column l\" + i + \" r\" + i + \"'></div>\")\n          .data(\"column\", m)\n          .appendTo($headerRowTarget);\n\n        trigger(self.onHeaderRowCellRendered, {\n          \"node\": headerRowCell[0],\n          \"column\": m\n        });\n      }\n    }\n\n    setSortColumns(sortColumns);\n    setupColumnResize();\n    if (options.enableColumnReorder){\n      setupColumnReorder();\n    }\n  }\n\n  function setupColumnSort(){\n    $headers.click(function(e){\n      // temporary workaround for a bug in jQuery 1.7.1 (http://bugs.jquery.com/ticket/11328)\n      e.metaKey = e.metaKey || e.ctrlKey;\n\n      if ($(e.target).hasClass(\"slick-resizable-handle\")){\n        return;\n      }\n\n      var $col = $(e.target).closest(\".slick-header-column\");\n      if (!$col.length){\n        return;\n      }\n\n      var column = $col.data(\"column\");\n      if (column.sortable){\n        if (!getEditorLock().commitCurrentEdit()){\n          return;\n        }\n\n        var sortOpts = null;\n        var i = 0;\n        for (; i < sortColumns.length; i++){\n          if (sortColumns[i].columnId == column.id){\n            sortOpts = sortColumns[i];\n            sortOpts.sortAsc = !sortOpts.sortAsc;\n            break;\n          }\n        }\n\n        if (e.metaKey && options.multiColumnSort){\n          if (sortOpts){\n            sortColumns.splice(i, 1);\n          }\n        } else {\n          if ((!e.shiftKey && !e.metaKey) || !options.multiColumnSort){\n            sortColumns = [];\n          }\n\n          if (!sortOpts){\n            sortOpts = {\n              columnId: column.id,\n              sortAsc: column.defaultSortAsc\n            };\n            sortColumns.push(sortOpts);\n          } else if (sortColumns.length == 0){\n            sortColumns.push(sortOpts);\n          }\n        }\n\n        setSortColumns(sortColumns);\n\n        if (!options.multiColumnSort){\n          trigger(self.onSort, {\n            multiColumnSort: false,\n            sortCol: column,\n            sortAsc: sortOpts.sortAsc\n          }, e);\n        } else {\n          trigger(self.onSort, {\n            multiColumnSort: true,\n            sortCols: $.map(sortColumns, function(col){\n              return {\n                sortCol: columns[getColumnIndex(col.columnId)],\n                sortAsc: col.sortAsc\n              };\n            })\n          }, e);\n        }\n      }\n    });\n  }\n\n  function currentPositionInHeader(id){\n    var currentPosition = 0;\n    $headers.find('.slick-header-column').each(function(i){\n      if (this.id == id){\n        currentPosition = i;\n        return false;\n      }\n    });\n\n    return currentPosition;\n  }\n\n  function limitPositionInGroup(idColumn){\n    var groupColumnOfPreviousPosition,\n      startLimit = 0,\n      endLimit = 0;\n\n    treeColumns.getColumnsInDepth($groupHeadersL.length - 1)\n      .some(function(groupColumn){\n        startLimit = endLimit;\n        endLimit += groupColumn.columns.length;\n\n        groupColumn.columns.some(function(column){\n\n          if (column.id === idColumn) groupColumnOfPreviousPosition = groupColumn;\n\n          return groupColumnOfPreviousPosition;\n        });\n\n        return groupColumnOfPreviousPosition;\n      });\n\n    endLimit--;\n\n    return {\n      start: startLimit,\n      end: endLimit,\n      group: groupColumnOfPreviousPosition\n    }\n  }\n\n  function remove(arr, elem){\n    var index = arr.lastIndexOf(elem);\n    if (index > -1){\n      arr.splice(index, 1);\n      remove(arr, elem);\n    }\n  }\n\n  function columnPositionValidInGroup($item){\n    var currentPosition = currentPositionInHeader($item[0].id);\n    var limit = limitPositionInGroup($item.data('column').id);\n    var positionValid = limit.start <= currentPosition && currentPosition <= limit.end;\n\n    return {\n      limit: limit,\n      valid: positionValid,\n      message: positionValid ? '' : 'Column \"'.concat($item.text(), '\" can be reordered only within the \"', limit.group.name, '\" group!')\n    };\n  }\n\n  function setupColumnReorder(){\n    let x = 0;\n    let delta = 0;\n    let placeholder = document.createElement('div');\n\n    placeholder.className = 'interact-placeholder';\n\n    interact('.slick-header-column', {context: $container[0]})\n      .ignoreFrom('.slick-resizable-handle')\n      .draggable({\n        inertia: true,\n        // keep the element within the area of it's parent\n        restrict: {\n          restriction: 'parent',\n          endOnly: true,\n          elementRect: {top: 0, left: 0, bottom: 0, right: 0}\n        },\n        // enable autoScroll\n        autoScroll: true,\n        axis: 'x',\n        onstart: event => {\n          x = 0;\n          delta = event.target.offsetWidth;\n\n          // get old order\n          $headers.find('.slick-header-column').each(function(index){\n            $(this).data('index', index);\n          });\n\n          placeholder.style.height = event.target.offsetHeight + 'px';\n          placeholder.style.width = delta + 'px';\n\n          $(event.target).after(placeholder).css({\n            position: 'absolute',\n            zIndex: 1000,\n            marginLeft: $(event.target).position().left - 1000\n          });\n        },\n\n        onmove: event => {\n          x += event.dx;\n          event.target.style.transform = `translate3d(${x}px, -3px, 100px)`;\n          event.target.style.zIndex = 1000;\n        },\n\n        onend: event => {\n          x = 0;\n          delta = 0;\n\n          if (treeColumns.hasDepth()) {\n            var validPositionInGroup = columnPositionValidInGroup($(event.target));\n            var limit = validPositionInGroup.limit;\n\n            var cancel = !validPositionInGroup.valid;\n\n            if (cancel)\n              alert(validPositionInGroup.message);\n          }\n\n          placeholder.parentNode.removeChild(placeholder);\n\n          if (cancel){\n            event.target.style.transform = 'none';\n            setColumns(getColumns());\n            return;\n          }\n\n          $(event.target).css({\n            position: 'relative',\n            zIndex: '',\n            marginLeft: 0,\n            transform: 'none'\n          });\n\n          const newColumns = [];\n          $headers.find('.slick-header-column').each(function(index){\n            newColumns.push(columns[$(this).data('index')]);\n            $(this).removeData('index');\n          });\n\n          setColumns(newColumns);\n\n          trigger(self.onColumnsReordered, { impactedColumns : getImpactedColumns( limit ), grid: self });\n          setupColumnResize();\n        }\n      })\n      .dropzone({\n        accept: '.slick-header-column',\n\n        ondragenter: event => {\n          event.target.classList.add('interact-drop-active');\n          event.relatedTarget.classList.add('interact-can-drop');\n        },\n\n        ondragleave: event => {\n          event.target.classList.remove('interact-drop-active');\n          event.relatedTarget.classList.remove('interact-can-drop');\n        },\n\n        ondrop: event => {\n          event.target.classList.remove('interact-drop-active');\n          event.relatedTarget.classList.remove('interact-can-drop');\n          $(event.target)[x > 0 ? 'after' : 'before'](event.relatedTarget);\n        }\n      }).styleCursor(false);\n  }\n\n  function getImpactedColumns(limit){\n    var impactedColumns = [];\n\n    if (limit != undefined){\n\n      for (var i = limit.start; i <= limit.end; i++){\n        impactedColumns.push(columns[i]);\n      }\n    } else {\n\n      impactedColumns = columns;\n    }\n\n    return impactedColumns;\n  }\n\n  function setupColumnResize(){\n    var $col, j, c, pageX, columnElements, minPageX, maxPageX, firstResizable, lastResizable;\n    columnElements = $headers.children();\n    columnElements.find('.slick-resizable-handle').remove();\n    columnElements.each(function(i, e){\n      if (columns[i].resizable){\n        if (firstResizable === undefined){\n          firstResizable = i;\n        }\n        lastResizable = i;\n      }\n    });\n    if (firstResizable === undefined){\n      return;\n    }\n    columnElements.each(function(i, element){\n      if (i < firstResizable || (options.forceFitColumns && i >= lastResizable)){\n        return;\n      }\n      $col = $(element);\n\n      const $handle = $(\"<div class='slick-resizable-handle' />\");\n      $handle.appendTo(element);\n\n      if ($col.data('resizable'))\n        return;\n\n      const activeColumn = columns[i];\n      if (activeColumn.resizable){\n        $col.data('resizable', true);\n        interact(element).resizable({\n          preserveAspectRatio: false,\n          edges: { left: true, right: true, bottom: false, top: false }\n        }).on('resizestart', function(event){\n          if (!getEditorLock().commitCurrentEdit()){\n            return false;\n          }\n          activeColumn.previousWidth = event.rect.width;\n          event.target.classList.add('slick-header-column-active');\n        }).on('resizemove', function(event){\n          let x = event.dx;\n          let width = activeColumn.width += x;\n\n          if (activeColumn.minWidth > 0 && activeColumn.minWidth > width)\n            width = activeColumn.minWidth;\n          else if (activeColumn.maxWidth > 0 && activeColumn.maxWidth < width)\n            width = activeColumn.maxWidth;\n\n          activeColumn.width = width;\n\n          if (options.forceFitColumns){\n            autosizeColumns();\n          }\n          applyColumnHeaderWidths();\n          if (options.syncColumnCellResize){\n            applyColumnWidths();\n          }\n        }).on('resizeend', function(event){\n          event.target.classList.remove('slick-header-column-active');\n          if (treeColumns.hasDepth())\n            createColumnGroupHeaders();\n\n          invalidateAllRows();\n          updateCanvasWidth(true);\n          render();\n          trigger(self.onColumnsResized, {grid: self});\n        });\n      }\n    });\n  }\n\n  function getVBoxDelta($el){\n    var p = [\"borderTopWidth\", \"borderBottomWidth\", \"paddingTop\", \"paddingBottom\"];\n    var delta = 0;\n    $.each(p, function(n, val){\n      delta += parseFloat($el.css(val)) || 0;\n    });\n    return delta;\n  }\n\n  function setFrozenOptions(){\n    options.frozenColumn = (options.frozenColumn >= 0 && options.frozenColumn < columns.length) ? parseInt(options.frozenColumn) : -1;\n\n    options.frozenRow = (options.frozenRow >= 0 && options.frozenRow < numVisibleRows) ? parseInt(options.frozenRow) : -1;\n\n    if (options.frozenRow > -1){\n      hasFrozenRows = true;\n      frozenRowsHeight = (options.frozenRow) * options.rowHeight;\n\n      var dataLength = getDataLength() || this.data.length;\n\n      actualFrozenRow = (options.frozenBottom) ? (dataLength - options.frozenRow) : options.frozenRow;\n    } else {\n      hasFrozenRows = false;\n    }\n  }\n\n  function setPaneVisibility(){\n    if (hasFrozenColumns()){\n      $paneHeaderR.show();\n      $paneTopR.show();\n\n      if (hasFrozenRows){\n        $paneBottomL.show();\n        $paneBottomR.show();\n      } else {\n        $paneBottomR.hide();\n        $paneBottomL.hide();\n      }\n    } else {\n      $paneHeaderR.hide();\n      $paneTopR.hide();\n      $paneBottomR.hide();\n\n      if (hasFrozenRows){\n        $paneBottomL.show();\n      } else {\n        $paneBottomR.hide();\n        $paneBottomL.hide();\n      }\n    }\n  }\n\n  function setOverflow(){\n    $viewportTopL.css({\n      'overflow-x': (hasFrozenColumns()) ? (hasFrozenRows ? 'hidden' : 'scroll') : (hasFrozenRows ? 'hidden' : 'auto'),\n      'overflow-y': (hasFrozenColumns()) ? (hasFrozenRows ? 'hidden' : 'hidden') : (hasFrozenRows ? 'scroll' : 'auto')\n    });\n\n    $viewportTopR.css({\n      'overflow-x': (hasFrozenColumns()) ? (hasFrozenRows ? 'hidden' : 'scroll') : (hasFrozenRows ? 'hidden' : 'auto'),\n      'overflow-y': (hasFrozenColumns()) ? (hasFrozenRows ? 'scroll' : 'auto') : (hasFrozenRows ? 'scroll' : 'auto')\n    });\n\n    $viewportBottomL.css({\n      'overflow-x': (hasFrozenColumns()) ? (hasFrozenRows ? 'scroll' : 'auto') : (hasFrozenRows ? 'auto' : 'auto'),\n      'overflow-y': (hasFrozenColumns()) ? (hasFrozenRows ? 'hidden' : 'hidden') : (hasFrozenRows ? 'scroll' : 'auto')\n    });\n\n    $viewportBottomR.css({\n      'overflow-x': (hasFrozenColumns()) ? (hasFrozenRows ? 'scroll' : 'auto') : (hasFrozenRows ? 'auto' : 'auto'),\n      'overflow-y': (hasFrozenColumns()) ? (hasFrozenRows ? 'auto' : 'auto') : (hasFrozenRows ? 'auto' : 'auto')\n    });\n  }\n\n  function setScroller(){\n    if (hasFrozenColumns()){\n      $headerScrollContainer = $headerScrollerR;\n      $headerRowScrollContainer = $headerRowScrollerR;\n      $footerRowScrollContainer = $footerRowScrollerR\n\n      if (hasFrozenRows){\n        if (options.frozenBottom){\n          $viewportScrollContainerX = $viewportBottomR;\n          $viewportScrollContainerY = $viewportTopR;\n        } else {\n          $viewportScrollContainerX = $viewportScrollContainerY = $viewportBottomR;\n        }\n      } else {\n        $viewportScrollContainerX = $viewportScrollContainerY = $viewportTopR;\n      }\n    } else {\n      $headerScrollContainer = $headerScrollerL;\n      $headerRowScrollContainer = $headerRowScrollerL;\n      $footerRowScrollContainer = $footerRowScrollerL;\n\n      if (hasFrozenRows){\n        if (options.frozenBottom){\n          $viewportScrollContainerX = $viewportBottomL;\n          $viewportScrollContainerY = $viewportTopL;\n        } else {\n          $viewportScrollContainerX = $viewportScrollContainerY = $viewportBottomL;\n        }\n      } else {\n        $viewportScrollContainerX = $viewportScrollContainerY = $viewportTopL;\n      }\n    }\n  }\n\n  function measureCellPaddingAndBorder(){\n    var el;\n    var h = [\"borderLeftWidth\", \"borderRightWidth\", \"paddingLeft\", \"paddingRight\"];\n    var v = [\"borderTopWidth\", \"borderBottomWidth\", \"paddingTop\", \"paddingBottom\"];\n\n    el = $(\"<div class='ui-state-default slick-header-column' style='visibility:hidden'>-</div>\").appendTo($headers);\n    headerColumnWidthDiff = headerColumnHeightDiff = 0;\n    if (el.css(\"box-sizing\") != \"border-box\" && el.css(\"-moz-box-sizing\") != \"border-box\" && el.css(\"-webkit-box-sizing\") != \"border-box\"){\n      $.each(h, function(n, val){\n        headerColumnWidthDiff += parseFloat(el.css(val)) || 0;\n      });\n      $.each(v, function(n, val){\n        headerColumnHeightDiff += parseFloat(el.css(val)) || 0;\n      });\n    }\n    el.remove();\n\n    var r = $(\"<div class='slick-row' />\").appendTo($canvas);\n    el = $(\"<div class='slick-cell' id='' style='visibility:hidden'>-</div>\").appendTo(r);\n    cellWidthDiff = cellHeightDiff = 0;\n    if (el.css(\"box-sizing\") != \"border-box\" && el.css(\"-moz-box-sizing\") != \"border-box\" && el.css(\"-webkit-box-sizing\") != \"border-box\"){\n      $.each(h, function(n, val){\n        cellWidthDiff += parseFloat(el.css(val)) || 0;\n      });\n      $.each(v, function(n, val){\n        cellHeightDiff += parseFloat(el.css(val)) || 0;\n      });\n    }\n    r.remove();\n\n    absoluteColumnMinWidth = Math.max(headerColumnWidthDiff, cellWidthDiff);\n  }\n\n  function createCssRules(){\n    $style = $(\"<style type='text/css' rel='stylesheet' />\").appendTo($(\"head\"));\n    var rowHeight = (options.rowHeight - cellHeightDiff);\n    var rules = [\".\" + uid + \" .slick-group-header-column { left: 1000px; }\", \".\" + uid + \" .slick-header-column { left: 1000px; }\", \".\" + uid + \" .slick-top-panel { height:\" + options.topPanelHeight + \"px; }\", \".\" + uid + \" .slick-headerrow-columns { height:\" + options.headerRowHeight + \"px; }\", \".\" + uid + \" .slick-cell { height:\" + rowHeight + \"px; }\", \".\" + uid + \" .slick-row { height:\" + options.rowHeight + \"px; }\", \".\" + uid + \" .slick-footerrow-columns { height:\" + options.footerRowHeight + \"px; }\"];\n\n    for (var i = 0; i < columns.length; i++){\n      rules.push(\".\" + uid + \" .l\" + i + \" { }\");\n      rules.push(\".\" + uid + \" .r\" + i + \" { }\");\n    }\n\n    if ($style[0].styleSheet){ // IE\n      $style[0].styleSheet.cssText = rules.join(\" \");\n    } else {\n      $style[0].appendChild(document.createTextNode(rules.join(\" \")));\n    }\n  }\n\n  function getColumnCssRules(idx){\n    if (!stylesheet){\n      var sheets = document.styleSheets;\n      for (var i = 0; i < sheets.length; i++){\n        if ((sheets[i].ownerNode || sheets[i].owningElement) == $style[0]){\n          stylesheet = sheets[i];\n          break;\n        }\n      }\n\n      if (!stylesheet){\n        throw new Error(\"Cannot find stylesheet.\");\n      }\n\n      // find and cache column CSS rules\n      columnCssRulesL = [];\n      columnCssRulesR = [];\n      var cssRules = (stylesheet.cssRules || stylesheet.rules);\n      var matches, columnIdx;\n      for (var i = 0; i < cssRules.length; i++){\n        var selector = cssRules[i].selectorText;\n        if (matches = /\\.l\\d+/.exec(selector)){\n          columnIdx = parseInt(matches[0].substr(2, matches[0].length - 2), 10);\n          columnCssRulesL[columnIdx] = cssRules[i];\n        } else if (matches = /\\.r\\d+/.exec(selector)){\n          columnIdx = parseInt(matches[0].substr(2, matches[0].length - 2), 10);\n          columnCssRulesR[columnIdx] = cssRules[i];\n        }\n      }\n    }\n\n    return {\n      \"left\": columnCssRulesL[idx],\n      \"right\": columnCssRulesR[idx]\n    };\n  }\n\n  function removeCssRules(){\n    $style.remove();\n    stylesheet = null;\n  }\n\n  function destroy(){\n    getEditorLock().cancelCurrentEdit();\n\n    trigger(self.onBeforeDestroy, {});\n\n    var i = plugins.length;\n    while (i--){\n      unregisterPlugin(plugins[i]);\n    }\n\n    unbindAncestorScrollEvents();\n    $container.unbind(\".slickgrid\");\n    removeCssRules();\n\n    $container.empty().removeClass(uid);\n  }\n\n  //////////////////////////////////////////////////////////////////////////////////////////////\n  // General\n\n  function trigger(evt, args, e){\n    e = e || new Slick.EventData();\n    args = args || {};\n    args.grid = self;\n    return evt.notify(args, e, self);\n  }\n\n  function getEditorLock(){\n    return options.editorLock;\n  }\n\n  function getEditController(){\n    return editController;\n  }\n\n  function getColumnIndex(id){\n    return columnsById[id];\n  }\n\n  function autosizeColumns(){\n    var i, c,\n      widths = [],\n      shrinkLeeway = 0,\n      total = 0,\n      prevTotal,\n      availWidth = viewportHasVScroll ? viewportW - scrollbarDimensions.width : viewportW;\n\n    for (i = 0; i < columns.length; i++){\n      c = columns[i];\n      widths.push(c.width);\n      total += c.width;\n      if (c.resizable){\n        shrinkLeeway += c.width - Math.max(c.minWidth, absoluteColumnMinWidth);\n      }\n    }\n\n    // shrink\n    prevTotal = total;\n    while (total > availWidth && shrinkLeeway){\n      var shrinkProportion = (total - availWidth) / shrinkLeeway;\n      for (i = 0; i < columns.length && total > availWidth; i++){\n        c = columns[i];\n        var width = widths[i];\n        if (!c.resizable || width <= c.minWidth || width <= absoluteColumnMinWidth){\n          continue;\n        }\n        var absMinWidth = Math.max(c.minWidth, absoluteColumnMinWidth);\n        var shrinkSize = Math.floor(shrinkProportion * (width - absMinWidth)) || 1;\n        shrinkSize = Math.min(shrinkSize, width - absMinWidth);\n        total -= shrinkSize;\n        shrinkLeeway -= shrinkSize;\n        widths[i] -= shrinkSize;\n      }\n      if (prevTotal <= total){ // avoid infinite loop\n        break;\n      }\n      prevTotal = total;\n    }\n\n    // grow\n    prevTotal = total;\n    while (total < availWidth){\n      var growProportion = availWidth / total;\n      for (i = 0; i < columns.length && total < availWidth; i++){\n        c = columns[i];\n        var currentWidth = widths[i];\n        var growSize;\n\n        if (!c.resizable || c.maxWidth <= currentWidth){\n          growSize = 0;\n        } else {\n          growSize = Math.min(Math.floor(growProportion * currentWidth) - currentWidth, (c.maxWidth - currentWidth) || 1000000) || 1;\n        }\n        total += growSize;\n        widths[i] += growSize;\n      }\n      if (prevTotal >= total){ // avoid infinite loop\n        break;\n      }\n      prevTotal = total;\n    }\n\n    var reRender = false;\n    for (i = 0; i < columns.length; i++){\n      if (columns[i].rerenderOnResize && columns[i].width != widths[i]){\n        reRender = true;\n      }\n      columns[i].width = widths[i];\n    }\n\n    applyColumnHeaderWidths();\n    applyColumnGroupHeaderWidths();\n    updateCanvasWidth(true);\n    if (reRender){\n      invalidateAllRows();\n      render();\n    }\n  }\n\n  function applyColumnGroupHeaderWidths(){\n    if (!treeColumns.hasDepth()) return;\n\n    for (var depth = $groupHeadersL.length - 1; depth >= 0; depth--){\n\n      var groupColumns = treeColumns.getColumnsInDepth(depth);\n\n      $().add($groupHeadersL[depth]).add($groupHeadersR[depth]).each(function(i){\n        var $groupHeader = $(this),\n          currentColumnIndex = 0;\n\n        $groupHeader.width(i == 0 ? getHeadersWidthL() : getHeadersWidthR());\n\n        $groupHeader.children().each(function(){\n          var $groupHeaderColumn = $(this);\n\n          var m = $(this).data('column');\n\n          m.width = 0;\n\n          m.columns.forEach(function(){\n            var $headerColumn = $groupHeader.next().children(':eq(' + (currentColumnIndex++) + ')');\n            m.width += $headerColumn.outerWidth();\n          })\n\n          $groupHeaderColumn.width(m.width - headerColumnWidthDiff);\n\n        });\n\n      })\n\n    }\n  }\n\n  function applyColumnHeaderWidths(){\n    if (!initialized){\n      return;\n    }\n    var h;\n    for (var i = 0, headers = $headers.children(), ii = headers.length; i < ii; i++){\n      h = $(headers[i]);\n      if (h.width() !== columns[i].width - headerColumnWidthDiff){\n        h.width(columns[i].width - headerColumnWidthDiff);\n      }\n    }\n\n    updateColumnCaches();\n  }\n\n  function applyColumnWidths(){\n    var x = 0,\n      w, rule;\n    for (var i = 0; i < columns.length; i++){\n      w = columns[i].width;\n\n      rule = getColumnCssRules(i);\n      rule.left.style.left = x + \"px\";\n      rule.right.style.right = (((options.frozenColumn != -1 && i > options.frozenColumn) ? canvasWidthR : canvasWidthL) - x - w) + \"px\";\n\n      // If this column is frozen, reset the css left value since the\n      // column starts in a new viewport.\n      if (options.frozenColumn == i){\n        x = 0;\n      } else {\n        x += columns[i].width;\n      }\n    }\n  }\n\n  function setSortColumn(columnId, ascending){\n    setSortColumns([{\n      columnId: columnId,\n      sortAsc: ascending\n    }]);\n  }\n\n  function setSortColumns(cols){\n    sortColumns = cols;\n\n    var headerColumnEls = $headers.children();\n    headerColumnEls.removeClass(\"slick-header-column-sorted\")\n      .find(\".slick-sort-indicator\")\n      .removeClass(\"slick-sort-indicator-asc slick-sort-indicator-desc\");\n\n    $.each(sortColumns, function(i, col){\n      if (col.sortAsc == null){\n        col.sortAsc = true;\n      }\n      var columnIndex = getColumnIndex(col.columnId);\n      if (columnIndex != null){\n        headerColumnEls.eq(columnIndex)\n          .addClass(\"slick-header-column-sorted\")\n          .find(\".slick-sort-indicator\")\n          .addClass(col.sortAsc ? \"slick-sort-indicator-asc\" : \"slick-sort-indicator-desc\");\n      }\n    });\n  }\n\n  function getSortColumns(){\n    return sortColumns;\n  }\n\n  function handleSelectedRangesChanged(e, ranges){\n    selectedRows = [];\n    var hash = {};\n    for (var i = 0; i < ranges.length; i++){\n      for (var j = ranges[i].fromRow; j <= ranges[i].toRow; j++){\n        if (!hash[j]){ // prevent duplicates\n          selectedRows.push(j);\n          hash[j] = {};\n        }\n        for (var k = ranges[i].fromCell; k <= ranges[i].toCell; k++){\n          if (canCellBeSelected(j, k)){\n            hash[j][columns[k].id] = options.selectedCellCssClass;\n          }\n        }\n      }\n    }\n\n    setCellCssStyles(options.selectedCellCssClass, hash);\n\n    trigger(self.onSelectedRowsChanged, {\n      rows: getSelectedRows()\n    }, e);\n  }\n\n  function getColumns(){\n    return columns;\n  }\n\n  function updateColumnCaches(){\n    // Pre-calculate cell boundaries.\n    columnPosLeft = [];\n    columnPosRight = [];\n    var x = 0;\n    for (var i = 0, ii = columns.length; i < ii; i++){\n      columnPosLeft[i] = x;\n      columnPosRight[i] = x + columns[i].width;\n\n      if (options.frozenColumn == i){\n        x = 0;\n      } else {\n        x += columns[i].width;\n      }\n    }\n  }\n\n  function setColumns(columnDefinitions){\n    var _treeColumns = new Slick.TreeColumns(columnDefinitions);\n    if (_treeColumns.hasDepth()){\n      treeColumns = _treeColumns;\n      columns = treeColumns.extractColumns();\n    } else {\n      columns = columnDefinitions;\n    }\n\n    columnsById = {};\n    for (var i = 0; i < columns.length; i++){\n      var m = columns[i] = $.extend({}, columnDefaults, columns[i]);\n      columnsById[m.id] = i;\n      if (m.minWidth && m.width < m.minWidth){\n        m.width = m.minWidth;\n      }\n      if (m.maxWidth && m.width > m.maxWidth){\n        m.width = m.maxWidth;\n      }\n    }\n\n    updateColumnCaches();\n\n    if (initialized){\n      setPaneVisibility();\n      setOverflow();\n\n      invalidateAllRows();\n      createColumnHeaders();\n      createColumnGroupHeaders();\n      createColumnFooter();\n      removeCssRules();\n      createCssRules();\n      resizeCanvas();\n      updateCanvasWidth();\n      applyColumnWidths();\n      handleScroll();\n    }\n  }\n\n  function getOptions(){\n    return options;\n  }\n\n  function setOptions(args){\n    if (!getEditorLock().commitCurrentEdit()){\n      return;\n    }\n\n    makeActiveCellNormal();\n\n    if (options.enableAddRow !== args.enableAddRow){\n      invalidateRow(getDataLength());\n    }\n\n    options = $.extend(options, args);\n    validateAndEnforceOptions();\n\n    setFrozenOptions();\n    setScroller();\n    zombieRowNodeFromLastMouseWheelEvent = null;\n\n    setColumns(treeColumns.extractColumns());\n    render();\n  }\n\n  function validateAndEnforceOptions(){\n    if (options.autoHeight){\n      options.leaveSpaceForNewRows = false;\n    }\n  }\n\n  function setData(newData, scrollToTop){\n    data = newData;\n    invalidateAllRows();\n    updateRowCount();\n    if (scrollToTop){\n      scrollTo(0);\n    }\n  }\n\n  function getData(){\n    return data;\n  }\n\n  function getDataLength(){\n    if (data.getLength){\n      return data.getLength();\n    } else {\n      return data.length;\n    }\n  }\n\n  function getDataLengthIncludingAddNew(){\n    return getDataLength() + (options.enableAddRow ? 1 : 0);\n  }\n\n  function getDataItem(i){\n    if (data.getItem){\n      return data.getItem(i);\n    } else {\n      return data[i];\n    }\n  }\n\n  function getTopPanel(){\n    return $topPanel[0];\n  }\n\n  function setTopPanelVisibility(visible){\n    if (options.showTopPanel != visible){\n      options.showTopPanel = visible;\n      if (visible){\n        $topPanelScroller.slideDown(\"fast\", resizeCanvas);\n      } else {\n        $topPanelScroller.slideUp(\"fast\", resizeCanvas);\n      }\n    }\n  }\n\n  function setHeaderRowVisibility(visible){\n    if (options.showHeaderRow != visible){\n      options.showHeaderRow = visible;\n      if (visible){\n        $headerRowScroller.slideDown(\"fast\", resizeCanvas);\n      } else {\n        $headerRowScroller.slideUp(\"fast\", resizeCanvas);\n      }\n    }\n  }\n\n  function setFooterRowVisibility(visible){\n    if (options.showFooterRow != visible){\n      options.showFooterRow = visible;\n      if (visible){\n        $footerRowScroller.fadeIn(\"fast\", resizeCanvas);\n      } else {\n        $footerRowScroller.slideDown(\"fast\", resizeCanvas);\n      }\n    }\n  }\n\n  function getContainerNode(){\n    return $container.get(0);\n  }\n\n  //////////////////////////////////////////////////////////////////////////////////////////////\n  // Rendering / Scrolling\n\n  function getRowTop(row){\n    return options.rowHeight * row - offset;\n  }\n\n  function getRowFromPosition(y){\n    return Math.floor((y + offset) / options.rowHeight);\n  }\n\n  function scrollTo(y){\n    y = Math.max(y, 0);\n    y = Math.min(y, th - $viewportScrollContainerY.height() + ((viewportHasHScroll || hasFrozenColumns()) ? scrollbarDimensions.height : 0));\n\n    var oldOffset = offset;\n\n    page = Math.min(n - 1, Math.floor(y / ph));\n    offset = Math.round(page * cj);\n    var newScrollTop = y - offset;\n\n    if (offset != oldOffset){\n      var range = getVisibleRange(newScrollTop);\n      cleanupRows(range);\n      updateRowPositions();\n    }\n\n    if (prevScrollTop != newScrollTop){\n      vScrollDir = (prevScrollTop + oldOffset < newScrollTop + offset) ? 1 : -1;\n\n      lastRenderedScrollTop = (scrollTop = prevScrollTop = newScrollTop);\n\n      if (hasFrozenColumns()){\n        $viewportTopL[0].scrollTop = newScrollTop;\n      }\n\n      if (hasFrozenRows){\n        $viewportBottomL[0].scrollTop = $viewportBottomR[0].scrollTop = newScrollTop;\n      }\n\n      $viewportScrollContainerY[0].scrollTop = newScrollTop;\n\n      trigger(self.onViewportChanged, {});\n    }\n  }\n\n  function defaultFormatter(row, cell, value, columnDef, dataContext){\n    if (value == null){\n      return \"\";\n    } else {\n      return (value + \"\").replace(/&/g, \"&\").replace(/</g, \"<\").replace(/>/g, \">\");\n    }\n  }\n\n  function getFormatter(row, column){\n    var rowMetadata = data.getItemMetadata && data.getItemMetadata(row);\n\n    // look up by id, then index\n    var columnOverrides = rowMetadata && rowMetadata.columns && (rowMetadata.columns[column.id] || rowMetadata.columns[getColumnIndex(column.id)]);\n\n    return (columnOverrides && columnOverrides.formatter) || (rowMetadata && rowMetadata.formatter) || column.formatter || (options.formatterFactory && options.formatterFactory.getFormatter(column)) || options.defaultFormatter;\n  }\n\n  function callFormatter(row, cell, value, m, item){\n\n    var result;\n\n    // pass metadata to formatter\n    var metadata = data.getItemMetadata && data.getItemMetadata(row);\n    metadata = metadata && metadata.columns;\n\n    if (metadata){\n      var columnData = metadata[m.id] || metadata[cell];\n      result = getFormatter(row, m)(row, cell, value, m, item, columnData);\n    } else {\n      result = getFormatter(row, m)(row, cell, value, m, item);\n    }\n\n    return result;\n  }\n\n  function getEditor(row, cell){\n    var column = columns[cell];\n    var rowMetadata = data.getItemMetadata && data.getItemMetadata(row);\n    var columnMetadata = rowMetadata && rowMetadata.columns;\n\n    if (columnMetadata && columnMetadata[column.id] && columnMetadata[column.id].editor !== undefined){\n      return columnMetadata[column.id].editor;\n    }\n    if (columnMetadata && columnMetadata[cell] && columnMetadata[cell].editor !== undefined){\n      return columnMetadata[cell].editor;\n    }\n\n    return column.editor || (options.editorFactory && options.editorFactory.getEditor(column));\n  }\n\n  function getDataItemValueForColumn(item, columnDef){\n    if (options.dataItemColumnValueExtractor){\n      return options.dataItemColumnValueExtractor(item, columnDef);\n    }\n    return item[columnDef.field];\n  }\n\n  function appendRowHtml(stringArrayL, stringArrayR, row, range, dataLength){\n    var d = getDataItem(row);\n    var dataLoading = row < dataLength && !d;\n    var rowCss = \"slick-row\" + (hasFrozenRows && row < options.frozenRow ? ' frozen' : '') + (dataLoading ? \" loading\" : \"\") + (row === activeRow ? \" active\" : \"\") + (row % 2 == 1 ? \" odd\" : \" even\");\n\n    if (!d){\n      rowCss += \" \" + options.addNewRowCssClass;\n    }\n\n    var metadata = data.getItemMetadata && data.getItemMetadata(row);\n\n    if (metadata && metadata.cssClasses){\n      rowCss += \" \" + metadata.cssClasses;\n    }\n\n    var frozenRowOffset = getFrozenRowOffset(row);\n\n    var rowHtml = \"<div class='ui-widget-content \" + rowCss + \"' style='top:\" + (getRowTop(row) - frozenRowOffset) + \"px'>\";\n\n    stringArrayL.push(rowHtml);\n\n    if (hasFrozenColumns()){\n      stringArrayR.push(rowHtml);\n    }\n\n    var colspan, m;\n    for (var i = 0, ii = columns.length; i < ii; i++){\n      m = columns[i];\n      colspan = 1;\n      if (metadata && metadata.columns){\n        var columnData = metadata.columns[m.id] || metadata.columns[i];\n        colspan = (columnData && columnData.colspan) || 1;\n        if (colspan === \"*\"){\n          colspan = ii - i;\n        }\n      }\n\n      // Do not render cells outside of the viewport.\n      if (columnPosRight[Math.min(ii - 1, i + colspan - 1)] > range.leftPx){\n        if (columnPosLeft[i] > range.rightPx){\n          // All columns to the right are outside the range.\n          break;\n        }\n\n        if (hasFrozenColumns() && (i > options.frozenColumn)){\n          appendCellHtml(stringArrayR, row, i, colspan, d);\n        } else {\n          appendCellHtml(stringArrayL, row, i, colspan, d);\n        }\n      } else if (hasFrozenColumns() && (i <= options.frozenColumn)){\n        appendCellHtml(stringArrayL, row, i, colspan, d);\n      }\n\n      if (colspan > 1){\n        i += (colspan - 1);\n      }\n    }\n\n    stringArrayL.push(\"</div>\");\n\n    if (hasFrozenColumns()){\n      stringArrayR.push(\"</div>\");\n    }\n  }\n\n  function appendCellHtml(stringArray, row, cell, colspan, item){\n    var m = columns[cell];\n    var cellCss = \"slick-cell l\" + cell + \" r\" + Math.min(columns.length - 1, cell + colspan - 1) + (m.cssClass ? \" \" + m.cssClass : \"\");\n\n    if (hasFrozenColumns() && cell <= options.frozenColumn) cellCss += ' frozen';\n\n    if (row === activeRow && cell === activeCell) cellCss += \" active\";\n\n    // TODO:  merge them together in the setter\n    for (var key in cellCssClasses){\n      if (cellCssClasses[key][row] && cellCssClasses[key][row][m.id]){\n        cellCss += (\" \" + cellCssClasses[key][row][m.id]);\n      }\n    }\n\n    stringArray.push(\"<div class='\" + cellCss + \"'>\");\n\n    // if there is a corresponding row (if not, this is the Add New row or this data hasn't been loaded yet)\n    if (item){\n      var value = getDataItemValueForColumn(item, m);\n      stringArray.push(callFormatter(row, cell, value, m, item));\n    }\n\n    stringArray.push(\"</div>\");\n\n    rowsCache[row].cellRenderQueue.push(cell);\n    rowsCache[row].cellColSpans[cell] = colspan;\n  }\n\n  function cleanupRows(rangeToKeep){\n    for (var i in rowsCache){\n      var removeFrozenRow = true;\n\n      if (hasFrozenRows && ((options.frozenBottom && i >= actualFrozenRow) // Frozen bottom rows\n          ||\n          (!options.frozenBottom && i <= actualFrozenRow) // Frozen top rows\n        )){\n        removeFrozenRow = false;\n      }\n\n      if (((i = parseInt(i, 10)) !== activeRow) && (i < rangeToKeep.top || i > rangeToKeep.bottom) && (removeFrozenRow)){\n        removeRowFromCache(i);\n      }\n    }\n  }\n\n  function invalidate(){\n    updateRowCount();\n    invalidateAllRows();\n    render();\n  }\n\n  function invalidateAllRows(){\n    if (currentEditor){\n      makeActiveCellNormal();\n    }\n    for (var row in rowsCache){\n      removeRowFromCache(row);\n    }\n  }\n\n  function removeRowFromCache(row){\n    var cacheEntry = rowsCache[row];\n    if (!cacheEntry){\n      return;\n    }\n\n    if (rowNodeFromLastMouseWheelEvent == cacheEntry.rowNode[0] || (hasFrozenColumns() && rowNodeFromLastMouseWheelEvent == cacheEntry.rowNode[1])){\n\n      cacheEntry.rowNode.hide();\n\n      zombieRowNodeFromLastMouseWheelEvent = cacheEntry.rowNode;\n    } else {\n\n      cacheEntry.rowNode.each(function(){\n        this.parentElement.removeChild(this);\n      });\n\n    }\n\n    delete rowsCache[row];\n    delete postProcessedRows[row];\n    renderedRows--;\n    counter_rows_removed++;\n  }\n\n  function invalidateRows(rows){\n    var i, rl;\n    if (!rows || !rows.length){\n      return;\n    }\n    vScrollDir = 0;\n    for (i = 0, rl = rows.length; i < rl; i++){\n      if (currentEditor && activeRow === rows[i]){\n        makeActiveCellNormal();\n      }\n      if (rowsCache[rows[i]]){\n        removeRowFromCache(rows[i]);\n      }\n    }\n  }\n\n  function invalidateRow(row){\n    invalidateRows([row]);\n  }\n\n  function updateCell(row, cell){\n    var cellNode = getCellNode(row, cell);\n    if (!cellNode){\n      return;\n    }\n\n    var m = columns[cell],\n      d = getDataItem(row);\n    if (currentEditor && activeRow === row && activeCell === cell){\n      currentEditor.loadValue(d);\n    } else {\n      cellNode.innerHTML = d ? callFormatter(row, cell, getDataItemValueForColumn(d, m), m, d) : \"\";\n      invalidatePostProcessingResults(row);\n    }\n  }\n\n  function updateRow(row){\n    var cacheEntry = rowsCache[row];\n    if (!cacheEntry){\n      return;\n    }\n\n    ensureCellNodesInRowsCache(row);\n\n    var d = getDataItem(row);\n\n    for (var columnIdx in cacheEntry.cellNodesByColumnIdx){\n      if (!cacheEntry.cellNodesByColumnIdx.hasOwnProperty(columnIdx)){\n        continue;\n      }\n\n      columnIdx = columnIdx | 0;\n      var m = columns[columnIdx],\n        node = cacheEntry.cellNodesByColumnIdx[columnIdx][0];\n\n      if (row === activeRow && columnIdx === activeCell && currentEditor){\n        currentEditor.loadValue(d);\n      } else if (d){\n        node.innerHTML = callFormatter(row, columnIdx, getDataItemValueForColumn(d, m), m, d);\n      } else {\n        node.innerHTML = \"\";\n      }\n    }\n\n    invalidatePostProcessingResults(row);\n  }\n\n  function getViewportHeight(){\n    if (options.autoHeight){\n      viewportH = options.rowHeight * getDataLengthIncludingAddNew() + ((options.frozenColumn == -1) ? $headers.outerHeight() : 0);\n    } else {\n      topPanelH = (options.showTopPanel) ? options.topPanelHeight + getVBoxDelta($topPanelScroller) : 0;\n\n      headerRowH = (options.showHeaderRow) ? options.headerRowHeight + getVBoxDelta($headerRowScroller) : 0;\n\n      footerRowH = (options.showFooterRow) ? options.footerRowHeight + getVBoxDelta($footerRowScroller) : 0;\n\n      viewportH = parseFloat($.css($container[0], \"height\", true)) - parseFloat($.css($container[0], \"paddingTop\", true)) - parseFloat($.css($container[0], \"paddingBottom\", true)) - parseFloat($.css($headerScroller[0], \"height\")) - getVBoxDelta($headerScroller) - topPanelH - headerRowH - footerRowH;\n    }\n\n    numVisibleRows = Math.ceil(viewportH / options.rowHeight);\n  }\n\n  function getViewportWidth(){\n    viewportW = parseFloat($.css($container[0], \"width\", true));\n  }\n\n  function resizeCanvas(){\n    if (!initialized){\n      return;\n    }\n\n    paneTopH = 0\n    paneBottomH = 0\n    viewportTopH = 0\n    viewportBottomH = 0;\n\n    getViewportWidth();\n    getViewportHeight();\n\n    // Account for Frozen Rows\n    if (hasFrozenRows){\n      if (options.frozenBottom){\n        paneTopH = viewportH - frozenRowsHeight - scrollbarDimensions.height;\n\n        paneBottomH = frozenRowsHeight + scrollbarDimensions.height;\n      } else {\n        paneTopH = frozenRowsHeight;\n        paneBottomH = viewportH - frozenRowsHeight;\n      }\n    } else {\n      paneTopH = viewportH;\n    }\n\n    // The top pane includes the top panel and the header row\n    paneTopH += topPanelH + headerRowH + footerRowH;\n\n    if (hasFrozenColumns() && options.autoHeight){\n      paneTopH += scrollbarDimensions.height;\n    }\n\n    // The top viewport does not contain the top panel or header row\n    viewportTopH = paneTopH - topPanelH - headerRowH - footerRowH;\n\n    if (options.autoHeight){\n      if (hasFrozenColumns()){\n        $container.height(\n          paneTopH + parseFloat($.css($headerScrollerL[0], \"height\")));\n      }\n\n      $paneTopL.css('position', 'relative');\n    }\n\n    $paneTopL.css({\n      'top': $paneHeaderL.height(),\n      'height': paneTopH\n    });\n\n    var paneBottomTop = $paneTopL.position().top + paneTopH;\n\n    $viewportTopL.height(viewportTopH);\n\n    if (hasFrozenColumns()){\n      $paneTopR.css({\n        'top': $paneHeaderL.height(),\n        'height': paneTopH\n      });\n\n      $viewportTopR.height(viewportTopH);\n\n      if (hasFrozenRows){\n        $paneBottomL.css({\n          'top': paneBottomTop,\n          'height': paneBottomH\n        });\n\n        $paneBottomR.css({\n          'top': paneBottomTop,\n          'height': paneBottomH\n        });\n\n        $viewportBottomR.height(paneBottomH);\n      }\n    } else {\n      if (hasFrozenRows){\n        $paneBottomL.css({\n          'width': '100%',\n          'height': paneBottomH\n        });\n\n        $paneBottomL.css('top', paneBottomTop);\n      }\n    }\n\n    if (hasFrozenRows){\n      $viewportBottomL.height(paneBottomH);\n\n      if (options.frozenBottom){\n        $canvasBottomL.height(frozenRowsHeight);\n\n        if (hasFrozenColumns()){\n          $canvasBottomR.height(frozenRowsHeight);\n        }\n      } else {\n        $canvasTopL.height(frozenRowsHeight);\n\n        if (hasFrozenColumns()){\n          $canvasTopR.height(frozenRowsHeight);\n        }\n      }\n    } else {\n      $viewportTopR.height(viewportTopH);\n    }\n\n    if (options.forceFitColumns){\n      autosizeColumns();\n    }\n\n    updateRowCount();\n    handleScroll();\n    // Since the width has changed, force the render() to reevaluate virtually rendered cells.\n    lastRenderedScrollLeft = -1;\n    render();\n  }\n\n  function updateRowCount(){\n    if (!initialized){\n      return;\n    }\n\n    var dataLengthIncludingAddNew = getDataLengthIncludingAddNew();\n    var numberOfRows = 0;\n    var oldH = (hasFrozenRows && !options.frozenBottom) ? $canvasBottomL.height() : $canvasTopL.height();\n\n    if (hasFrozenRows){\n      var numberOfRows = getDataLength() - options.frozenRow;\n    } else {\n      var numberOfRows = dataLengthIncludingAddNew + (options.leaveSpaceForNewRows ? numVisibleRows - 1 : 0);\n    }\n\n    var tempViewportH = $viewportScrollContainerY.height();\n    var oldViewportHasVScroll = viewportHasVScroll;\n    // with autoHeight, we do not need to accommodate the vertical scroll bar\n    viewportHasVScroll = !options.autoHeight && (numberOfRows * options.rowHeight > tempViewportH);\n\n    makeActiveCellNormal();\n\n    // remove the rows that are now outside of the data range\n    // this helps avoid redundant calls to .removeRow() when the size of the data decreased by thousands of rows\n    var l = dataLengthIncludingAddNew - 1;\n    for (var i in rowsCache){\n      if (i >= l){\n        removeRowFromCache(i);\n      }\n    }\n\n    th = Math.max(options.rowHeight * numberOfRows, tempViewportH - scrollbarDimensions.height);\n\n    if (activeCellNode && activeRow > l){\n      resetActiveCell();\n    }\n\n    if (th < maxSupportedCssHeight){\n      // just one page\n      h = ph = th;\n      n = 1;\n      cj = 0;\n    } else {\n      // break into pages\n      h = maxSupportedCssHeight;\n      ph = h / 100;\n      n = Math.floor(th / ph);\n      cj = (th - h) / (n - 1);\n    }\n\n    if (h !== oldH){\n      if (hasFrozenRows && !options.frozenBottom){\n        $canvasBottomL.css(\"height\", h);\n\n        if (hasFrozenColumns()){\n          $canvasBottomR.css(\"height\", h);\n        }\n      } else {\n        $canvasTopL.css(\"height\", h);\n        $canvasTopR.css(\"height\", h);\n      }\n\n      scrollTop = $viewportScrollContainerY[0].scrollTop;\n    }\n\n    var oldScrollTopInRange = (scrollTop + offset <= th - tempViewportH);\n\n    if (th == 0 || scrollTop == 0){\n      page = offset = 0;\n    } else if (oldScrollTopInRange){\n      // maintain virtual position\n      scrollTo(scrollTop + offset);\n    } else {\n      // scroll to bottom\n      scrollTo(th - tempViewportH);\n    }\n\n    if (h != oldH && options.autoHeight){\n      resizeCanvas();\n    }\n\n    if (options.forceFitColumns && oldViewportHasVScroll != viewportHasVScroll){\n      autosizeColumns();\n    }\n    updateCanvasWidth(false);\n  }\n\n  function getVisibleRange(viewportTop, viewportLeft){\n    if (viewportTop == null){\n      viewportTop = scrollTop;\n    }\n    if (viewportLeft == null){\n      viewportLeft = scrollLeft;\n    }\n\n    return {\n      top: getRowFromPosition(viewportTop),\n      bottom: getRowFromPosition(viewportTop + viewportH) + 1,\n      leftPx: viewportLeft,\n      rightPx: viewportLeft + viewportW\n    };\n  }\n\n  function getRenderedRange(viewportTop, viewportLeft){\n    var range = getVisibleRange(viewportTop, viewportLeft);\n    var buffer = Math.round(viewportH / options.rowHeight);\n    var minBuffer = 3;\n\n    if (vScrollDir == -1){\n      range.top -= buffer;\n      range.bottom += minBuffer;\n    } else if (vScrollDir == 1){\n      range.top -= minBuffer;\n      range.bottom += buffer;\n    } else {\n      range.top -= minBuffer;\n      range.bottom += minBuffer;\n    }\n\n    range.top = Math.max(0, range.top);\n    range.bottom = Math.min(getDataLengthIncludingAddNew() - 1, range.bottom);\n\n    range.leftPx -= viewportW;\n    range.rightPx += viewportW;\n\n    range.leftPx = Math.max(0, range.leftPx);\n    range.rightPx = Math.min(canvasWidth, range.rightPx);\n\n    return range;\n  }\n\n  function ensureCellNodesInRowsCache(row){\n    var cacheEntry = rowsCache[row];\n    if (cacheEntry){\n      if (cacheEntry.cellRenderQueue.length){\n        var $lastNode = cacheEntry.rowNode.children().last();\n        while (cacheEntry.cellRenderQueue.length){\n          var columnIdx = cacheEntry.cellRenderQueue.pop();\n\n          cacheEntry.cellNodesByColumnIdx[columnIdx] = $lastNode;\n          $lastNode = $lastNode.prev();\n\n          // Hack to retrieve the frozen columns because\n          if ($lastNode.length == 0){\n            $lastNode = $(cacheEntry.rowNode[0]).children().last();\n          }\n        }\n      }\n    }\n  }\n\n  function cleanUpCells(range, row){\n    // Ignore frozen rows\n    if (hasFrozenRows && ((options.frozenBottom && row > actualFrozenRow) // Frozen bottom rows\n        ||\n        (row <= actualFrozenRow) // Frozen top rows\n      )){\n      return;\n    }\n\n    var totalCellsRemoved = 0;\n    var cacheEntry = rowsCache[row];\n\n    // Remove cells outside the range.\n    var cellsToRemove = [];\n    for (var i in cacheEntry.cellNodesByColumnIdx){\n      // I really hate it when people mess with Array.prototype.\n      if (!cacheEntry.cellNodesByColumnIdx.hasOwnProperty(i)){\n        continue;\n      }\n\n      // This is a string, so it needs to be cast back to a number.\n      i = i | 0;\n\n      // Ignore frozen columns\n      if (i <= options.frozenColumn){\n        continue;\n      }\n\n      var colspan = cacheEntry.cellColSpans[i];\n      if (columnPosLeft[i] > range.rightPx || columnPosRight[Math.min(columns.length - 1, i + colspan - 1)] < range.leftPx){\n        if (!(row == activeRow && i == activeCell)){\n          cellsToRemove.push(i);\n        }\n      }\n    }\n\n    var cellToRemove;\n    while ((cellToRemove = cellsToRemove.pop()) != null){\n      cacheEntry.cellNodesByColumnIdx[cellToRemove][0].parentElement.removeChild(cacheEntry.cellNodesByColumnIdx[cellToRemove][0]);\n      delete cacheEntry.cellColSpans[cellToRemove];\n      delete cacheEntry.cellNodesByColumnIdx[cellToRemove];\n      if (postProcessedRows[row]){\n        delete postProcessedRows[row][cellToRemove];\n      }\n      totalCellsRemoved++;\n    }\n  }\n\n  function cleanUpAndRenderCells(range){\n    var cacheEntry;\n    var stringArray = [];\n    var processedRows = [];\n    var cellsAdded;\n    var totalCellsAdded = 0;\n    var colspan;\n\n    for (var row = range.top, btm = range.bottom; row <= btm; row++){\n      cacheEntry = rowsCache[row];\n      if (!cacheEntry){\n        continue;\n      }\n\n      // cellRenderQueue populated in renderRows() needs to be cleared first\n      ensureCellNodesInRowsCache(row);\n\n      cleanUpCells(range, row);\n\n      // Render missing cells.\n      cellsAdded = 0;\n\n      var metadata = data.getItemMetadata && data.getItemMetadata(row);\n      metadata = metadata && metadata.columns;\n\n      var d = getDataItem(row);\n\n      // TODO:  shorten this loop (index? heuristics? binary search?)\n      for (var i = 0, ii = columns.length; i < ii; i++){\n        // Cells to the right are outside the range.\n        if (columnPosLeft[i] > range.rightPx){\n          break;\n        }\n\n        // Already rendered.\n        if ((colspan = cacheEntry.cellColSpans[i]) != null){\n          i += (colspan > 1 ? colspan - 1 : 0);\n          continue;\n        }\n\n        colspan = 1;\n        if (metadata){\n          var columnData = metadata[columns[i].id] || metadata[i];\n          colspan = (columnData && columnData.colspan) || 1;\n          if (colspan === \"*\"){\n            colspan = ii - i;\n          }\n        }\n\n        if (columnPosRight[Math.min(ii - 1, i + colspan - 1)] > range.leftPx){\n          appendCellHtml(stringArray, row, i, colspan, d);\n          cellsAdded++;\n        }\n\n        i += (colspan > 1 ? colspan - 1 : 0);\n      }\n\n      if (cellsAdded){\n        totalCellsAdded += cellsAdded;\n        processedRows.push(row);\n      }\n    }\n\n    if (!stringArray.length){\n      return;\n    }\n\n    var x = document.createElement(\"div\");\n    x.innerHTML = stringArray.join(\"\");\n\n    var processedRow;\n    var $node;\n    while ((processedRow = processedRows.pop()) != null){\n      cacheEntry = rowsCache[processedRow];\n      var columnIdx;\n      while ((columnIdx = cacheEntry.cellRenderQueue.pop()) != null){\n        $node = $(x).children().last();\n\n        if (hasFrozenColumns() && (columnIdx > options.frozenColumn)){\n          $(cacheEntry.rowNode[1]).append($node);\n        } else {\n          $(cacheEntry.rowNode[0]).append($node);\n        }\n\n        cacheEntry.cellNodesByColumnIdx[columnIdx] = $node;\n      }\n    }\n  }\n\n  function renderRows(range){\n    var stringArrayL = [],\n      stringArrayR = [],\n      rows = [],\n      needToReselectCell = false,\n      dataLength = getDataLength();\n\n    for (var i = range.top, ii = range.bottom; i <= ii; i++){\n      if (rowsCache[i] || (hasFrozenRows && options.frozenBottom && i == getDataLength())){\n        continue;\n      }\n      renderedRows++;\n      rows.push(i);\n\n      // Create an entry right away so that appendRowHtml() can\n      // start populatating it.\n      rowsCache[i] = {\n        \"rowNode\": null,\n\n        // ColSpans of rendered cells (by column idx).\n        // Can also be used for checking whether a cell has been rendered.\n        \"cellColSpans\": [],\n\n        // Cell nodes (by column idx).  Lazy-populated by ensureCellNodesInRowsCache().\n        \"cellNodesByColumnIdx\": [],\n\n        // Column indices of cell nodes that have been rendered, but not yet indexed in\n        // cellNodesByColumnIdx.  These are in the same order as cell nodes added at the\n        // end of the row.\n        \"cellRenderQueue\": []\n      };\n\n      appendRowHtml(stringArrayL, stringArrayR, i, range, dataLength);\n      if (activeCellNode && activeRow === i){\n        needToReselectCell = true;\n      }\n      counter_rows_rendered++;\n    }\n\n    if (!rows.length){\n      return;\n    }\n\n    var x = document.createElement(\"div\"),\n      xRight = document.createElement(\"div\");\n\n    x.innerHTML = stringArrayL.join(\"\");\n    xRight.innerHTML = stringArrayR.join(\"\");\n\n    for (var i = 0, ii = rows.length; i < ii; i++){\n      if ((hasFrozenRows) && (rows[i] >= actualFrozenRow)){\n        if (hasFrozenColumns()){\n          rowsCache[rows[i]].rowNode = $()\n            .add($(x.firstChild).appendTo($canvasBottomL))\n            .add($(xRight.firstChild).appendTo($canvasBottomR));\n        } else {\n          rowsCache[rows[i]].rowNode = $()\n            .add($(x.firstChild).appendTo($canvasBottomL));\n        }\n      } else if (hasFrozenColumns()){\n        rowsCache[rows[i]].rowNode = $()\n          .add($(x.firstChild).appendTo($canvasTopL))\n          .add($(xRight.firstChild).appendTo($canvasTopR));\n      } else {\n        rowsCache[rows[i]].rowNode = $()\n          .add($(x.firstChild).appendTo($canvasTopL));\n      }\n    }\n\n    if (needToReselectCell){\n      activeCellNode = getCellNode(activeRow, activeCell);\n    }\n  }\n\n  function startPostProcessing(){\n    if (!options.enableAsyncPostRender){\n      return;\n    }\n    clearTimeout(h_postrender);\n    h_postrender = setTimeout(asyncPostProcessRows, options.asyncPostRenderDelay);\n  }\n\n  function invalidatePostProcessingResults(row){\n    delete postProcessedRows[row];\n    postProcessFromRow = Math.min(postProcessFromRow, row);\n    postProcessToRow = Math.max(postProcessToRow, row);\n    startPostProcessing();\n  }\n\n  function updateRowPositions(){\n    for (var row in rowsCache){\n      rowsCache[row].rowNode.css('top', getRowTop(row) + \"px\");\n    }\n  }\n\n  function render(){\n    if (!initialized){\n      return;\n    }\n    var visible = getVisibleRange();\n    var rendered = getRenderedRange();\n\n    // remove rows no longer in the viewport\n    cleanupRows(rendered);\n\n    // add new rows & missing cells in existing rows\n    if (lastRenderedScrollLeft != scrollLeft){\n\n      if (hasFrozenRows){\n\n        var renderedFrozenRows = $.extend(true, {}, rendered);\n\n        if (options.frozenBottom){\n\n          renderedFrozenRows.top = actualFrozenRow;\n          renderedFrozenRows.bottom = getDataLength();\n        } else {\n\n          renderedFrozenRows.top = 0;\n          renderedFrozenRows.bottom = options.frozenRow;\n        }\n\n        cleanUpAndRenderCells(renderedFrozenRows);\n      }\n\n      cleanUpAndRenderCells(rendered);\n    }\n\n    // render missing rows\n    renderRows(rendered);\n\n    // Render frozen rows\n    if (hasFrozenRows){\n      if (options.frozenBottom){\n        renderRows({\n          top: actualFrozenRow,\n          bottom: getDataLength() - 1,\n          leftPx: rendered.leftPx,\n          rightPx: rendered.rightPx\n        });\n      } else {\n        renderRows({\n          top: 0,\n          bottom: options.frozenRow - 1,\n          leftPx: rendered.leftPx,\n          rightPx: rendered.rightPx\n        });\n      }\n    }\n\n    postProcessFromRow = visible.top;\n    postProcessToRow = Math.min(getDataLengthIncludingAddNew() - 1, visible.bottom);\n    startPostProcessing();\n\n    lastRenderedScrollTop = scrollTop;\n    lastRenderedScrollLeft = scrollLeft;\n    h_render = null;\n  }\n\n  function handleHeaderRowScroll(){\n    var scrollLeft = $headerRowScrollContainer[0].scrollLeft;\n    if (scrollLeft != $viewportScrollContainerX[0].scrollLeft){\n      $viewportScrollContainerX[0].scrollLeft = scrollLeft;\n    }\n  }\n\n  function handleFooterRowScroll(){\n    var scrollLeft = $footerRowScrollContainer[0].scrollLeft;\n    if (scrollLeft != $viewportScrollContainerX[0].scrollLeft){\n      $viewportScrollContainerX[0].scrollLeft = scrollLeft;\n    }\n  }\n\n  function handleMouseWheel(e, delta, deltaX, deltaY){\n    var $rowNode = $(e.target).closest(\".slick-row\");\n    var rowNode = $rowNode[0];\n\n    if (rowNode != rowNodeFromLastMouseWheelEvent){\n\n      var $gridCanvas = $rowNode.parents('.grid-canvas');\n      var left = $gridCanvas.hasClass('grid-canvas-left');\n\n      if (zombieRowNodeFromLastMouseWheelEvent && zombieRowNodeFromLastMouseWheelEvent[left ? 0 : 1] != rowNode){\n        var zombieRow = zombieRowNodeFromLastMouseWheelEvent[left || zombieRowNodeFromLastMouseWheelEvent.length == 1 ? 0 : 1];\n        zombieRow.parentElement.removeChild(zombieRow);\n\n        zombieRowNodeFromLastMouseWheelEvent = null;\n      }\n\n      rowNodeFromLastMouseWheelEvent = rowNode;\n    }\n\n    scrollTop = Math.max(0, $viewportScrollContainerY[0].scrollTop - (deltaY * options.rowHeight));\n    scrollLeft = $viewportScrollContainerX[0].scrollLeft + (deltaX * 10);\n    var handled = _handleScroll(true);\n    if (handled) e.preventDefault();\n  }\n\n  function handleScroll(){\n    scrollTop = $viewportScrollContainerY[0].scrollTop;\n    scrollLeft = $viewportScrollContainerX[0].scrollLeft;\n    return _handleScroll(false);\n  }\n\n  function _handleScroll(isMouseWheel){\n    var maxScrollDistanceY = $viewportScrollContainerY[0].scrollHeight - $viewportScrollContainerY[0].clientHeight;\n    var maxScrollDistanceX = $viewportScrollContainerY[0].scrollWidth - $viewportScrollContainerY[0].clientWidth;\n    var hasFrozenCols = hasFrozenColumns();\n\n    // Ceiling the max scroll values\n    if (scrollTop > maxScrollDistanceY){\n      scrollTop = maxScrollDistanceY;\n    }\n    if (scrollLeft > maxScrollDistanceX){\n      scrollLeft = maxScrollDistanceX;\n    }\n\n    var vScrollDist = Math.abs(scrollTop - prevScrollTop);\n    var hScrollDist = Math.abs(scrollLeft - prevScrollLeft);\n\n    if (hScrollDist){\n      prevScrollLeft = scrollLeft;\n\n      $viewportScrollContainerX[0].scrollLeft = scrollLeft;\n      $headerScrollContainer[0].scrollLeft = scrollLeft;\n      $topPanelScroller[0].scrollLeft = scrollLeft;\n      $headerRowScrollContainer[0].scrollLeft = scrollLeft;\n      $footerRowScrollContainer[0].scrollLeft = scrollLeft;\n\n      if (hasFrozenCols){\n        if (hasFrozenRows){\n          $viewportTopR[0].scrollLeft = scrollLeft;\n        }\n      } else {\n        if (hasFrozenRows){\n          $viewportTopL[0].scrollLeft = scrollLeft;\n        }\n      }\n    }\n\n    if (vScrollDist){\n      vScrollDir = prevScrollTop < scrollTop ? 1 : -1;\n      prevScrollTop = scrollTop;\n\n      if (isMouseWheel){\n        $viewportScrollContainerY[0].scrollTop = scrollTop;\n      }\n\n      if (hasFrozenCols){\n        if (hasFrozenRows && !options.frozenBottom){\n          $viewportBottomL[0].scrollTop = scrollTop;\n        } else {\n          $viewportTopL[0].scrollTop = scrollTop;\n        }\n      }\n\n      // switch virtual pages if needed\n      if (vScrollDist < viewportH){\n        scrollTo(scrollTop + offset);\n      } else {\n        var oldOffset = offset;\n        if (h == viewportH){\n          page = 0;\n        } else {\n          page = Math.min(n - 1, Math.floor(scrollTop * ((th - viewportH) / (h - viewportH)) * (1 / ph)));\n        }\n        offset = Math.round(page * cj);\n        if (oldOffset != offset){\n          invalidateAllRows();\n        }\n      }\n    }\n\n    if (hScrollDist || vScrollDist){\n      if (h_render){\n        clearTimeout(h_render);\n      }\n\n      if (Math.abs(lastRenderedScrollTop - scrollTop) > 20 || Math.abs(lastRenderedScrollLeft - scrollLeft) > 20){\n        if (options.forceSyncScrolling || (\n          Math.abs(lastRenderedScrollTop - scrollTop) < viewportH && Math.abs(lastRenderedScrollLeft - scrollLeft) < viewportW)){\n          render();\n        } else {\n          h_render = setTimeout(render, 50);\n        }\n\n        trigger(self.onViewportChanged, {});\n      }\n    }\n\n    trigger(self.onScroll, {\n      scrollLeft: scrollLeft,\n      scrollTop: scrollTop\n    });\n\n    if (hScrollDist || vScrollDist) return true;\n    return false;\n  }\n\n  function asyncPostProcessRows(){\n    var dataLength = getDataLength();\n    while (postProcessFromRow <= postProcessToRow){\n      var row = (vScrollDir >= 0) ? postProcessFromRow++ : postProcessToRow--;\n      var cacheEntry = rowsCache[row];\n      if (!cacheEntry || row >= dataLength){\n        continue;\n      }\n\n      if (!postProcessedRows[row]){\n        postProcessedRows[row] = {};\n      }\n\n      ensureCellNodesInRowsCache(row);\n      for (var columnIdx in cacheEntry.cellNodesByColumnIdx){\n        if (!cacheEntry.cellNodesByColumnIdx.hasOwnProperty(columnIdx)){\n          continue;\n        }\n\n        columnIdx = columnIdx | 0;\n\n        var m = columns[columnIdx];\n        if (m.asyncPostRender && !postProcessedRows[row][columnIdx]){\n          var node = cacheEntry.cellNodesByColumnIdx[columnIdx];\n          if (node){\n            m.asyncPostRender(node, row, getDataItem(row), m);\n          }\n          postProcessedRows[row][columnIdx] = true;\n        }\n      }\n\n      h_postrender = setTimeout(asyncPostProcessRows, options.asyncPostRenderDelay);\n      return;\n    }\n  }\n\n  function updateCellCssStylesOnRenderedRows(addedHash, removedHash){\n    var node, columnId, addedRowHash, removedRowHash;\n    for (var row in rowsCache){\n      removedRowHash = removedHash && removedHash[row];\n      addedRowHash = addedHash && addedHash[row];\n\n      if (removedRowHash){\n        for (columnId in removedRowHash){\n          if (!addedRowHash || removedRowHash[columnId] != addedRowHash[columnId]){\n            node = getCellNode(row, getColumnIndex(columnId));\n            if (node){\n              $(node).removeClass(removedRowHash[columnId]);\n            }\n          }\n        }\n      }\n\n      if (addedRowHash){\n        for (columnId in addedRowHash){\n          if (!removedRowHash || removedRowHash[columnId] != addedRowHash[columnId]){\n            node = getCellNode(row, getColumnIndex(columnId));\n            if (node){\n              $(node).addClass(addedRowHash[columnId]);\n            }\n          }\n        }\n      }\n    }\n  }\n\n  function addCellCssStyles(key, hash){\n    if (cellCssClasses[key]){\n      throw \"addCellCssStyles: cell CSS hash with key '\" + key + \"' already exists.\";\n    }\n\n    cellCssClasses[key] = hash;\n    updateCellCssStylesOnRenderedRows(hash, null);\n\n    trigger(self.onCellCssStylesChanged, {\n      \"key\": key,\n      \"hash\": hash\n    });\n  }\n\n  function removeCellCssStyles(key){\n    if (!cellCssClasses[key]){\n      return;\n    }\n\n    updateCellCssStylesOnRenderedRows(null, cellCssClasses[key]);\n    delete cellCssClasses[key];\n\n    trigger(self.onCellCssStylesChanged, {\n      \"key\": key,\n      \"hash\": null\n    });\n  }\n\n  function setCellCssStyles(key, hash){\n    var prevHash = cellCssClasses[key];\n\n    cellCssClasses[key] = hash;\n    updateCellCssStylesOnRenderedRows(hash, prevHash);\n\n    trigger(self.onCellCssStylesChanged, {\n      \"key\": key,\n      \"hash\": hash\n    });\n  }\n\n  function getCellCssStyles(key){\n    return cellCssClasses[key];\n  }\n\n  function flashCell(row, cell, speed){\n    speed = speed || 100;\n    if (rowsCache[row]){\n      var $cell = $(getCellNode(row, cell));\n\n      function toggleCellClass(times){\n        if (!times){\n          return;\n        }\n        setTimeout(function(){\n            $cell.queue(function(){\n              $cell.toggleClass(options.cellFlashingCssClass).dequeue();\n              toggleCellClass(times - 1);\n            });\n          },\n          speed);\n      }\n\n      toggleCellClass(4);\n    }\n  }\n\n  //////////////////////////////////////////////////////////////////////////////////////////////\n  // Interactivity\n\n  function handleDragInit(e, dd){\n    var cell = getCellFromEvent(e);\n    if (!cell || !cellExists(cell.row, cell.cell)){\n      return false;\n    }\n\n    var retval = trigger(self.onDragInit, dd, e);\n    if (e.isImmediatePropagationStopped()){\n      return retval;\n    }\n\n    // if nobody claims to be handling drag'n'drop by stopping immediate propagation,\n    // cancel out of it\n    return false;\n  }\n\n  function handleDragStart(interactEvent){\n    var event = $.Event(interactEvent.originalEvent.type, interactEvent.originalEvent);\n    var cell = getCellFromEvent(event);\n    if (!cell || !cellExists(cell.row, cell.cell)){\n      return false;\n    }\n\n    var retval = trigger(self.onDragStart, interactEvent, event);\n    if (event.isImmediatePropagationStopped()){\n      return retval;\n    }\n\n    return false;\n  }\n\n  function handleDrag(interactEvent){\n    var event = $.Event(interactEvent.originalEvent.type, interactEvent.originalEvent);\n    return trigger(self.onDrag, interactEvent, event);\n  }\n\n  function handleDragEnd(interactEvent){\n    trigger(self.onDragEnd, interactEvent, $.Event('mousedown'));\n  }\n\n  function handleKeyDown(e){\n    trigger(self.onKeyDown, {\n      row: activeRow,\n      cell: activeCell\n    }, e);\n    var handled = e.isImmediatePropagationStopped();\n\n    if (!handled){\n      if (!e.shiftKey && !e.altKey && !e.ctrlKey){\n        if (e.which == 27){\n          if (!getEditorLock().isActive()){\n            return; // no editing mode to cancel, allow bubbling and default processing (exit without cancelling the event)\n          }\n          cancelEditAndSetFocus();\n        } else if (e.which == 34){\n          navigatePageDown();\n          handled = true;\n        } else if (e.which == 33){\n          navigatePageUp();\n          handled = true;\n        } else if (e.which == 37){\n          handled = navigateLeft();\n        } else if (e.which == 39){\n          handled = navigateRight();\n        } else if (e.which == 38){\n          handled = navigateUp();\n        } else if (e.which == 40){\n          handled = navigateDown();\n        } else if (e.which == 9){\n          handled = navigateNext();\n        } else if (e.which == 13){\n          if (options.editable){\n            if (currentEditor){\n              // adding new row\n              if (activeRow === getDataLength()){\n                navigateDown();\n              } else {\n                commitEditAndSetFocus();\n              }\n            } else {\n              if (getEditorLock().commitCurrentEdit()){\n                makeActiveCellEditable();\n              }\n            }\n          }\n          handled = true;\n        }\n      } else if (e.which == 9 && e.shiftKey && !e.ctrlKey && !e.altKey){\n        handled = navigatePrev();\n      }\n    }\n\n    if (handled){\n      // the event has been handled so don't let parent element (bubbling/propagation) or browser (default) handle it\n      e.stopPropagation();\n      e.preventDefault();\n      try {\n        e.originalEvent.keyCode = 0; // prevent default behaviour for special keys in IE browsers (F3, F5, etc.)\n      }\n        // ignore exceptions - setting the original event's keycode throws access denied exception for \"Ctrl\"\n        // (hitting control key only, nothing else), \"Shift\" (maybe others)\n      catch (error) {\n      }\n    }\n  }\n\n  function handleClick(e){\n    if (!currentEditor){\n      // if this click resulted in some cell child node getting focus,\n      // don't steal it back - keyboard events will still bubble up\n      // IE9+ seems to default DIVs to tabIndex=0 instead of -1, so check for cell clicks directly.\n      if (e.target != document.activeElement || $(e.target).hasClass(\"slick-cell\")){\n        setFocus();\n      }\n    }\n\n    var cell = getCellFromEvent(e);\n    if (!cell || (currentEditor !== null && activeRow == cell.row && activeCell == cell.cell)){\n      return;\n    }\n\n    trigger(self.onClick, {\n      row: cell.row,\n      cell: cell.cell\n    }, e);\n    if (e.isImmediatePropagationStopped()){\n      return;\n    }\n\n    if ((activeCell != cell.cell || activeRow != cell.row) && canCellBeActive(cell.row, cell.cell)){\n      if (!getEditorLock().isActive() || getEditorLock().commitCurrentEdit()){\n\n        scrollRowIntoView(cell.row, false);\n        setActiveCellInternal(getCellNode(cell.row, cell.cell));\n      }\n    }\n  }\n\n  function handleContextMenu(e){\n    var $cell = $(e.target).closest(\".slick-cell\", $canvas);\n    if ($cell.length === 0){\n      return;\n    }\n\n    // are we editing this cell?\n    if (activeCellNode === $cell[0] && currentEditor !== null){\n      return;\n    }\n\n    trigger(self.onContextMenu, {}, e);\n  }\n\n  function handleDblClick(e){\n    var cell = getCellFromEvent(e);\n    if (!cell || (currentEditor !== null && activeRow == cell.row && activeCell == cell.cell)){\n      return;\n    }\n\n    trigger(self.onDblClick, {\n      row: cell.row,\n      cell: cell.cell\n    }, e);\n    if (e.isImmediatePropagationStopped()){\n      return;\n    }\n\n    if (options.editable){\n      gotoCell(cell.row, cell.cell, true);\n    }\n  }\n\n  function handleHeaderMouseEnter(e){\n    trigger(self.onHeaderMouseEnter, {\n      \"column\": $(this).data(\"column\")\n    }, e);\n  }\n\n  function handleHeaderMouseLeave(e){\n    trigger(self.onHeaderMouseLeave, {\n      \"column\": $(this).data(\"column\")\n    }, e);\n  }\n\n  function handleHeaderContextMenu(e){\n    var $header = $(e.target).closest(\".slick-header-column\", \".slick-header-columns\");\n    var column = $header && $header.data(\"column\");\n    trigger(self.onHeaderContextMenu, {\n      column: column\n    }, e);\n  }\n\n  function handleHeaderClick(e){\n    var $header = $(e.target).closest(\".slick-header-column\", \".slick-header-columns\");\n    var column = $header && $header.data(\"column\");\n    if (column){\n      trigger(self.onHeaderClick, {\n        column: column\n      }, e);\n    }\n  }\n\n  function handleMouseEnter(e){\n    trigger(self.onMouseEnter, {}, e);\n  }\n\n  function handleMouseLeave(e){\n    trigger(self.onMouseLeave, {}, e);\n  }\n\n  function cellExists(row, cell){\n    return !(row < 0 || row >= getDataLength() || cell < 0 || cell >= columns.length);\n  }\n\n  function getCellFromPoint(x, y){\n    var row = getRowFromPosition(y);\n    var cell = 0;\n\n    var w = 0;\n    for (var i = 0; i < columns.length && w < x; i++){\n      w += columns[i].width;\n      cell++;\n    }\n\n    if (cell < 0){\n      cell = 0;\n    }\n\n    return {\n      row: row,\n      cell: cell - 1\n    };\n  }\n\n  function getCellFromNode(cellNode){\n    // read column number from .l<columnNumber> CSS class\n    var cls = /l\\d+/.exec(cellNode.className);\n    if (!cls){\n      throw \"getCellFromNode: cannot get cell - \" + cellNode.className;\n    }\n    return parseInt(cls[0].substr(1, cls[0].length - 1), 10);\n  }\n\n  function getRowFromNode(rowNode){\n    for (var row in rowsCache)\n      for (var i in rowsCache[row].rowNode)\n        if (rowsCache[row].rowNode[i] === rowNode) return row | 0;\n\n    return null;\n  }\n\n  function getFrozenRowOffset(row){\n    var offset = (hasFrozenRows) ? (options.frozenBottom) ? (row >= actualFrozenRow) ? (h < viewportTopH) ? (actualFrozenRow * options.rowHeight) : h : 0 : (row >= actualFrozenRow) ? frozenRowsHeight : 0 : 0;\n\n    return offset;\n  }\n\n  function getCellFromEvent(e){\n    var row, cell;\n    var $cell = $(e.target).closest(\".slick-cell\", $canvas);\n    if (!$cell.length){\n      return null;\n    }\n\n    row = getRowFromNode($cell[0].parentNode);\n\n    if (hasFrozenRows){\n\n      var c = $cell.parents('.grid-canvas').offset();\n\n      var rowOffset = 0;\n      var isBottom = $cell.parents('.grid-canvas-bottom').length;\n\n      if (isBottom){\n        rowOffset = (options.frozenBottom) ? $canvasTopL.height() : frozenRowsHeight;\n      }\n\n      row = getCellFromPoint(e.clientX - c.left, e.clientY - c.top + rowOffset + $(document).scrollTop()).row;\n    }\n\n    cell = getCellFromNode($cell[0]);\n\n    if (row == null || cell == null){\n      return null;\n    } else {\n      return {\n        \"row\": row,\n        \"cell\": cell\n      };\n    }\n  }\n\n  function getCellNodeBox(row, cell){\n    if (!cellExists(row, cell)){\n      return null;\n    }\n\n    var frozenRowOffset = getFrozenRowOffset(row);\n\n    var y1 = getRowTop(row) - frozenRowOffset;\n    var y2 = y1 + options.rowHeight - 1;\n    var x1 = 0;\n    for (var i = 0; i < cell; i++){\n      x1 += columns[i].width;\n\n      if (options.frozenColumn == i){\n        x1 = 0;\n      }\n    }\n    var x2 = x1 + columns[cell].width;\n\n    return {\n      top: y1,\n      left: x1,\n      bottom: y2,\n      right: x2\n    };\n  }\n\n  //////////////////////////////////////////////////////////////////////////////////////////////\n  // Cell switching\n\n  function resetActiveCell(){\n    setActiveCellInternal(null, false);\n  }\n\n  function setFocus(){\n    if (tabbingDirection == -1){\n      $focusSink[0].focus();\n    } else {\n      $focusSink2[0].focus();\n    }\n  }\n\n  function scrollCellIntoView(row, cell, doPaging){\n    // Don't scroll to frozen cells\n    if (cell < options.frozenColumn){\n      return;\n    }\n\n    if (options.frozenRow > 0 && row < actualFrozenRow){\n      scrollRowIntoView(row, doPaging);\n    } else {\n      // always scroll like normal slickgrid.\n      scrollRowIntoView(row, doPaging);\n    }\n\n    var colspan = getColspan(row, cell);\n    var left = columnPosLeft[cell],\n      right = columnPosRight[cell + (colspan > 1 ? colspan - 1 : 0)],\n      scrollRight = scrollLeft + $viewportScrollContainerX.width();\n\n    if (left < scrollLeft){\n      $viewportScrollContainerX.scrollLeft(left);\n      handleScroll();\n      render();\n    } else if (right > scrollRight){\n      $viewportScrollContainerX.scrollLeft(Math.min(left, right - $viewportScrollContainerX[0].clientWidth));\n      handleScroll();\n      render();\n    }\n  }\n\n  function setActiveCellInternal(newCell, opt_editMode){\n    if (activeCellNode !== null){\n      makeActiveCellNormal();\n      $(activeCellNode).removeClass(\"active\");\n      if (rowsCache[activeRow]){\n        $(rowsCache[activeRow].rowNode).removeClass(\"active\");\n      }\n    }\n\n    var activeCellChanged = (activeCellNode !== newCell);\n    activeCellNode = newCell;\n\n    if (activeCellNode != null){\n      var $activeCellNode = $(activeCellNode);\n      var $activeCellOffset = $activeCellNode.offset();\n\n      var rowOffset = Math.floor($activeCellNode.parents('.grid-canvas').offset().top);\n      var isBottom = $activeCellNode.parents('.grid-canvas-bottom').length;\n\n      if (hasFrozenRows && isBottom){\n        rowOffset -= (options.frozenBottom) ? $canvasTopL.height() : frozenRowsHeight;\n      }\n\n      var cell = getCellFromPoint($activeCellOffset.left, Math.ceil($activeCellOffset.top) - rowOffset);\n\n      activeRow = cell.row;\n      activeCell = activePosX = activeCell = activePosX = getCellFromNode(activeCellNode[0]);\n\n      $activeCellNode.addClass(\"active\");\n      if (rowsCache[activeRow]){\n        $(rowsCache[activeRow].rowNode).addClass('active');\n      }\n\n      if (opt_editMode == null){\n        opt_editMode = (activeRow == getDataLength()) || options.autoEdit;\n      }\n\n      if (options.editable && opt_editMode && isCellPotentiallyEditable(activeRow, activeCell)){\n        clearTimeout(h_editorLoader);\n\n        if (options.asyncEditorLoading){\n          h_editorLoader = setTimeout(function(){\n            makeActiveCellEditable();\n          }, options.asyncEditorLoadDelay);\n        } else {\n          makeActiveCellEditable();\n        }\n      }\n    } else {\n      activeRow = activeCell = null;\n    }\n\n    if (activeCellChanged){\n      setTimeout(scrollActiveCellIntoView, 50);\n      trigger(self.onActiveCellChanged, getActiveCell());\n    }\n  }\n\n  function clearTextSelection(){\n    if (document.selection && document.selection.empty){\n      try {\n        //IE fails here if selected element is not in dom\n        document.selection.empty();\n      } catch (e) {\n      }\n    } else if (window.getSelection){\n      var sel = window.getSelection();\n      if (sel && sel.removeAllRanges){\n        sel.removeAllRanges();\n      }\n    }\n  }\n\n  function isCellPotentiallyEditable(row, cell){\n    var dataLength = getDataLength();\n    // is the data for this row loaded?\n    if (row < dataLength && !getDataItem(row)){\n      return false;\n    }\n\n    // are we in the Add New row?  can we create new from this cell?\n    if (columns[cell].cannotTriggerInsert && row >= dataLength){\n      return false;\n    }\n\n    // does this cell have an editor?\n    if (!getEditor(row, cell)){\n      return false;\n    }\n\n    return true;\n  }\n\n  function makeActiveCellNormal(){\n    if (!currentEditor){\n      return;\n    }\n    trigger(self.onBeforeCellEditorDestroy, {\n      editor: currentEditor\n    });\n    currentEditor.destroy();\n    currentEditor = null;\n\n    if (activeCellNode){\n      var d = getDataItem(activeRow);\n      $(activeCellNode).removeClass(\"editable invalid\");\n      if (d){\n        var column = columns[activeCell];\n        activeCellNode[0].innerHTML = callFormatter(activeRow, activeCell, getDataItemValueForColumn(d, column), column, d);\n        invalidatePostProcessingResults(activeRow);\n      }\n    }\n\n    // if there previously was text selected on a page (such as selected text in the edit cell just removed),\n    // IE can't set focus to anything else correctly\n    if (navigator.userAgent.toLowerCase().match(/msie/)){\n      clearTextSelection();\n    }\n\n    getEditorLock().deactivate(editController);\n  }\n\n  function makeActiveCellEditable(editor){\n    if (!activeCellNode){\n      return;\n    }\n    if (!options.editable){\n      throw \"Grid : makeActiveCellEditable : should never get called when options.editable is false\";\n    }\n\n    // cancel pending async call if there is one\n    clearTimeout(h_editorLoader);\n\n    if (!isCellPotentiallyEditable(activeRow, activeCell)){\n      return;\n    }\n\n    var columnDef = columns[activeCell];\n    var item = getDataItem(activeRow);\n\n    if (trigger(self.onBeforeEditCell, {\n        row: activeRow,\n        cell: activeCell,\n        item: item,\n        column: columnDef\n      }) === false){\n      setFocus();\n      return;\n    }\n\n    getEditorLock().activate(editController);\n    $(activeCellNode).addClass(\"editable\");\n\n    // don't clear the cell if a custom editor is passed through\n    if (!editor){\n      activeCellNode[0].innerHTML = \"\";\n    }\n\n    currentEditor = new (editor || getEditor(activeRow, activeCell))({\n      grid: self,\n      gridPosition: absBox($container[0]),\n      position: absBox(activeCellNode[0]),\n      container: activeCellNode,\n      column: columnDef,\n      item: item || {},\n      commitChanges: commitEditAndSetFocus,\n      cancelChanges: cancelEditAndSetFocus\n    });\n\n    if (item){\n      currentEditor.loadValue(item);\n    }\n\n    serializedEditorValue = currentEditor.serializeValue();\n\n    if (currentEditor.position){\n      handleActiveCellPositionChange();\n    }\n  }\n\n  function commitEditAndSetFocus(){\n    // if the commit fails, it would do so due to a validation error\n    // if so, do not steal the focus from the editor\n    if (getEditorLock().commitCurrentEdit()){\n      setFocus();\n      if (options.autoEdit){\n        navigateDown();\n      }\n    }\n  }\n\n  function cancelEditAndSetFocus(){\n    if (getEditorLock().cancelCurrentEdit()){\n      setFocus();\n    }\n  }\n\n  function absBox(elem){\n    var box = {\n      top: elem.offsetTop,\n      left: elem.offsetLeft,\n      bottom: 0,\n      right: 0,\n      width: $(elem).outerWidth(),\n      height: $(elem).outerHeight(),\n      visible: true\n    };\n    box.bottom = box.top + box.height;\n    box.right = box.left + box.width;\n\n    // walk up the tree\n    var offsetParent = elem.offsetParent;\n    while ((elem = elem.parentNode) != document.body){\n      if (box.visible && elem.scrollHeight != elem.offsetHeight && $(elem).css(\"overflowY\") != \"visible\"){\n        box.visible = box.bottom > elem.scrollTop && box.top < elem.scrollTop + elem.clientHeight;\n      }\n\n      if (box.visible && elem.scrollWidth != elem.offsetWidth && $(elem).css(\"overflowX\") != \"visible\"){\n        box.visible = box.right > elem.scrollLeft && box.left < elem.scrollLeft + elem.clientWidth;\n      }\n\n      box.left -= elem.scrollLeft;\n      box.top -= elem.scrollTop;\n\n      if (elem === offsetParent){\n        box.left += elem.offsetLeft;\n        box.top += elem.offsetTop;\n        offsetParent = elem.offsetParent;\n      }\n\n      box.bottom = box.top + box.height;\n      box.right = box.left + box.width;\n    }\n\n    return box;\n  }\n\n  function getActiveCellPosition(){\n    return absBox(activeCellNode[0]);\n  }\n\n  function getGridPosition(){\n    return absBox($container[0])\n  }\n\n  function handleActiveCellPositionChange(){\n    if (!activeCellNode){\n      return;\n    }\n\n    trigger(self.onActiveCellPositionChanged, {});\n\n    if (currentEditor){\n      var cellBox = getActiveCellPosition();\n      if (currentEditor.show && currentEditor.hide){\n        if (!cellBox.visible){\n          currentEditor.hide();\n        } else {\n          currentEditor.show();\n        }\n      }\n\n      if (currentEditor.position){\n        currentEditor.position(cellBox);\n      }\n    }\n  }\n\n  function getCellEditor(){\n    return currentEditor;\n  }\n\n  function getActiveCell(){\n    if (!activeCellNode){\n      return null;\n    } else {\n      return {\n        row: activeRow,\n        cell: activeCell\n      };\n    }\n  }\n\n  function getActiveCellNode(){\n    return activeCellNode;\n  }\n\n  function scrollActiveCellIntoView(){\n    if (activeRow != null && activeCell != null){\n      scrollCellIntoView(activeRow, activeCell);\n    }\n  }\n\n  function scrollRowIntoView(row, doPaging){\n\n    if (!hasFrozenRows || (!options.frozenBottom && row > actualFrozenRow - 1) || (options.frozenBottom && row < actualFrozenRow - 1)){\n\n      var viewportScrollH = $viewportScrollContainerY.height();\n\n      var rowAtTop = row * options.rowHeight;\n      var rowAtBottom = (row + 1) * options.rowHeight - viewportScrollH + (viewportHasHScroll ? scrollbarDimensions.height : 0);\n\n      // need to page down?\n      if ((row + 1) * options.rowHeight > scrollTop + viewportScrollH + offset){\n        scrollTo(doPaging ? rowAtTop : rowAtBottom);\n        render();\n      }\n      // or page up?\n      else if (row * options.rowHeight < scrollTop + offset){\n        scrollTo(doPaging ? rowAtBottom : rowAtTop);\n        render();\n      }\n    }\n  }\n\n  function scrollRowToTop(row){\n    scrollTo(row * options.rowHeight);\n    render();\n  }\n\n  function scrollPage(dir){\n    var deltaRows = dir * numVisibleRows;\n    scrollTo((getRowFromPosition(scrollTop) + deltaRows) * options.rowHeight);\n    render();\n\n    if (options.enableCellNavigation && activeRow != null){\n      var row = activeRow + deltaRows;\n      var dataLengthIncludingAddNew = getDataLengthIncludingAddNew();\n      if (row >= dataLengthIncludingAddNew){\n        row = dataLengthIncludingAddNew - 1;\n      }\n      if (row < 0){\n        row = 0;\n      }\n\n      var cell = 0,\n        prevCell = null;\n      var prevActivePosX = activePosX;\n      while (cell <= activePosX){\n        if (canCellBeActive(row, cell)){\n          prevCell = cell;\n        }\n        cell += getColspan(row, cell);\n      }\n\n      if (prevCell !== null){\n        setActiveCellInternal(getCellNode(row, prevCell));\n        activePosX = prevActivePosX;\n      } else {\n        resetActiveCell();\n      }\n    }\n  }\n\n  function navigatePageDown(){\n    scrollPage(1);\n  }\n\n  function navigatePageUp(){\n    scrollPage(-1);\n  }\n\n  function getColspan(row, cell){\n    var metadata = data.getItemMetadata && data.getItemMetadata(row);\n    if (!metadata || !metadata.columns){\n      return 1;\n    }\n\n    var columnData = columns[cell] && (metadata.columns[columns[cell].id] || metadata.columns[cell]);\n    var colspan = (columnData && columnData.colspan);\n    if (colspan === \"*\"){\n      colspan = columns.length - cell;\n    } else {\n      colspan = colspan || 1;\n    }\n\n    return colspan;\n  }\n\n  function findFirstFocusableCell(row){\n    var cell = 0;\n    while (cell < columns.length){\n      if (canCellBeActive(row, cell)){\n        return cell;\n      }\n      cell += getColspan(row, cell);\n    }\n    return null;\n  }\n\n  function findLastFocusableCell(row){\n    var cell = 0;\n    var lastFocusableCell = null;\n    while (cell < columns.length){\n      if (canCellBeActive(row, cell)){\n        lastFocusableCell = cell;\n      }\n      cell += getColspan(row, cell);\n    }\n    return lastFocusableCell;\n  }\n\n  function gotoRight(row, cell, posX){\n    if (cell >= columns.length){\n      return null;\n    }\n\n    do {\n      cell += getColspan(row, cell);\n    }\n    while (cell < columns.length && !canCellBeActive(row, cell));\n\n    if (cell < columns.length){\n      return {\n        \"row\": row,\n        \"cell\": cell,\n        \"posX\": cell\n      };\n    }\n    return null;\n  }\n\n  function gotoLeft(row, cell, posX){\n    if (cell <= 0){\n      return null;\n    }\n\n    var firstFocusableCell = findFirstFocusableCell(row);\n    if (firstFocusableCell === null || firstFocusableCell >= cell){\n      return null;\n    }\n\n    var prev = {\n      \"row\": row,\n      \"cell\": firstFocusableCell,\n      \"posX\": firstFocusableCell\n    };\n    var pos;\n    while (true){\n      pos = gotoRight(prev.row, prev.cell, prev.posX);\n      if (!pos){\n        return null;\n      }\n      if (pos.cell >= cell){\n        return prev;\n      }\n      prev = pos;\n    }\n  }\n\n  function gotoDown(row, cell, posX){\n    var prevCell;\n    var dataLengthIncludingAddNew = getDataLengthIncludingAddNew();\n    while (true){\n      if (++row >= dataLengthIncludingAddNew){\n        return null;\n      }\n\n      prevCell = cell = 0;\n      while (cell <= posX){\n        prevCell = cell;\n        cell += getColspan(row, cell);\n      }\n\n      if (canCellBeActive(row, prevCell)){\n        return {\n          \"row\": row,\n          \"cell\": prevCell,\n          \"posX\": posX\n        };\n      }\n    }\n  }\n\n  function gotoUp(row, cell, posX){\n    var prevCell;\n    while (true){\n      if (--row < 0){\n        return null;\n      }\n\n      prevCell = cell = 0;\n      while (cell <= posX){\n        prevCell = cell;\n        cell += getColspan(row, cell);\n      }\n\n      if (canCellBeActive(row, prevCell)){\n        return {\n          \"row\": row,\n          \"cell\": prevCell,\n          \"posX\": posX\n        };\n      }\n    }\n  }\n\n  function gotoNext(row, cell, posX){\n    if (row == null && cell == null){\n      row = cell = posX = 0;\n      if (canCellBeActive(row, cell)){\n        return {\n          \"row\": row,\n          \"cell\": cell,\n          \"posX\": cell\n        };\n      }\n    }\n\n    var pos = gotoRight(row, cell, posX);\n    if (pos){\n      return pos;\n    }\n\n    var firstFocusableCell = null;\n    var dataLengthIncludingAddNew = getDataLengthIncludingAddNew();\n    while (++row < dataLengthIncludingAddNew){\n      firstFocusableCell = findFirstFocusableCell(row);\n      if (firstFocusableCell !== null){\n        return {\n          \"row\": row,\n          \"cell\": firstFocusableCell,\n          \"posX\": firstFocusableCell\n        };\n      }\n    }\n    return null;\n  }\n\n  function gotoPrev(row, cell, posX){\n    if (row == null && cell == null){\n      row = getDataLengthIncludingAddNew() - 1;\n      cell = posX = columns.length - 1;\n      if (canCellBeActive(row, cell)){\n        return {\n          \"row\": row,\n          \"cell\": cell,\n          \"posX\": cell\n        };\n      }\n    }\n\n    var pos;\n    var lastSelectableCell;\n    while (!pos){\n      pos = gotoLeft(row, cell, posX);\n      if (pos){\n        break;\n      }\n      if (--row < 0){\n        return null;\n      }\n\n      cell = 0;\n      lastSelectableCell = findLastFocusableCell(row);\n      if (lastSelectableCell !== null){\n        pos = {\n          \"row\": row,\n          \"cell\": lastSelectableCell,\n          \"posX\": lastSelectableCell\n        };\n      }\n    }\n    return pos;\n  }\n\n  function navigateRight(){\n    return navigate(\"right\");\n  }\n\n  function navigateLeft(){\n    return navigate(\"left\");\n  }\n\n  function navigateDown(){\n    console.log('down');\n    return navigate(\"down\");\n  }\n\n  function navigateUp(){\n    return navigate(\"up\");\n  }\n\n  function navigateNext(){\n    return navigate(\"next\");\n  }\n\n  function navigatePrev(){\n    return navigate(\"prev\");\n  }\n\n  /**\n   * @param {string} dir Navigation direction.\n   * @return {boolean} Whether navigation resulted in a change of active cell.\n   */\n  function navigate(dir){\n    if (!options.enableCellNavigation){\n      return false;\n    }\n\n    if (!activeCellNode && dir != \"prev\" && dir != \"next\"){\n      return false;\n    }\n\n    if (!getEditorLock().commitCurrentEdit()){\n      return true;\n    }\n    setFocus();\n\n    var tabbingDirections = {\n      \"up\": -1,\n      \"down\": 1,\n      \"left\": -1,\n      \"right\": 1,\n      \"prev\": -1,\n      \"next\": 1\n    };\n    tabbingDirection = tabbingDirections[dir];\n\n    var stepFunctions = {\n      \"up\": gotoUp,\n      \"down\": gotoDown,\n      \"left\": gotoLeft,\n      \"right\": gotoRight,\n      \"prev\": gotoPrev,\n      \"next\": gotoNext\n    };\n    var stepFn = stepFunctions[dir];\n    var pos = stepFn(activeRow, activeCell, activePosX);\n    if (pos){\n      if (hasFrozenRows && options.frozenBottom & pos.row == getDataLength()){\n        return;\n      }\n\n      var isAddNewRow = (pos.row == getDataLength());\n\n      if ((!options.frozenBottom && pos.row >= actualFrozenRow) || (options.frozenBottom && pos.row < actualFrozenRow)){\n        scrollCellIntoView(pos.row, pos.cell, !isAddNewRow);\n      }\n\n      setActiveCellInternal(getCellNode(pos.row, pos.cell))\n      activePosX = pos.posX;\n      return true;\n    } else {\n      setActiveCellInternal(getCellNode(activeRow, activeCell));\n      return false;\n    }\n  }\n\n  function getCellNode(row, cell){\n    if (rowsCache[row]){\n      ensureCellNodesInRowsCache(row);\n      return rowsCache[row].cellNodesByColumnIdx[cell];\n    }\n    return null;\n  }\n\n  function setActiveCell(row, cell){\n    if (!initialized){\n      return;\n    }\n    if (row > getDataLength() || row < 0 || cell >= columns.length || cell < 0){\n      return;\n    }\n\n    if (!options.enableCellNavigation){\n      return;\n    }\n\n    scrollCellIntoView(row, cell, false);\n    setActiveCellInternal(getCellNode(row, cell), false);\n  }\n\n  function canCellBeActive(row, cell){\n    if (!options.enableCellNavigation || row >= getDataLengthIncludingAddNew() || row < 0 || cell >= columns.length || cell < 0){\n      return false;\n    }\n\n    var rowMetadata = data.getItemMetadata && data.getItemMetadata(row);\n    if (rowMetadata && typeof rowMetadata.focusable === \"boolean\"){\n      return rowMetadata.focusable;\n    }\n\n    var columnMetadata = rowMetadata && rowMetadata.columns;\n    if (columnMetadata && columns[cell] && columnMetadata[columns[cell].id] && typeof columnMetadata[columns[cell].id].focusable === \"boolean\"){\n      return columnMetadata[columns[cell].id].focusable;\n    }\n    if (columnMetadata && columnMetadata[cell] && typeof columnMetadata[cell].focusable === \"boolean\"){\n      return columnMetadata[cell].focusable;\n    }\n\n    return columns[cell] && columns[cell].focusable;\n  }\n\n  function canCellBeSelected(row, cell){\n    if (row >= getDataLength() || row < 0 || cell >= columns.length || cell < 0){\n      return false;\n    }\n\n    var rowMetadata = data.getItemMetadata && data.getItemMetadata(row);\n    if (rowMetadata && typeof rowMetadata.selectable === \"boolean\"){\n      return rowMetadata.selectable;\n    }\n\n    var columnMetadata = rowMetadata && rowMetadata.columns && (rowMetadata.columns[columns[cell].id] || rowMetadata.columns[cell]);\n    if (columnMetadata && typeof columnMetadata.selectable === \"boolean\"){\n      return columnMetadata.selectable;\n    }\n\n    return columns[cell].selectable;\n  }\n\n  function gotoCell(row, cell, forceEdit){\n    if (!initialized){\n      return;\n    }\n    if (!canCellBeActive(row, cell)){\n      return;\n    }\n\n    if (!getEditorLock().commitCurrentEdit()){\n      return;\n    }\n\n    scrollCellIntoView(row, cell, false);\n\n    var newCell = getCellNode(row, cell);\n\n    // if selecting the 'add new' row, start editing right away\n    setActiveCellInternal(newCell, forceEdit || (row === getDataLength()) || options.autoEdit);\n\n    // if no editor was created, set the focus back on the grid\n    if (!currentEditor){\n      setFocus();\n    }\n  }\n\n  //////////////////////////////////////////////////////////////////////////////////////////////\n  // IEditor implementation for the editor lock\n\n  function commitCurrentEdit(){\n    var item = getDataItem(activeRow);\n    var column = columns[activeCell];\n\n    if (currentEditor){\n      if (currentEditor.isValueChanged()){\n        var validationResults = currentEditor.validate();\n\n        if (validationResults.valid){\n          if (activeRow < getDataLength()){\n            var editCommand = {\n              row: activeRow,\n              cell: activeCell,\n              editor: currentEditor,\n              serializedValue: currentEditor.serializeValue(),\n              prevSerializedValue: serializedEditorValue,\n              execute: function(){\n                this.editor.applyValue(item, this.serializedValue);\n                updateRow(this.row);\n                trigger(self.onCellChange, {\n                  row: activeRow,\n                  cell: activeCell,\n                  item: item\n                });\n              },\n              undo: function(){\n                this.editor.applyValue(item, this.prevSerializedValue);\n                updateRow(this.row);\n                trigger(self.onCellChange, {\n                  row: activeRow,\n                  cell: activeCell,\n                  item: item\n                });\n              }\n            };\n\n            if (options.editCommandHandler){\n              makeActiveCellNormal();\n              options.editCommandHandler(item, column, editCommand);\n            } else {\n              editCommand.execute();\n              makeActiveCellNormal();\n            }\n\n          } else {\n            var newItem = {};\n            currentEditor.applyValue(newItem, currentEditor.serializeValue());\n            makeActiveCellNormal();\n            trigger(self.onAddNewRow, {\n              item: newItem,\n              column: column\n            });\n          }\n\n          // check whether the lock has been re-acquired by event handlers\n          return !getEditorLock().isActive();\n        } else {\n          // Re-add the CSS class to trigger transitions, if any.\n          $(activeCellNode).removeClass(\"invalid\");\n          $(activeCellNode).width(); // force layout\n          $(activeCellNode).addClass(\"invalid\");\n\n          trigger(self.onValidationError, {\n            editor: currentEditor,\n            cellNode: activeCellNode,\n            validationResults: validationResults,\n            row: activeRow,\n            cell: activeCell,\n            column: column\n          });\n\n          currentEditor.focus();\n          return false;\n        }\n      }\n\n      makeActiveCellNormal();\n    }\n    return true;\n  }\n\n  function cancelCurrentEdit(){\n    makeActiveCellNormal();\n    return true;\n  }\n\n  function rowsToRanges(rows){\n    var ranges = [];\n    var lastCell = columns.length - 1;\n    for (var i = 0; i < rows.length; i++){\n      ranges.push(new Slick.Range(rows[i], 0, rows[i], lastCell));\n    }\n    return ranges;\n  }\n\n  function getSelectedRows(){\n    if (!selectionModel){\n      throw \"Selection model is not set\";\n    }\n    return selectedRows;\n  }\n\n  function setSelectedRows(rows){\n    if (!selectionModel){\n      throw \"Selection model is not set\";\n    }\n    selectionModel.setSelectedRanges(rowsToRanges(rows));\n  }\n\n  //////////////////////////////////////////////////////////////////////////////////////////////\n  // Debug\n\n  this.debug = function(){\n    var s = \"\";\n\n    s += (\"\\n\" + \"counter_rows_rendered:  \" + counter_rows_rendered);\n    s += (\"\\n\" + \"counter_rows_removed:  \" + counter_rows_removed);\n    s += (\"\\n\" + \"renderedRows:  \" + renderedRows);\n    s += (\"\\n\" + \"numVisibleRows:  \" + numVisibleRows);\n    s += (\"\\n\" + \"maxSupportedCssHeight:  \" + maxSupportedCssHeight);\n    s += (\"\\n\" + \"n(umber of pages):  \" + n);\n    s += (\"\\n\" + \"(current) page:  \" + page);\n    s += (\"\\n\" + \"page height (ph):  \" + ph);\n    s += (\"\\n\" + \"vScrollDir:  \" + vScrollDir);\n\n    alert(s);\n  };\n\n  // a debug helper to be able to access private members\n  this.eval = function(expr){\n    return eval(expr);\n  };\n\n  //////////////////////////////////////////////////////////////////////////////////////////////\n  // Public API\n\n  $.extend(this, {\n    \"slickGridVersion\": \"2.1\",\n\n    // Events\n    \"onScroll\": new Slick.Event(),\n    \"onSort\": new Slick.Event(),\n    \"onHeaderMouseEnter\": new Slick.Event(),\n    \"onHeaderMouseLeave\": new Slick.Event(),\n    \"onHeaderContextMenu\": new Slick.Event(),\n    \"onHeaderClick\": new Slick.Event(),\n    \"onHeaderCellRendered\": new Slick.Event(),\n    \"onBeforeHeaderCellDestroy\": new Slick.Event(),\n    \"onHeaderRowCellRendered\": new Slick.Event(),\n    \"onFooterRowCellRendered\": new Slick.Event(),\n    \"onBeforeHeaderRowCellDestroy\": new Slick.Event(),\n    \"onBeforeFooterRowCellDestroy\": new Slick.Event(),\n    \"onMouseEnter\": new Slick.Event(),\n    \"onMouseLeave\": new Slick.Event(),\n    \"onClick\": new Slick.Event(),\n    \"onDblClick\": new Slick.Event(),\n    \"onContextMenu\": new Slick.Event(),\n    \"onKeyDown\": new Slick.Event(),\n    \"onAddNewRow\": new Slick.Event(),\n    \"onValidationError\": new Slick.Event(),\n    \"onViewportChanged\": new Slick.Event(),\n    \"onColumnsReordered\": new Slick.Event(),\n    \"onColumnsResized\": new Slick.Event(),\n    \"onCellChange\": new Slick.Event(),\n    \"onBeforeEditCell\": new Slick.Event(),\n    \"onBeforeCellEditorDestroy\": new Slick.Event(),\n    \"onBeforeDestroy\": new Slick.Event(),\n    \"onActiveCellChanged\": new Slick.Event(),\n    \"onActiveCellPositionChanged\": new Slick.Event(),\n    \"onDragInit\": new Slick.Event(),\n    \"onDragStart\": new Slick.Event(),\n    \"onDrag\": new Slick.Event(),\n    \"onDragEnd\": new Slick.Event(),\n    \"onSelectedRowsChanged\": new Slick.Event(),\n    \"onCellCssStylesChanged\": new Slick.Event(),\n\n    // Methods\n    \"registerPlugin\": registerPlugin,\n    \"unregisterPlugin\": unregisterPlugin,\n    \"getColumns\": getColumns,\n    \"setColumns\": setColumns,\n    \"getColumnIndex\": getColumnIndex,\n    \"updateColumnHeader\": updateColumnHeader,\n    \"setSortColumn\": setSortColumn,\n    \"setSortColumns\": setSortColumns,\n    \"getSortColumns\": getSortColumns,\n    \"autosizeColumns\": autosizeColumns,\n    \"getOptions\": getOptions,\n    \"setOptions\": setOptions,\n    \"getData\": getData,\n    \"getDataLength\": getDataLength,\n    \"getDataItem\": getDataItem,\n    \"setData\": setData,\n    \"getSelectionModel\": getSelectionModel,\n    \"setSelectionModel\": setSelectionModel,\n    \"getSelectedRows\": getSelectedRows,\n    \"setSelectedRows\": setSelectedRows,\n    \"getContainerNode\": getContainerNode,\n\n    \"render\": render,\n    \"invalidate\": invalidate,\n    \"invalidateRow\": invalidateRow,\n    \"invalidateRows\": invalidateRows,\n    \"invalidateAllRows\": invalidateAllRows,\n    \"updateCell\": updateCell,\n    \"updateRow\": updateRow,\n    \"getViewport\": getVisibleRange,\n    \"getRenderedRange\": getRenderedRange,\n    \"resizeCanvas\": resizeCanvas,\n    \"updateRowCount\": updateRowCount,\n    \"scrollRowIntoView\": scrollRowIntoView,\n    \"scrollRowToTop\": scrollRowToTop,\n    \"scrollCellIntoView\": scrollCellIntoView,\n    \"getCanvasNode\": getCanvasNode,\n    \"getCanvases\": getCanvases,\n    \"getActiveCanvasNode\": getActiveCanvasNode,\n    \"setActiveCanvasNode\": setActiveCanvasNode,\n    \"getViewportNode\": getViewportNode,\n    \"getActiveViewportNode\": getActiveViewportNode,\n    \"setActiveViewportNode\": setActiveViewportNode,\n    \"focus\": setFocus,\n\n    \"getCellFromPoint\": getCellFromPoint,\n    \"getCellFromEvent\": getCellFromEvent,\n    \"getActiveCell\": getActiveCell,\n    \"setActiveCell\": setActiveCell,\n    \"getActiveCellNode\": getActiveCellNode,\n    \"getActiveCellPosition\": getActiveCellPosition,\n    \"resetActiveCell\": resetActiveCell,\n    \"editActiveCell\": makeActiveCellEditable,\n    \"getCellEditor\": getCellEditor,\n    \"getCellNode\": getCellNode,\n    \"getCellNodeBox\": getCellNodeBox,\n    \"canCellBeSelected\": canCellBeSelected,\n    \"canCellBeActive\": canCellBeActive,\n    \"navigatePrev\": navigatePrev,\n    \"navigateNext\": navigateNext,\n    \"navigateUp\": navigateUp,\n    \"navigateDown\": navigateDown,\n    \"navigateLeft\": navigateLeft,\n    \"navigateRight\": navigateRight,\n    \"navigatePageUp\": navigatePageUp,\n    \"navigatePageDown\": navigatePageDown,\n    \"gotoCell\": gotoCell,\n    \"getTopPanel\": getTopPanel,\n    \"setTopPanelVisibility\": setTopPanelVisibility,\n    \"setHeaderRowVisibility\": setHeaderRowVisibility,\n    \"getHeaderRow\": getHeaderRow,\n    \"getHeaderRowColumn\": getHeaderRowColumn,\n    \"setFooterRowVisibility\": setFooterRowVisibility,\n    \"getFooterRow\": getFooterRow,\n    \"getFooterRowColumn\": getFooterRowColumn,\n    \"getGridPosition\": getGridPosition,\n    \"flashCell\": flashCell,\n    \"addCellCssStyles\": addCellCssStyles,\n    \"setCellCssStyles\": setCellCssStyles,\n    \"removeCellCssStyles\": removeCellCssStyles,\n    \"getCellCssStyles\": getCellCssStyles,\n    \"getFrozenRowOffset\": getFrozenRowOffset,\n\n    \"init\": finishInitialization,\n    \"destroy\": destroy,\n\n    // IEditor implementation\n    \"getEditorLock\": getEditorLock,\n    \"getEditController\": getEditController\n  });\n\n  init();\n}\n\n\n\n// WEBPACK FOOTER //\n// ../src/slick-frozen.grid.js","import Slick                      from './slick.core';\nimport $                          from 'jquery';\nimport GroupItemMetaDataProvider  from './slick.groupmetadataprovider';\n\nconst Aggregators = {\n  Avg: AvgAggregator,\n  Min: MinAggregator,\n  Max: MaxAggregator,\n  Sum: SumAggregator\n};\n\nconst Data = {\n  DataView,\n  GroupMetaDataProvider: GroupItemMetaDataProvider,\n  Aggregators\n};\n\nexport default Data;\n\n/** *\n * A sample Model implementation.\n * Provides a filtered view of the underlying data.\n *\n * Relies on the data item having an \"id\" property uniquely identifying it.\n */\nfunction DataView(options){\n  let self = this;\n\n  let defaults = {\n    groupItemMetadataProvider: null,\n    inlineFilters: false\n  };\n\n  // private\n  let idProperty = 'id';  // property holding a unique row id\n  let items = [];         // data by index\n  let rows = [];          // data by row\n  let idxById = {};       // indexes by id\n  let rowsById = null;    // rows by id; lazy-calculated\n  let filter = null;      // filter function\n  let updated = null;     // updated item ids\n  let suspend = false;    // suspends the recalculation\n  let sortAsc = true;\n  let fastSortField;\n  let sortComparer;\n  let refreshHints = {};\n  let prevRefreshHints = {};\n  let filterArgs;\n  let filteredItems = [];\n  let compiledFilter;\n  let compiledFilterWithCaching;\n  let filterCache = [];\n\n  // grouping\n  let groupingInfoDefaults = {\n    getter: null,\n    formatter: null,\n    comparer: function(a, b){\n      return (a.value === b.value ? 0 :\n          (a.value > b.value ? 1 : -1)\n      );\n    },\n    predefinedValues: [],\n    aggregators: [],\n    aggregateEmpty: false,\n    aggregateCollapsed: false,\n    aggregateChildGroups: false,\n    collapsed: false,\n    displayTotalsRow: true,\n    lazyTotalsCalculation: false\n  };\n  let groupingInfos = [];\n  let groups = [];\n  let toggledGroupsByLevel = [];\n  let groupingDelimiter = ':|:';\n\n  let pagesize = 0;\n  let pagenum = 0;\n  let totalRows = 0;\n\n  // events\n  let onRowCountChanged = new Slick.Event();\n  let onRowsChanged = new Slick.Event();\n  let onPagingInfoChanged = new Slick.Event();\n\n  options = $.extend(true, {}, defaults, options);\n\n  function beginUpdate(){\n    suspend = true;\n  }\n\n  function endUpdate(){\n    suspend = false;\n    refresh();\n  }\n\n  function setRefreshHints(hints){\n    refreshHints = hints;\n  }\n\n  function setFilterArgs(args){\n    filterArgs = args;\n  }\n\n  function updateIdxById(startingIndex){\n    startingIndex = startingIndex || 0;\n    let id;\n    for (let i = startingIndex, l = items.length; i < l; i++){\n      id = items[i][idProperty];\n      if (id === undefined){\n        throw \"Each data element must implement a unique 'id' property\";\n      }\n      idxById[id] = i;\n    }\n  }\n\n  function ensureIdUniqueness(){\n    let id;\n    for (let i = 0, l = items.length; i < l; i++){\n      id = items[i][idProperty];\n      if (id === undefined || idxById[id] !== i){\n        throw \"Each data element must implement a unique 'id' property\";\n      }\n    }\n  }\n\n  function getItems(){\n    return items;\n  }\n\n  function setItems(data, objectIdProperty){\n    if (objectIdProperty !== undefined){\n      idProperty = objectIdProperty;\n    }\n    items = filteredItems = data;\n    idxById = {};\n    updateIdxById();\n    ensureIdUniqueness();\n    refresh();\n  }\n\n  function setPagingOptions(args){\n    if (args.pageSize != undefined){\n      pagesize = args.pageSize;\n      pagenum = pagesize ? Math.min(pagenum, Math.max(0, Math.ceil(totalRows / pagesize) - 1)) : 0;\n    }\n\n    if (args.pageNum != undefined){\n      pagenum = Math.min(args.pageNum, Math.max(0, Math.ceil(totalRows / pagesize) - 1));\n    }\n\n    onPagingInfoChanged.notify(getPagingInfo(), null, self);\n\n    refresh();\n  }\n\n  function getPagingInfo(){\n    let totalPages = pagesize ? Math.max(1, Math.ceil(totalRows / pagesize)) : 1;\n    return {pageSize: pagesize, pageNum: pagenum, totalRows: totalRows, totalPages: totalPages, dataView: self};\n  }\n\n  function sort(comparer, ascending){\n    sortAsc = ascending;\n    sortComparer = comparer;\n    fastSortField = null;\n    if (ascending === false){\n      items.reverse();\n    }\n    items.sort(comparer);\n    if (ascending === false){\n      items.reverse();\n    }\n    idxById = {};\n    updateIdxById();\n    refresh();\n  }\n\n  /** *\n   * Provides a workaround for the extremely slow sorting in IE.\n   * Does a [lexicographic] sort on a give column by temporarily overriding Object.prototype.toString\n   * to return the value of that field and then doing a native Array.sort().\n   */\n  function fastSort(field, ascending){\n    sortAsc = ascending;\n    fastSortField = field;\n    sortComparer = null;\n    let oldToString = Object.prototype.toString;\n    Object.prototype.toString = (typeof field == 'function') ? field : function(){\n      return this[field];\n    };\n    // an extra reversal for descending sort keeps the sort stable\n    // (assuming a stable native sort implementation, which isn't true in some cases)\n    if (ascending === false){\n      items.reverse();\n    }\n    items.sort();\n    Object.prototype.toString = oldToString;\n    if (ascending === false){\n      items.reverse();\n    }\n    idxById = {};\n    updateIdxById();\n    refresh();\n  }\n\n  function reSort(){\n    if (sortComparer){\n      sort(sortComparer, sortAsc);\n    } else if (fastSortField){\n      fastSort(fastSortField, sortAsc);\n    }\n  }\n\n  function setFilter(filterFn){\n    filter = filterFn;\n    if (options.inlineFilters){\n      compiledFilter = compileFilter();\n      compiledFilterWithCaching = compileFilterWithCaching();\n    }\n    refresh();\n  }\n\n  function getGrouping(){\n    return groupingInfos;\n  }\n\n  function setGrouping(groupingInfo){\n    if (!options.groupItemMetadataProvider){\n      options.groupItemMetadataProvider = GroupItemMetadataProvider();\n    }\n\n    groups = [];\n    toggledGroupsByLevel = [];\n    groupingInfo = groupingInfo || [];\n    groupingInfos = (groupingInfo instanceof Array) ? groupingInfo : [groupingInfo];\n\n    for (let i = 0; i < groupingInfos.length; i++){\n      let gi = groupingInfos[i] = $.extend(true, {}, groupingInfoDefaults, groupingInfos[i]);\n      gi.getterIsAFn = typeof gi.getter === 'function';\n\n      // pre-compile accumulator loops\n      gi.compiledAccumulators = [];\n      let idx = gi.aggregators.length;\n      while (idx--){\n        gi.compiledAccumulators[idx] = compileAccumulatorLoop(gi.aggregators[idx]);\n      }\n\n      toggledGroupsByLevel[i] = {};\n    }\n\n    refresh();\n  }\n\n  /**\n   * @deprecated Please use {@link setGrouping}.\n   */\n  function groupBy(valueGetter, valueFormatter, sortComparer){\n    if (valueGetter == null){\n      setGrouping([]);\n      return;\n    }\n\n    setGrouping({\n      getter: valueGetter,\n      formatter: valueFormatter,\n      comparer: sortComparer\n    });\n  }\n\n  /**\n   * @deprecated Please use {@link setGrouping}.\n   */\n  function setAggregators(groupAggregators, includeCollapsed){\n    if (!groupingInfos.length){\n      throw new Error('At least one grouping must be specified before calling setAggregators().');\n    }\n\n    groupingInfos[0].aggregators = groupAggregators;\n    groupingInfos[0].aggregateCollapsed = includeCollapsed;\n\n    setGrouping(groupingInfos);\n  }\n\n  function getItemByIdx(i){\n    return items[i];\n  }\n\n  function getIdxById(id){\n    return idxById[id];\n  }\n\n  function ensureRowsByIdCache(){\n    if (!rowsById){\n      rowsById = {};\n      for (let i = 0, l = rows.length; i < l; i++){\n        rowsById[rows[i][idProperty]] = i;\n      }\n    }\n  }\n\n  function getRowById(id){\n    ensureRowsByIdCache();\n    return rowsById[id];\n  }\n\n  function getItemById(id){\n    return items[idxById[id]];\n  }\n\n  function mapIdsToRows(idArray){\n    let rows = [];\n    ensureRowsByIdCache();\n    for (let i = 0, l = idArray.length; i < l; i++){\n      let row = rowsById[idArray[i]];\n      if (row != null){\n        rows[rows.length] = row;\n      }\n    }\n    return rows;\n  }\n\n  function mapRowsToIds(rowArray){\n    let ids = [];\n    for (let i = 0, l = rowArray.length; i < l; i++){\n      if (rowArray[i] < rows.length){\n        ids[ids.length] = rows[rowArray[i]][idProperty];\n      }\n    }\n    return ids;\n  }\n\n  function updateItem(id, item){\n    if (idxById[id] === undefined || id !== item[idProperty]){\n      throw 'Invalid or non-matching id';\n    }\n    items[idxById[id]] = item;\n    if (!updated){\n      updated = {};\n    }\n    updated[id] = true;\n    refresh();\n  }\n\n  function insertItem(insertBefore, item){\n    items.splice(insertBefore, 0, item);\n    updateIdxById(insertBefore);\n    refresh();\n  }\n\n  function addItem(item){\n    items.push(item);\n    updateIdxById(items.length - 1);\n    refresh();\n  }\n\n  function deleteItem(id){\n    let idx = idxById[id];\n    if (idx === undefined){\n      throw 'Invalid id';\n    }\n    delete idxById[id];\n    items.splice(idx, 1);\n    updateIdxById(idx);\n    refresh();\n  }\n\n  function getLength(){\n    return rows.length;\n  }\n\n  function getItem(i){\n    let item = rows[i];\n\n    // if this is a group row, make sure totals are calculated and update the title\n    if (item && item.__group && item.totals && !item.totals.initialized){\n      let gi = groupingInfos[item.level];\n      if (!gi.displayTotalsRow){\n        calculateTotals(item.totals);\n        item.title = gi.formatter ? gi.formatter(item) : item.value;\n      }\n    }\n    // if this is a totals row, make sure it's calculated\n    else if (item && item.__groupTotals && !item.initialized){\n      calculateTotals(item);\n    }\n\n    return item;\n  }\n\n  function getItemMetadata(i){\n    let item = rows[i];\n    if (item === undefined){\n      return null;\n    }\n\n    // overrides for grouping rows\n    if (item.__group){\n      return options.groupItemMetadataProvider.getGroupRowMetadata(item);\n    }\n\n    // overrides for totals rows\n    if (item.__groupTotals){\n      return options.groupItemMetadataProvider.getTotalsRowMetadata(item);\n    }\n\n    return null;\n  }\n\n  function expandCollapseAllGroups(level, collapse){\n    if (level == null){\n      for (let i = 0; i < groupingInfos.length; i++){\n        toggledGroupsByLevel[i] = {};\n        groupingInfos[i].collapsed = collapse;\n      }\n    } else {\n      toggledGroupsByLevel[level] = {};\n      groupingInfos[level].collapsed = collapse;\n    }\n    refresh();\n  }\n\n  /**\n   * @param level {Number} Optional level to collapse.  If not specified, applies to all levels.\n   */\n  function collapseAllGroups(level){\n    expandCollapseAllGroups(level, true);\n  }\n\n  /**\n   * @param level {Number} Optional level to expand.  If not specified, applies to all levels.\n   */\n  function expandAllGroups(level){\n    expandCollapseAllGroups(level, false);\n  }\n\n  function expandCollapseGroup(level, groupingKey, collapse){\n    toggledGroupsByLevel[level][groupingKey] = groupingInfos[level].collapsed ^ collapse;\n    refresh();\n  }\n\n  /**\n   * @param letArgs Either a Slick.Group's \"groupingKey\" property, or a\n   *     letiable argument list of grouping values denoting a unique path to the row.  For\n   *     example, calling collapseGroup('high', '10%') will collapse the '10%' subgroup of\n   *     the 'high' group.\n   */\n  function collapseGroup(letArgs){\n    let args = Array.prototype.slice.call(arguments);\n    let arg0 = args[0];\n    if (args.length == 1 && arg0.indexOf(groupingDelimiter) != -1){\n      expandCollapseGroup(arg0.split(groupingDelimiter).length - 1, arg0, true);\n    } else {\n      expandCollapseGroup(args.length - 1, args.join(groupingDelimiter), true);\n    }\n  }\n\n  /**\n   * @param letArgs Either a Slick.Group's \"groupingKey\" property, or a\n   *     letiable argument list of grouping values denoting a unique path to the row.  For\n   *     example, calling expandGroup('high', '10%') will expand the '10%' subgroup of\n   *     the 'high' group.\n   */\n  function expandGroup(letArgs){\n    let args = Array.prototype.slice.call(arguments);\n    let arg0 = args[0];\n    if (args.length == 1 && arg0.indexOf(groupingDelimiter) != -1){\n      expandCollapseGroup(arg0.split(groupingDelimiter).length - 1, arg0, false);\n    } else {\n      expandCollapseGroup(args.length - 1, args.join(groupingDelimiter), false);\n    }\n  }\n\n  function getGroups(){\n    return groups;\n  }\n\n  function extractGroups(rows, parentGroup){\n    let group;\n    let val;\n    let groups = [];\n    let groupsByVal = {};\n    let r;\n    let level = parentGroup ? parentGroup.level + 1 : 0;\n    let gi = groupingInfos[level];\n\n    for (let i = 0, l = gi.predefinedValues.length; i < l; i++){\n      val = gi.predefinedValues[i];\n      group = groupsByVal[val];\n      if (!group){\n        group = new Slick.Group();\n        group.value = val;\n        group.level = level;\n        group.groupingKey = (parentGroup ? parentGroup.groupingKey + groupingDelimiter : '') + val;\n        groups[groups.length] = group;\n        groupsByVal[val] = group;\n      }\n    }\n\n    for (let i = 0, l = rows.length; i < l; i++){\n      r = rows[i];\n      val = gi.getterIsAFn ? gi.getter(r) : r[gi.getter];\n      group = groupsByVal[val];\n      if (!group){\n        group = new Slick.Group();\n        group.value = val;\n        group.level = level;\n        group.groupingKey = (parentGroup ? parentGroup.groupingKey + groupingDelimiter : '') + val;\n        groups[groups.length] = group;\n        groupsByVal[val] = group;\n      }\n\n      group.rows[group.count++] = r;\n    }\n\n    if (level < groupingInfos.length - 1){\n      for (let i = 0; i < groups.length; i++){\n        group = groups[i];\n        group.groups = extractGroups(group.rows, group);\n      }\n    }\n\n    groups.sort(groupingInfos[level].comparer);\n\n    return groups;\n  }\n\n  function calculateTotals(totals){\n    let group = totals.group;\n    let gi = groupingInfos[group.level];\n    let isLeafLevel = (group.level == groupingInfos.length);\n    let agg, idx = gi.aggregators.length;\n\n    if (!isLeafLevel && gi.aggregateChildGroups){\n      // make sure all the subgroups are calculated\n      let i = group.groups.length;\n      while (i--){\n        if (!group.groups[i].totals.initialized){\n          calculateTotals(group.groups[i].totals);\n        }\n      }\n    }\n\n    while (idx--){\n      agg = gi.aggregators[idx];\n      agg.init();\n      if (!isLeafLevel && gi.aggregateChildGroups){\n        gi.compiledAccumulators[idx].call(agg, group.groups);\n      } else {\n        gi.compiledAccumulators[idx].call(agg, group.rows);\n      }\n      agg.storeResult(totals);\n    }\n    totals.initialized = true;\n  }\n\n  function addGroupTotals(group){\n    let gi = groupingInfos[group.level];\n    let totals = new Slick.GroupTotals();\n    totals.group = group;\n    group.totals = totals;\n    if (!gi.lazyTotalsCalculation){\n      calculateTotals(totals);\n    }\n  }\n\n  function addTotals(groups, level){\n    level = level || 0;\n    let gi = groupingInfos[level];\n    let groupCollapsed = gi.collapsed;\n    let toggledGroups = toggledGroupsByLevel[level];\n    let idx = groups.length, g;\n    while (idx--){\n      g = groups[idx];\n\n      if (g.collapsed && !gi.aggregateCollapsed){\n        continue;\n      }\n\n      // Do a depth-first aggregation so that parent group aggregators can access subgroup totals.\n      if (g.groups){\n        addTotals(g.groups, level + 1);\n      }\n\n      if (gi.aggregators.length && (\n        gi.aggregateEmpty || g.rows.length || (g.groups && g.groups.length))){\n        addGroupTotals(g);\n      }\n\n      g.collapsed = groupCollapsed ^ toggledGroups[g.groupingKey];\n      g.title = gi.formatter ? gi.formatter(g) : g.value;\n    }\n  }\n\n  function flattenGroupedRows(groups, level){\n    level = level || 0;\n    let gi = groupingInfos[level];\n    let groupedRows = [], rows, gl = 0, g;\n    for (let i = 0, l = groups.length; i < l; i++){\n      g = groups[i];\n      groupedRows[gl++] = g;\n\n      if (!g.collapsed){\n        rows = g.groups ? flattenGroupedRows(g.groups, level + 1) : g.rows;\n        for (let j = 0, jj = rows.length; j < jj; j++){\n          groupedRows[gl++] = rows[j];\n        }\n      }\n\n      if (g.totals && gi.displayTotalsRow && (!g.collapsed || gi.aggregateCollapsed)){\n        groupedRows[gl++] = g.totals;\n      }\n    }\n    return groupedRows;\n  }\n\n  function getFunctionInfo(fn){\n    let fnRegex = /^function[^(]*\\(([^)]*)\\)\\s*{([\\s\\S]*)}$/;\n    let matches = fn.toString().match(fnRegex);\n    return {\n      params: matches[1].split(','),\n      body: matches[2]\n    };\n  }\n\n  function compileAccumulatorLoop(aggregator){\n    let accumulatorInfo = getFunctionInfo(aggregator.accumulate);\n    let fn = new Function(\n      '_items',\n      'for (let ' + accumulatorInfo.params[0] + ', _i=0, _il=_items.length; _i<_il; _i++) {' +\n      accumulatorInfo.params[0] + ' = _items[_i]; ' +\n      accumulatorInfo.body +\n      '}'\n    );\n    fn.displayName = 'compiledAccumulatorLoop';\n    return fn;\n  }\n\n  function compileFilter(){\n    let filterInfo = getFunctionInfo(filter);\n\n    let filterPath1 = '{ continue _coreloop; }$1';\n    let filterPath2 = '{ _retval[_idx++] = $item$; continue _coreloop; }$1';\n    // make some allowances for minification - there's only so far we can go with RegEx\n    let filterBody = filterInfo.body\n      .replace(/return false\\s*([;}]|\\}|$)/gi, filterPath1)\n      .replace(/return!1([;}]|\\}|$)/gi, filterPath1)\n      .replace(/return true\\s*([;}]|\\}|$)/gi, filterPath2)\n      .replace(/return!0([;}]|\\}|$)/gi, filterPath2)\n      .replace(/return ([^;}]+?)\\s*([;}]|$)/gi,\n        '{ if ($1) { _retval[_idx++] = $item$; }; continue _coreloop; }$2');\n\n    // This preserves the function template code after JS compression,\n    // so that replace() commands still work as expected.\n    let tpl = [\n      // \"function(_items, _args) { \",\n      'let _retval = [], _idx = 0; ',\n      'let $item$, $args$ = _args; ',\n      '_coreloop: ',\n      'for (let _i = 0, _il = _items.length; _i < _il; _i++) { ',\n      '$item$ = _items[_i]; ',\n      '$filter$; ',\n      '} ',\n      'return _retval; '\n      // \"}\"\n    ].join('');\n    tpl = tpl.replace(/\\$filter\\$/gi, filterBody);\n    tpl = tpl.replace(/\\$item\\$/gi, filterInfo.params[0]);\n    tpl = tpl.replace(/\\$args\\$/gi, filterInfo.params[1]);\n\n    let fn = new Function('_items,_args', tpl);\n    fn.displayName = 'compiledFilter';\n\n    return fn;\n  }\n\n  function compileFilterWithCaching(){\n    let filterInfo = getFunctionInfo(filter);\n\n    let filterPath1 = '{ continue _coreloop; }$1';\n    let filterPath2 = '{ _cache[_i] = true;_retval[_idx++] = $item$; continue _coreloop; }$1';\n    // make some allowances for minification - there's only so far we can go with RegEx\n    let filterBody = filterInfo.body\n      .replace(/return false\\s*([;}]|\\}|$)/gi, filterPath1)\n      .replace(/return!1([;}]|\\}|$)/gi, filterPath1)\n      .replace(/return true\\s*([;}]|\\}|$)/gi, filterPath2)\n      .replace(/return!0([;}]|\\}|$)/gi, filterPath2)\n      .replace(/return ([^;}]+?)\\s*([;}]|$)/gi,\n        '{ if ((_cache[_i] = $1)) { _retval[_idx++] = $item$; }; continue _coreloop; }$2');\n\n    // This preserves the function template code after JS compression,\n    // so that replace() commands still work as expected.\n    let tpl = [\n      // \"function(_items, _args, _cache) { \",\n      'let _retval = [], _idx = 0; ',\n      'let $item$, $args$ = _args; ',\n      '_coreloop: ',\n      'for (let _i = 0, _il = _items.length; _i < _il; _i++) { ',\n      '$item$ = _items[_i]; ',\n      'if (_cache[_i]) { ',\n      '_retval[_idx++] = $item$; ',\n      'continue _coreloop; ',\n      '} ',\n      '$filter$; ',\n      '} ',\n      'return _retval; '\n      // \"}\"\n    ].join('');\n    tpl = tpl.replace(/\\$filter\\$/gi, filterBody);\n    tpl = tpl.replace(/\\$item\\$/gi, filterInfo.params[0]);\n    tpl = tpl.replace(/\\$args\\$/gi, filterInfo.params[1]);\n\n    let fn = new Function('_items,_args,_cache', tpl);\n    fn.displayName = 'compiledFilterWithCaching';\n    return fn;\n  }\n\n  function uncompiledFilter(items, args){\n    let retval = [], idx = 0;\n\n    for (let i = 0, ii = items.length; i < ii; i++){\n      if (filter(items[i], args)){\n        retval[idx++] = items[i];\n      }\n    }\n\n    return retval;\n  }\n\n  function uncompiledFilterWithCaching(items, args, cache){\n    let retval = [], idx = 0, item;\n\n    for (let i = 0, ii = items.length; i < ii; i++){\n      item = items[i];\n      if (cache[i]){\n        retval[idx++] = item;\n      } else if (filter(item, args)){\n        retval[idx++] = item;\n        cache[i] = true;\n      }\n    }\n\n    return retval;\n  }\n\n  function getFilteredAndPagedItems(items){\n    if (filter){\n      let batchFilter = options.inlineFilters ? compiledFilter : uncompiledFilter;\n      let batchFilterWithCaching = options.inlineFilters ? compiledFilterWithCaching : uncompiledFilterWithCaching;\n\n      if (refreshHints.isFilterNarrowing){\n        filteredItems = batchFilter(filteredItems, filterArgs);\n      } else if (refreshHints.isFilterExpanding){\n        filteredItems = batchFilterWithCaching(items, filterArgs, filterCache);\n      } else if (!refreshHints.isFilterUnchanged){\n        filteredItems = batchFilter(items, filterArgs);\n      }\n    } else {\n      // special case:  if not filtering and not paging, the resulting\n      // rows collection needs to be a copy so that changes due to sort\n      // can be caught\n      filteredItems = pagesize ? items : items.concat();\n    }\n\n    // get the current page\n    let paged;\n    if (pagesize){\n      if (filteredItems.length < pagenum * pagesize){\n        pagenum = Math.floor(filteredItems.length / pagesize);\n      }\n      paged = filteredItems.slice(pagesize * pagenum, pagesize * pagenum + pagesize);\n    } else {\n      paged = filteredItems;\n    }\n\n    return {totalRows: filteredItems.length, rows: paged};\n  }\n\n  function getRowDiffs(rows, newRows){\n    let item, r, eitherIsNonData, diff = [];\n    let from = 0, to = newRows.length;\n\n    if (refreshHints && refreshHints.ignoreDiffsBefore){\n      from = Math.max(0,\n        Math.min(newRows.length, refreshHints.ignoreDiffsBefore));\n    }\n\n    if (refreshHints && refreshHints.ignoreDiffsAfter){\n      to = Math.min(newRows.length,\n        Math.max(0, refreshHints.ignoreDiffsAfter));\n    }\n\n    for (let i = from, rl = rows.length; i < to; i++){\n      if (i >= rl){\n        diff[diff.length] = i;\n      } else {\n        item = newRows[i];\n        r = rows[i];\n\n        if ((groupingInfos.length && (eitherIsNonData = (item.__nonDataRow) || (r.__nonDataRow)) &&\n          item.__group !== r.__group ||\n          item.__group && !item.equals(r))\n          || (eitherIsNonData &&\n          // no good way to compare totals since they are arbitrary DTOs\n          // deep object comparison is pretty expensive\n          // always considering them 'dirty' seems easier for the time being\n          (item.__groupTotals || r.__groupTotals))\n          || item[idProperty] != r[idProperty]\n          || (updated && updated[item[idProperty]])\n        ){\n          diff[diff.length] = i;\n        }\n      }\n    }\n    return diff;\n  }\n\n  function recalc(_items){\n    rowsById = null;\n\n    if (refreshHints.isFilterNarrowing != prevRefreshHints.isFilterNarrowing ||\n      refreshHints.isFilterExpanding != prevRefreshHints.isFilterExpanding){\n      filterCache = [];\n    }\n\n    let filteredItems = getFilteredAndPagedItems(_items);\n    totalRows = filteredItems.totalRows;\n    let newRows = filteredItems.rows;\n\n    groups = [];\n    if (groupingInfos.length){\n      groups = extractGroups(newRows);\n      if (groups.length){\n        addTotals(groups);\n        newRows = flattenGroupedRows(groups);\n      }\n    }\n\n    let diff = getRowDiffs(rows, newRows);\n\n    rows = newRows;\n\n    return diff;\n  }\n\n  function refresh(){\n    if (suspend){\n      return;\n    }\n\n    let countBefore = rows.length;\n    let totalRowsBefore = totalRows;\n\n    let diff = recalc(items, filter); // pass as direct refs to avoid closure perf hit\n\n    // if the current page is no longer valid, go to last page and recalc\n    // we suffer a performance penalty here, but the main loop (recalc) remains highly optimized\n    if (pagesize && totalRows < pagenum * pagesize){\n      pagenum = Math.max(0, Math.ceil(totalRows / pagesize) - 1);\n      diff = recalc(items, filter);\n    }\n\n    updated = null;\n    prevRefreshHints = refreshHints;\n    refreshHints = {};\n\n    if (totalRowsBefore !== totalRows){\n      onPagingInfoChanged.notify(getPagingInfo(), null, self);\n    }\n    if (countBefore !== rows.length){\n      onRowCountChanged.notify({previous: countBefore, current: rows.length, dataView: self}, null, self);\n    }\n    if (diff.length > 0){\n      onRowsChanged.notify({rows: diff, dataView: self}, null, self);\n    }\n  }\n\n  /** *\n   * Wires the grid and the DataView together to keep row selection tied to item ids.\n   * This is useful since, without it, the grid only knows about rows, so if the items\n   * move around, the same rows stay selected instead of the selection moving along\n   * with the items.\n   *\n   * NOTE:  This doesn't work with cell selection model.\n   *\n   * @param grid {Slick.Grid} The grid to sync selection with.\n   * @param preserveHidden {Boolean} Whether to keep selected items that go out of the\n   *     view due to them getting filtered out.\n   * @param preserveHiddenOnSelectionChange {Boolean} Whether to keep selected items\n   *     that are currently out of the view (see preserveHidden) as selected when selection\n   *     changes.\n   * @return {Slick.Event} An event that notifies when an internal list of selected row ids\n   *     changes.  This is useful since, in combination with the above two options, it allows\n   *     access to the full list selected row ids, and not just the ones visible to the grid.\n   * @method syncGridSelection\n   */\n  function syncGridSelection(grid, preserveHidden, preserveHiddenOnSelectionChange){\n    let self = this;\n    let inHandler;\n    let selectedRowIds = self.mapRowsToIds(grid.getSelectedRows());\n    let onSelectedRowIdsChanged = new Slick.Event();\n\n    function setSelectedRowIds(rowIds){\n      if (selectedRowIds.join(',') == rowIds.join(',')){\n        return;\n      }\n\n      selectedRowIds = rowIds;\n\n      onSelectedRowIdsChanged.notify({\n        'grid': grid,\n        'ids': selectedRowIds,\n        'dataView': self\n      }, new Slick.EventData(), self);\n    }\n\n    function update(){\n      if (selectedRowIds.length > 0){\n        inHandler = true;\n        let selectedRows = self.mapIdsToRows(selectedRowIds);\n        if (!preserveHidden){\n          setSelectedRowIds(self.mapRowsToIds(selectedRows));\n        }\n        grid.setSelectedRows(selectedRows);\n        inHandler = false;\n      }\n    }\n\n    grid.onSelectedRowsChanged.subscribe(function(e, args){\n      if (inHandler){\n        return;\n      }\n      let newSelectedRowIds = self.mapRowsToIds(grid.getSelectedRows());\n      if (!preserveHiddenOnSelectionChange || !grid.getOptions().multiSelect){\n        setSelectedRowIds(newSelectedRowIds);\n      } else {\n        // keep the ones that are hidden\n        let existing = $.grep(selectedRowIds, function(id){\n          return self.getRowById(id) === undefined;\n        });\n        // add the newly selected ones\n        setSelectedRowIds(existing.concat(newSelectedRowIds));\n      }\n    });\n\n    this.onRowsChanged.subscribe(update);\n\n    this.onRowCountChanged.subscribe(update);\n\n    return onSelectedRowIdsChanged;\n  }\n\n  function syncGridCellCssStyles(grid, key){\n    let hashById;\n    let inHandler;\n\n    // since this method can be called after the cell styles have been set,\n    // get the existing ones right away\n    storeCellCssStyles(grid.getCellCssStyles(key));\n\n    function storeCellCssStyles(hash){\n      hashById = {};\n      for (let row in hash){\n        let id = rows[row][idProperty];\n        hashById[id] = hash[row];\n      }\n    }\n\n    function update(){\n      if (hashById){\n        inHandler = true;\n        ensureRowsByIdCache();\n        let newHash = {};\n        for (let id in hashById){\n          let row = rowsById[id];\n          if (row != undefined){\n            newHash[row] = hashById[id];\n          }\n        }\n        grid.setCellCssStyles(key, newHash);\n        inHandler = false;\n      }\n    }\n\n    grid.onCellCssStylesChanged.subscribe(function(e, args){\n      if (inHandler){\n        return;\n      }\n      if (key != args.key){\n        return;\n      }\n      if (args.hash){\n        storeCellCssStyles(args.hash);\n      }\n    });\n\n    this.onRowsChanged.subscribe(update);\n\n    this.onRowCountChanged.subscribe(update);\n  }\n\n  $.extend(this, {\n    // methods\n    'beginUpdate': beginUpdate,\n    'endUpdate': endUpdate,\n    'setPagingOptions': setPagingOptions,\n    'getPagingInfo': getPagingInfo,\n    'getItems': getItems,\n    'setItems': setItems,\n    'setFilter': setFilter,\n    'sort': sort,\n    'fastSort': fastSort,\n    'reSort': reSort,\n    'setGrouping': setGrouping,\n    'getGrouping': getGrouping,\n    'groupBy': groupBy,\n    'setAggregators': setAggregators,\n    'collapseAllGroups': collapseAllGroups,\n    'expandAllGroups': expandAllGroups,\n    'collapseGroup': collapseGroup,\n    'expandGroup': expandGroup,\n    'getGroups': getGroups,\n    'getIdxById': getIdxById,\n    'getRowById': getRowById,\n    'getItemById': getItemById,\n    'getItemByIdx': getItemByIdx,\n    'mapRowsToIds': mapRowsToIds,\n    'mapIdsToRows': mapIdsToRows,\n    'setRefreshHints': setRefreshHints,\n    'setFilterArgs': setFilterArgs,\n    'refresh': refresh,\n    'updateItem': updateItem,\n    'insertItem': insertItem,\n    'addItem': addItem,\n    'deleteItem': deleteItem,\n    'syncGridSelection': syncGridSelection,\n    'syncGridCellCssStyles': syncGridCellCssStyles,\n\n    // data provider methods\n    'getLength': getLength,\n    'getItem': getItem,\n    'getItemMetadata': getItemMetadata,\n\n    // events\n    'onRowCountChanged': onRowCountChanged,\n    'onRowsChanged': onRowsChanged,\n    'onPagingInfoChanged': onPagingInfoChanged\n  });\n}\n\nfunction AvgAggregator(field){\n  this.field_ = field;\n\n  this.init = function(){\n    this.count_ = 0;\n    this.nonNullCount_ = 0;\n    this.sum_ = 0;\n  };\n\n  this.accumulate = function(item){\n    let val = item[this.field_];\n    this.count_++;\n    if (val != null && val !== '' && !isNaN(val)){\n      this.nonNullCount_++;\n      this.sum_ += parseFloat(val);\n    }\n  };\n\n  this.storeResult = function(groupTotals){\n    if (!groupTotals.avg){\n      groupTotals.avg = {};\n    }\n    if (this.nonNullCount_ != 0){\n      groupTotals.avg[this.field_] = this.sum_ / this.nonNullCount_;\n    }\n  };\n}\n\nfunction MinAggregator(field){\n  this.field_ = field;\n\n  this.init = function(){\n    this.min_ = null;\n  };\n\n  this.accumulate = function(item){\n    let val = item[this.field_];\n    if (val != null && val !== '' && !isNaN(val)){\n      if (this.min_ == null || val < this.min_){\n        this.min_ = val;\n      }\n    }\n  };\n\n  this.storeResult = function(groupTotals){\n    if (!groupTotals.min){\n      groupTotals.min = {};\n    }\n    groupTotals.min[this.field_] = this.min_;\n  };\n}\n\nfunction MaxAggregator(field){\n  this.field_ = field;\n\n  this.init = function(){\n    this.max_ = null;\n  };\n\n  this.accumulate = function(item){\n    let val = item[this.field_];\n    if (val != null && val !== '' && !isNaN(val)){\n      if (this.max_ == null || val > this.max_){\n        this.max_ = val;\n      }\n    }\n  };\n\n  this.storeResult = function(groupTotals){\n    if (!groupTotals.max){\n      groupTotals.max = {};\n    }\n    groupTotals.max[this.field_] = this.max_;\n  };\n}\n\nfunction SumAggregator(field){\n  this.field_ = field;\n\n  this.init = function(){\n    this.sum_ = null;\n  };\n\n  this.accumulate = function(item){\n    let val = item[this.field_];\n    if (val != null && val !== '' && !isNaN(val)){\n      this.sum_ += parseFloat(val);\n    }\n  };\n\n  this.storeResult = function(groupTotals){\n    if (!groupTotals.sum){\n      groupTotals.sum = {};\n    }\n    groupTotals.sum[this.field_] = this.sum_;\n  };\n}\n\n\n\n// WEBPACK FOOTER //\n// ../src/slick.dataview.js","import $      from 'jquery';\nimport Slick  from './slick.core';\n\nexport default GroupItemMetadataProvider;\n\n/***\n * Provides item metadata for group (Slick.Group) and totals (Slick.Totals) rows produced by the DataView.\n * This metadata overrides the default behavior and formatting of those rows so that they appear and function\n * correctly when processed by the grid.\n *\n * This class also acts as a grid plugin providing event handlers to expand & collapse groups.\n * If \"grid.registerPlugin(...)\" is not called, expand & collapse will not work.\n *\n * @class GroupItemMetadataProvider\n * @module Data\n * @namespace Slick.Data\n * @constructor\n * @param options\n */\nfunction GroupItemMetadataProvider(options){\n  let _grid;\n  let _defaults = {\n    groupCssClass: \"slick-group\",\n    groupTitleCssClass: \"slick-group-title\",\n    totalsCssClass: \"slick-group-totals\",\n    groupFocusable: true,\n    totalsFocusable: false,\n    toggleCssClass: \"slick-group-toggle\",\n    toggleExpandedCssClass: \"expanded\",\n    toggleCollapsedCssClass: \"collapsed\",\n    enableExpandCollapse: true,\n    groupFormatter: defaultGroupCellFormatter,\n    totalsFormatter: defaultTotalsCellFormatter\n  };\n\n  options = $.extend(true, {}, _defaults, options);\n\n  function defaultGroupCellFormatter(row, cell, value, columnDef, item){\n    if (!options.enableExpandCollapse){\n      return item.title;\n    }\n\n    let indentation = item.level * 15 + \"px\";\n\n    return \"<span class='\" + options.toggleCssClass + \" \" +\n      (item.collapsed ? options.toggleCollapsedCssClass : options.toggleExpandedCssClass) +\n      \"' style='margin-left:\" + indentation + \"'>\" +\n      \"</span>\" +\n      \"<span class='\" + options.groupTitleCssClass + \"' level='\" + item.level + \"'>\" +\n      item.title +\n      \"</span>\";\n  }\n\n  function defaultTotalsCellFormatter(row, cell, value, columnDef, item){\n    return (columnDef.groupTotalsFormatter && columnDef.groupTotalsFormatter(item, columnDef)) || \"\";\n  }\n\n  function init(grid){\n    _grid = grid;\n    _grid.onClick.subscribe(handleGridClick);\n    _grid.onKeyDown.subscribe(handleGridKeyDown);\n  }\n\n  function destroy(){\n    if (_grid){\n      _grid.onClick.unsubscribe(handleGridClick);\n      _grid.onKeyDown.unsubscribe(handleGridKeyDown);\n    }\n  }\n\n  function handleGridClick(e, args){\n    let item = this.getDataItem(args.row);\n    if (item && item instanceof Slick.Group && $(e.target).hasClass(options.toggleCssClass)){\n      let range = _grid.getRenderedRange();\n      this.getData().setRefreshHints({\n        ignoreDiffsBefore: range.top,\n        ignoreDiffsAfter: range.bottom + 1\n      });\n\n      if (item.collapsed){\n        this.getData().expandGroup(item.groupingKey);\n      } else {\n        this.getData().collapseGroup(item.groupingKey);\n      }\n\n      e.stopImmediatePropagation();\n      e.preventDefault();\n    }\n  }\n\n  // TODO:  add -/+ handling\n  function handleGridKeyDown(e){\n    if (options.enableExpandCollapse && (e.which == Slick.keyCode.SPACE)){\n      let activeCell = this.getActiveCell();\n      if (activeCell){\n        let item = this.getDataItem(activeCell.row);\n        if (item && item instanceof Slick.Group){\n          let range = _grid.getRenderedRange();\n          this.getData().setRefreshHints({\n            ignoreDiffsBefore: range.top,\n            ignoreDiffsAfter: range.bottom + 1\n          });\n\n          if (item.collapsed){\n            this.getData().expandGroup(item.groupingKey);\n          } else {\n            this.getData().collapseGroup(item.groupingKey);\n          }\n\n          e.stopImmediatePropagation();\n          e.preventDefault();\n        }\n      }\n    }\n  }\n\n  function getGroupRowMetadata(item){\n    return {\n      selectable: false,\n      focusable: options.groupFocusable,\n      cssClasses: options.groupCssClass,\n      columns: {\n        0: {\n          colspan: \"*\",\n          formatter: options.groupFormatter,\n          editor: null\n        }\n      }\n    };\n  }\n\n  function getTotalsRowMetadata(item){\n    return {\n      selectable: false,\n      focusable: options.totalsFocusable,\n      cssClasses: options.totalsCssClass,\n      formatter: options.totalsFormatter,\n      editor: null\n    };\n  }\n\n  return {\n    init,\n    destroy,\n    getGroupRowMetadata,\n    getTotalsRowMetadata\n  };\n}\n\n\n\n// WEBPACK FOOTER //\n// ../src/slick.groupmetadataprovider.js"],"sourceRoot":""}