{"version":3,"sources":["webpack:///interact.js","webpack:///webpack/bootstrap 118ae0e52e5cacaf4382?1a03****","webpack:///./src/interact.js?afe3**"],"names":["module","exports","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","_typeof","Symbol","iterator","obj","constructor","prototype","realWindow","blank","isElement","o","_window","getWindow","window","test","Element","nodeType","nodeName","isWindow","thing","Window","isDocFrag","DocumentFragment","isArray","isObject","undefined","length","isFunction","splice","isNumber","isBool","isString","trySelector","value","document","querySelector","extend","dest","source","prop","pointerExtend","deprecated","vendor","prefixedPropREs","indexOf","copyCoords","src","page","x","y","client","timeStamp","setEventXY","targetObj","pointers","interaction","pointer","pointerAverage","getPageXY","tmpXY","getClientXY","Date","getTime","setEventDeltas","prev","cur","dt","Math","max","speed","hypot","vx","vy","isNativePointer","Event","supportsTouch","Touch","getXY","type","xy","isOperaMobile","scrollX","scrollY","getScrollXY","win","documentElement","scrollLeft","scrollTop","getPointerId","pointerId","identifier","getActualElement","element","SVGElementInstance","correspondingUseElement","node","rootNode","ownerDocument","defaultView","parentWindow","getElementClientRect","clientRect","SVGElement","getBoundingClientRect","getClientRects","left","right","top","bottom","width","height","getElementRect","isIOS7","scroll","getTouchPair","event","touches","changedTouches","average","pageX","pageY","clientX","clientY","screenX","screenY","i","touchBBox","minX","min","minY","maxX","maxY","touchDistance","deltaSource","defaultOptions","sourceX","sourceY","dx","dy","touchAngle","prevAngle","angle","atan","PI","dr","drClamped","getOriginXY","interactable","origin","options","parentElement","getRect","closest","_getQBezierValue","t","p1","p2","p3","iT","getQuadraticCurvePoint","startX","startY","cpX","cpY","endX","endY","position","easeOutQuad","b","d","nodeContains","parent","child","parentNode","selector","matchesSelector","host","inContext","_context","testIgnore","interactableElement","ignoreFrom","matchesUpTo","testAllow","allowFrom","checkAxis","axis","thisAxis","drag","checkSnap","action","snap","enabled","checkRestrict","restrict","checkAutoScroll","autoScroll","withinInteractionLimit","maxActions","name","maxPerElement","activeInteractions","targetCount","targetElementCount","len","interactions","otherAction","prepared","active","interacting","maxInteractions","target","indexOfDeepestElement","elements","dropzone","n","deepestZone","index","deepestZoneParents","dropzoneParents","unshift","HTMLElement","SVGSVGElement","ownerSVGElement","parents","lastChild","previousSibling","Interaction","this","dropTarget","dropElement","prevDropTarget","prevDropElement","edges","matches","matchElements","inertiaStatus","smoothEnd","ending","startEvent","upCoords","xe","ye","sx","sy","t0","vx0","vys","duration","resumeDx","resumeDy","lambda_v0","one_ve_v0","Function","bind","boundInertiaFrame","inertiaFrame","boundSmoothEndFrame","smoothEndFrame","that","activeDrops","dropzones","rects","pointerIds","downTargets","downTimes","holdTimers","prevCoords","curCoords","startCoords","pointerDelta","downEvent","downPointer","_eventTarget","_curEventTarget","prevEvent","tapTime","prevTap","startOffset","restrictOffset","snapOffsets","gesture","start","startDistance","prevDistance","distance","scale","startAngle","snapStatus","realX","realY","snappedX","snappedY","targets","locked","changed","restrictStatus","restrictedX","restrictedY","restricted","pointerIsDown","pointerWasMoved","gesturing","dragging","resizing","resizeAxes","mouse","push","getInteractionFromPointer","eventType","eventTarget","mouseEvent","pointerType","inertia","allowResume","supportsPointerEvent","contains","doOnInteractions","method","path","curEventTarget","currentTarget","prevTouchTime","_updateEventTargets","InteractEvent","phase","related","starting","coords","relativePoints","range","elementRect","x0","y0","clientX0","clientY0","ctrlKey","altKey","shiftKey","metaKey","button","buttons","detail","relatedTarget","zeroResumeDelta","resize","square","axes","box","ds","da","prevScale","velocityX","velocityY","atan2","overlap","up","down","swipe","velocity","preventOriginalDefault","originalEvent","preventDefault","getActionCursor","cursor","actionCursors","cursorKey","edgeNames","checkResizeEdge","rect","margin","defaultActionChecker","resizeEdges","shouldResize","actionIsEnabled","resizeOptions","edge","validateAction","actionName","delegateListener","useCapture","fakeEvent","delegated","delegatedEvents","selectors","context","contexts","listeners","j","delegateUseCapture","interact","interactables","get","Interactable","_element","_iEvents","Node","events","add","pEventTypes","pointerDown","move","pointerHover","_doc","documents","listenToDocument","set","warnOnce","message","warned","console","warn","apply","arguments","endAllInteractions","pointerEnd","doc","PointerEvent","MSPointerEvent","over","out","cancel","selectorDown","pointerMove","pointerOver","pointerOut","pointerUp","pointerCancel","autoScrollMove","frameElement","parentDoc","error","windowParentError","checkAndPreventDefault","useAttachEvent","currentAction","array","nodeList","ie8MatchesSelector","replace","prefixedMatchesSelector","limit","el","createTextNode","wrap","sqrt","dynamicDrop","base","accept","actionChecker","styleCursor","dropChecker","manualStart","Infinity","drop","preserveAspectRatio","NaN","invert","perAction","endOnly","offsets","container","resistance","minSpeed","endSpeed","smoothEndDuration","_holdDuration","now","dtx","prevTimeX","dty","prevTimeY","scrollBy","isScrolling","cancelFrame","reqFrame","stop","DocumentTouch","navigator","userAgent","pointerMoveTolerance","all","atob","resizex","resizey","resizexy","resizetop","resizeleft","resizebottom","resizeright","resizetopleft","resizebottomright","resizetopright","resizebottomleft","wheelEvent","eventTypes","globalEvents","appName","match","platform","appVersion","requestAnimationFrame","cancelAnimationFrame","listener","elementIndex","typeCount","attachedListeners","supplied","wrapped","useCount","ret","listenerIndex","immediatePropagationStopped","srcElement","preventDef","stopPropagation","stopProp","stopImmediatePropagation","stopImmProp","addEvent","on","Boolean","remove","removeEvent","hasOwnProperty","returnValue","cancelBubble","_elements","_targets","_attachedListeners","webkit","ptr","pushCurMatches","curMatches","curMatchElements","prevTargetElement","addPointer","elementInteractable","elementAction","getAction","forEachSelector","validateSelector","style","pushMatches","querySelectorAll","eventCopy","pointerIndex","setTimeout","pointerHold","collectEventTargets","forceAction","newAction","setModifications","preEnd","shouldMove","shouldSnap","shouldRestrict","setSnapping","setRestriction","setStartOffsets","snapOffset","offset","pageUp","clientUp","inertiaPosition","recordPointer","duplicateMove","clearTimeout","absX","abs","absY","targetAxis","thisInteraction","getDraggable","selectorInteractable","dragStart","dragEvent","fire","setActiveDrops","dropEvents","getDropEvents","activate","fireActiveDrops","dragMove","draggableElement","getDrop","leave","enter","resizeStart","resizeEvent","startRect","linkedEdges","_linkedEdges","resizeStartAspectRatio","resizeRects","current","previous","delta","deltaRect","resizeMove","invertible","originalEdges","swap","gestureStart","gestureEvent","gestureMove","isNaN","removePointer","ie8Dblclick","endEvent","inertiaOptions","pointerSpeed","inertiaPossible","endSnap","endRestrict","snapRestrict","vy0","v0","calcInertia","statusObject","useStatusXY","modifiedXe","modifiedYe","deactivate","collectDrops","drops","dropElements","currentElement","prevElement","dragElement","possibleDrops","validDrops","dropCheck","dropIndex","pointerEvent","draggable","dragLeave","prevDropzone","dragEnter","dragmove","clearTargets","lambda","te","progress","exp","quadPoint","collectSelectors","els","isSet","firePointers","interval","createNewDoubleTap","originalPointer","double","propagationStopped","doubleTap","matchElement","pageCoords","status","relIndex","relative","inRange","snapChanged","restriction","prevent","inertiaDur","log","innerWidth","innerHeight","interactionListeners","indexOfElement","callback","setOnEvents","phases","ondrop","ondropactivate","ondropdeactivate","ondragenter","ondragleave","ondropmove","onstart","onmove","onend","oninertiastart","setPerAction","option","checker","dropped","dropOverlap","horizontal","vertical","dragRect","cx","cy","overlapArea","overlapRatio","newValue","resizable","squareResize","gesturable","actions","setOptions","thisOption","mode","createSnapGrid","gridOffset","grid","anchors","paths","elementOrigin","allActions","rectChecker","iEvent","onEvent","funcName","search","trim","split","off","eventList","matchFound","fn","useCap","methods","perActions","settings","setting","unset","enableDragging","enableResizing","enableGesturing","debug","downTime","getPointerAverage","getTouchBBox","getTouchDistance","getTouchAngle","newvalue","offsetX","offsetY","gridx","round","gridy","newX","newY","elems","lastTime","vendors","currTime","timeToCall"],"mappings":"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","file":"interact.js","sourcesContent":["module.exports =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"/\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(3);\n\n\n/***/ }),\n/* 1 */,\n/* 2 */,\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\t\n\t/**\n\t * interact.js v1.2.6\n\t *\n\t * Copyright (c) 2012-2015 Taye Adeyemi <dev@taye.me>\n\t * Open source under the MIT License.\n\t * https://raw.github.com/taye/interact.js/master/LICENSE\n\t *\n\t * This file has been monkey patched to pass the originalEvent on to drag events\n\t */\n\t(function (realWindow) {\n\t  'use strict';\n\t\n\t  // return early if there's no window to work with (eg. Node.js)\n\t\n\t  if (!realWindow) {\n\t    return;\n\t  }\n\t\n\t  var // get wrapped window if using Shadow DOM polyfill\n\t  window = function () {\n\t    // create a TextNode\n\t    var el = realWindow.document.createTextNode('');\n\t\n\t    // check if it's wrapped by a polyfill\n\t    if (el.ownerDocument !== realWindow.document && typeof realWindow.wrap === 'function' && realWindow.wrap(el) === el) {\n\t      // return wrapped window\n\t      return realWindow.wrap(realWindow);\n\t    }\n\t\n\t    // no Shadow DOM polyfil or native implementation\n\t    return realWindow;\n\t  }(),\n\t      document = window.document,\n\t      DocumentFragment = window.DocumentFragment || blank,\n\t      SVGElement = window.SVGElement || blank,\n\t      SVGSVGElement = window.SVGSVGElement || blank,\n\t      SVGElementInstance = window.SVGElementInstance || blank,\n\t      HTMLElement = window.HTMLElement || window.Element,\n\t      PointerEvent = window.PointerEvent || window.MSPointerEvent,\n\t      pEventTypes,\n\t      hypot = Math.hypot || function (x, y) {\n\t    return Math.sqrt(x * x + y * y);\n\t  },\n\t      tmpXY = {},\n\t      // reduce object creation in getXY()\n\t  documents = [],\n\t      // all documents being listened to\n\t  interactables = [],\n\t      // all set interactables\n\t  interactions = [],\n\t      // all interactions\n\t  dynamicDrop = false,\n\t\n\t  // {\n\t  //      type: {\n\t  //          selectors: ['selector', ...],\n\t  //          contexts : [document, ...],\n\t  //          listeners: [[listener, useCapture], ...]\n\t  //      }\n\t  //  }\n\t  delegatedEvents = {},\n\t      defaultOptions = {\n\t    base: {\n\t      accept: null,\n\t      actionChecker: null,\n\t      styleCursor: true,\n\t      preventDefault: 'auto',\n\t      origin: { x: 0, y: 0 },\n\t      deltaSource: 'page',\n\t      allowFrom: null,\n\t      ignoreFrom: null,\n\t      _context: document,\n\t      dropChecker: null\n\t    },\n\t\n\t    drag: {\n\t      enabled: false,\n\t      manualStart: true,\n\t      max: Infinity,\n\t      maxPerElement: 1,\n\t\n\t      snap: null,\n\t      restrict: null,\n\t      inertia: null,\n\t      autoScroll: null,\n\t\n\t      axis: 'xy'\n\t    },\n\t\n\t    drop: {\n\t      enabled: false,\n\t      accept: null,\n\t      overlap: 'pointer'\n\t    },\n\t\n\t    resize: {\n\t      enabled: false,\n\t      manualStart: false,\n\t      max: Infinity,\n\t      maxPerElement: 1,\n\t\n\t      snap: null,\n\t      restrict: null,\n\t      inertia: null,\n\t      autoScroll: null,\n\t\n\t      square: false,\n\t      preserveAspectRatio: false,\n\t      axis: 'xy',\n\t\n\t      // use default margin\n\t      margin: NaN,\n\t\n\t      // object with props left, right, top, bottom which are\n\t      // true/false values to resize when the pointer is over that edge,\n\t      // CSS selectors to match the handles for each direction\n\t      // or the Elements for each handle\n\t      edges: null,\n\t\n\t      // a value of 'none' will limit the resize rect to a minimum of 0x0\n\t      // 'negate' will alow the rect to have negative width/height\n\t      // 'reposition' will keep the width/height positive by swapping\n\t      // the top and bottom edges and/or swapping the left and right edges\n\t      invert: 'none'\n\t    },\n\t\n\t    gesture: {\n\t      manualStart: false,\n\t      enabled: false,\n\t      max: Infinity,\n\t      maxPerElement: 1,\n\t\n\t      restrict: null\n\t    },\n\t\n\t    perAction: {\n\t      manualStart: false,\n\t      max: Infinity,\n\t      maxPerElement: 1,\n\t\n\t      snap: {\n\t        enabled: false,\n\t        endOnly: false,\n\t        range: Infinity,\n\t        targets: null,\n\t        offsets: null,\n\t\n\t        relativePoints: null\n\t      },\n\t\n\t      restrict: {\n\t        enabled: false,\n\t        endOnly: false\n\t      },\n\t\n\t      autoScroll: {\n\t        enabled: false,\n\t        container: null, // the item that is scrolled (Window or HTMLElement)\n\t        margin: 60,\n\t        speed: 300 // the scroll speed in pixels per second\n\t      },\n\t\n\t      inertia: {\n\t        enabled: false,\n\t        resistance: 10, // the lambda in exponential decay\n\t        minSpeed: 100, // target speed must be above this for inertia to start\n\t        endSpeed: 10, // the speed at which inertia is slow enough to stop\n\t        allowResume: true, // allow resuming an action in inertia phase\n\t        zeroResumeDelta: true, // if an action is resumed after launch, set dx/dy to 0\n\t        smoothEndDuration: 300 // animate to snap/restrict endOnly if there's no inertia\n\t      }\n\t    },\n\t\n\t    _holdDuration: 600\n\t  },\n\t\n\t  // Things related to autoScroll\n\t  autoScroll = {\n\t    interaction: null,\n\t    i: null, // the handle returned by window.setInterval\n\t    x: 0,\n\t    y: 0, // Direction each pulse is to scroll in\n\t\n\t    // scroll the window by the values in scroll.x/y\n\t    scroll: function scroll() {\n\t      var options = autoScroll.interaction.target.options[autoScroll.interaction.prepared.name].autoScroll,\n\t          container = options.container || getWindow(autoScroll.interaction.element),\n\t          now = new Date().getTime(),\n\t\n\t      // change in time in seconds\n\t      dtx = (now - autoScroll.prevTimeX) / 1000,\n\t          dty = (now - autoScroll.prevTimeY) / 1000,\n\t          vx,\n\t          vy,\n\t          sx,\n\t          sy;\n\t\n\t      // displacement\n\t      if (options.velocity) {\n\t        vx = options.velocity.x;\n\t        vy = options.velocity.y;\n\t      } else {\n\t        vx = vy = options.speed;\n\t      }\n\t\n\t      sx = vx * dtx;\n\t      sy = vy * dty;\n\t\n\t      if (sx >= 1 || sy >= 1) {\n\t        if (isWindow(container)) {\n\t          container.scrollBy(autoScroll.x * sx, autoScroll.y * sy);\n\t        } else if (container) {\n\t          container.scrollLeft += autoScroll.x * sx;\n\t          container.scrollTop += autoScroll.y * sy;\n\t        }\n\t\n\t        if (sx >= 1) autoScroll.prevTimeX = now;\n\t        if (sy >= 1) autoScroll.prevTimeY = now;\n\t      }\n\t\n\t      if (autoScroll.isScrolling) {\n\t        cancelFrame(autoScroll.i);\n\t        autoScroll.i = reqFrame(autoScroll.scroll);\n\t      }\n\t    },\n\t\n\t    isScrolling: false,\n\t    prevTimeX: 0,\n\t    prevTimeY: 0,\n\t\n\t    start: function start(interaction) {\n\t      autoScroll.isScrolling = true;\n\t      cancelFrame(autoScroll.i);\n\t\n\t      autoScroll.interaction = interaction;\n\t      autoScroll.prevTimeX = new Date().getTime();\n\t      autoScroll.prevTimeY = new Date().getTime();\n\t      autoScroll.i = reqFrame(autoScroll.scroll);\n\t    },\n\t\n\t    stop: function stop() {\n\t      autoScroll.isScrolling = false;\n\t      cancelFrame(autoScroll.i);\n\t    }\n\t  },\n\t\n\t  // Does the browser support touch input?\n\t  supportsTouch = 'ontouchstart' in window || window.DocumentTouch && document instanceof window.DocumentTouch,\n\t\n\t  // Does the browser support PointerEvents\n\t  // Avoid PointerEvent bugs introduced in Chrome 55\n\t  supportsPointerEvent = PointerEvent && !/Chrome/.test(navigator.userAgent),\n\t\n\t  // Less Precision with touch input\n\t  margin = supportsTouch || supportsPointerEvent ? 20 : 10,\n\t      pointerMoveTolerance = 1,\n\t\n\t  // for ignoring browser's simulated mouse events\n\t  prevTouchTime = 0,\n\t\n\t  // Allow this many interactions to happen simultaneously\n\t  maxInteractions = Infinity,\n\t\n\t  // Check if is IE9 or older\n\t  actionCursors = document.all && !window.atob ? {\n\t    drag: 'move',\n\t    resizex: 'e-resize',\n\t    resizey: 's-resize',\n\t    resizexy: 'se-resize',\n\t\n\t    resizetop: 'n-resize',\n\t    resizeleft: 'w-resize',\n\t    resizebottom: 's-resize',\n\t    resizeright: 'e-resize',\n\t    resizetopleft: 'se-resize',\n\t    resizebottomright: 'se-resize',\n\t    resizetopright: 'ne-resize',\n\t    resizebottomleft: 'ne-resize',\n\t\n\t    gesture: ''\n\t  } : {\n\t    drag: 'move',\n\t    resizex: 'ew-resize',\n\t    resizey: 'ns-resize',\n\t    resizexy: 'nwse-resize',\n\t\n\t    resizetop: 'ns-resize',\n\t    resizeleft: 'ew-resize',\n\t    resizebottom: 'ns-resize',\n\t    resizeright: 'ew-resize',\n\t    resizetopleft: 'nwse-resize',\n\t    resizebottomright: 'nwse-resize',\n\t    resizetopright: 'nesw-resize',\n\t    resizebottomleft: 'nesw-resize',\n\t\n\t    gesture: ''\n\t  },\n\t      actionIsEnabled = {\n\t    drag: true,\n\t    resize: true,\n\t    gesture: true\n\t  },\n\t\n\t  // because Webkit and Opera still use 'mousewheel' event type\n\t  wheelEvent = 'onmousewheel' in document ? 'mousewheel' : 'wheel',\n\t      eventTypes = ['dragstart', 'dragmove', 'draginertiastart', 'dragend', 'dragenter', 'dragleave', 'dropactivate', 'dropdeactivate', 'dropmove', 'drop', 'resizestart', 'resizemove', 'resizeinertiastart', 'resizeend', 'gesturestart', 'gesturemove', 'gestureinertiastart', 'gestureend', 'down', 'move', 'up', 'cancel', 'tap', 'doubletap', 'hold'],\n\t      globalEvents = {},\n\t\n\t  // Opera Mobile must be handled differently\n\t  isOperaMobile = navigator.appName == 'Opera' && supportsTouch && navigator.userAgent.match('Presto'),\n\t\n\t  // scrolling doesn't change the result of getClientRects on iOS 7\n\t  isIOS7 = /iP(hone|od|ad)/.test(navigator.platform) && /OS 7[^\\d]/.test(navigator.appVersion),\n\t\n\t  // prefix matchesSelector\n\t  prefixedMatchesSelector = 'matches' in Element.prototype ? 'matches' : 'webkitMatchesSelector' in Element.prototype ? 'webkitMatchesSelector' : 'mozMatchesSelector' in Element.prototype ? 'mozMatchesSelector' : 'oMatchesSelector' in Element.prototype ? 'oMatchesSelector' : 'msMatchesSelector',\n\t\n\t  // will be polyfill function if browser is IE8\n\t  ie8MatchesSelector,\n\t\n\t  // native requestAnimationFrame or polyfill\n\t  reqFrame = realWindow.requestAnimationFrame,\n\t      cancelFrame = realWindow.cancelAnimationFrame,\n\t\n\t  // Events wrapper\n\t  events = function () {\n\t    var useAttachEvent = 'attachEvent' in window && !('addEventListener' in window),\n\t        addEvent = useAttachEvent ? 'attachEvent' : 'addEventListener',\n\t        removeEvent = useAttachEvent ? 'detachEvent' : 'removeEventListener',\n\t        on = useAttachEvent ? 'on' : '',\n\t        elements = [],\n\t        targets = [],\n\t        attachedListeners = [];\n\t\n\t    function add(element, type, listener, useCapture) {\n\t      var elementIndex = indexOf(elements, element),\n\t          target = targets[elementIndex];\n\t\n\t      if (!target) {\n\t        target = {\n\t          events: {},\n\t          typeCount: 0\n\t        };\n\t\n\t        elementIndex = elements.push(element) - 1;\n\t        targets.push(target);\n\t\n\t        attachedListeners.push(useAttachEvent ? {\n\t          supplied: [],\n\t          wrapped: [],\n\t          useCount: []\n\t        } : null);\n\t      }\n\t\n\t      if (!target.events[type]) {\n\t        target.events[type] = [];\n\t        target.typeCount++;\n\t      }\n\t\n\t      if (!contains(target.events[type], listener)) {\n\t        var ret;\n\t\n\t        if (useAttachEvent) {\n\t          var listeners = attachedListeners[elementIndex],\n\t              listenerIndex = indexOf(listeners.supplied, listener);\n\t\n\t          var wrapped = listeners.wrapped[listenerIndex] || function (event) {\n\t            if (!event.immediatePropagationStopped) {\n\t              event.target = event.srcElement;\n\t              event.currentTarget = element;\n\t\n\t              event.preventDefault = event.preventDefault || preventDef;\n\t              event.stopPropagation = event.stopPropagation || stopProp;\n\t              event.stopImmediatePropagation = event.stopImmediatePropagation || stopImmProp;\n\t\n\t              if (/mouse|click/.test(event.type)) {\n\t                event.pageX = event.clientX + getWindow(element).document.documentElement.scrollLeft;\n\t                event.pageY = event.clientY + getWindow(element).document.documentElement.scrollTop;\n\t              }\n\t\n\t              listener(event);\n\t            }\n\t          };\n\t\n\t          ret = element[addEvent](on + type, wrapped, Boolean(useCapture));\n\t\n\t          if (listenerIndex === -1) {\n\t            listeners.supplied.push(listener);\n\t            listeners.wrapped.push(wrapped);\n\t            listeners.useCount.push(1);\n\t          } else {\n\t            listeners.useCount[listenerIndex]++;\n\t          }\n\t        } else {\n\t          ret = element[addEvent](type, listener, useCapture || false);\n\t        }\n\t        target.events[type].push(listener);\n\t\n\t        return ret;\n\t      }\n\t    }\n\t\n\t    function remove(element, type, listener, useCapture) {\n\t      var i,\n\t          elementIndex = indexOf(elements, element),\n\t          target = targets[elementIndex],\n\t          listeners,\n\t          listenerIndex,\n\t          wrapped = listener;\n\t\n\t      if (!target || !target.events) {\n\t        return;\n\t      }\n\t\n\t      if (useAttachEvent) {\n\t        listeners = attachedListeners[elementIndex];\n\t        listenerIndex = indexOf(listeners.supplied, listener);\n\t        wrapped = listeners.wrapped[listenerIndex];\n\t      }\n\t\n\t      if (type === 'all') {\n\t        for (type in target.events) {\n\t          if (target.events.hasOwnProperty(type)) {\n\t            remove(element, type, 'all');\n\t          }\n\t        }\n\t        return;\n\t      }\n\t\n\t      if (target.events[type]) {\n\t        var len = target.events[type].length;\n\t\n\t        if (listener === 'all') {\n\t          for (i = 0; i < len; i++) {\n\t            remove(element, type, target.events[type][i], Boolean(useCapture));\n\t          }\n\t          return;\n\t        } else {\n\t          for (i = 0; i < len; i++) {\n\t            if (target.events[type][i] === listener) {\n\t              element[removeEvent](on + type, wrapped, useCapture || false);\n\t              target.events[type].splice(i, 1);\n\t\n\t              if (useAttachEvent && listeners) {\n\t                listeners.useCount[listenerIndex]--;\n\t                if (listeners.useCount[listenerIndex] === 0) {\n\t                  listeners.supplied.splice(listenerIndex, 1);\n\t                  listeners.wrapped.splice(listenerIndex, 1);\n\t                  listeners.useCount.splice(listenerIndex, 1);\n\t                }\n\t              }\n\t\n\t              break;\n\t            }\n\t          }\n\t        }\n\t\n\t        if (target.events[type] && target.events[type].length === 0) {\n\t          target.events[type] = null;\n\t          target.typeCount--;\n\t        }\n\t      }\n\t\n\t      if (!target.typeCount) {\n\t        targets.splice(elementIndex, 1);\n\t        elements.splice(elementIndex, 1);\n\t        attachedListeners.splice(elementIndex, 1);\n\t      }\n\t    }\n\t\n\t    function preventDef() {\n\t      this.returnValue = false;\n\t    }\n\t\n\t    function stopProp() {\n\t      this.cancelBubble = true;\n\t    }\n\t\n\t    function stopImmProp() {\n\t      this.cancelBubble = true;\n\t      this.immediatePropagationStopped = true;\n\t    }\n\t\n\t    return {\n\t      add: add,\n\t      remove: remove,\n\t      useAttachEvent: useAttachEvent,\n\t\n\t      _elements: elements,\n\t      _targets: targets,\n\t      _attachedListeners: attachedListeners\n\t    };\n\t  }();\n\t\n\t  function blank() {}\n\t\n\t  function isElement(o) {\n\t    if (!o || (typeof o === 'undefined' ? 'undefined' : _typeof(o)) !== 'object') {\n\t      return false;\n\t    }\n\t\n\t    var _window = getWindow(o) || window;\n\t\n\t    return (/object|function/.test(_typeof(_window.Element)) ? o instanceof _window.Element //DOM2\n\t      : o.nodeType === 1 && typeof o.nodeName === 'string'\n\t    );\n\t  }\n\t  function isWindow(thing) {\n\t    return thing === window || !!(thing && thing.Window) && thing instanceof thing.Window;\n\t  }\n\t  function isDocFrag(thing) {\n\t    return !!thing && thing instanceof DocumentFragment;\n\t  }\n\t  function isArray(thing) {\n\t    return isObject(thing) && _typeof(thing.length) !== undefined && isFunction(thing.splice);\n\t  }\n\t  function isObject(thing) {\n\t    return !!thing && (typeof thing === 'undefined' ? 'undefined' : _typeof(thing)) === 'object';\n\t  }\n\t  function isFunction(thing) {\n\t    return typeof thing === 'function';\n\t  }\n\t  function isNumber(thing) {\n\t    return typeof thing === 'number';\n\t  }\n\t  function isBool(thing) {\n\t    return typeof thing === 'boolean';\n\t  }\n\t  function isString(thing) {\n\t    return typeof thing === 'string';\n\t  }\n\t\n\t  function trySelector(value) {\n\t    if (!isString(value)) {\n\t      return false;\n\t    }\n\t\n\t    // an exception will be raised if it is invalid\n\t    document.querySelector(value);\n\t    return true;\n\t  }\n\t\n\t  function extend(dest, source) {\n\t    for (var prop in source) {\n\t      dest[prop] = source[prop];\n\t    }\n\t    return dest;\n\t  }\n\t\n\t  var prefixedPropREs = {\n\t    webkit: /(Movement[XY]|Radius[XY]|RotationAngle|Force)$/\n\t  };\n\t\n\t  function pointerExtend(dest, source) {\n\t    for (var prop in source) {\n\t      var deprecated = false;\n\t\n\t      // skip deprecated prefixed properties\n\t      for (var vendor in prefixedPropREs) {\n\t        if (prop.indexOf(vendor) === 0 && prefixedPropREs[vendor].test(prop)) {\n\t          deprecated = true;\n\t          break;\n\t        }\n\t      }\n\t\n\t      if (!deprecated) {\n\t        dest[prop] = source[prop];\n\t      }\n\t    }\n\t    return dest;\n\t  }\n\t\n\t  function copyCoords(dest, src) {\n\t    dest.page = dest.page || {};\n\t    dest.page.x = src.page.x;\n\t    dest.page.y = src.page.y;\n\t\n\t    dest.client = dest.client || {};\n\t    dest.client.x = src.client.x;\n\t    dest.client.y = src.client.y;\n\t\n\t    dest.timeStamp = src.timeStamp;\n\t  }\n\t\n\t  function _setEventXY(targetObj, pointers, interaction) {\n\t    var pointer = pointers.length > 1 ? pointerAverage(pointers) : pointers[0];\n\t\n\t    _getPageXY(pointer, tmpXY, interaction);\n\t    targetObj.page.x = tmpXY.x;\n\t    targetObj.page.y = tmpXY.y;\n\t\n\t    _getClientXY(pointer, tmpXY, interaction);\n\t    targetObj.client.x = tmpXY.x;\n\t    targetObj.client.y = tmpXY.y;\n\t\n\t    targetObj.timeStamp = new Date().getTime();\n\t  }\n\t\n\t  function setEventDeltas(targetObj, prev, cur) {\n\t    targetObj.page.x = cur.page.x - prev.page.x;\n\t    targetObj.page.y = cur.page.y - prev.page.y;\n\t    targetObj.client.x = cur.client.x - prev.client.x;\n\t    targetObj.client.y = cur.client.y - prev.client.y;\n\t    targetObj.timeStamp = new Date().getTime() - prev.timeStamp;\n\t\n\t    // set pointer velocity\n\t    var dt = Math.max(targetObj.timeStamp / 1000, 0.001);\n\t    targetObj.page.speed = hypot(targetObj.page.x, targetObj.page.y) / dt;\n\t    targetObj.page.vx = targetObj.page.x / dt;\n\t    targetObj.page.vy = targetObj.page.y / dt;\n\t\n\t    targetObj.client.speed = hypot(targetObj.client.x, targetObj.page.y) / dt;\n\t    targetObj.client.vx = targetObj.client.x / dt;\n\t    targetObj.client.vy = targetObj.client.y / dt;\n\t  }\n\t\n\t  function isNativePointer(pointer) {\n\t    return pointer instanceof window.Event || supportsTouch && window.Touch && pointer instanceof window.Touch;\n\t  }\n\t\n\t  // Get specified X/Y coords for mouse or event.touches[0]\n\t  function getXY(type, pointer, xy) {\n\t    xy = xy || {};\n\t    type = type || 'page';\n\t\n\t    xy.x = pointer[type + 'X'];\n\t    xy.y = pointer[type + 'Y'];\n\t\n\t    return xy;\n\t  }\n\t\n\t  function _getPageXY(pointer, page) {\n\t    page = page || {};\n\t\n\t    // Opera Mobile handles the viewport and scrolling oddly\n\t    if (isOperaMobile && isNativePointer(pointer)) {\n\t      getXY('screen', pointer, page);\n\t\n\t      page.x += window.scrollX;\n\t      page.y += window.scrollY;\n\t    } else {\n\t      getXY('page', pointer, page);\n\t    }\n\t\n\t    return page;\n\t  }\n\t\n\t  function _getClientXY(pointer, client) {\n\t    client = client || {};\n\t\n\t    if (isOperaMobile && isNativePointer(pointer)) {\n\t      // Opera Mobile handles the viewport and scrolling oddly\n\t      getXY('screen', pointer, client);\n\t    } else {\n\t      getXY('client', pointer, client);\n\t    }\n\t\n\t    return client;\n\t  }\n\t\n\t  function getScrollXY(win) {\n\t    win = win || window;\n\t    return {\n\t      x: win.scrollX || win.document.documentElement.scrollLeft,\n\t      y: win.scrollY || win.document.documentElement.scrollTop\n\t    };\n\t  }\n\t\n\t  function getPointerId(pointer) {\n\t    return isNumber(pointer.pointerId) ? pointer.pointerId : pointer.identifier;\n\t  }\n\t\n\t  function getActualElement(element) {\n\t    return element instanceof SVGElementInstance ? element.correspondingUseElement : element;\n\t  }\n\t\n\t  function getWindow(node) {\n\t    if (isWindow(node)) {\n\t      return node;\n\t    }\n\t\n\t    var rootNode = node.ownerDocument || node;\n\t\n\t    return rootNode.defaultView || rootNode.parentWindow || window;\n\t  }\n\t\n\t  function getElementClientRect(element) {\n\t    var clientRect = element instanceof SVGElement ? element.getBoundingClientRect() : element.getClientRects()[0];\n\t\n\t    return clientRect && {\n\t      left: clientRect.left,\n\t      right: clientRect.right,\n\t      top: clientRect.top,\n\t      bottom: clientRect.bottom,\n\t      width: clientRect.width || clientRect.right - clientRect.left,\n\t      height: clientRect.height || clientRect.bottom - clientRect.top\n\t    };\n\t  }\n\t\n\t  function getElementRect(element) {\n\t    var clientRect = getElementClientRect(element);\n\t\n\t    if (!isIOS7 && clientRect) {\n\t      var scroll = getScrollXY(getWindow(element));\n\t\n\t      clientRect.left += scroll.x;\n\t      clientRect.right += scroll.x;\n\t      clientRect.top += scroll.y;\n\t      clientRect.bottom += scroll.y;\n\t    }\n\t\n\t    return clientRect;\n\t  }\n\t\n\t  function getTouchPair(event) {\n\t    var touches = [];\n\t\n\t    // array of touches is supplied\n\t    if (isArray(event)) {\n\t      touches[0] = event[0];\n\t      touches[1] = event[1];\n\t    }\n\t    // an event\n\t    else {\n\t        if (event.type === 'touchend') {\n\t          if (event.touches.length === 1) {\n\t            touches[0] = event.touches[0];\n\t            touches[1] = event.changedTouches[0];\n\t          } else if (event.touches.length === 0) {\n\t            touches[0] = event.changedTouches[0];\n\t            touches[1] = event.changedTouches[1];\n\t          }\n\t        } else {\n\t          touches[0] = event.touches[0];\n\t          touches[1] = event.touches[1];\n\t        }\n\t      }\n\t\n\t    return touches;\n\t  }\n\t\n\t  function pointerAverage(pointers) {\n\t    var average = {\n\t      pageX: 0,\n\t      pageY: 0,\n\t      clientX: 0,\n\t      clientY: 0,\n\t      screenX: 0,\n\t      screenY: 0\n\t    };\n\t    var prop;\n\t\n\t    for (var i = 0; i < pointers.length; i++) {\n\t      for (prop in average) {\n\t        average[prop] += pointers[i][prop];\n\t      }\n\t    }\n\t    for (prop in average) {\n\t      average[prop] /= pointers.length;\n\t    }\n\t\n\t    return average;\n\t  }\n\t\n\t  function touchBBox(event) {\n\t    if (!event.length && !(event.touches && event.touches.length > 1)) {\n\t      return;\n\t    }\n\t\n\t    var touches = getTouchPair(event),\n\t        minX = Math.min(touches[0].pageX, touches[1].pageX),\n\t        minY = Math.min(touches[0].pageY, touches[1].pageY),\n\t        maxX = Math.max(touches[0].pageX, touches[1].pageX),\n\t        maxY = Math.max(touches[0].pageY, touches[1].pageY);\n\t\n\t    return {\n\t      x: minX,\n\t      y: minY,\n\t      left: minX,\n\t      top: minY,\n\t      width: maxX - minX,\n\t      height: maxY - minY\n\t    };\n\t  }\n\t\n\t  function touchDistance(event, deltaSource) {\n\t    deltaSource = deltaSource || defaultOptions.deltaSource;\n\t\n\t    var sourceX = deltaSource + 'X',\n\t        sourceY = deltaSource + 'Y',\n\t        touches = getTouchPair(event);\n\t\n\t    var dx = touches[0][sourceX] - touches[1][sourceX],\n\t        dy = touches[0][sourceY] - touches[1][sourceY];\n\t\n\t    return hypot(dx, dy);\n\t  }\n\t\n\t  function touchAngle(event, prevAngle, deltaSource) {\n\t    deltaSource = deltaSource || defaultOptions.deltaSource;\n\t\n\t    var sourceX = deltaSource + 'X',\n\t        sourceY = deltaSource + 'Y',\n\t        touches = getTouchPair(event),\n\t        dx = touches[0][sourceX] - touches[1][sourceX],\n\t        dy = touches[0][sourceY] - touches[1][sourceY],\n\t        angle = 180 * Math.atan(dy / dx) / Math.PI;\n\t\n\t    if (isNumber(prevAngle)) {\n\t      var dr = angle - prevAngle,\n\t          drClamped = dr % 360;\n\t\n\t      if (drClamped > 315) {\n\t        angle -= 360 + angle / 360 | 0 * 360;\n\t      } else if (drClamped > 135) {\n\t        angle -= 180 + angle / 360 | 0 * 360;\n\t      } else if (drClamped < -315) {\n\t        angle += 360 + angle / 360 | 0 * 360;\n\t      } else if (drClamped < -135) {\n\t        angle += 180 + angle / 360 | 0 * 360;\n\t      }\n\t    }\n\t\n\t    return angle;\n\t  }\n\t\n\t  function getOriginXY(interactable, element) {\n\t    var origin = interactable ? interactable.options.origin : defaultOptions.origin;\n\t\n\t    if (origin === 'parent') {\n\t      origin = parentElement(element);\n\t    } else if (origin === 'self') {\n\t      origin = interactable.getRect(element);\n\t    } else if (trySelector(origin)) {\n\t      origin = closest(element, origin) || { x: 0, y: 0 };\n\t    }\n\t\n\t    if (isFunction(origin)) {\n\t      origin = origin(interactable && element);\n\t    }\n\t\n\t    if (isElement(origin)) {\n\t      origin = getElementRect(origin);\n\t    }\n\t\n\t    origin.x = 'x' in origin ? origin.x : origin.left;\n\t    origin.y = 'y' in origin ? origin.y : origin.top;\n\t\n\t    return origin;\n\t  }\n\t\n\t  // http://stackoverflow.com/a/5634528/2280888\n\t  function _getQBezierValue(t, p1, p2, p3) {\n\t    var iT = 1 - t;\n\t    return iT * iT * p1 + 2 * iT * t * p2 + t * t * p3;\n\t  }\n\t\n\t  function getQuadraticCurvePoint(startX, startY, cpX, cpY, endX, endY, position) {\n\t    return {\n\t      x: _getQBezierValue(position, startX, cpX, endX),\n\t      y: _getQBezierValue(position, startY, cpY, endY)\n\t    };\n\t  }\n\t\n\t  // http://gizma.com/easing/\n\t  function easeOutQuad(t, b, c, d) {\n\t    t /= d;\n\t    return -c * t * (t - 2) + b;\n\t  }\n\t\n\t  function nodeContains(parent, child) {\n\t    while (child) {\n\t      if (child === parent) {\n\t        return true;\n\t      }\n\t\n\t      child = child.parentNode;\n\t    }\n\t\n\t    return false;\n\t  }\n\t\n\t  function closest(child, selector) {\n\t    var parent = parentElement(child);\n\t\n\t    while (isElement(parent)) {\n\t      if (matchesSelector(parent, selector)) {\n\t        return parent;\n\t      }\n\t\n\t      parent = parentElement(parent);\n\t    }\n\t\n\t    return null;\n\t  }\n\t\n\t  function parentElement(node) {\n\t    var parent = node.parentNode;\n\t\n\t    if (isDocFrag(parent)) {\n\t      // skip past #shado-root fragments\n\t      while ((parent = parent.host) && isDocFrag(parent)) {}\n\t\n\t      return parent;\n\t    }\n\t\n\t    return parent;\n\t  }\n\t\n\t  function inContext(interactable, element) {\n\t    return interactable._context === element.ownerDocument || nodeContains(interactable._context, element);\n\t  }\n\t\n\t  function testIgnore(interactable, interactableElement, element) {\n\t    var ignoreFrom = interactable.options.ignoreFrom;\n\t\n\t    if (!ignoreFrom || !isElement(element)) {\n\t      return false;\n\t    }\n\t\n\t    if (isString(ignoreFrom)) {\n\t      return matchesUpTo(element, ignoreFrom, interactableElement);\n\t    } else if (isElement(ignoreFrom)) {\n\t      return nodeContains(ignoreFrom, element);\n\t    }\n\t\n\t    return false;\n\t  }\n\t\n\t  function testAllow(interactable, interactableElement, element) {\n\t    var allowFrom = interactable.options.allowFrom;\n\t\n\t    if (!allowFrom) {\n\t      return true;\n\t    }\n\t\n\t    if (!isElement(element)) {\n\t      return false;\n\t    }\n\t\n\t    if (isString(allowFrom)) {\n\t      return matchesUpTo(element, allowFrom, interactableElement);\n\t    } else if (isElement(allowFrom)) {\n\t      return nodeContains(allowFrom, element);\n\t    }\n\t\n\t    return false;\n\t  }\n\t\n\t  function checkAxis(axis, interactable) {\n\t    if (!interactable) {\n\t      return false;\n\t    }\n\t\n\t    var thisAxis = interactable.options.drag.axis;\n\t\n\t    return axis === 'xy' || thisAxis === 'xy' || thisAxis === axis;\n\t  }\n\t\n\t  function checkSnap(interactable, action) {\n\t    var options = interactable.options;\n\t\n\t    if (/^resize/.test(action)) {\n\t      action = 'resize';\n\t    }\n\t\n\t    return options[action].snap && options[action].snap.enabled;\n\t  }\n\t\n\t  function checkRestrict(interactable, action) {\n\t    var options = interactable.options;\n\t\n\t    if (/^resize/.test(action)) {\n\t      action = 'resize';\n\t    }\n\t\n\t    return options[action].restrict && options[action].restrict.enabled;\n\t  }\n\t\n\t  function checkAutoScroll(interactable, action) {\n\t    var options = interactable.options;\n\t\n\t    if (/^resize/.test(action)) {\n\t      action = 'resize';\n\t    }\n\t\n\t    return options[action].autoScroll && options[action].autoScroll.enabled;\n\t  }\n\t\n\t  function withinInteractionLimit(interactable, element, action) {\n\t    var options = interactable.options,\n\t        maxActions = options[action.name].max,\n\t        maxPerElement = options[action.name].maxPerElement,\n\t        activeInteractions = 0,\n\t        targetCount = 0,\n\t        targetElementCount = 0;\n\t\n\t    for (var i = 0, len = interactions.length; i < len; i++) {\n\t      var interaction = interactions[i],\n\t          otherAction = interaction.prepared.name,\n\t          active = interaction.interacting();\n\t\n\t      if (!active) {\n\t        continue;\n\t      }\n\t\n\t      activeInteractions++;\n\t\n\t      if (activeInteractions >= maxInteractions) {\n\t        return false;\n\t      }\n\t\n\t      if (interaction.target !== interactable) {\n\t        continue;\n\t      }\n\t\n\t      targetCount += otherAction === action.name | 0;\n\t\n\t      if (targetCount >= maxActions) {\n\t        return false;\n\t      }\n\t\n\t      if (interaction.element === element) {\n\t        targetElementCount++;\n\t\n\t        if (otherAction !== action.name || targetElementCount >= maxPerElement) {\n\t          return false;\n\t        }\n\t      }\n\t    }\n\t\n\t    return maxInteractions > 0;\n\t  }\n\t\n\t  // Test for the element that's \"above\" all other qualifiers\n\t  function indexOfDeepestElement(elements) {\n\t    var dropzone,\n\t        deepestZone = elements[0],\n\t        index = deepestZone ? 0 : -1,\n\t        parent,\n\t        deepestZoneParents = [],\n\t        dropzoneParents = [],\n\t        child,\n\t        i,\n\t        n;\n\t\n\t    for (i = 1; i < elements.length; i++) {\n\t      dropzone = elements[i];\n\t\n\t      // an element might belong to multiple selector dropzones\n\t      if (!dropzone || dropzone === deepestZone) {\n\t        continue;\n\t      }\n\t\n\t      if (!deepestZone) {\n\t        deepestZone = dropzone;\n\t        index = i;\n\t        continue;\n\t      }\n\t\n\t      // check if the deepest or current are document.documentElement or document.rootElement\n\t      // - if the current dropzone is, do nothing and continue\n\t      if (dropzone.parentNode === dropzone.ownerDocument) {\n\t        continue;\n\t      }\n\t      // - if deepest is, update with the current dropzone and continue to next\n\t      else if (deepestZone.parentNode === dropzone.ownerDocument) {\n\t          deepestZone = dropzone;\n\t          index = i;\n\t          continue;\n\t        }\n\t\n\t      if (!deepestZoneParents.length) {\n\t        parent = deepestZone;\n\t        while (parent.parentNode && parent.parentNode !== parent.ownerDocument) {\n\t          deepestZoneParents.unshift(parent);\n\t          parent = parent.parentNode;\n\t        }\n\t      }\n\t\n\t      // if this element is an svg element and the current deepest is\n\t      // an HTMLElement\n\t      if (deepestZone instanceof HTMLElement && dropzone instanceof SVGElement && !(dropzone instanceof SVGSVGElement)) {\n\t        if (dropzone === deepestZone.parentNode) {\n\t          continue;\n\t        }\n\t\n\t        parent = dropzone.ownerSVGElement;\n\t      } else {\n\t        parent = dropzone;\n\t      }\n\t\n\t      dropzoneParents = [];\n\t\n\t      while (parent.parentNode !== parent.ownerDocument) {\n\t        dropzoneParents.unshift(parent);\n\t        parent = parent.parentNode;\n\t      }\n\t\n\t      n = 0;\n\t\n\t      // get (position of last common ancestor) + 1\n\t      while (dropzoneParents[n] && dropzoneParents[n] === deepestZoneParents[n]) {\n\t        n++;\n\t      }\n\t\n\t      var parents = [dropzoneParents[n - 1], dropzoneParents[n], deepestZoneParents[n]];\n\t\n\t      child = parents[0].lastChild;\n\t\n\t      while (child) {\n\t        if (child === parents[1]) {\n\t          deepestZone = dropzone;\n\t          index = i;\n\t          deepestZoneParents = [];\n\t\n\t          break;\n\t        } else if (child === parents[2]) {\n\t          break;\n\t        }\n\t\n\t        child = child.previousSibling;\n\t      }\n\t    }\n\t\n\t    return index;\n\t  }\n\t\n\t  function Interaction() {\n\t    this.target = null; // current interactable being interacted with\n\t    this.element = null; // the target element of the interactable\n\t    this.dropTarget = null; // the dropzone a drag target might be dropped into\n\t    this.dropElement = null; // the element at the time of checking\n\t    this.prevDropTarget = null; // the dropzone that was recently dragged away from\n\t    this.prevDropElement = null; // the element at the time of checking\n\t\n\t    this.prepared = {\n\t      // action that's ready to be fired on next move event\n\t      name: null,\n\t      axis: null,\n\t      edges: null\n\t    };\n\t\n\t    this.matches = []; // all selectors that are matched by target element\n\t    this.matchElements = []; // corresponding elements\n\t\n\t    this.inertiaStatus = {\n\t      active: false,\n\t      smoothEnd: false,\n\t      ending: false,\n\t\n\t      startEvent: null,\n\t      upCoords: {},\n\t\n\t      xe: 0,\n\t      ye: 0,\n\t      sx: 0,\n\t      sy: 0,\n\t\n\t      t0: 0,\n\t      vx0: 0,\n\t      vys: 0,\n\t      duration: 0,\n\t\n\t      resumeDx: 0,\n\t      resumeDy: 0,\n\t\n\t      lambda_v0: 0,\n\t      one_ve_v0: 0,\n\t      i: null\n\t    };\n\t\n\t    if (isFunction(Function.prototype.bind)) {\n\t      this.boundInertiaFrame = this.inertiaFrame.bind(this);\n\t      this.boundSmoothEndFrame = this.smoothEndFrame.bind(this);\n\t    } else {\n\t      var that = this;\n\t\n\t      this.boundInertiaFrame = function () {\n\t        return that.inertiaFrame();\n\t      };\n\t      this.boundSmoothEndFrame = function () {\n\t        return that.smoothEndFrame();\n\t      };\n\t    }\n\t\n\t    this.activeDrops = {\n\t      dropzones: [], // the dropzones that are mentioned below\n\t      elements: [], // elements of dropzones that accept the target draggable\n\t      rects: [] // the rects of the elements mentioned above\n\t    };\n\t\n\t    // keep track of added pointers\n\t    this.pointers = [];\n\t    this.pointerIds = [];\n\t    this.downTargets = [];\n\t    this.downTimes = [];\n\t    this.holdTimers = [];\n\t\n\t    // Previous native pointer move event coordinates\n\t    this.prevCoords = {\n\t      page: { x: 0, y: 0 },\n\t      client: { x: 0, y: 0 },\n\t      timeStamp: 0\n\t    };\n\t    // current native pointer move event coordinates\n\t    this.curCoords = {\n\t      page: { x: 0, y: 0 },\n\t      client: { x: 0, y: 0 },\n\t      timeStamp: 0\n\t    };\n\t\n\t    // Starting InteractEvent pointer coordinates\n\t    this.startCoords = {\n\t      page: { x: 0, y: 0 },\n\t      client: { x: 0, y: 0 },\n\t      timeStamp: 0\n\t    };\n\t\n\t    // Change in coordinates and time of the pointer\n\t    this.pointerDelta = {\n\t      page: { x: 0, y: 0, vx: 0, vy: 0, speed: 0 },\n\t      client: { x: 0, y: 0, vx: 0, vy: 0, speed: 0 },\n\t      timeStamp: 0\n\t    };\n\t\n\t    this.downEvent = null; // pointerdown/mousedown/touchstart event\n\t    this.downPointer = {};\n\t\n\t    this._eventTarget = null;\n\t    this._curEventTarget = null;\n\t\n\t    this.prevEvent = null; // previous action event\n\t    this.tapTime = 0; // time of the most recent tap event\n\t    this.prevTap = null;\n\t\n\t    this.startOffset = { left: 0, right: 0, top: 0, bottom: 0 };\n\t    this.restrictOffset = { left: 0, right: 0, top: 0, bottom: 0 };\n\t    this.snapOffsets = [];\n\t\n\t    this.gesture = {\n\t      start: { x: 0, y: 0 },\n\t\n\t      startDistance: 0, // distance between two touches of touchStart\n\t      prevDistance: 0,\n\t      distance: 0,\n\t\n\t      scale: 1, // gesture.distance / gesture.startDistance\n\t\n\t      startAngle: 0, // angle of line joining two touches\n\t      prevAngle: 0 // angle of the previous gesture event\n\t    };\n\t\n\t    this.snapStatus = {\n\t      x: 0,\n\t      y: 0,\n\t      dx: 0,\n\t      dy: 0,\n\t      realX: 0,\n\t      realY: 0,\n\t      snappedX: 0,\n\t      snappedY: 0,\n\t      targets: [],\n\t      locked: false,\n\t      changed: false\n\t    };\n\t\n\t    this.restrictStatus = {\n\t      dx: 0,\n\t      dy: 0,\n\t      restrictedX: 0,\n\t      restrictedY: 0,\n\t      snap: null,\n\t      restricted: false,\n\t      changed: false\n\t    };\n\t\n\t    this.restrictStatus.snap = this.snapStatus;\n\t\n\t    this.pointerIsDown = false;\n\t    this.pointerWasMoved = false;\n\t    this.gesturing = false;\n\t    this.dragging = false;\n\t    this.resizing = false;\n\t    this.resizeAxes = 'xy';\n\t\n\t    this.mouse = false;\n\t\n\t    interactions.push(this);\n\t  }\n\t\n\t  Interaction.prototype = {\n\t    getPageXY: function getPageXY(pointer, xy) {\n\t      return _getPageXY(pointer, xy, this);\n\t    },\n\t    getClientXY: function getClientXY(pointer, xy) {\n\t      return _getClientXY(pointer, xy, this);\n\t    },\n\t    setEventXY: function setEventXY(target, ptr) {\n\t      return _setEventXY(target, ptr, this);\n\t    },\n\t\n\t    pointerOver: function pointerOver(pointer, event, eventTarget) {\n\t      if (this.prepared.name || !this.mouse) {\n\t        return;\n\t      }\n\t\n\t      var curMatches = [],\n\t          curMatchElements = [],\n\t          prevTargetElement = this.element;\n\t\n\t      this.addPointer(pointer);\n\t\n\t      if (this.target && (testIgnore(this.target, this.element, eventTarget) || !testAllow(this.target, this.element, eventTarget))) {\n\t        // if the eventTarget should be ignored or shouldn't be allowed\n\t        // clear the previous target\n\t        this.target = null;\n\t        this.element = null;\n\t        this.matches = [];\n\t        this.matchElements = [];\n\t      }\n\t\n\t      var elementInteractable = interactables.get(eventTarget),\n\t          elementAction = elementInteractable && !testIgnore(elementInteractable, eventTarget, eventTarget) && testAllow(elementInteractable, eventTarget, eventTarget) && validateAction(elementInteractable.getAction(pointer, event, this, eventTarget), elementInteractable);\n\t\n\t      if (elementAction && !withinInteractionLimit(elementInteractable, eventTarget, elementAction)) {\n\t        elementAction = null;\n\t      }\n\t\n\t      function pushCurMatches(interactable, selector) {\n\t        if (interactable && inContext(interactable, eventTarget) && !testIgnore(interactable, eventTarget, eventTarget) && testAllow(interactable, eventTarget, eventTarget) && matchesSelector(eventTarget, selector)) {\n\t          curMatches.push(interactable);\n\t          curMatchElements.push(eventTarget);\n\t        }\n\t      }\n\t\n\t      if (elementAction) {\n\t        this.target = elementInteractable;\n\t        this.element = eventTarget;\n\t        this.matches = [];\n\t        this.matchElements = [];\n\t      } else {\n\t        interactables.forEachSelector(pushCurMatches);\n\t\n\t        if (this.validateSelector(pointer, event, curMatches, curMatchElements)) {\n\t          this.matches = curMatches;\n\t          this.matchElements = curMatchElements;\n\t\n\t          this.pointerHover(pointer, event, this.matches, this.matchElements);\n\t          events.add(eventTarget, supportsPointerEvent ? pEventTypes.move : 'mousemove', listeners.pointerHover);\n\t        } else if (this.target) {\n\t          if (nodeContains(prevTargetElement, eventTarget)) {\n\t            this.pointerHover(pointer, event, this.matches, this.matchElements);\n\t            events.add(this.element, supportsPointerEvent ? pEventTypes.move : 'mousemove', listeners.pointerHover);\n\t          } else {\n\t            this.target = null;\n\t            this.element = null;\n\t            this.matches = [];\n\t            this.matchElements = [];\n\t          }\n\t        }\n\t      }\n\t    },\n\t\n\t    // Check what action would be performed on pointerMove target if a mouse\n\t    // button were pressed and change the cursor accordingly\n\t    pointerHover: function pointerHover(pointer, event, eventTarget, curEventTarget, matches, matchElements) {\n\t      var target = this.target;\n\t\n\t      if (!this.prepared.name && this.mouse) {\n\t        var action;\n\t\n\t        // update pointer coords for defaultActionChecker to use\n\t        this.setEventXY(this.curCoords, [pointer]);\n\t\n\t        if (matches) {\n\t          action = this.validateSelector(pointer, event, matches, matchElements);\n\t        } else if (target) {\n\t          action = validateAction(target.getAction(this.pointers[0], event, this, this.element), this.target);\n\t        }\n\t\n\t        if (target && target.options.styleCursor) {\n\t          if (action) {\n\t            target._doc.documentElement.style.cursor = getActionCursor(action);\n\t          } else {\n\t            target._doc.documentElement.style.cursor = '';\n\t          }\n\t        }\n\t      } else if (this.prepared.name) {\n\t        this.checkAndPreventDefault(event, target, this.element);\n\t      }\n\t    },\n\t\n\t    pointerOut: function pointerOut(pointer, event, eventTarget) {\n\t      if (this.prepared.name) {\n\t        return;\n\t      }\n\t\n\t      // Remove temporary event listeners for selector Interactables\n\t      if (!interactables.get(eventTarget)) {\n\t        events.remove(eventTarget, supportsPointerEvent ? pEventTypes.move : 'mousemove', listeners.pointerHover);\n\t      }\n\t\n\t      if (this.target && this.target.options.styleCursor && !this.interacting()) {\n\t        this.target._doc.documentElement.style.cursor = '';\n\t      }\n\t    },\n\t\n\t    selectorDown: function selectorDown(pointer, event, eventTarget, curEventTarget) {\n\t      var that = this,\n\t\n\t      // copy event to be used in timeout for IE8\n\t      eventCopy = events.useAttachEvent ? extend({}, event) : event,\n\t          element = eventTarget,\n\t          pointerIndex = this.addPointer(pointer),\n\t          action;\n\t\n\t      this.holdTimers[pointerIndex] = setTimeout(function () {\n\t        that.pointerHold(events.useAttachEvent ? eventCopy : pointer, eventCopy, eventTarget, curEventTarget);\n\t      }, defaultOptions._holdDuration);\n\t\n\t      this.pointerIsDown = true;\n\t\n\t      // Check if the down event hits the current inertia target\n\t      if (this.inertiaStatus.active && this.target.selector) {\n\t        // climb up the DOM tree from the event target\n\t        while (isElement(element)) {\n\t          // if this element is the current inertia target element\n\t          if (element === this.element &&\n\t          // and the prospective action is the same as the ongoing one\n\t          validateAction(this.target.getAction(pointer, event, this, this.element), this.target).name === this.prepared.name) {\n\t            // stop inertia so that the next move will be a normal one\n\t            cancelFrame(this.inertiaStatus.i);\n\t            this.inertiaStatus.active = false;\n\t\n\t            this.collectEventTargets(pointer, event, eventTarget, 'down');\n\t            return;\n\t          }\n\t          element = parentElement(element);\n\t        }\n\t      }\n\t\n\t      // do nothing if interacting\n\t      if (this.interacting()) {\n\t        this.collectEventTargets(pointer, event, eventTarget, 'down');\n\t        return;\n\t      }\n\t\n\t      function pushMatches(interactable, selector, context) {\n\t        var elements = ie8MatchesSelector ? context.querySelectorAll(selector) : undefined;\n\t\n\t        if (inContext(interactable, element) && !testIgnore(interactable, element, eventTarget) && testAllow(interactable, element, eventTarget) && matchesSelector(element, selector, elements)) {\n\t          that.matches.push(interactable);\n\t          that.matchElements.push(element);\n\t        }\n\t      }\n\t\n\t      // update pointer coords for defaultActionChecker to use\n\t      this.setEventXY(this.curCoords, [pointer]);\n\t      this.downEvent = event;\n\t\n\t      while (isElement(element) && !action) {\n\t        this.matches = [];\n\t        this.matchElements = [];\n\t\n\t        interactables.forEachSelector(pushMatches);\n\t\n\t        action = this.validateSelector(pointer, event, this.matches, this.matchElements);\n\t        element = parentElement(element);\n\t      }\n\t\n\t      if (action) {\n\t        this.prepared.name = action.name;\n\t        this.prepared.axis = action.axis;\n\t        this.prepared.edges = action.edges;\n\t\n\t        this.collectEventTargets(pointer, event, eventTarget, 'down');\n\t\n\t        return this.pointerDown(pointer, event, eventTarget, curEventTarget, action);\n\t      } else {\n\t        // do these now since pointerDown isn't being called from here\n\t        this.downTimes[pointerIndex] = new Date().getTime();\n\t        this.downTargets[pointerIndex] = eventTarget;\n\t        pointerExtend(this.downPointer, pointer);\n\t\n\t        copyCoords(this.prevCoords, this.curCoords);\n\t        this.pointerWasMoved = false;\n\t      }\n\t\n\t      this.collectEventTargets(pointer, event, eventTarget, 'down');\n\t    },\n\t\n\t    // Determine action to be performed on next pointerMove and add appropriate\n\t    // style and event Listeners\n\t    pointerDown: function pointerDown(pointer, event, eventTarget, curEventTarget, forceAction) {\n\t      if (!forceAction && !this.inertiaStatus.active && this.pointerWasMoved && this.prepared.name) {\n\t        this.checkAndPreventDefault(event, this.target, this.element);\n\t\n\t        return;\n\t      }\n\t\n\t      this.pointerIsDown = true;\n\t      this.downEvent = event;\n\t\n\t      var pointerIndex = this.addPointer(pointer),\n\t          action;\n\t\n\t      // If it is the second touch of a multi-touch gesture, keep the\n\t      // target the same and get a new action if a target was set by the\n\t      // first touch\n\t      if (this.pointerIds.length > 1 && this.target._element === this.element) {\n\t        var newAction = validateAction(forceAction || this.target.getAction(pointer, event, this, this.element), this.target);\n\t\n\t        if (withinInteractionLimit(this.target, this.element, newAction)) {\n\t          action = newAction;\n\t        }\n\t\n\t        this.prepared.name = null;\n\t      }\n\t      // Otherwise, set the target if there is no action prepared\n\t      else if (!this.prepared.name) {\n\t          var interactable = interactables.get(curEventTarget);\n\t\n\t          if (interactable && !testIgnore(interactable, curEventTarget, eventTarget) && testAllow(interactable, curEventTarget, eventTarget) && (action = validateAction(forceAction || interactable.getAction(pointer, event, this, curEventTarget), interactable, eventTarget)) && withinInteractionLimit(interactable, curEventTarget, action)) {\n\t            this.target = interactable;\n\t            this.element = curEventTarget;\n\t          }\n\t        }\n\t\n\t      var target = this.target,\n\t          options = target && target.options;\n\t\n\t      if (target && (forceAction || !this.prepared.name)) {\n\t        action = action || validateAction(forceAction || target.getAction(pointer, event, this, curEventTarget), target, this.element);\n\t\n\t        this.setEventXY(this.startCoords, this.pointers);\n\t\n\t        if (!action) {\n\t          return;\n\t        }\n\t\n\t        if (options.styleCursor) {\n\t          target._doc.documentElement.style.cursor = getActionCursor(action);\n\t        }\n\t\n\t        this.resizeAxes = action.name === 'resize' ? action.axis : null;\n\t\n\t        if (action === 'gesture' && this.pointerIds.length < 2) {\n\t          action = null;\n\t        }\n\t\n\t        this.prepared.name = action.name;\n\t        this.prepared.axis = action.axis;\n\t        this.prepared.edges = action.edges;\n\t\n\t        this.snapStatus.snappedX = this.snapStatus.snappedY = this.restrictStatus.restrictedX = this.restrictStatus.restrictedY = NaN;\n\t\n\t        this.downTimes[pointerIndex] = new Date().getTime();\n\t        this.downTargets[pointerIndex] = eventTarget;\n\t        pointerExtend(this.downPointer, pointer);\n\t\n\t        copyCoords(this.prevCoords, this.startCoords);\n\t        this.pointerWasMoved = false;\n\t\n\t        this.checkAndPreventDefault(event, target, this.element);\n\t      }\n\t      // if inertia is active try to resume action\n\t      else if (this.inertiaStatus.active && curEventTarget === this.element && validateAction(target.getAction(pointer, event, this, this.element), target).name === this.prepared.name) {\n\t          cancelFrame(this.inertiaStatus.i);\n\t          this.inertiaStatus.active = false;\n\t\n\t          this.checkAndPreventDefault(event, target, this.element);\n\t        }\n\t    },\n\t\n\t    setModifications: function setModifications(coords, preEnd) {\n\t      var target = this.target,\n\t          shouldMove = true,\n\t          shouldSnap = checkSnap(target, this.prepared.name) && (!target.options[this.prepared.name].snap.endOnly || preEnd),\n\t          shouldRestrict = checkRestrict(target, this.prepared.name) && (!target.options[this.prepared.name].restrict.endOnly || preEnd);\n\t\n\t      if (shouldSnap) {\n\t        this.setSnapping(coords);\n\t      } else {\n\t        this.snapStatus.locked = false;\n\t      }\n\t      if (shouldRestrict) {\n\t        this.setRestriction(coords);\n\t      } else {\n\t        this.restrictStatus.restricted = false;\n\t      }\n\t\n\t      if (shouldSnap && this.snapStatus.locked && !this.snapStatus.changed) {\n\t        shouldMove = shouldRestrict && this.restrictStatus.restricted && this.restrictStatus.changed;\n\t      } else if (shouldRestrict && this.restrictStatus.restricted && !this.restrictStatus.changed) {\n\t        shouldMove = false;\n\t      }\n\t\n\t      return shouldMove;\n\t    },\n\t\n\t    setStartOffsets: function setStartOffsets(action, interactable, element) {\n\t      var rect = interactable.getRect(element),\n\t          origin = getOriginXY(interactable, element),\n\t          snap = interactable.options[this.prepared.name].snap,\n\t          restrict = interactable.options[this.prepared.name].restrict,\n\t          width,\n\t          height;\n\t\n\t      if (rect) {\n\t        this.startOffset.left = this.startCoords.page.x - rect.left;\n\t        this.startOffset.top = this.startCoords.page.y - rect.top;\n\t\n\t        this.startOffset.right = rect.right - this.startCoords.page.x;\n\t        this.startOffset.bottom = rect.bottom - this.startCoords.page.y;\n\t\n\t        if ('width' in rect) {\n\t          width = rect.width;\n\t        } else {\n\t          width = rect.right - rect.left;\n\t        }\n\t        if ('height' in rect) {\n\t          height = rect.height;\n\t        } else {\n\t          height = rect.bottom - rect.top;\n\t        }\n\t      } else {\n\t        this.startOffset.left = this.startOffset.top = this.startOffset.right = this.startOffset.bottom = 0;\n\t      }\n\t\n\t      this.snapOffsets.splice(0);\n\t\n\t      var snapOffset = snap && snap.offset === 'startCoords' ? {\n\t        x: this.startCoords.page.x - origin.x,\n\t        y: this.startCoords.page.y - origin.y\n\t      } : snap && snap.offset || { x: 0, y: 0 };\n\t\n\t      if (rect && snap && snap.relativePoints && snap.relativePoints.length) {\n\t        for (var i = 0; i < snap.relativePoints.length; i++) {\n\t          this.snapOffsets.push({\n\t            x: this.startOffset.left - width * snap.relativePoints[i].x + snapOffset.x,\n\t            y: this.startOffset.top - height * snap.relativePoints[i].y + snapOffset.y\n\t          });\n\t        }\n\t      } else {\n\t        this.snapOffsets.push(snapOffset);\n\t      }\n\t\n\t      if (rect && restrict.elementRect) {\n\t        this.restrictOffset.left = this.startOffset.left - width * restrict.elementRect.left;\n\t        this.restrictOffset.top = this.startOffset.top - height * restrict.elementRect.top;\n\t\n\t        this.restrictOffset.right = this.startOffset.right - width * (1 - restrict.elementRect.right);\n\t        this.restrictOffset.bottom = this.startOffset.bottom - height * (1 - restrict.elementRect.bottom);\n\t      } else {\n\t        this.restrictOffset.left = this.restrictOffset.top = this.restrictOffset.right = this.restrictOffset.bottom = 0;\n\t      }\n\t    },\n\t\n\t    /*\\\n\t         * Interaction.start\n\t         [ method ]\n\t         *\n\t         * Start an action with the given Interactable and Element as tartgets. The\n\t         * action must be enabled for the target Interactable and an appropriate number\n\t         * of pointers must be held down – 1 for drag/resize, 2 for gesture.\n\t         *\n\t         * Use it with `interactable.<action>able({ manualStart: false })` to always\n\t         * [start actions manually](https://github.com/taye/interact.js/issues/114)\n\t         *\n\t         - action       (object)  The action to be performed - drag, resize, etc.\n\t         - interactable (Interactable) The Interactable to target\n\t         - element      (Element) The DOM Element to target\n\t         = (object) interact\n\t         **\n\t         | interact(target)\n\t         |   .draggable({\n\t         |     // disable the default drag start by down->move\n\t         |     manualStart: true\n\t         |   })\n\t         |   // start dragging after the user holds the pointer down\n\t         |   .on('hold', function (event) {\n\t         |     var interaction = event.interaction;\n\t         |\n\t         |     if (!interaction.interacting()) {\n\t         |       interaction.start({ name: 'drag' },\n\t         |                         event.interactable,\n\t         |                         event.currentTarget);\n\t         |     }\n\t         | });\n\t        \\*/\n\t    start: function start(action, interactable, element) {\n\t      if (this.interacting() || !this.pointerIsDown || this.pointerIds.length < (action.name === 'gesture' ? 2 : 1)) {\n\t        return;\n\t      }\n\t\n\t      // if this interaction had been removed after stopping\n\t      // add it back\n\t      if (indexOf(interactions, this) === -1) {\n\t        interactions.push(this);\n\t      }\n\t\n\t      // set the startCoords if there was no prepared action\n\t      if (!this.prepared.name) {\n\t        this.setEventXY(this.startCoords, this.pointers);\n\t      }\n\t\n\t      this.prepared.name = action.name;\n\t      this.prepared.axis = action.axis;\n\t      this.prepared.edges = action.edges;\n\t      this.target = interactable;\n\t      this.element = element;\n\t\n\t      this.setStartOffsets(action.name, interactable, element);\n\t      this.setModifications(this.startCoords.page);\n\t\n\t      this.prevEvent = this[this.prepared.name + 'Start'](this.downEvent);\n\t    },\n\t\n\t    pointerMove: function pointerMove(pointer, event, eventTarget, curEventTarget, preEnd) {\n\t      if (this.inertiaStatus.active) {\n\t        var pageUp = this.inertiaStatus.upCoords.page;\n\t        var clientUp = this.inertiaStatus.upCoords.client;\n\t\n\t        var inertiaPosition = {\n\t          pageX: pageUp.x + this.inertiaStatus.sx,\n\t          pageY: pageUp.y + this.inertiaStatus.sy,\n\t          clientX: clientUp.x + this.inertiaStatus.sx,\n\t          clientY: clientUp.y + this.inertiaStatus.sy\n\t        };\n\t\n\t        this.setEventXY(this.curCoords, [inertiaPosition]);\n\t      } else {\n\t        this.recordPointer(pointer);\n\t        this.setEventXY(this.curCoords, this.pointers);\n\t      }\n\t\n\t      var duplicateMove = this.curCoords.page.x === this.prevCoords.page.x && this.curCoords.page.y === this.prevCoords.page.y && this.curCoords.client.x === this.prevCoords.client.x && this.curCoords.client.y === this.prevCoords.client.y;\n\t\n\t      var dx,\n\t          dy,\n\t          pointerIndex = this.mouse ? 0 : indexOf(this.pointerIds, getPointerId(pointer));\n\t\n\t      // register movement greater than pointerMoveTolerance\n\t      if (this.pointerIsDown && !this.pointerWasMoved) {\n\t        dx = this.curCoords.client.x - this.startCoords.client.x;\n\t        dy = this.curCoords.client.y - this.startCoords.client.y;\n\t\n\t        this.pointerWasMoved = hypot(dx, dy) > pointerMoveTolerance;\n\t      }\n\t\n\t      if (!duplicateMove && (!this.pointerIsDown || this.pointerWasMoved)) {\n\t        if (this.pointerIsDown) {\n\t          clearTimeout(this.holdTimers[pointerIndex]);\n\t        }\n\t\n\t        this.collectEventTargets(pointer, event, eventTarget, 'move');\n\t      }\n\t\n\t      if (!this.pointerIsDown) {\n\t        return;\n\t      }\n\t\n\t      if (duplicateMove && this.pointerWasMoved && !preEnd) {\n\t        this.checkAndPreventDefault(event, this.target, this.element);\n\t        return;\n\t      }\n\t\n\t      // set pointer coordinate, time changes and speeds\n\t      setEventDeltas(this.pointerDelta, this.prevCoords, this.curCoords);\n\t\n\t      if (!this.prepared.name) {\n\t        return;\n\t      }\n\t\n\t      if (this.pointerWasMoved && (\n\t      // ignore movement while inertia is active\n\t      !this.inertiaStatus.active || pointer instanceof InteractEvent && /inertiastart/.test(pointer.type))) {\n\t        // if just starting an action, calculate the pointer speed now\n\t        if (!this.interacting()) {\n\t          setEventDeltas(this.pointerDelta, this.prevCoords, this.curCoords);\n\t\n\t          // check if a drag is in the correct axis\n\t          if (this.prepared.name === 'drag') {\n\t            var absX = Math.abs(dx),\n\t                absY = Math.abs(dy),\n\t                targetAxis = this.target.options.drag.axis,\n\t                axis = absX > absY ? 'x' : absX < absY ? 'y' : 'xy';\n\t\n\t            // if the movement isn't in the axis of the interactable\n\t            if (axis !== 'xy' && targetAxis !== 'xy' && targetAxis !== axis) {\n\t              // cancel the prepared action\n\t              this.prepared.name = null;\n\t\n\t              // then try to get a drag from another ineractable\n\t\n\t              var element = eventTarget;\n\t\n\t              // check element interactables\n\t              while (isElement(element)) {\n\t                var elementInteractable = interactables.get(element);\n\t\n\t                if (elementInteractable && elementInteractable !== this.target && !elementInteractable.options.drag.manualStart && (elementInteractable.getAction(this.downPointer, this.downEvent, this, element) || {}).name === 'drag' && checkAxis(axis, elementInteractable)) {\n\t                  this.prepared.name = 'drag';\n\t                  this.target = elementInteractable;\n\t                  this.element = element;\n\t                  break;\n\t                }\n\t\n\t                element = parentElement(element);\n\t              }\n\t\n\t              // if there's no drag from element interactables,\n\t              // check the selector interactables\n\t              if (!this.prepared.name) {\n\t                var thisInteraction = this;\n\t\n\t                var getDraggable = function getDraggable(interactable, selector, context) {\n\t                  var elements = ie8MatchesSelector ? context.querySelectorAll(selector) : undefined;\n\t\n\t                  if (interactable === thisInteraction.target) {\n\t                    return;\n\t                  }\n\t\n\t                  if (inContext(interactable, eventTarget) && !interactable.options.drag.manualStart && !testIgnore(interactable, element, eventTarget) && testAllow(interactable, element, eventTarget) && matchesSelector(element, selector, elements) && interactable.getAction(thisInteraction.downPointer, thisInteraction.downEvent, thisInteraction, element).name === 'drag' && checkAxis(axis, interactable) && withinInteractionLimit(interactable, element, 'drag')) {\n\t                    return interactable;\n\t                  }\n\t                };\n\t\n\t                element = eventTarget;\n\t\n\t                while (isElement(element)) {\n\t                  var selectorInteractable = interactables.forEachSelector(getDraggable);\n\t\n\t                  if (selectorInteractable) {\n\t                    this.prepared.name = 'drag';\n\t                    this.target = selectorInteractable;\n\t                    this.element = element;\n\t                    break;\n\t                  }\n\t\n\t                  element = parentElement(element);\n\t                }\n\t              }\n\t            }\n\t          }\n\t        }\n\t\n\t        var starting = !!this.prepared.name && !this.interacting();\n\t\n\t        if (starting && (this.target.options[this.prepared.name].manualStart || !withinInteractionLimit(this.target, this.element, this.prepared))) {\n\t          this.stop(event);\n\t          return;\n\t        }\n\t\n\t        if (this.prepared.name && this.target) {\n\t          if (starting) {\n\t            this.start(this.prepared, this.target, this.element);\n\t          }\n\t\n\t          var shouldMove = this.setModifications(this.curCoords.page, preEnd);\n\t\n\t          // move if snapping or restriction doesn't prevent it\n\t          if (shouldMove || starting) {\n\t            this.prevEvent = this[this.prepared.name + 'Move'](event);\n\t          }\n\t\n\t          this.checkAndPreventDefault(event, this.target, this.element);\n\t        }\n\t      }\n\t\n\t      copyCoords(this.prevCoords, this.curCoords);\n\t\n\t      if (this.dragging || this.resizing) {\n\t        this.autoScrollMove(pointer);\n\t      }\n\t    },\n\t\n\t    dragStart: function dragStart(event) {\n\t      var dragEvent = new InteractEvent(this, event, 'drag', 'start', this.element);\n\t\n\t      dragEvent.originalEvent = event;\n\t      this.dragging = true;\n\t      this.target.fire(dragEvent);\n\t\n\t      // reset active dropzones\n\t      this.activeDrops.dropzones = [];\n\t      this.activeDrops.elements = [];\n\t      this.activeDrops.rects = [];\n\t\n\t      if (!this.dynamicDrop) {\n\t        this.setActiveDrops(this.element);\n\t      }\n\t\n\t      var dropEvents = this.getDropEvents(event, dragEvent);\n\t\n\t      if (dropEvents.activate) {\n\t        this.fireActiveDrops(dropEvents.activate);\n\t      }\n\t\n\t      return dragEvent;\n\t    },\n\t\n\t    dragMove: function dragMove(event) {\n\t      var target = this.target,\n\t          dragEvent = new InteractEvent(this, event, 'drag', 'move', this.element),\n\t          draggableElement = this.element,\n\t          drop = this.getDrop(dragEvent, event, draggableElement);\n\t\n\t      dragEvent.originalEvent = event;\n\t\n\t      this.dropTarget = drop.dropzone;\n\t      this.dropElement = drop.element;\n\t\n\t      var dropEvents = this.getDropEvents(event, dragEvent);\n\t\n\t      target.fire(dragEvent);\n\t\n\t      if (dropEvents.leave) {\n\t        this.prevDropTarget.fire(dropEvents.leave);\n\t      }\n\t      if (dropEvents.enter) {\n\t        this.dropTarget.fire(dropEvents.enter);\n\t      }\n\t      if (dropEvents.move) {\n\t        this.dropTarget.fire(dropEvents.move);\n\t      }\n\t\n\t      this.prevDropTarget = this.dropTarget;\n\t      this.prevDropElement = this.dropElement;\n\t\n\t      return dragEvent;\n\t    },\n\t\n\t    resizeStart: function resizeStart(event) {\n\t      var resizeEvent = new InteractEvent(this, event, 'resize', 'start', this.element);\n\t\n\t      if (this.prepared.edges) {\n\t        var startRect = this.target.getRect(this.element);\n\t\n\t        /*\n\t         * When using the `resizable.square` or `resizable.preserveAspectRatio` options, resizing from one edge\n\t         * will affect another. E.g. with `resizable.square`, resizing to make the right edge larger will make\n\t         * the bottom edge larger by the same amount. We call these 'linked' edges. Any linked edges will depend\n\t         * on the active edges and the edge being interacted with.\n\t         */\n\t        if (this.target.options.resize.square || this.target.options.resize.preserveAspectRatio) {\n\t          var linkedEdges = extend({}, this.prepared.edges);\n\t\n\t          linkedEdges.top = linkedEdges.top || linkedEdges.left && !linkedEdges.bottom;\n\t          linkedEdges.left = linkedEdges.left || linkedEdges.top && !linkedEdges.right;\n\t          linkedEdges.bottom = linkedEdges.bottom || linkedEdges.right && !linkedEdges.top;\n\t          linkedEdges.right = linkedEdges.right || linkedEdges.bottom && !linkedEdges.left;\n\t\n\t          this.prepared._linkedEdges = linkedEdges;\n\t        } else {\n\t          this.prepared._linkedEdges = null;\n\t        }\n\t\n\t        // if using `resizable.preserveAspectRatio` option, record aspect ratio at the start of the resize\n\t        if (this.target.options.resize.preserveAspectRatio) {\n\t          this.resizeStartAspectRatio = startRect.width / startRect.height;\n\t        }\n\t\n\t        this.resizeRects = {\n\t          start: startRect,\n\t          current: extend({}, startRect),\n\t          restricted: extend({}, startRect),\n\t          previous: extend({}, startRect),\n\t          delta: {\n\t            left: 0,\n\t            right: 0,\n\t            width: 0,\n\t            top: 0,\n\t            bottom: 0,\n\t            height: 0\n\t          }\n\t        };\n\t\n\t        resizeEvent.rect = this.resizeRects.restricted;\n\t        resizeEvent.deltaRect = this.resizeRects.delta;\n\t      }\n\t\n\t      this.target.fire(resizeEvent);\n\t\n\t      this.resizing = true;\n\t\n\t      return resizeEvent;\n\t    },\n\t\n\t    resizeMove: function resizeMove(event) {\n\t      var resizeEvent = new InteractEvent(this, event, 'resize', 'move', this.element);\n\t\n\t      var edges = this.prepared.edges,\n\t          invert = this.target.options.resize.invert,\n\t          invertible = invert === 'reposition' || invert === 'negate';\n\t\n\t      if (edges) {\n\t        var dx = resizeEvent.dx,\n\t            dy = resizeEvent.dy,\n\t            start = this.resizeRects.start,\n\t            current = this.resizeRects.current,\n\t            restricted = this.resizeRects.restricted,\n\t            delta = this.resizeRects.delta,\n\t            previous = extend(this.resizeRects.previous, restricted),\n\t            originalEdges = edges;\n\t\n\t        // `resize.preserveAspectRatio` takes precedence over `resize.square`\n\t        if (this.target.options.resize.preserveAspectRatio) {\n\t          var resizeStartAspectRatio = this.resizeStartAspectRatio;\n\t\n\t          edges = this.prepared._linkedEdges;\n\t\n\t          if (originalEdges.left && originalEdges.bottom || originalEdges.right && originalEdges.top) {\n\t            dy = -dx / resizeStartAspectRatio;\n\t          } else if (originalEdges.left || originalEdges.right) {\n\t            dy = dx / resizeStartAspectRatio;\n\t          } else if (originalEdges.top || originalEdges.bottom) {\n\t            dx = dy * resizeStartAspectRatio;\n\t          }\n\t        } else if (this.target.options.resize.square) {\n\t          edges = this.prepared._linkedEdges;\n\t\n\t          if (originalEdges.left && originalEdges.bottom || originalEdges.right && originalEdges.top) {\n\t            dy = -dx;\n\t          } else if (originalEdges.left || originalEdges.right) {\n\t            dy = dx;\n\t          } else if (originalEdges.top || originalEdges.bottom) {\n\t            dx = dy;\n\t          }\n\t        }\n\t\n\t        // update the 'current' rect without modifications\n\t        if (edges.top) {\n\t          current.top += dy;\n\t        }\n\t        if (edges.bottom) {\n\t          current.bottom += dy;\n\t        }\n\t        if (edges.left) {\n\t          current.left += dx;\n\t        }\n\t        if (edges.right) {\n\t          current.right += dx;\n\t        }\n\t\n\t        if (invertible) {\n\t          // if invertible, copy the current rect\n\t          extend(restricted, current);\n\t\n\t          if (invert === 'reposition') {\n\t            // swap edge values if necessary to keep width/height positive\n\t            var swap;\n\t\n\t            if (restricted.top > restricted.bottom) {\n\t              swap = restricted.top;\n\t\n\t              restricted.top = restricted.bottom;\n\t              restricted.bottom = swap;\n\t            }\n\t            if (restricted.left > restricted.right) {\n\t              swap = restricted.left;\n\t\n\t              restricted.left = restricted.right;\n\t              restricted.right = swap;\n\t            }\n\t          }\n\t        } else {\n\t          // if not invertible, restrict to minimum of 0x0 rect\n\t          restricted.top = Math.min(current.top, start.bottom);\n\t          restricted.bottom = Math.max(current.bottom, start.top);\n\t          restricted.left = Math.min(current.left, start.right);\n\t          restricted.right = Math.max(current.right, start.left);\n\t        }\n\t\n\t        restricted.width = restricted.right - restricted.left;\n\t        restricted.height = restricted.bottom - restricted.top;\n\t\n\t        for (var edge in restricted) {\n\t          delta[edge] = restricted[edge] - previous[edge];\n\t        }\n\t\n\t        resizeEvent.edges = this.prepared.edges;\n\t        resizeEvent.rect = restricted;\n\t        resizeEvent.deltaRect = delta;\n\t      }\n\t\n\t      this.target.fire(resizeEvent);\n\t\n\t      return resizeEvent;\n\t    },\n\t\n\t    gestureStart: function gestureStart(event) {\n\t      var gestureEvent = new InteractEvent(this, event, 'gesture', 'start', this.element);\n\t\n\t      gestureEvent.ds = 0;\n\t\n\t      this.gesture.startDistance = this.gesture.prevDistance = gestureEvent.distance;\n\t      this.gesture.startAngle = this.gesture.prevAngle = gestureEvent.angle;\n\t      this.gesture.scale = 1;\n\t\n\t      this.gesturing = true;\n\t\n\t      this.target.fire(gestureEvent);\n\t\n\t      return gestureEvent;\n\t    },\n\t\n\t    gestureMove: function gestureMove(event) {\n\t      if (!this.pointerIds.length) {\n\t        return this.prevEvent;\n\t      }\n\t\n\t      var gestureEvent;\n\t\n\t      gestureEvent = new InteractEvent(this, event, 'gesture', 'move', this.element);\n\t      gestureEvent.ds = gestureEvent.scale - this.gesture.scale;\n\t\n\t      this.target.fire(gestureEvent);\n\t\n\t      this.gesture.prevAngle = gestureEvent.angle;\n\t      this.gesture.prevDistance = gestureEvent.distance;\n\t\n\t      if (gestureEvent.scale !== Infinity && gestureEvent.scale !== null && gestureEvent.scale !== undefined && !isNaN(gestureEvent.scale)) {\n\t        this.gesture.scale = gestureEvent.scale;\n\t      }\n\t\n\t      return gestureEvent;\n\t    },\n\t\n\t    pointerHold: function pointerHold(pointer, event, eventTarget) {\n\t      this.collectEventTargets(pointer, event, eventTarget, 'hold');\n\t    },\n\t\n\t    pointerUp: function pointerUp(pointer, event, eventTarget, curEventTarget) {\n\t      var pointerIndex = this.mouse ? 0 : indexOf(this.pointerIds, getPointerId(pointer));\n\t\n\t      clearTimeout(this.holdTimers[pointerIndex]);\n\t\n\t      this.collectEventTargets(pointer, event, eventTarget, 'up');\n\t      this.collectEventTargets(pointer, event, eventTarget, 'tap');\n\t\n\t      this.pointerEnd(pointer, event, eventTarget, curEventTarget);\n\t\n\t      this.removePointer(pointer);\n\t    },\n\t\n\t    pointerCancel: function pointerCancel(pointer, event, eventTarget, curEventTarget) {\n\t      var pointerIndex = this.mouse ? 0 : indexOf(this.pointerIds, getPointerId(pointer));\n\t\n\t      clearTimeout(this.holdTimers[pointerIndex]);\n\t\n\t      this.collectEventTargets(pointer, event, eventTarget, 'cancel');\n\t      this.pointerEnd(pointer, event, eventTarget, curEventTarget);\n\t\n\t      this.removePointer(pointer);\n\t    },\n\t\n\t    // http://www.quirksmode.org/dom/events/click.html\n\t    // >Events leading to dblclick\n\t    //\n\t    // IE8 doesn't fire down event before dblclick.\n\t    // This workaround tries to fire a tap and doubletap after dblclick\n\t    ie8Dblclick: function ie8Dblclick(pointer, event, eventTarget) {\n\t      if (this.prevTap && event.clientX === this.prevTap.clientX && event.clientY === this.prevTap.clientY && eventTarget === this.prevTap.target) {\n\t        this.downTargets[0] = eventTarget;\n\t        this.downTimes[0] = new Date().getTime();\n\t        this.collectEventTargets(pointer, event, eventTarget, 'tap');\n\t      }\n\t    },\n\t\n\t    // End interact move events and stop auto-scroll unless inertia is enabled\n\t    pointerEnd: function pointerEnd(pointer, event, eventTarget, curEventTarget) {\n\t      var endEvent,\n\t          target = this.target,\n\t          options = target && target.options,\n\t          inertiaOptions = options && this.prepared.name && options[this.prepared.name].inertia,\n\t          inertiaStatus = this.inertiaStatus;\n\t\n\t      if (this.interacting()) {\n\t        if (inertiaStatus.active && !inertiaStatus.ending) {\n\t          return;\n\t        }\n\t\n\t        var pointerSpeed,\n\t            now = new Date().getTime(),\n\t            inertiaPossible = false,\n\t            inertia = false,\n\t            smoothEnd = false,\n\t            endSnap = checkSnap(target, this.prepared.name) && options[this.prepared.name].snap.endOnly,\n\t            endRestrict = checkRestrict(target, this.prepared.name) && options[this.prepared.name].restrict.endOnly,\n\t            dx = 0,\n\t            dy = 0,\n\t            startEvent;\n\t\n\t        if (this.dragging) {\n\t          if (options.drag.axis === 'x') {\n\t            pointerSpeed = Math.abs(this.pointerDelta.client.vx);\n\t          } else if (options.drag.axis === 'y') {\n\t            pointerSpeed = Math.abs(this.pointerDelta.client.vy);\n\t          } /*options.drag.axis === 'xy'*/else {\n\t              pointerSpeed = this.pointerDelta.client.speed;\n\t            }\n\t        } else {\n\t          pointerSpeed = this.pointerDelta.client.speed;\n\t        }\n\t\n\t        // check if inertia should be started\n\t        inertiaPossible = inertiaOptions && inertiaOptions.enabled && this.prepared.name !== 'gesture' && event !== inertiaStatus.startEvent;\n\t\n\t        inertia = inertiaPossible && now - this.curCoords.timeStamp < 50 && pointerSpeed > inertiaOptions.minSpeed && pointerSpeed > inertiaOptions.endSpeed;\n\t\n\t        if (inertiaPossible && !inertia && (endSnap || endRestrict)) {\n\t          var snapRestrict = {};\n\t\n\t          snapRestrict.snap = snapRestrict.restrict = snapRestrict;\n\t\n\t          if (endSnap) {\n\t            this.setSnapping(this.curCoords.page, snapRestrict);\n\t            if (snapRestrict.locked) {\n\t              dx += snapRestrict.dx;\n\t              dy += snapRestrict.dy;\n\t            }\n\t          }\n\t\n\t          if (endRestrict) {\n\t            this.setRestriction(this.curCoords.page, snapRestrict);\n\t            if (snapRestrict.restricted) {\n\t              dx += snapRestrict.dx;\n\t              dy += snapRestrict.dy;\n\t            }\n\t          }\n\t\n\t          if (dx || dy) {\n\t            smoothEnd = true;\n\t          }\n\t        }\n\t\n\t        if (inertia || smoothEnd) {\n\t          copyCoords(inertiaStatus.upCoords, this.curCoords);\n\t\n\t          this.pointers[0] = inertiaStatus.startEvent = startEvent = new InteractEvent(this, event, this.prepared.name, 'inertiastart', this.element);\n\t\n\t          inertiaStatus.t0 = now;\n\t\n\t          target.fire(inertiaStatus.startEvent);\n\t\n\t          if (inertia) {\n\t            inertiaStatus.vx0 = this.pointerDelta.client.vx;\n\t            inertiaStatus.vy0 = this.pointerDelta.client.vy;\n\t            inertiaStatus.v0 = pointerSpeed;\n\t\n\t            this.calcInertia(inertiaStatus);\n\t\n\t            var page = extend({}, this.curCoords.page),\n\t                origin = getOriginXY(target, this.element),\n\t                statusObject;\n\t\n\t            page.x = page.x + inertiaStatus.xe - origin.x;\n\t            page.y = page.y + inertiaStatus.ye - origin.y;\n\t\n\t            statusObject = {\n\t              useStatusXY: true,\n\t              x: page.x,\n\t              y: page.y,\n\t              dx: 0,\n\t              dy: 0,\n\t              snap: null\n\t            };\n\t\n\t            statusObject.snap = statusObject;\n\t\n\t            dx = dy = 0;\n\t\n\t            if (endSnap) {\n\t              var snap = this.setSnapping(this.curCoords.page, statusObject);\n\t\n\t              if (snap.locked) {\n\t                dx += snap.dx;\n\t                dy += snap.dy;\n\t              }\n\t            }\n\t\n\t            if (endRestrict) {\n\t              var restrict = this.setRestriction(this.curCoords.page, statusObject);\n\t\n\t              if (restrict.restricted) {\n\t                dx += restrict.dx;\n\t                dy += restrict.dy;\n\t              }\n\t            }\n\t\n\t            inertiaStatus.modifiedXe += dx;\n\t            inertiaStatus.modifiedYe += dy;\n\t\n\t            inertiaStatus.i = reqFrame(this.boundInertiaFrame);\n\t          } else {\n\t            inertiaStatus.smoothEnd = true;\n\t            inertiaStatus.xe = dx;\n\t            inertiaStatus.ye = dy;\n\t\n\t            inertiaStatus.sx = inertiaStatus.sy = 0;\n\t\n\t            inertiaStatus.i = reqFrame(this.boundSmoothEndFrame);\n\t          }\n\t\n\t          inertiaStatus.active = true;\n\t          return;\n\t        }\n\t\n\t        if (endSnap || endRestrict) {\n\t          // fire a move event at the snapped coordinates\n\t          this.pointerMove(pointer, event, eventTarget, curEventTarget, true);\n\t        }\n\t      }\n\t\n\t      if (this.dragging) {\n\t        endEvent = new InteractEvent(this, event, 'drag', 'end', this.element);\n\t\n\t        var draggableElement = this.element,\n\t            drop = this.getDrop(endEvent, event, draggableElement);\n\t\n\t        this.dropTarget = drop.dropzone;\n\t        this.dropElement = drop.element;\n\t\n\t        var dropEvents = this.getDropEvents(event, endEvent);\n\t\n\t        if (dropEvents.leave) {\n\t          this.prevDropTarget.fire(dropEvents.leave);\n\t        }\n\t        if (dropEvents.enter) {\n\t          this.dropTarget.fire(dropEvents.enter);\n\t        }\n\t        if (dropEvents.drop) {\n\t          this.dropTarget.fire(dropEvents.drop);\n\t        }\n\t        if (dropEvents.deactivate) {\n\t          this.fireActiveDrops(dropEvents.deactivate);\n\t        }\n\t\n\t        target.fire(endEvent);\n\t      } else if (this.resizing) {\n\t        endEvent = new InteractEvent(this, event, 'resize', 'end', this.element);\n\t        target.fire(endEvent);\n\t      } else if (this.gesturing) {\n\t        endEvent = new InteractEvent(this, event, 'gesture', 'end', this.element);\n\t        target.fire(endEvent);\n\t      }\n\t\n\t      this.stop(event);\n\t    },\n\t\n\t    collectDrops: function collectDrops(element) {\n\t      var drops = [],\n\t          elements = [],\n\t          i;\n\t\n\t      element = element || this.element;\n\t\n\t      // collect all dropzones and their elements which qualify for a drop\n\t      for (i = 0; i < interactables.length; i++) {\n\t        if (!interactables[i].options.drop.enabled) {\n\t          continue;\n\t        }\n\t\n\t        var current = interactables[i],\n\t            accept = current.options.drop.accept;\n\t\n\t        // test the draggable element against the dropzone's accept setting\n\t        if (isElement(accept) && accept !== element || isString(accept) && !matchesSelector(element, accept)) {\n\t          continue;\n\t        }\n\t\n\t        // query for new elements if necessary\n\t        var dropElements = current.selector ? current._context.querySelectorAll(current.selector) : [current._element];\n\t\n\t        for (var j = 0, len = dropElements.length; j < len; j++) {\n\t          var currentElement = dropElements[j];\n\t\n\t          if (currentElement === element) {\n\t            continue;\n\t          }\n\t\n\t          drops.push(current);\n\t          elements.push(currentElement);\n\t        }\n\t      }\n\t\n\t      return {\n\t        dropzones: drops,\n\t        elements: elements\n\t      };\n\t    },\n\t\n\t    fireActiveDrops: function fireActiveDrops(event) {\n\t      var i, current, currentElement, prevElement;\n\t\n\t      // loop through all active dropzones and trigger event\n\t      for (i = 0; i < this.activeDrops.dropzones.length; i++) {\n\t        current = this.activeDrops.dropzones[i];\n\t        currentElement = this.activeDrops.elements[i];\n\t\n\t        // prevent trigger of duplicate events on same element\n\t        if (currentElement !== prevElement) {\n\t          // set current element as event target\n\t          event.target = currentElement;\n\t          current.fire(event);\n\t        }\n\t        prevElement = currentElement;\n\t      }\n\t    },\n\t\n\t    // Collect a new set of possible drops and save them in activeDrops.\n\t    // setActiveDrops should always be called when a drag has just started or a\n\t    // drag event happens while dynamicDrop is true\n\t    setActiveDrops: function setActiveDrops(dragElement) {\n\t      // get dropzones and their elements that could receive the draggable\n\t      var possibleDrops = this.collectDrops(dragElement, true);\n\t\n\t      this.activeDrops.dropzones = possibleDrops.dropzones;\n\t      this.activeDrops.elements = possibleDrops.elements;\n\t      this.activeDrops.rects = [];\n\t\n\t      for (var i = 0; i < this.activeDrops.dropzones.length; i++) {\n\t        this.activeDrops.rects[i] = this.activeDrops.dropzones[i].getRect(this.activeDrops.elements[i]);\n\t      }\n\t    },\n\t\n\t    getDrop: function getDrop(dragEvent, event, dragElement) {\n\t      var validDrops = [];\n\t\n\t      if (dynamicDrop) {\n\t        this.setActiveDrops(dragElement);\n\t      }\n\t\n\t      // collect all dropzones and their elements which qualify for a drop\n\t      for (var j = 0; j < this.activeDrops.dropzones.length; j++) {\n\t        var current = this.activeDrops.dropzones[j],\n\t            currentElement = this.activeDrops.elements[j],\n\t            rect = this.activeDrops.rects[j];\n\t\n\t        validDrops.push(current.dropCheck(dragEvent, event, this.target, dragElement, currentElement, rect) ? currentElement : null);\n\t      }\n\t\n\t      // get the most appropriate dropzone based on DOM depth and order\n\t      var dropIndex = indexOfDeepestElement(validDrops),\n\t          dropzone = this.activeDrops.dropzones[dropIndex] || null,\n\t          element = this.activeDrops.elements[dropIndex] || null;\n\t\n\t      return {\n\t        dropzone: dropzone,\n\t        element: element\n\t      };\n\t    },\n\t\n\t    getDropEvents: function getDropEvents(pointerEvent, dragEvent) {\n\t      var dropEvents = {\n\t        enter: null,\n\t        leave: null,\n\t        activate: null,\n\t        deactivate: null,\n\t        move: null,\n\t        drop: null\n\t      };\n\t\n\t      if (this.dropElement !== this.prevDropElement) {\n\t        // if there was a prevDropTarget, create a dragleave event\n\t        if (this.prevDropTarget) {\n\t          dropEvents.leave = {\n\t            target: this.prevDropElement,\n\t            dropzone: this.prevDropTarget,\n\t            relatedTarget: dragEvent.target,\n\t            draggable: dragEvent.interactable,\n\t            dragEvent: dragEvent,\n\t            interaction: this,\n\t            timeStamp: dragEvent.timeStamp,\n\t            type: 'dragleave'\n\t          };\n\t\n\t          dragEvent.dragLeave = this.prevDropElement;\n\t          dragEvent.prevDropzone = this.prevDropTarget;\n\t        }\n\t        // if the dropTarget is not null, create a dragenter event\n\t        if (this.dropTarget) {\n\t          dropEvents.enter = {\n\t            target: this.dropElement,\n\t            dropzone: this.dropTarget,\n\t            relatedTarget: dragEvent.target,\n\t            draggable: dragEvent.interactable,\n\t            dragEvent: dragEvent,\n\t            interaction: this,\n\t            timeStamp: dragEvent.timeStamp,\n\t            type: 'dragenter'\n\t          };\n\t\n\t          dragEvent.dragEnter = this.dropElement;\n\t          dragEvent.dropzone = this.dropTarget;\n\t        }\n\t      }\n\t\n\t      if (dragEvent.type === 'dragend' && this.dropTarget) {\n\t        dropEvents.drop = {\n\t          target: this.dropElement,\n\t          dropzone: this.dropTarget,\n\t          relatedTarget: dragEvent.target,\n\t          draggable: dragEvent.interactable,\n\t          dragEvent: dragEvent,\n\t          interaction: this,\n\t          timeStamp: dragEvent.timeStamp,\n\t          type: 'drop'\n\t        };\n\t\n\t        dragEvent.dropzone = this.dropTarget;\n\t      }\n\t      if (dragEvent.type === 'dragstart') {\n\t        dropEvents.activate = {\n\t          target: null,\n\t          dropzone: null,\n\t          relatedTarget: dragEvent.target,\n\t          draggable: dragEvent.interactable,\n\t          dragEvent: dragEvent,\n\t          interaction: this,\n\t          timeStamp: dragEvent.timeStamp,\n\t          type: 'dropactivate'\n\t        };\n\t      }\n\t      if (dragEvent.type === 'dragend') {\n\t        dropEvents.deactivate = {\n\t          target: null,\n\t          dropzone: null,\n\t          relatedTarget: dragEvent.target,\n\t          draggable: dragEvent.interactable,\n\t          dragEvent: dragEvent,\n\t          interaction: this,\n\t          timeStamp: dragEvent.timeStamp,\n\t          type: 'dropdeactivate'\n\t        };\n\t      }\n\t      if (dragEvent.type === 'dragmove' && this.dropTarget) {\n\t        dropEvents.move = {\n\t          target: this.dropElement,\n\t          dropzone: this.dropTarget,\n\t          relatedTarget: dragEvent.target,\n\t          draggable: dragEvent.interactable,\n\t          dragEvent: dragEvent,\n\t          interaction: this,\n\t          dragmove: dragEvent,\n\t          timeStamp: dragEvent.timeStamp,\n\t          type: 'dropmove'\n\t        };\n\t        dragEvent.dropzone = this.dropTarget;\n\t      }\n\t\n\t      return dropEvents;\n\t    },\n\t\n\t    currentAction: function currentAction() {\n\t      return this.dragging && 'drag' || this.resizing && 'resize' || this.gesturing && 'gesture' || null;\n\t    },\n\t\n\t    interacting: function interacting() {\n\t      return this.dragging || this.resizing || this.gesturing;\n\t    },\n\t\n\t    clearTargets: function clearTargets() {\n\t      this.target = this.element = null;\n\t\n\t      this.dropTarget = this.dropElement = this.prevDropTarget = this.prevDropElement = null;\n\t    },\n\t\n\t    stop: function stop(event) {\n\t      if (this.interacting()) {\n\t        autoScroll.stop();\n\t        this.matches = [];\n\t        this.matchElements = [];\n\t\n\t        var target = this.target;\n\t\n\t        if (target.options.styleCursor) {\n\t          target._doc.documentElement.style.cursor = '';\n\t        }\n\t\n\t        // prevent Default only if were previously interacting\n\t        if (event && isFunction(event.preventDefault)) {\n\t          this.checkAndPreventDefault(event, target, this.element);\n\t        }\n\t\n\t        if (this.dragging) {\n\t          this.activeDrops.dropzones = this.activeDrops.elements = this.activeDrops.rects = null;\n\t        }\n\t      }\n\t\n\t      this.clearTargets();\n\t\n\t      this.pointerIsDown = this.snapStatus.locked = this.dragging = this.resizing = this.gesturing = false;\n\t      this.prepared.name = this.prevEvent = null;\n\t      this.inertiaStatus.resumeDx = this.inertiaStatus.resumeDy = 0;\n\t\n\t      // remove pointers if their ID isn't in this.pointerIds\n\t      for (var i = 0; i < this.pointers.length; i++) {\n\t        if (indexOf(this.pointerIds, getPointerId(this.pointers[i])) === -1) {\n\t          this.pointers.splice(i, 1);\n\t        }\n\t      }\n\t    },\n\t\n\t    inertiaFrame: function inertiaFrame() {\n\t      var inertiaStatus = this.inertiaStatus,\n\t          options = this.target.options[this.prepared.name].inertia,\n\t          lambda = options.resistance,\n\t          t = new Date().getTime() / 1000 - inertiaStatus.t0;\n\t\n\t      if (t < inertiaStatus.te) {\n\t        var progress = 1 - (Math.exp(-lambda * t) - inertiaStatus.lambda_v0) / inertiaStatus.one_ve_v0;\n\t\n\t        if (inertiaStatus.modifiedXe === inertiaStatus.xe && inertiaStatus.modifiedYe === inertiaStatus.ye) {\n\t          inertiaStatus.sx = inertiaStatus.xe * progress;\n\t          inertiaStatus.sy = inertiaStatus.ye * progress;\n\t        } else {\n\t          var quadPoint = getQuadraticCurvePoint(0, 0, inertiaStatus.xe, inertiaStatus.ye, inertiaStatus.modifiedXe, inertiaStatus.modifiedYe, progress);\n\t\n\t          inertiaStatus.sx = quadPoint.x;\n\t          inertiaStatus.sy = quadPoint.y;\n\t        }\n\t\n\t        this.pointerMove(inertiaStatus.startEvent, inertiaStatus.startEvent);\n\t\n\t        inertiaStatus.i = reqFrame(this.boundInertiaFrame);\n\t      } else {\n\t        inertiaStatus.ending = true;\n\t\n\t        inertiaStatus.sx = inertiaStatus.modifiedXe;\n\t        inertiaStatus.sy = inertiaStatus.modifiedYe;\n\t\n\t        this.pointerMove(inertiaStatus.startEvent, inertiaStatus.startEvent);\n\t        this.pointerEnd(inertiaStatus.startEvent, inertiaStatus.startEvent);\n\t\n\t        inertiaStatus.active = inertiaStatus.ending = false;\n\t      }\n\t    },\n\t\n\t    smoothEndFrame: function smoothEndFrame() {\n\t      var inertiaStatus = this.inertiaStatus,\n\t          t = new Date().getTime() - inertiaStatus.t0,\n\t          duration = this.target.options[this.prepared.name].inertia.smoothEndDuration;\n\t\n\t      if (t < duration) {\n\t        inertiaStatus.sx = easeOutQuad(t, 0, inertiaStatus.xe, duration);\n\t        inertiaStatus.sy = easeOutQuad(t, 0, inertiaStatus.ye, duration);\n\t\n\t        this.pointerMove(inertiaStatus.startEvent, inertiaStatus.startEvent);\n\t\n\t        inertiaStatus.i = reqFrame(this.boundSmoothEndFrame);\n\t      } else {\n\t        inertiaStatus.ending = true;\n\t\n\t        inertiaStatus.sx = inertiaStatus.xe;\n\t        inertiaStatus.sy = inertiaStatus.ye;\n\t\n\t        this.pointerMove(inertiaStatus.startEvent, inertiaStatus.startEvent);\n\t        this.pointerEnd(inertiaStatus.startEvent, inertiaStatus.startEvent);\n\t\n\t        inertiaStatus.smoothEnd = inertiaStatus.active = inertiaStatus.ending = false;\n\t      }\n\t    },\n\t\n\t    addPointer: function addPointer(pointer) {\n\t      var id = getPointerId(pointer),\n\t          index = this.mouse ? 0 : indexOf(this.pointerIds, id);\n\t\n\t      if (index === -1) {\n\t        index = this.pointerIds.length;\n\t      }\n\t\n\t      this.pointerIds[index] = id;\n\t      this.pointers[index] = pointer;\n\t\n\t      return index;\n\t    },\n\t\n\t    removePointer: function removePointer(pointer) {\n\t      var id = getPointerId(pointer),\n\t          index = this.mouse ? 0 : indexOf(this.pointerIds, id);\n\t\n\t      if (index === -1) {\n\t        return;\n\t      }\n\t\n\t      this.pointers.splice(index, 1);\n\t      this.pointerIds.splice(index, 1);\n\t      this.downTargets.splice(index, 1);\n\t      this.downTimes.splice(index, 1);\n\t      this.holdTimers.splice(index, 1);\n\t    },\n\t\n\t    recordPointer: function recordPointer(pointer) {\n\t      var index = this.mouse ? 0 : indexOf(this.pointerIds, getPointerId(pointer));\n\t\n\t      if (index === -1) {\n\t        return;\n\t      }\n\t\n\t      this.pointers[index] = pointer;\n\t    },\n\t\n\t    collectEventTargets: function collectEventTargets(pointer, event, eventTarget, eventType) {\n\t      var pointerIndex = this.mouse ? 0 : indexOf(this.pointerIds, getPointerId(pointer));\n\t\n\t      // do not fire a tap event if the pointer was moved before being lifted\n\t      if (eventType === 'tap' && (this.pointerWasMoved ||\n\t      // or if the pointerup target is different to the pointerdown target\n\t      !(this.downTargets[pointerIndex] && this.downTargets[pointerIndex] === eventTarget))) {\n\t        return;\n\t      }\n\t\n\t      var targets = [],\n\t          elements = [],\n\t          element = eventTarget;\n\t\n\t      function collectSelectors(interactable, selector, context) {\n\t        var els = ie8MatchesSelector ? context.querySelectorAll(selector) : undefined;\n\t\n\t        if (interactable._iEvents[eventType] && isElement(element) && inContext(interactable, element) && !testIgnore(interactable, element, eventTarget) && testAllow(interactable, element, eventTarget) && matchesSelector(element, selector, els)) {\n\t          targets.push(interactable);\n\t          elements.push(element);\n\t        }\n\t      }\n\t\n\t      while (element) {\n\t        if (interact.isSet(element) && interact(element)._iEvents[eventType]) {\n\t          targets.push(interact(element));\n\t          elements.push(element);\n\t        }\n\t\n\t        interactables.forEachSelector(collectSelectors);\n\t\n\t        element = parentElement(element);\n\t      }\n\t\n\t      // create the tap event even if there are no listeners so that\n\t      // doubletap can still be created and fired\n\t      if (targets.length || eventType === 'tap') {\n\t        this.firePointers(pointer, event, eventTarget, targets, elements, eventType);\n\t      }\n\t    },\n\t\n\t    firePointers: function firePointers(pointer, event, eventTarget, targets, elements, eventType) {\n\t      var pointerIndex = this.mouse ? 0 : indexOf(this.pointerIds, getPointerId(pointer)),\n\t          pointerEvent = {},\n\t          i,\n\t\n\t      // for tap events\n\t      interval,\n\t          createNewDoubleTap;\n\t\n\t      // if it's a doubletap then the event properties would have been\n\t      // copied from the tap event and provided as the pointer argument\n\t      if (eventType === 'doubletap') {\n\t        pointerEvent = pointer;\n\t      } else {\n\t        pointerExtend(pointerEvent, event);\n\t        if (event !== pointer) {\n\t          pointerExtend(pointerEvent, pointer);\n\t        }\n\t\n\t        pointerEvent.preventDefault = preventOriginalDefault;\n\t        pointerEvent.stopPropagation = InteractEvent.prototype.stopPropagation;\n\t        pointerEvent.stopImmediatePropagation = InteractEvent.prototype.stopImmediatePropagation;\n\t        pointerEvent.interaction = this;\n\t\n\t        pointerEvent.timeStamp = new Date().getTime();\n\t        pointerEvent.originalEvent = event;\n\t        pointerEvent.originalPointer = pointer;\n\t        pointerEvent.type = eventType;\n\t        pointerEvent.pointerId = getPointerId(pointer);\n\t        pointerEvent.pointerType = this.mouse ? 'mouse' : !supportsPointerEvent ? 'touch' : isString(pointer.pointerType) ? pointer.pointerType : [,, 'touch', 'pen', 'mouse'][pointer.pointerType];\n\t      }\n\t\n\t      if (eventType === 'tap') {\n\t        pointerEvent.dt = pointerEvent.timeStamp - this.downTimes[pointerIndex];\n\t\n\t        interval = pointerEvent.timeStamp - this.tapTime;\n\t        createNewDoubleTap = !!(this.prevTap && this.prevTap.type !== 'doubletap' && this.prevTap.target === pointerEvent.target && interval < 500);\n\t\n\t        pointerEvent.double = createNewDoubleTap;\n\t\n\t        this.tapTime = pointerEvent.timeStamp;\n\t      }\n\t\n\t      for (i = 0; i < targets.length; i++) {\n\t        pointerEvent.currentTarget = elements[i];\n\t        pointerEvent.interactable = targets[i];\n\t        targets[i].fire(pointerEvent);\n\t\n\t        if (pointerEvent.immediatePropagationStopped || pointerEvent.propagationStopped && elements[i + 1] !== pointerEvent.currentTarget) {\n\t          break;\n\t        }\n\t      }\n\t\n\t      if (createNewDoubleTap) {\n\t        var doubleTap = {};\n\t\n\t        extend(doubleTap, pointerEvent);\n\t\n\t        doubleTap.dt = interval;\n\t        doubleTap.type = 'doubletap';\n\t\n\t        this.collectEventTargets(doubleTap, event, eventTarget, 'doubletap');\n\t\n\t        this.prevTap = doubleTap;\n\t      } else if (eventType === 'tap') {\n\t        this.prevTap = pointerEvent;\n\t      }\n\t    },\n\t\n\t    validateSelector: function validateSelector(pointer, event, matches, matchElements) {\n\t      for (var i = 0, len = matches.length; i < len; i++) {\n\t        var match = matches[i],\n\t            matchElement = matchElements[i],\n\t            action = validateAction(match.getAction(pointer, event, this, matchElement), match);\n\t\n\t        if (action && withinInteractionLimit(match, matchElement, action)) {\n\t          this.target = match;\n\t          this.element = matchElement;\n\t\n\t          return action;\n\t        }\n\t      }\n\t    },\n\t\n\t    setSnapping: function setSnapping(pageCoords, status) {\n\t      var snap = this.target.options[this.prepared.name].snap,\n\t          targets = [],\n\t          target,\n\t          page,\n\t          i;\n\t\n\t      status = status || this.snapStatus;\n\t\n\t      if (status.useStatusXY) {\n\t        page = { x: status.x, y: status.y };\n\t      } else {\n\t        var origin = getOriginXY(this.target, this.element);\n\t\n\t        page = extend({}, pageCoords);\n\t\n\t        page.x -= origin.x;\n\t        page.y -= origin.y;\n\t      }\n\t\n\t      status.realX = page.x;\n\t      status.realY = page.y;\n\t\n\t      page.x = page.x - this.inertiaStatus.resumeDx;\n\t      page.y = page.y - this.inertiaStatus.resumeDy;\n\t\n\t      var len = snap.targets ? snap.targets.length : 0;\n\t\n\t      for (var relIndex = 0; relIndex < this.snapOffsets.length; relIndex++) {\n\t        var relative = {\n\t          x: page.x - this.snapOffsets[relIndex].x,\n\t          y: page.y - this.snapOffsets[relIndex].y\n\t        };\n\t\n\t        for (i = 0; i < len; i++) {\n\t          if (isFunction(snap.targets[i])) {\n\t            target = snap.targets[i](relative.x, relative.y, this);\n\t          } else {\n\t            target = snap.targets[i];\n\t          }\n\t\n\t          if (!target) {\n\t            continue;\n\t          }\n\t\n\t          targets.push({\n\t            x: isNumber(target.x) ? target.x + this.snapOffsets[relIndex].x : relative.x,\n\t            y: isNumber(target.y) ? target.y + this.snapOffsets[relIndex].y : relative.y,\n\t\n\t            range: isNumber(target.range) ? target.range : snap.range\n\t          });\n\t        }\n\t      }\n\t\n\t      var closest = {\n\t        target: null,\n\t        inRange: false,\n\t        distance: 0,\n\t        range: 0,\n\t        dx: 0,\n\t        dy: 0\n\t      };\n\t\n\t      for (i = 0, len = targets.length; i < len; i++) {\n\t        target = targets[i];\n\t\n\t        var range = target.range,\n\t            dx = target.x - page.x,\n\t            dy = target.y - page.y,\n\t            distance = hypot(dx, dy),\n\t            inRange = distance <= range;\n\t\n\t        // Infinite targets count as being out of range\n\t        // compared to non infinite ones that are in range\n\t        if (range === Infinity && closest.inRange && closest.range !== Infinity) {\n\t          inRange = false;\n\t        }\n\t\n\t        if (!closest.target || (inRange ? // is the closest target in range?\n\t        closest.inRange && range !== Infinity ? // the pointer is relatively deeper in this target\n\t        distance / range < closest.distance / closest.range : // this target has Infinite range and the closest doesn't\n\t        range === Infinity && closest.range !== Infinity ||\n\t        // OR this target is closer that the previous closest\n\t        distance < closest.distance : // The other is not in range and the pointer is closer to this target\n\t        !closest.inRange && distance < closest.distance)) {\n\t          if (range === Infinity) {\n\t            inRange = true;\n\t          }\n\t\n\t          closest.target = target;\n\t          closest.distance = distance;\n\t          closest.range = range;\n\t          closest.inRange = inRange;\n\t          closest.dx = dx;\n\t          closest.dy = dy;\n\t\n\t          status.range = range;\n\t        }\n\t      }\n\t\n\t      var snapChanged;\n\t\n\t      if (closest.target) {\n\t        snapChanged = status.snappedX !== closest.target.x || status.snappedY !== closest.target.y;\n\t\n\t        status.snappedX = closest.target.x;\n\t        status.snappedY = closest.target.y;\n\t      } else {\n\t        snapChanged = true;\n\t\n\t        status.snappedX = NaN;\n\t        status.snappedY = NaN;\n\t      }\n\t\n\t      status.dx = closest.dx;\n\t      status.dy = closest.dy;\n\t\n\t      status.changed = snapChanged || closest.inRange && !status.locked;\n\t      status.locked = closest.inRange;\n\t\n\t      return status;\n\t    },\n\t\n\t    setRestriction: function setRestriction(pageCoords, status) {\n\t      var target = this.target,\n\t          restrict = target && target.options[this.prepared.name].restrict,\n\t          restriction = restrict && restrict.restriction,\n\t          page;\n\t\n\t      if (!restriction) {\n\t        return status;\n\t      }\n\t\n\t      status = status || this.restrictStatus;\n\t\n\t      page = status.useStatusXY ? page = { x: status.x, y: status.y } : page = extend({}, pageCoords);\n\t\n\t      if (status.snap && status.snap.locked) {\n\t        page.x += status.snap.dx || 0;\n\t        page.y += status.snap.dy || 0;\n\t      }\n\t\n\t      page.x -= this.inertiaStatus.resumeDx;\n\t      page.y -= this.inertiaStatus.resumeDy;\n\t\n\t      status.dx = 0;\n\t      status.dy = 0;\n\t      status.restricted = false;\n\t\n\t      var rect, restrictedX, restrictedY;\n\t\n\t      if (isString(restriction)) {\n\t        if (restriction === 'parent') {\n\t          restriction = parentElement(this.element);\n\t        } else if (restriction === 'self') {\n\t          restriction = target.getRect(this.element);\n\t        } else {\n\t          restriction = closest(this.element, restriction);\n\t        }\n\t\n\t        if (!restriction) {\n\t          return status;\n\t        }\n\t      }\n\t\n\t      if (isFunction(restriction)) {\n\t        restriction = restriction(page.x, page.y, this.element);\n\t      }\n\t\n\t      if (isElement(restriction)) {\n\t        restriction = getElementRect(restriction);\n\t      }\n\t\n\t      rect = restriction;\n\t\n\t      if (!restriction) {\n\t        restrictedX = page.x;\n\t        restrictedY = page.y;\n\t      }\n\t      // object is assumed to have\n\t      // x, y, width, height or\n\t      // left, top, right, bottom\n\t      else if ('x' in restriction && 'y' in restriction) {\n\t          restrictedX = Math.max(Math.min(rect.x + rect.width - this.restrictOffset.right, page.x), rect.x + this.restrictOffset.left);\n\t          restrictedY = Math.max(Math.min(rect.y + rect.height - this.restrictOffset.bottom, page.y), rect.y + this.restrictOffset.top);\n\t        } else {\n\t          restrictedX = Math.max(Math.min(rect.right - this.restrictOffset.right, page.x), rect.left + this.restrictOffset.left);\n\t          restrictedY = Math.max(Math.min(rect.bottom - this.restrictOffset.bottom, page.y), rect.top + this.restrictOffset.top);\n\t        }\n\t\n\t      status.dx = restrictedX - page.x;\n\t      status.dy = restrictedY - page.y;\n\t\n\t      status.changed = status.restrictedX !== restrictedX || status.restrictedY !== restrictedY;\n\t      status.restricted = !!(status.dx || status.dy);\n\t\n\t      status.restrictedX = restrictedX;\n\t      status.restrictedY = restrictedY;\n\t\n\t      return status;\n\t    },\n\t\n\t    checkAndPreventDefault: function checkAndPreventDefault(event, interactable, element) {\n\t      if (!(interactable = interactable || this.target)) {\n\t        return;\n\t      }\n\t\n\t      var options = interactable.options,\n\t          prevent = options.preventDefault;\n\t\n\t      if (prevent === 'auto' && element && !/^(input|select|textarea)$/i.test(event.target.nodeName)) {\n\t        // do not preventDefault on pointerdown if the prepared action is a drag\n\t        // and dragging can only start from a certain direction - this allows\n\t        // a touch to pan the viewport if a drag isn't in the right direction\n\t        if (/down|start/i.test(event.type) && this.prepared.name === 'drag' && options.drag.axis !== 'xy') {\n\t          return;\n\t        }\n\t\n\t        // with manualStart, only preventDefault while interacting\n\t        if (options[this.prepared.name] && options[this.prepared.name].manualStart && !this.interacting()) {\n\t          return;\n\t        }\n\t\n\t        event.preventDefault();\n\t        return;\n\t      }\n\t\n\t      if (prevent === 'always') {\n\t        event.preventDefault();\n\t        return;\n\t      }\n\t    },\n\t\n\t    calcInertia: function calcInertia(status) {\n\t      var inertiaOptions = this.target.options[this.prepared.name].inertia,\n\t          lambda = inertiaOptions.resistance,\n\t          inertiaDur = -Math.log(inertiaOptions.endSpeed / status.v0) / lambda;\n\t\n\t      status.x0 = this.prevEvent.pageX;\n\t      status.y0 = this.prevEvent.pageY;\n\t      status.t0 = status.startEvent.timeStamp / 1000;\n\t      status.sx = status.sy = 0;\n\t\n\t      status.modifiedXe = status.xe = (status.vx0 - inertiaDur) / lambda;\n\t      status.modifiedYe = status.ye = (status.vy0 - inertiaDur) / lambda;\n\t      status.te = inertiaDur;\n\t\n\t      status.lambda_v0 = lambda / status.v0;\n\t      status.one_ve_v0 = 1 - inertiaOptions.endSpeed / status.v0;\n\t    },\n\t\n\t    autoScrollMove: function autoScrollMove(pointer) {\n\t      if (!(this.interacting() && checkAutoScroll(this.target, this.prepared.name))) {\n\t        return;\n\t      }\n\t\n\t      if (this.inertiaStatus.active) {\n\t        autoScroll.x = autoScroll.y = 0;\n\t        return;\n\t      }\n\t\n\t      var top,\n\t          right,\n\t          bottom,\n\t          left,\n\t          options = this.target.options[this.prepared.name].autoScroll,\n\t          container = options.container || getWindow(this.element);\n\t\n\t      if (isWindow(container)) {\n\t        left = pointer.clientX < autoScroll.margin;\n\t        top = pointer.clientY < autoScroll.margin;\n\t        right = pointer.clientX > container.innerWidth - autoScroll.margin;\n\t        bottom = pointer.clientY > container.innerHeight - autoScroll.margin;\n\t      } else {\n\t        var rect = getElementClientRect(container);\n\t\n\t        left = pointer.clientX < rect.left + autoScroll.margin;\n\t        top = pointer.clientY < rect.top + autoScroll.margin;\n\t        right = pointer.clientX > rect.right - autoScroll.margin;\n\t        bottom = pointer.clientY > rect.bottom - autoScroll.margin;\n\t      }\n\t\n\t      autoScroll.x = right ? 1 : left ? -1 : 0;\n\t      autoScroll.y = bottom ? 1 : top ? -1 : 0;\n\t\n\t      if (!autoScroll.isScrolling) {\n\t        // set the autoScroll properties to those of the target\n\t        autoScroll.margin = options.margin;\n\t        autoScroll.speed = options.speed;\n\t\n\t        autoScroll.start(this);\n\t      }\n\t    },\n\t\n\t    _updateEventTargets: function _updateEventTargets(target, currentTarget) {\n\t      this._eventTarget = target;\n\t      this._curEventTarget = currentTarget;\n\t    }\n\t  };\n\t\n\t  function getInteractionFromPointer(pointer, eventType, eventTarget) {\n\t    var i = 0,\n\t        len = interactions.length,\n\t        mouseEvent = /mouse/i.test(pointer.pointerType || eventType) ||\n\t    // MSPointerEvent.MSPOINTER_TYPE_MOUSE\n\t    pointer.pointerType === 4,\n\t        interaction;\n\t\n\t    var id = getPointerId(pointer);\n\t\n\t    // try to resume inertia with a new pointer\n\t    if (/down|start/i.test(eventType)) {\n\t      for (i = 0; i < len; i++) {\n\t        interaction = interactions[i];\n\t\n\t        var element = eventTarget;\n\t\n\t        if (interaction.inertiaStatus.active && interaction.target.options[interaction.prepared.name].inertia.allowResume && interaction.mouse === mouseEvent) {\n\t          while (element) {\n\t            // if the element is the interaction element\n\t            if (element === interaction.element) {\n\t              return interaction;\n\t            }\n\t            element = parentElement(element);\n\t          }\n\t        }\n\t      }\n\t    }\n\t\n\t    // if it's a mouse interaction\n\t    if (mouseEvent || !(supportsTouch || supportsPointerEvent)) {\n\t      // find a mouse interaction that's not in inertia phase\n\t      for (i = 0; i < len; i++) {\n\t        if (interactions[i].mouse && !interactions[i].inertiaStatus.active) {\n\t          return interactions[i];\n\t        }\n\t      }\n\t\n\t      // find any interaction specifically for mouse.\n\t      // if the eventType is a mousedown, and inertia is active\n\t      // ignore the interaction\n\t      for (i = 0; i < len; i++) {\n\t        if (interactions[i].mouse && !(/down/.test(eventType) && interactions[i].inertiaStatus.active)) {\n\t          return interaction;\n\t        }\n\t      }\n\t\n\t      // create a new interaction for mouse\n\t      interaction = new Interaction();\n\t      interaction.mouse = true;\n\t\n\t      return interaction;\n\t    }\n\t\n\t    // get interaction that has this pointer\n\t    for (i = 0; i < len; i++) {\n\t      if (contains(interactions[i].pointerIds, id)) {\n\t        return interactions[i];\n\t      }\n\t    }\n\t\n\t    // at this stage, a pointerUp should not return an interaction\n\t    if (/up|end|out/i.test(eventType)) {\n\t      return null;\n\t    }\n\t\n\t    // get first idle interaction\n\t    for (i = 0; i < len; i++) {\n\t      interaction = interactions[i];\n\t\n\t      if ((!interaction.prepared.name || interaction.target.options.gesture.enabled) && !interaction.interacting() && !(!mouseEvent && interaction.mouse)) {\n\t        return interaction;\n\t      }\n\t    }\n\t\n\t    return new Interaction();\n\t  }\n\t\n\t  function doOnInteractions(method) {\n\t    return function (event) {\n\t      var interaction,\n\t          eventTarget = getActualElement(event.path ? event.path[0] : event.target),\n\t          curEventTarget = getActualElement(event.currentTarget),\n\t          i;\n\t\n\t      if (supportsTouch && /touch/.test(event.type)) {\n\t        prevTouchTime = new Date().getTime();\n\t\n\t        for (i = 0; i < event.changedTouches.length; i++) {\n\t          var pointer = event.changedTouches[i];\n\t\n\t          interaction = getInteractionFromPointer(pointer, event.type, eventTarget);\n\t\n\t          if (!interaction) {\n\t            continue;\n\t          }\n\t\n\t          interaction._updateEventTargets(eventTarget, curEventTarget);\n\t\n\t          interaction[method](pointer, event, eventTarget, curEventTarget);\n\t        }\n\t      } else {\n\t        if (!supportsPointerEvent && /mouse/.test(event.type)) {\n\t          // ignore mouse events while touch interactions are active\n\t          for (i = 0; i < interactions.length; i++) {\n\t            if (!interactions[i].mouse && interactions[i].pointerIsDown) {\n\t              return;\n\t            }\n\t          }\n\t\n\t          // try to ignore mouse events that are simulated by the browser\n\t          // after a touch event\n\t          if (new Date().getTime() - prevTouchTime < 500) {\n\t            return;\n\t          }\n\t        }\n\t\n\t        interaction = getInteractionFromPointer(event, event.type, eventTarget);\n\t\n\t        if (!interaction) {\n\t          return;\n\t        }\n\t\n\t        interaction._updateEventTargets(eventTarget, curEventTarget);\n\t\n\t        interaction[method](event, event, eventTarget, curEventTarget);\n\t      }\n\t    };\n\t  }\n\t\n\t  function InteractEvent(interaction, event, action, phase, element, related) {\n\t    var client,\n\t        page,\n\t        target = interaction.target,\n\t        snapStatus = interaction.snapStatus,\n\t        restrictStatus = interaction.restrictStatus,\n\t        pointers = interaction.pointers,\n\t        deltaSource = (target && target.options || defaultOptions).deltaSource,\n\t        sourceX = deltaSource + 'X',\n\t        sourceY = deltaSource + 'Y',\n\t        options = target ? target.options : defaultOptions,\n\t        origin = getOriginXY(target, element),\n\t        starting = phase === 'start',\n\t        ending = phase === 'end',\n\t        coords = starting ? interaction.startCoords : interaction.curCoords;\n\t\n\t    element = element || interaction.element;\n\t\n\t    page = extend({}, coords.page);\n\t    client = extend({}, coords.client);\n\t\n\t    page.x -= origin.x;\n\t    page.y -= origin.y;\n\t\n\t    client.x -= origin.x;\n\t    client.y -= origin.y;\n\t\n\t    var relativePoints = options[action].snap && options[action].snap.relativePoints;\n\t\n\t    if (checkSnap(target, action) && !(starting && relativePoints && relativePoints.length)) {\n\t      this.snap = {\n\t        range: snapStatus.range,\n\t        locked: snapStatus.locked,\n\t        x: snapStatus.snappedX,\n\t        y: snapStatus.snappedY,\n\t        realX: snapStatus.realX,\n\t        realY: snapStatus.realY,\n\t        dx: snapStatus.dx,\n\t        dy: snapStatus.dy\n\t      };\n\t\n\t      if (snapStatus.locked) {\n\t        page.x += snapStatus.dx;\n\t        page.y += snapStatus.dy;\n\t        client.x += snapStatus.dx;\n\t        client.y += snapStatus.dy;\n\t      }\n\t    }\n\t\n\t    if (checkRestrict(target, action) && !(starting && options[action].restrict.elementRect) && restrictStatus.restricted) {\n\t      page.x += restrictStatus.dx;\n\t      page.y += restrictStatus.dy;\n\t      client.x += restrictStatus.dx;\n\t      client.y += restrictStatus.dy;\n\t\n\t      this.restrict = {\n\t        dx: restrictStatus.dx,\n\t        dy: restrictStatus.dy\n\t      };\n\t    }\n\t\n\t    this.pageX = page.x;\n\t    this.pageY = page.y;\n\t    this.clientX = client.x;\n\t    this.clientY = client.y;\n\t\n\t    this.x0 = interaction.startCoords.page.x - origin.x;\n\t    this.y0 = interaction.startCoords.page.y - origin.y;\n\t    this.clientX0 = interaction.startCoords.client.x - origin.x;\n\t    this.clientY0 = interaction.startCoords.client.y - origin.y;\n\t    this.ctrlKey = event.ctrlKey;\n\t    this.altKey = event.altKey;\n\t    this.shiftKey = event.shiftKey;\n\t    this.metaKey = event.metaKey;\n\t    this.button = event.button;\n\t    this.buttons = event.buttons;\n\t    this.target = element;\n\t    this.t0 = interaction.downTimes[0];\n\t    this.type = action + (phase || '');\n\t\n\t    this.interaction = interaction;\n\t    this.interactable = target;\n\t\n\t    var inertiaStatus = interaction.inertiaStatus;\n\t\n\t    if (inertiaStatus.active) {\n\t      this.detail = 'inertia';\n\t    }\n\t\n\t    if (related) {\n\t      this.relatedTarget = related;\n\t    }\n\t\n\t    // end event dx, dy is difference between start and end points\n\t    if (ending) {\n\t      if (deltaSource === 'client') {\n\t        this.dx = client.x - interaction.startCoords.client.x;\n\t        this.dy = client.y - interaction.startCoords.client.y;\n\t      } else {\n\t        this.dx = page.x - interaction.startCoords.page.x;\n\t        this.dy = page.y - interaction.startCoords.page.y;\n\t      }\n\t    } else if (starting) {\n\t      this.dx = 0;\n\t      this.dy = 0;\n\t    }\n\t    // copy properties from previousmove if starting inertia\n\t    else if (phase === 'inertiastart') {\n\t        this.dx = interaction.prevEvent.dx;\n\t        this.dy = interaction.prevEvent.dy;\n\t      } else {\n\t        if (deltaSource === 'client') {\n\t          this.dx = client.x - interaction.prevEvent.clientX;\n\t          this.dy = client.y - interaction.prevEvent.clientY;\n\t        } else {\n\t          this.dx = page.x - interaction.prevEvent.pageX;\n\t          this.dy = page.y - interaction.prevEvent.pageY;\n\t        }\n\t      }\n\t    if (interaction.prevEvent && interaction.prevEvent.detail === 'inertia' && !inertiaStatus.active && options[action].inertia && options[action].inertia.zeroResumeDelta) {\n\t      inertiaStatus.resumeDx += this.dx;\n\t      inertiaStatus.resumeDy += this.dy;\n\t\n\t      this.dx = this.dy = 0;\n\t    }\n\t\n\t    if (action === 'resize' && interaction.resizeAxes) {\n\t      if (options.resize.square) {\n\t        if (interaction.resizeAxes === 'y') {\n\t          this.dx = this.dy;\n\t        } else {\n\t          this.dy = this.dx;\n\t        }\n\t        this.axes = 'xy';\n\t      } else {\n\t        this.axes = interaction.resizeAxes;\n\t\n\t        if (interaction.resizeAxes === 'x') {\n\t          this.dy = 0;\n\t        } else if (interaction.resizeAxes === 'y') {\n\t          this.dx = 0;\n\t        }\n\t      }\n\t    } else if (action === 'gesture') {\n\t      this.touches = [pointers[0], pointers[1]];\n\t\n\t      if (starting) {\n\t        this.distance = touchDistance(pointers, deltaSource);\n\t        this.box = touchBBox(pointers);\n\t        this.scale = 1;\n\t        this.ds = 0;\n\t        this.angle = touchAngle(pointers, undefined, deltaSource);\n\t        this.da = 0;\n\t      } else if (ending || event instanceof InteractEvent) {\n\t        this.distance = interaction.prevEvent.distance;\n\t        this.box = interaction.prevEvent.box;\n\t        this.scale = interaction.prevEvent.scale;\n\t        this.ds = this.scale - 1;\n\t        this.angle = interaction.prevEvent.angle;\n\t        this.da = this.angle - interaction.gesture.startAngle;\n\t      } else {\n\t        this.distance = touchDistance(pointers, deltaSource);\n\t        this.box = touchBBox(pointers);\n\t        this.scale = this.distance / interaction.gesture.startDistance;\n\t        this.angle = touchAngle(pointers, interaction.gesture.prevAngle, deltaSource);\n\t\n\t        this.ds = this.scale - interaction.gesture.prevScale;\n\t        this.da = this.angle - interaction.gesture.prevAngle;\n\t      }\n\t    }\n\t\n\t    if (starting) {\n\t      this.timeStamp = interaction.downTimes[0];\n\t      this.dt = 0;\n\t      this.duration = 0;\n\t      this.speed = 0;\n\t      this.velocityX = 0;\n\t      this.velocityY = 0;\n\t    } else if (phase === 'inertiastart') {\n\t      this.timeStamp = interaction.prevEvent.timeStamp;\n\t      this.dt = interaction.prevEvent.dt;\n\t      this.duration = interaction.prevEvent.duration;\n\t      this.speed = interaction.prevEvent.speed;\n\t      this.velocityX = interaction.prevEvent.velocityX;\n\t      this.velocityY = interaction.prevEvent.velocityY;\n\t    } else {\n\t      this.timeStamp = new Date().getTime();\n\t      this.dt = this.timeStamp - interaction.prevEvent.timeStamp;\n\t      this.duration = this.timeStamp - interaction.downTimes[0];\n\t\n\t      if (event instanceof InteractEvent) {\n\t        var dx = this[sourceX] - interaction.prevEvent[sourceX],\n\t            dy = this[sourceY] - interaction.prevEvent[sourceY],\n\t            dt = this.dt / 1000;\n\t\n\t        this.speed = hypot(dx, dy) / dt;\n\t        this.velocityX = dx / dt;\n\t        this.velocityY = dy / dt;\n\t      }\n\t      // if normal move or end event, use previous user event coords\n\t      else {\n\t          // speed and velocity in pixels per second\n\t          this.speed = interaction.pointerDelta[deltaSource].speed;\n\t          this.velocityX = interaction.pointerDelta[deltaSource].vx;\n\t          this.velocityY = interaction.pointerDelta[deltaSource].vy;\n\t        }\n\t    }\n\t\n\t    if ((ending || phase === 'inertiastart') && interaction.prevEvent.speed > 600 && this.timeStamp - interaction.prevEvent.timeStamp < 150) {\n\t      var angle = 180 * Math.atan2(interaction.prevEvent.velocityY, interaction.prevEvent.velocityX) / Math.PI,\n\t          overlap = 22.5;\n\t\n\t      if (angle < 0) {\n\t        angle += 360;\n\t      }\n\t\n\t      var left = 135 - overlap <= angle && angle < 225 + overlap,\n\t          up = 225 - overlap <= angle && angle < 315 + overlap,\n\t          right = !left && (315 - overlap <= angle || angle < 45 + overlap),\n\t          down = !up && 45 - overlap <= angle && angle < 135 + overlap;\n\t\n\t      this.swipe = {\n\t        up: up,\n\t        down: down,\n\t        left: left,\n\t        right: right,\n\t        angle: angle,\n\t        speed: interaction.prevEvent.speed,\n\t        velocity: {\n\t          x: interaction.prevEvent.velocityX,\n\t          y: interaction.prevEvent.velocityY\n\t        }\n\t      };\n\t    }\n\t  }\n\t\n\t  InteractEvent.prototype = {\n\t    preventDefault: blank,\n\t    stopImmediatePropagation: function stopImmediatePropagation() {\n\t      this.immediatePropagationStopped = this.propagationStopped = true;\n\t    },\n\t    stopPropagation: function stopPropagation() {\n\t      this.propagationStopped = true;\n\t    }\n\t  };\n\t\n\t  function preventOriginalDefault() {\n\t    this.originalEvent.preventDefault();\n\t  }\n\t\n\t  function getActionCursor(action) {\n\t    var cursor = '';\n\t\n\t    if (action.name === 'drag') {\n\t      cursor = actionCursors.drag;\n\t    }\n\t    if (action.name === 'resize') {\n\t      if (action.axis) {\n\t        cursor = actionCursors[action.name + action.axis];\n\t      } else if (action.edges) {\n\t        var cursorKey = 'resize',\n\t            edgeNames = ['top', 'bottom', 'left', 'right'];\n\t\n\t        for (var i = 0; i < 4; i++) {\n\t          if (action.edges[edgeNames[i]]) {\n\t            cursorKey += edgeNames[i];\n\t          }\n\t        }\n\t\n\t        cursor = actionCursors[cursorKey];\n\t      }\n\t    }\n\t\n\t    return cursor;\n\t  }\n\t\n\t  function checkResizeEdge(name, value, page, element, interactableElement, rect, margin) {\n\t    // false, '', undefined, null\n\t    if (!value) {\n\t      return false;\n\t    }\n\t\n\t    // true value, use pointer coords and element rect\n\t    if (value === true) {\n\t      // if dimensions are negative, \"switch\" edges\n\t      var width = isNumber(rect.width) ? rect.width : rect.right - rect.left,\n\t          height = isNumber(rect.height) ? rect.height : rect.bottom - rect.top;\n\t\n\t      if (width < 0) {\n\t        if (name === 'left') {\n\t          name = 'right';\n\t        } else if (name === 'right') {\n\t          name = 'left';\n\t        }\n\t      }\n\t      if (height < 0) {\n\t        if (name === 'top') {\n\t          name = 'bottom';\n\t        } else if (name === 'bottom') {\n\t          name = 'top';\n\t        }\n\t      }\n\t\n\t      if (name === 'left') {\n\t        return page.x < (width >= 0 ? rect.left : rect.right) + margin;\n\t      }\n\t      if (name === 'top') {\n\t        return page.y < (height >= 0 ? rect.top : rect.bottom) + margin;\n\t      }\n\t\n\t      if (name === 'right') {\n\t        return page.x > (width >= 0 ? rect.right : rect.left) - margin;\n\t      }\n\t      if (name === 'bottom') {\n\t        return page.y > (height >= 0 ? rect.bottom : rect.top) - margin;\n\t      }\n\t    }\n\t\n\t    // the remaining checks require an element\n\t    if (!isElement(element)) {\n\t      return false;\n\t    }\n\t\n\t    return isElement(value) ? // the value is an element to use as a resize handle\n\t    value === element : // otherwise check if element matches value as selector\n\t    matchesUpTo(element, value, interactableElement);\n\t  }\n\t\n\t  function defaultActionChecker(pointer, interaction, element) {\n\t    var rect = this.getRect(element),\n\t        shouldResize = false,\n\t        action = null,\n\t        resizeAxes = null,\n\t        resizeEdges,\n\t        page = extend({}, interaction.curCoords.page),\n\t        options = this.options;\n\t\n\t    if (!rect) {\n\t      return null;\n\t    }\n\t\n\t    if (actionIsEnabled.resize && options.resize.enabled) {\n\t      var resizeOptions = options.resize;\n\t\n\t      resizeEdges = {\n\t        left: false,\n\t        right: false,\n\t        top: false,\n\t        bottom: false\n\t      };\n\t\n\t      // if using resize.edges\n\t      if (isObject(resizeOptions.edges)) {\n\t        for (var edge in resizeEdges) {\n\t          resizeEdges[edge] = checkResizeEdge(edge, resizeOptions.edges[edge], page, interaction._eventTarget, element, rect, resizeOptions.margin || margin);\n\t        }\n\t\n\t        resizeEdges.left = resizeEdges.left && !resizeEdges.right;\n\t        resizeEdges.top = resizeEdges.top && !resizeEdges.bottom;\n\t\n\t        shouldResize = resizeEdges.left || resizeEdges.right || resizeEdges.top || resizeEdges.bottom;\n\t      } else {\n\t        var right = options.resize.axis !== 'y' && page.x > rect.right - margin,\n\t            bottom = options.resize.axis !== 'x' && page.y > rect.bottom - margin;\n\t\n\t        shouldResize = right || bottom;\n\t        resizeAxes = (right ? 'x' : '') + (bottom ? 'y' : '');\n\t      }\n\t    }\n\t\n\t    action = shouldResize ? 'resize' : actionIsEnabled.drag && options.drag.enabled ? 'drag' : null;\n\t\n\t    if (actionIsEnabled.gesture && interaction.pointerIds.length >= 2 && !(interaction.dragging || interaction.resizing)) {\n\t      action = 'gesture';\n\t    }\n\t\n\t    if (action) {\n\t      return {\n\t        name: action,\n\t        axis: resizeAxes,\n\t        edges: resizeEdges\n\t      };\n\t    }\n\t\n\t    return null;\n\t  }\n\t\n\t  // Check if action is enabled globally and the current target supports it\n\t  // If so, return the validated action. Otherwise, return null\n\t  function validateAction(action, interactable) {\n\t    if (!isObject(action)) {\n\t      return null;\n\t    }\n\t\n\t    var actionName = action.name,\n\t        options = interactable.options;\n\t\n\t    if ((actionName === 'resize' && options.resize.enabled || actionName === 'drag' && options.drag.enabled || actionName === 'gesture' && options.gesture.enabled) && actionIsEnabled[actionName]) {\n\t      if (actionName === 'resize' || actionName === 'resizeyx') {\n\t        actionName = 'resizexy';\n\t      }\n\t\n\t      return action;\n\t    }\n\t    return null;\n\t  }\n\t\n\t  var listeners = {},\n\t      interactionListeners = ['dragStart', 'dragMove', 'resizeStart', 'resizeMove', 'gestureStart', 'gestureMove', 'pointerOver', 'pointerOut', 'pointerHover', 'selectorDown', 'pointerDown', 'pointerMove', 'pointerUp', 'pointerCancel', 'pointerEnd', 'addPointer', 'removePointer', 'recordPointer', 'autoScrollMove'];\n\t\n\t  for (var i = 0, len = interactionListeners.length; i < len; i++) {\n\t    var name = interactionListeners[i];\n\t\n\t    listeners[name] = doOnInteractions(name);\n\t  }\n\t\n\t  // bound to the interactable context when a DOM event\n\t  // listener is added to a selector interactable\n\t  function delegateListener(event, useCapture) {\n\t    var fakeEvent = {},\n\t        delegated = delegatedEvents[event.type],\n\t        eventTarget = getActualElement(event.path ? event.path[0] : event.target),\n\t        element = eventTarget;\n\t\n\t    useCapture = useCapture ? true : false;\n\t\n\t    // duplicate the event so that currentTarget can be changed\n\t    for (var prop in event) {\n\t      fakeEvent[prop] = event[prop];\n\t    }\n\t\n\t    fakeEvent.originalEvent = event;\n\t    fakeEvent.preventDefault = preventOriginalDefault;\n\t\n\t    // climb up document tree looking for selector matches\n\t    while (isElement(element)) {\n\t      for (var i = 0; i < delegated.selectors.length; i++) {\n\t        var selector = delegated.selectors[i],\n\t            context = delegated.contexts[i];\n\t\n\t        if (matchesSelector(element, selector) && nodeContains(context, eventTarget) && nodeContains(context, element)) {\n\t          var listeners = delegated.listeners[i];\n\t\n\t          fakeEvent.currentTarget = element;\n\t\n\t          for (var j = 0; j < listeners.length; j++) {\n\t            if (listeners[j][1] === useCapture) {\n\t              listeners[j][0](fakeEvent);\n\t            }\n\t          }\n\t        }\n\t      }\n\t\n\t      element = parentElement(element);\n\t    }\n\t  }\n\t\n\t  function delegateUseCapture(event) {\n\t    return delegateListener.call(this, event, true);\n\t  }\n\t\n\t  interactables.indexOfElement = function indexOfElement(element, context) {\n\t    context = context || document;\n\t\n\t    for (var i = 0; i < this.length; i++) {\n\t      var interactable = this[i];\n\t\n\t      if (interactable.selector === element && interactable._context === context || !interactable.selector && interactable._element === element) {\n\t        return i;\n\t      }\n\t    }\n\t    return -1;\n\t  };\n\t\n\t  interactables.get = function interactableGet(element, options) {\n\t    return this[this.indexOfElement(element, options && options.context)];\n\t  };\n\t\n\t  interactables.forEachSelector = function (callback) {\n\t    for (var i = 0; i < this.length; i++) {\n\t      var interactable = this[i];\n\t\n\t      if (!interactable.selector) {\n\t        continue;\n\t      }\n\t\n\t      var ret = callback(interactable, interactable.selector, interactable._context, i, this);\n\t\n\t      if (ret !== undefined) {\n\t        return ret;\n\t      }\n\t    }\n\t  };\n\t\n\t  /*\\\n\t     * interact\n\t     [ method ]\n\t     *\n\t     * The methods of this variable can be used to set elements as\n\t     * interactables and also to change various default settings.\n\t     *\n\t     * Calling it as a function and passing an element or a valid CSS selector\n\t     * string returns an Interactable object which has various methods to\n\t     * configure it.\n\t     *\n\t     - element (Element | string) The HTML or SVG Element to interact with or CSS selector\n\t     = (object) An @Interactable\n\t     *\n\t     > Usage\n\t     | interact(document.getElementById('draggable')).draggable(true);\n\t     |\n\t     | var rectables = interact('rect');\n\t     | rectables\n\t     |     .gesturable(true)\n\t     |     .on('gesturemove', function (event) {\n\t     |         // something cool...\n\t     |     })\n\t     |     .autoScroll(true);\n\t    \\*/\n\t  function interact(element, options) {\n\t    return interactables.get(element, options) || new Interactable(element, options);\n\t  }\n\t\n\t  /*\\\n\t     * Interactable\n\t     [ property ]\n\t     **\n\t     * Object type returned by @interact\n\t    \\*/\n\t  function Interactable(element, options) {\n\t    this._element = element;\n\t    this._iEvents = this._iEvents || {};\n\t\n\t    var _window;\n\t\n\t    if (trySelector(element)) {\n\t      this.selector = element;\n\t\n\t      var context = options && options.context;\n\t\n\t      _window = context ? getWindow(context) : window;\n\t\n\t      if (context && (_window.Node ? context instanceof _window.Node : isElement(context) || context === _window.document)) {\n\t        this._context = context;\n\t      }\n\t    } else {\n\t      _window = getWindow(element);\n\t\n\t      if (isElement(element, _window)) {\n\t        if (supportsPointerEvent) {\n\t          events.add(this._element, pEventTypes.down, listeners.pointerDown);\n\t          events.add(this._element, pEventTypes.move, listeners.pointerHover);\n\t        } else {\n\t          events.add(this._element, 'mousedown', listeners.pointerDown);\n\t          events.add(this._element, 'mousemove', listeners.pointerHover);\n\t          events.add(this._element, 'touchstart', listeners.pointerDown);\n\t          events.add(this._element, 'touchmove', listeners.pointerHover);\n\t        }\n\t      }\n\t    }\n\t\n\t    this._doc = _window.document;\n\t\n\t    if (!contains(documents, this._doc)) {\n\t      listenToDocument(this._doc);\n\t    }\n\t\n\t    interactables.push(this);\n\t\n\t    this.set(options);\n\t  }\n\t\n\t  Interactable.prototype = {\n\t    setOnEvents: function setOnEvents(action, phases) {\n\t      if (action === 'drop') {\n\t        if (isFunction(phases.ondrop)) {\n\t          this.ondrop = phases.ondrop;\n\t        }\n\t        if (isFunction(phases.ondropactivate)) {\n\t          this.ondropactivate = phases.ondropactivate;\n\t        }\n\t        if (isFunction(phases.ondropdeactivate)) {\n\t          this.ondropdeactivate = phases.ondropdeactivate;\n\t        }\n\t        if (isFunction(phases.ondragenter)) {\n\t          this.ondragenter = phases.ondragenter;\n\t        }\n\t        if (isFunction(phases.ondragleave)) {\n\t          this.ondragleave = phases.ondragleave;\n\t        }\n\t        if (isFunction(phases.ondropmove)) {\n\t          this.ondropmove = phases.ondropmove;\n\t        }\n\t      } else {\n\t        action = 'on' + action;\n\t\n\t        if (isFunction(phases.onstart)) {\n\t          this[action + 'start'] = phases.onstart;\n\t        }\n\t        if (isFunction(phases.onmove)) {\n\t          this[action + 'move'] = phases.onmove;\n\t        }\n\t        if (isFunction(phases.onend)) {\n\t          this[action + 'end'] = phases.onend;\n\t        }\n\t        if (isFunction(phases.oninertiastart)) {\n\t          this[action + 'inertiastart'] = phases.oninertiastart;\n\t        }\n\t      }\n\t\n\t      return this;\n\t    },\n\t\n\t    /*\\\n\t         * Interactable.draggable\n\t         [ method ]\n\t         *\n\t         * Gets or sets whether drag actions can be performed on the\n\t         * Interactable\n\t         *\n\t         = (boolean) Indicates if this can be the target of drag events\n\t         | var isDraggable = interact('ul li').draggable();\n\t         * or\n\t         - options (boolean | object) #optional true/false or An object with event listeners to be fired on drag events (object makes the Interactable draggable)\n\t         = (object) This Interactable\n\t         | interact(element).draggable({\n\t         |     onstart: function (event) {},\n\t         |     onmove : function (event) {},\n\t         |     onend  : function (event) {},\n\t         |\n\t         |     // the axis in which the first movement must be\n\t         |     // for the drag sequence to start\n\t         |     // 'xy' by default - any direction\n\t         |     axis: 'x' || 'y' || 'xy',\n\t         |\n\t         |     // max number of drags that can happen concurrently\n\t         |     // with elements of this Interactable. Infinity by default\n\t         |     max: Infinity,\n\t         |\n\t         |     // max number of drags that can target the same element+Interactable\n\t         |     // 1 by default\n\t         |     maxPerElement: 2\n\t         | });\n\t        \\*/\n\t    draggable: function draggable(options) {\n\t      if (isObject(options)) {\n\t        this.options.drag.enabled = options.enabled === false ? false : true;\n\t        this.setPerAction('drag', options);\n\t        this.setOnEvents('drag', options);\n\t\n\t        if (/^x$|^y$|^xy$/.test(options.axis)) {\n\t          this.options.drag.axis = options.axis;\n\t        } else if (options.axis === null) {\n\t          delete this.options.drag.axis;\n\t        }\n\t\n\t        return this;\n\t      }\n\t\n\t      if (isBool(options)) {\n\t        this.options.drag.enabled = options;\n\t\n\t        return this;\n\t      }\n\t\n\t      return this.options.drag;\n\t    },\n\t\n\t    setPerAction: function setPerAction(action, options) {\n\t      // for all the default per-action options\n\t      for (var option in options) {\n\t        // if this option exists for this action\n\t        if (option in defaultOptions[action]) {\n\t          // if the option in the options arg is an object value\n\t          if (isObject(options[option])) {\n\t            // duplicate the object\n\t            this.options[action][option] = extend(this.options[action][option] || {}, options[option]);\n\t\n\t            if (isObject(defaultOptions.perAction[option]) && 'enabled' in defaultOptions.perAction[option]) {\n\t              this.options[action][option].enabled = options[option].enabled === false ? false : true;\n\t            }\n\t          } else if (isBool(options[option]) && isObject(defaultOptions.perAction[option])) {\n\t            this.options[action][option].enabled = options[option];\n\t          } else if (options[option] !== undefined) {\n\t            // or if it's not undefined, do a plain assignment\n\t            this.options[action][option] = options[option];\n\t          }\n\t        }\n\t      }\n\t    },\n\t\n\t    /*\\\n\t         * Interactable.dropzone\n\t         [ method ]\n\t         *\n\t         * Returns or sets whether elements can be dropped onto this\n\t         * Interactable to trigger drop events\n\t         *\n\t         * Dropzones can receive the following events:\n\t         *  - `dropactivate` and `dropdeactivate` when an acceptable drag starts and ends\n\t         *  - `dragenter` and `dragleave` when a draggable enters and leaves the dropzone\n\t         *  - `dragmove` when a draggable that has entered the dropzone is moved\n\t         *  - `drop` when a draggable is dropped into this dropzone\n\t         *\n\t         *  Use the `accept` option to allow only elements that match the given CSS selector or element.\n\t         *\n\t         *  Use the `overlap` option to set how drops are checked for. The allowed values are:\n\t         *   - `'pointer'`, the pointer must be over the dropzone (default)\n\t         *   - `'center'`, the draggable element's center must be over the dropzone\n\t         *   - a number from 0-1 which is the `(intersection area) / (draggable area)`.\n\t         *       e.g. `0.5` for drop to happen when half of the area of the\n\t         *       draggable is over the dropzone\n\t         *\n\t         - options (boolean | object | null) #optional The new value to be set.\n\t         | interact('.drop').dropzone({\n\t         |   accept: '.can-drop' || document.getElementById('single-drop'),\n\t         |   overlap: 'pointer' || 'center' || zeroToOne\n\t         | }\n\t         = (boolean | object) The current setting or this Interactable\n\t        \\*/\n\t    dropzone: function dropzone(options) {\n\t      if (isObject(options)) {\n\t        this.options.drop.enabled = options.enabled === false ? false : true;\n\t        this.setOnEvents('drop', options);\n\t\n\t        if (/^(pointer|center)$/.test(options.overlap)) {\n\t          this.options.drop.overlap = options.overlap;\n\t        } else if (isNumber(options.overlap)) {\n\t          this.options.drop.overlap = Math.max(Math.min(1, options.overlap), 0);\n\t        }\n\t        if ('accept' in options) {\n\t          this.options.drop.accept = options.accept;\n\t        }\n\t        if ('checker' in options) {\n\t          this.options.drop.checker = options.checker;\n\t        }\n\t\n\t        return this;\n\t      }\n\t\n\t      if (isBool(options)) {\n\t        this.options.drop.enabled = options;\n\t\n\t        return this;\n\t      }\n\t\n\t      return this.options.drop;\n\t    },\n\t\n\t    dropCheck: function dropCheck(dragEvent, event, draggable, draggableElement, dropElement, rect) {\n\t      var dropped = false;\n\t\n\t      // if the dropzone has no rect (eg. display: none)\n\t      // call the custom dropChecker or just return false\n\t      if (!(rect = rect || this.getRect(dropElement))) {\n\t        return this.options.drop.checker ? this.options.drop.checker(dragEvent, event, dropped, this, dropElement, draggable, draggableElement) : false;\n\t      }\n\t\n\t      var dropOverlap = this.options.drop.overlap;\n\t\n\t      if (dropOverlap === 'pointer') {\n\t        var page = _getPageXY(dragEvent),\n\t            origin = getOriginXY(draggable, draggableElement),\n\t            horizontal,\n\t            vertical;\n\t\n\t        page.x += origin.x;\n\t        page.y += origin.y;\n\t\n\t        horizontal = page.x > rect.left && page.x < rect.right;\n\t        vertical = page.y > rect.top && page.y < rect.bottom;\n\t\n\t        dropped = horizontal && vertical;\n\t      }\n\t\n\t      var dragRect = draggable.getRect(draggableElement);\n\t\n\t      if (dropOverlap === 'center') {\n\t        var cx = dragRect.left + dragRect.width / 2,\n\t            cy = dragRect.top + dragRect.height / 2;\n\t\n\t        dropped = cx >= rect.left && cx <= rect.right && cy >= rect.top && cy <= rect.bottom;\n\t      }\n\t\n\t      if (isNumber(dropOverlap)) {\n\t        var overlapArea = Math.max(0, Math.min(rect.right, dragRect.right) - Math.max(rect.left, dragRect.left)) * Math.max(0, Math.min(rect.bottom, dragRect.bottom) - Math.max(rect.top, dragRect.top)),\n\t            overlapRatio = overlapArea / (dragRect.width * dragRect.height);\n\t\n\t        dropped = overlapRatio >= dropOverlap;\n\t      }\n\t\n\t      if (this.options.drop.checker) {\n\t        dropped = this.options.drop.checker(dragEvent, event, dropped, this, dropElement, draggable, draggableElement);\n\t      }\n\t\n\t      return dropped;\n\t    },\n\t\n\t    /*\\\n\t         * Interactable.dropChecker\n\t         [ method ]\n\t         *\n\t         * DEPRECATED. Use interactable.dropzone({ checker: function... }) instead.\n\t         *\n\t         * Gets or sets the function used to check if a dragged element is\n\t         * over this Interactable.\n\t         *\n\t         - checker (function) #optional The function that will be called when checking for a drop\n\t         = (Function | Interactable) The checker function or this Interactable\n\t         *\n\t         * The checker function takes the following arguments:\n\t         *\n\t         - dragEvent (InteractEvent) The related dragmove or dragend event\n\t         - event (TouchEvent | PointerEvent | MouseEvent) The user move/up/end Event related to the dragEvent\n\t         - dropped (boolean) The value from the default drop checker\n\t         - dropzone (Interactable) The dropzone interactable\n\t         - dropElement (Element) The dropzone element\n\t         - draggable (Interactable) The Interactable being dragged\n\t         - draggableElement (Element) The actual element that's being dragged\n\t         *\n\t         > Usage:\n\t         | interact(target)\n\t         | .dropChecker(function(dragEvent,         // related dragmove or dragend event\n\t         |                       event,             // TouchEvent/PointerEvent/MouseEvent\n\t         |                       dropped,           // bool result of the default checker\n\t         |                       dropzone,          // dropzone Interactable\n\t         |                       dropElement,       // dropzone elemnt\n\t         |                       draggable,         // draggable Interactable\n\t         |                       draggableElement) {// draggable element\n\t         |\n\t         |   return dropped && event.target.hasAttribute('allow-drop');\n\t         | }\n\t        \\*/\n\t    dropChecker: function dropChecker(checker) {\n\t      if (isFunction(checker)) {\n\t        this.options.drop.checker = checker;\n\t\n\t        return this;\n\t      }\n\t      if (checker === null) {\n\t        delete this.options.getRect;\n\t\n\t        return this;\n\t      }\n\t\n\t      return this.options.drop.checker;\n\t    },\n\t\n\t    /*\\\n\t         * Interactable.accept\n\t         [ method ]\n\t         *\n\t         * Deprecated. add an `accept` property to the options object passed to\n\t         * @Interactable.dropzone instead.\n\t         *\n\t         * Gets or sets the Element or CSS selector match that this\n\t         * Interactable accepts if it is a dropzone.\n\t         *\n\t         - newValue (Element | string | null) #optional\n\t         * If it is an Element, then only that element can be dropped into this dropzone.\n\t         * If it is a string, the element being dragged must match it as a selector.\n\t         * If it is null, the accept options is cleared - it accepts any element.\n\t         *\n\t         = (string | Element | null | Interactable) The current accept option if given `undefined` or this Interactable\n\t        \\*/\n\t    accept: function accept(newValue) {\n\t      if (isElement(newValue)) {\n\t        this.options.drop.accept = newValue;\n\t\n\t        return this;\n\t      }\n\t\n\t      // test if it is a valid CSS selector\n\t      if (trySelector(newValue)) {\n\t        this.options.drop.accept = newValue;\n\t\n\t        return this;\n\t      }\n\t\n\t      if (newValue === null) {\n\t        delete this.options.drop.accept;\n\t\n\t        return this;\n\t      }\n\t\n\t      return this.options.drop.accept;\n\t    },\n\t\n\t    /*\\\n\t         * Interactable.resizable\n\t         [ method ]\n\t         *\n\t         * Gets or sets whether resize actions can be performed on the\n\t         * Interactable\n\t         *\n\t         = (boolean) Indicates if this can be the target of resize elements\n\t         | var isResizeable = interact('input[type=text]').resizable();\n\t         * or\n\t         - options (boolean | object) #optional true/false or An object with event listeners to be fired on resize events (object makes the Interactable resizable)\n\t         = (object) This Interactable\n\t         | interact(element).resizable({\n\t         |     onstart: function (event) {},\n\t         |     onmove : function (event) {},\n\t         |     onend  : function (event) {},\n\t         |\n\t         |     edges: {\n\t         |       top   : true,       // Use pointer coords to check for resize.\n\t         |       left  : false,      // Disable resizing from left edge.\n\t         |       bottom: '.resize-s',// Resize if pointer target matches selector\n\t         |       right : handleEl    // Resize if pointer target is the given Element\n\t         |     },\n\t         |\n\t         |     // Width and height can be adjusted independently. When `true`, width and\n\t         |     // height are adjusted at a 1:1 ratio.\n\t         |     square: false,\n\t         |\n\t         |     // Width and height can be adjusted independently. When `true`, width and\n\t         |     // height maintain the aspect ratio they had when resizing started.\n\t         |     preserveAspectRatio: false,\n\t         |\n\t         |     // a value of 'none' will limit the resize rect to a minimum of 0x0\n\t         |     // 'negate' will allow the rect to have negative width/height\n\t         |     // 'reposition' will keep the width/height positive by swapping\n\t         |     // the top and bottom edges and/or swapping the left and right edges\n\t         |     invert: 'none' || 'negate' || 'reposition'\n\t         |\n\t         |     // limit multiple resizes.\n\t         |     // See the explanation in the @Interactable.draggable example\n\t         |     max: Infinity,\n\t         |     maxPerElement: 1,\n\t         | });\n\t        \\*/\n\t    resizable: function resizable(options) {\n\t      if (isObject(options)) {\n\t        this.options.resize.enabled = options.enabled === false ? false : true;\n\t        this.setPerAction('resize', options);\n\t        this.setOnEvents('resize', options);\n\t\n\t        if (/^x$|^y$|^xy$/.test(options.axis)) {\n\t          this.options.resize.axis = options.axis;\n\t        } else if (options.axis === null) {\n\t          this.options.resize.axis = defaultOptions.resize.axis;\n\t        }\n\t\n\t        if (isBool(options.preserveAspectRatio)) {\n\t          this.options.resize.preserveAspectRatio = options.preserveAspectRatio;\n\t        } else if (isBool(options.square)) {\n\t          this.options.resize.square = options.square;\n\t        }\n\t\n\t        return this;\n\t      }\n\t      if (isBool(options)) {\n\t        this.options.resize.enabled = options;\n\t\n\t        return this;\n\t      }\n\t      return this.options.resize;\n\t    },\n\t\n\t    /*\\\n\t         * Interactable.squareResize\n\t         [ method ]\n\t         *\n\t         * Deprecated. Add a `square: true || false` property to @Interactable.resizable instead\n\t         *\n\t         * Gets or sets whether resizing is forced 1:1 aspect\n\t         *\n\t         = (boolean) Current setting\n\t         *\n\t         * or\n\t         *\n\t         - newValue (boolean) #optional\n\t         = (object) this Interactable\n\t        \\*/\n\t    squareResize: function squareResize(newValue) {\n\t      if (isBool(newValue)) {\n\t        this.options.resize.square = newValue;\n\t\n\t        return this;\n\t      }\n\t\n\t      if (newValue === null) {\n\t        delete this.options.resize.square;\n\t\n\t        return this;\n\t      }\n\t\n\t      return this.options.resize.square;\n\t    },\n\t\n\t    /*\\\n\t         * Interactable.gesturable\n\t         [ method ]\n\t         *\n\t         * Gets or sets whether multitouch gestures can be performed on the\n\t         * Interactable's element\n\t         *\n\t         = (boolean) Indicates if this can be the target of gesture events\n\t         | var isGestureable = interact(element).gesturable();\n\t         * or\n\t         - options (boolean | object) #optional true/false or An object with event listeners to be fired on gesture events (makes the Interactable gesturable)\n\t         = (object) this Interactable\n\t         | interact(element).gesturable({\n\t         |     onstart: function (event) {},\n\t         |     onmove : function (event) {},\n\t         |     onend  : function (event) {},\n\t         |\n\t         |     // limit multiple gestures.\n\t         |     // See the explanation in @Interactable.draggable example\n\t         |     max: Infinity,\n\t         |     maxPerElement: 1,\n\t         | });\n\t        \\*/\n\t    gesturable: function gesturable(options) {\n\t      if (isObject(options)) {\n\t        this.options.gesture.enabled = options.enabled === false ? false : true;\n\t        this.setPerAction('gesture', options);\n\t        this.setOnEvents('gesture', options);\n\t\n\t        return this;\n\t      }\n\t\n\t      if (isBool(options)) {\n\t        this.options.gesture.enabled = options;\n\t\n\t        return this;\n\t      }\n\t\n\t      return this.options.gesture;\n\t    },\n\t\n\t    /*\\\n\t         * Interactable.autoScroll\n\t         [ method ]\n\t         **\n\t         * Deprecated. Add an `autoscroll` property to the options object\n\t         * passed to @Interactable.draggable or @Interactable.resizable instead.\n\t         *\n\t         * Returns or sets whether dragging and resizing near the edges of the\n\t         * window/container trigger autoScroll for this Interactable\n\t         *\n\t         = (object) Object with autoScroll properties\n\t         *\n\t         * or\n\t         *\n\t         - options (object | boolean) #optional\n\t         * options can be:\n\t         * - an object with margin, distance and interval properties,\n\t         * - true or false to enable or disable autoScroll or\n\t         = (Interactable) this Interactable\n\t        \\*/\n\t    autoScroll: function autoScroll(options) {\n\t      if (isObject(options)) {\n\t        options = extend({ actions: ['drag', 'resize'] }, options);\n\t      } else if (isBool(options)) {\n\t        options = { actions: ['drag', 'resize'], enabled: options };\n\t      }\n\t\n\t      return this.setOptions('autoScroll', options);\n\t    },\n\t\n\t    /*\\\n\t         * Interactable.snap\n\t         [ method ]\n\t         **\n\t         * Deprecated. Add a `snap` property to the options object passed\n\t         * to @Interactable.draggable or @Interactable.resizable instead.\n\t         *\n\t         * Returns or sets if and how action coordinates are snapped. By\n\t         * default, snapping is relative to the pointer coordinates. You can\n\t         * change this by setting the\n\t         * [`elementOrigin`](https://github.com/taye/interact.js/pull/72).\n\t         **\n\t         = (boolean | object) `false` if snap is disabled; object with snap properties if snap is enabled\n\t         **\n\t         * or\n\t         **\n\t         - options (object | boolean | null) #optional\n\t         = (Interactable) this Interactable\n\t         > Usage\n\t         | interact(document.querySelector('#thing')).snap({\n\t         |     targets: [\n\t         |         // snap to this specific point\n\t         |         {\n\t         |             x: 100,\n\t         |             y: 100,\n\t         |             range: 25\n\t         |         },\n\t         |         // give this function the x and y page coords and snap to the object returned\n\t         |         function (x, y) {\n\t         |             return {\n\t         |                 x: x,\n\t         |                 y: (75 + 50 * Math.sin(x * 0.04)),\n\t         |                 range: 40\n\t         |             };\n\t         |         },\n\t         |         // create a function that snaps to a grid\n\t         |         interact.createSnapGrid({\n\t         |             x: 50,\n\t         |             y: 50,\n\t         |             range: 10,              // optional\n\t         |             offset: { x: 5, y: 10 } // optional\n\t         |         })\n\t         |     ],\n\t         |     // do not snap during normal movement.\n\t         |     // Instead, trigger only one snapped move event\n\t         |     // immediately before the end event.\n\t         |     endOnly: true,\n\t         |\n\t         |     relativePoints: [\n\t         |         { x: 0, y: 0 },  // snap relative to the top left of the element\n\t         |         { x: 1, y: 1 },  // and also to the bottom right\n\t         |     ],\n\t         |\n\t         |     // offset the snap target coordinates\n\t         |     // can be an object with x/y or 'startCoords'\n\t         |     offset: { x: 50, y: 50 }\n\t         |   }\n\t         | });\n\t        \\*/\n\t    snap: function snap(options) {\n\t      var ret = this.setOptions('snap', options);\n\t\n\t      if (ret === this) {\n\t        return this;\n\t      }\n\t\n\t      return ret.drag;\n\t    },\n\t\n\t    setOptions: function setOptions(option, options) {\n\t      var actions = options && isArray(options.actions) ? options.actions : ['drag'];\n\t\n\t      var i;\n\t\n\t      if (isObject(options) || isBool(options)) {\n\t        for (i = 0; i < actions.length; i++) {\n\t          var action = /resize/.test(actions[i]) ? 'resize' : actions[i];\n\t\n\t          if (!isObject(this.options[action])) {\n\t            continue;\n\t          }\n\t\n\t          var thisOption = this.options[action][option];\n\t\n\t          if (isObject(options)) {\n\t            extend(thisOption, options);\n\t            thisOption.enabled = options.enabled === false ? false : true;\n\t\n\t            if (option === 'snap') {\n\t              if (thisOption.mode === 'grid') {\n\t                thisOption.targets = [interact.createSnapGrid(extend({\n\t                  offset: thisOption.gridOffset || { x: 0, y: 0 }\n\t                }, thisOption.grid || {}))];\n\t              } else if (thisOption.mode === 'anchor') {\n\t                thisOption.targets = thisOption.anchors;\n\t              } else if (thisOption.mode === 'path') {\n\t                thisOption.targets = thisOption.paths;\n\t              }\n\t\n\t              if ('elementOrigin' in options) {\n\t                thisOption.relativePoints = [options.elementOrigin];\n\t              }\n\t            }\n\t          } else if (isBool(options)) {\n\t            thisOption.enabled = options;\n\t          }\n\t        }\n\t\n\t        return this;\n\t      }\n\t\n\t      var ret = {},\n\t          allActions = ['drag', 'resize', 'gesture'];\n\t\n\t      for (i = 0; i < allActions.length; i++) {\n\t        if (option in defaultOptions[allActions[i]]) {\n\t          ret[allActions[i]] = this.options[allActions[i]][option];\n\t        }\n\t      }\n\t\n\t      return ret;\n\t    },\n\t\n\t    /*\\\n\t         * Interactable.inertia\n\t         [ method ]\n\t         **\n\t         * Deprecated. Add an `inertia` property to the options object passed\n\t         * to @Interactable.draggable or @Interactable.resizable instead.\n\t         *\n\t         * Returns or sets if and how events continue to run after the pointer is released\n\t         **\n\t         = (boolean | object) `false` if inertia is disabled; `object` with inertia properties if inertia is enabled\n\t         **\n\t         * or\n\t         **\n\t         - options (object | boolean | null) #optional\n\t         = (Interactable) this Interactable\n\t         > Usage\n\t         | // enable and use default settings\n\t         | interact(element).inertia(true);\n\t         |\n\t         | // enable and use custom settings\n\t         | interact(element).inertia({\n\t         |     // value greater than 0\n\t         |     // high values slow the object down more quickly\n\t         |     resistance     : 16,\n\t         |\n\t         |     // the minimum launch speed (pixels per second) that results in inertia start\n\t         |     minSpeed       : 200,\n\t         |\n\t         |     // inertia will stop when the object slows down to this speed\n\t         |     endSpeed       : 20,\n\t         |\n\t         |     // boolean; should actions be resumed when the pointer goes down during inertia\n\t         |     allowResume    : true,\n\t         |\n\t         |     // boolean; should the jump when resuming from inertia be ignored in event.dx/dy\n\t         |     zeroResumeDelta: false,\n\t         |\n\t         |     // if snap/restrict are set to be endOnly and inertia is enabled, releasing\n\t         |     // the pointer without triggering inertia will animate from the release\n\t         |     // point to the snaped/restricted point in the given amount of time (ms)\n\t         |     smoothEndDuration: 300,\n\t         |\n\t         |     // an array of action types that can have inertia (no gesture)\n\t         |     actions        : ['drag', 'resize']\n\t         | });\n\t         |\n\t         | // reset custom settings and use all defaults\n\t         | interact(element).inertia(null);\n\t        \\*/\n\t    inertia: function inertia(options) {\n\t      var ret = this.setOptions('inertia', options);\n\t\n\t      if (ret === this) {\n\t        return this;\n\t      }\n\t\n\t      return ret.drag;\n\t    },\n\t\n\t    getAction: function getAction(pointer, event, interaction, element) {\n\t      var action = this.defaultActionChecker(pointer, interaction, element);\n\t\n\t      if (this.options.actionChecker) {\n\t        return this.options.actionChecker(pointer, event, action, this, element, interaction);\n\t      }\n\t\n\t      return action;\n\t    },\n\t\n\t    defaultActionChecker: defaultActionChecker,\n\t\n\t    /*\\\n\t         * Interactable.actionChecker\n\t         [ method ]\n\t         *\n\t         * Gets or sets the function used to check action to be performed on\n\t         * pointerDown\n\t         *\n\t         - checker (function | null) #optional A function which takes a pointer event, defaultAction string, interactable, element and interaction as parameters and returns an object with name property 'drag' 'resize' or 'gesture' and optionally an `edges` object with boolean 'top', 'left', 'bottom' and right props.\n\t         = (Function | Interactable) The checker function or this Interactable\n\t         *\n\t         | interact('.resize-drag')\n\t         |   .resizable(true)\n\t         |   .draggable(true)\n\t         |   .actionChecker(function (pointer, event, action, interactable, element, interaction) {\n\t         |\n\t         |   if (interact.matchesSelector(event.target, '.drag-handle') {\n\t         |     // force drag with handle target\n\t         |     action.name = drag;\n\t         |   }\n\t         |   else {\n\t         |     // resize from the top and right edges\n\t         |     action.name  = 'resize';\n\t         |     action.edges = { top: true, right: true };\n\t         |   }\n\t         |\n\t         |   return action;\n\t         | });\n\t        \\*/\n\t    actionChecker: function actionChecker(checker) {\n\t      if (isFunction(checker)) {\n\t        this.options.actionChecker = checker;\n\t\n\t        return this;\n\t      }\n\t\n\t      if (checker === null) {\n\t        delete this.options.actionChecker;\n\t\n\t        return this;\n\t      }\n\t\n\t      return this.options.actionChecker;\n\t    },\n\t\n\t    /*\\\n\t         * Interactable.getRect\n\t         [ method ]\n\t         *\n\t         * The default function to get an Interactables bounding rect. Can be\n\t         * overridden using @Interactable.rectChecker.\n\t         *\n\t         - element (Element) #optional The element to measure.\n\t         = (object) The object's bounding rectangle.\n\t         o {\n\t         o     top   : 0,\n\t         o     left  : 0,\n\t         o     bottom: 0,\n\t         o     right : 0,\n\t         o     width : 0,\n\t         o     height: 0\n\t         o }\n\t        \\*/\n\t    getRect: function rectCheck(element) {\n\t      element = element || this._element;\n\t\n\t      if (this.selector && !isElement(element)) {\n\t        element = this._context.querySelector(this.selector);\n\t      }\n\t\n\t      return getElementRect(element);\n\t    },\n\t\n\t    /*\\\n\t         * Interactable.rectChecker\n\t         [ method ]\n\t         *\n\t         * Returns or sets the function used to calculate the interactable's\n\t         * element's rectangle\n\t         *\n\t         - checker (function) #optional A function which returns this Interactable's bounding rectangle. See @Interactable.getRect\n\t         = (function | object) The checker function or this Interactable\n\t        \\*/\n\t    rectChecker: function rectChecker(checker) {\n\t      if (isFunction(checker)) {\n\t        this.getRect = checker;\n\t\n\t        return this;\n\t      }\n\t\n\t      if (checker === null) {\n\t        delete this.options.getRect;\n\t\n\t        return this;\n\t      }\n\t\n\t      return this.getRect;\n\t    },\n\t\n\t    /*\\\n\t         * Interactable.styleCursor\n\t         [ method ]\n\t         *\n\t         * Returns or sets whether the action that would be performed when the\n\t         * mouse on the element are checked on `mousemove` so that the cursor\n\t         * may be styled appropriately\n\t         *\n\t         - newValue (boolean) #optional\n\t         = (boolean | Interactable) The current setting or this Interactable\n\t        \\*/\n\t    styleCursor: function styleCursor(newValue) {\n\t      if (isBool(newValue)) {\n\t        this.options.styleCursor = newValue;\n\t\n\t        return this;\n\t      }\n\t\n\t      if (newValue === null) {\n\t        delete this.options.styleCursor;\n\t\n\t        return this;\n\t      }\n\t\n\t      return this.options.styleCursor;\n\t    },\n\t\n\t    /*\\\n\t         * Interactable.preventDefault\n\t         [ method ]\n\t         *\n\t         * Returns or sets whether to prevent the browser's default behaviour\n\t         * in response to pointer events. Can be set to:\n\t         *  - `'always'` to always prevent\n\t         *  - `'never'` to never prevent\n\t         *  - `'auto'` to let interact.js try to determine what would be best\n\t         *\n\t         - newValue (string) #optional `true`, `false` or `'auto'`\n\t         = (string | Interactable) The current setting or this Interactable\n\t        \\*/\n\t    preventDefault: function preventDefault(newValue) {\n\t      if (/^(always|never|auto)$/.test(newValue)) {\n\t        this.options.preventDefault = newValue;\n\t        return this;\n\t      }\n\t\n\t      if (isBool(newValue)) {\n\t        this.options.preventDefault = newValue ? 'always' : 'never';\n\t        return this;\n\t      }\n\t\n\t      return this.options.preventDefault;\n\t    },\n\t\n\t    /*\\\n\t         * Interactable.origin\n\t         [ method ]\n\t         *\n\t         * Gets or sets the origin of the Interactable's element.  The x and y\n\t         * of the origin will be subtracted from action event coordinates.\n\t         *\n\t         - origin (object | string) #optional An object eg. { x: 0, y: 0 } or string 'parent', 'self' or any CSS selector\n\t         * OR\n\t         - origin (Element) #optional An HTML or SVG Element whose rect will be used\n\t         **\n\t         = (object) The current origin or this Interactable\n\t        \\*/\n\t    origin: function origin(newValue) {\n\t      if (trySelector(newValue)) {\n\t        this.options.origin = newValue;\n\t        return this;\n\t      } else if (isObject(newValue)) {\n\t        this.options.origin = newValue;\n\t        return this;\n\t      }\n\t\n\t      return this.options.origin;\n\t    },\n\t\n\t    /*\\\n\t         * Interactable.deltaSource\n\t         [ method ]\n\t         *\n\t         * Returns or sets the mouse coordinate types used to calculate the\n\t         * movement of the pointer.\n\t         *\n\t         - newValue (string) #optional Use 'client' if you will be scrolling while interacting; Use 'page' if you want autoScroll to work\n\t         = (string | object) The current deltaSource or this Interactable\n\t        \\*/\n\t    deltaSource: function deltaSource(newValue) {\n\t      if (newValue === 'page' || newValue === 'client') {\n\t        this.options.deltaSource = newValue;\n\t\n\t        return this;\n\t      }\n\t\n\t      return this.options.deltaSource;\n\t    },\n\t\n\t    /*\\\n\t         * Interactable.restrict\n\t         [ method ]\n\t         **\n\t         * Deprecated. Add a `restrict` property to the options object passed to\n\t         * @Interactable.draggable, @Interactable.resizable or @Interactable.gesturable instead.\n\t         *\n\t         * Returns or sets the rectangles within which actions on this\n\t         * interactable (after snap calculations) are restricted. By default,\n\t         * restricting is relative to the pointer coordinates. You can change\n\t         * this by setting the\n\t         * [`elementRect`](https://github.com/taye/interact.js/pull/72).\n\t         **\n\t         - options (object) #optional an object with keys drag, resize, and/or gesture whose values are rects, Elements, CSS selectors, or 'parent' or 'self'\n\t         = (object) The current restrictions object or this Interactable\n\t         **\n\t         | interact(element).restrict({\n\t         |     // the rect will be `interact.getElementRect(element.parentNode)`\n\t         |     drag: element.parentNode,\n\t         |\n\t         |     // x and y are relative to the the interactable's origin\n\t         |     resize: { x: 100, y: 100, width: 200, height: 200 }\n\t         | })\n\t         |\n\t         | interact('.draggable').restrict({\n\t         |     // the rect will be the selected element's parent\n\t         |     drag: 'parent',\n\t         |\n\t         |     // do not restrict during normal movement.\n\t         |     // Instead, trigger only one restricted move event\n\t         |     // immediately before the end event.\n\t         |     endOnly: true,\n\t         |\n\t         |     // https://github.com/taye/interact.js/pull/72#issue-41813493\n\t         |     elementRect: { top: 0, left: 0, bottom: 1, right: 1 }\n\t         | });\n\t        \\*/\n\t    restrict: function restrict(options) {\n\t      if (!isObject(options)) {\n\t        return this.setOptions('restrict', options);\n\t      }\n\t\n\t      var actions = ['drag', 'resize', 'gesture'],\n\t          ret;\n\t\n\t      for (var i = 0; i < actions.length; i++) {\n\t        var action = actions[i];\n\t\n\t        if (action in options) {\n\t          var perAction = extend({\n\t            actions: [action],\n\t            restriction: options[action]\n\t          }, options);\n\t\n\t          ret = this.setOptions('restrict', perAction);\n\t        }\n\t      }\n\t\n\t      return ret;\n\t    },\n\t\n\t    /*\\\n\t         * Interactable.context\n\t         [ method ]\n\t         *\n\t         * Gets the selector context Node of the Interactable. The default is `window.document`.\n\t         *\n\t         = (Node) The context Node of this Interactable\n\t         **\n\t        \\*/\n\t    context: function context() {\n\t      return this._context;\n\t    },\n\t\n\t    _context: document,\n\t\n\t    /*\\\n\t         * Interactable.ignoreFrom\n\t         [ method ]\n\t         *\n\t         * If the target of the `mousedown`, `pointerdown` or `touchstart`\n\t         * event or any of it's parents match the given CSS selector or\n\t         * Element, no drag/resize/gesture is started.\n\t         *\n\t         - newValue (string | Element | null) #optional a CSS selector string, an Element or `null` to not ignore any elements\n\t         = (string | Element | object) The current ignoreFrom value or this Interactable\n\t         **\n\t         | interact(element, { ignoreFrom: document.getElementById('no-action') });\n\t         | // or\n\t         | interact(element).ignoreFrom('input, textarea, a');\n\t        \\*/\n\t    ignoreFrom: function ignoreFrom(newValue) {\n\t      if (trySelector(newValue)) {\n\t        // CSS selector to match event.target\n\t        this.options.ignoreFrom = newValue;\n\t        return this;\n\t      }\n\t\n\t      if (isElement(newValue)) {\n\t        // specific element\n\t        this.options.ignoreFrom = newValue;\n\t        return this;\n\t      }\n\t\n\t      return this.options.ignoreFrom;\n\t    },\n\t\n\t    /*\\\n\t         * Interactable.allowFrom\n\t         [ method ]\n\t         *\n\t         * A drag/resize/gesture is started only If the target of the\n\t         * `mousedown`, `pointerdown` or `touchstart` event or any of it's\n\t         * parents match the given CSS selector or Element.\n\t         *\n\t         - newValue (string | Element | null) #optional a CSS selector string, an Element or `null` to allow from any element\n\t         = (string | Element | object) The current allowFrom value or this Interactable\n\t         **\n\t         | interact(element, { allowFrom: document.getElementById('drag-handle') });\n\t         | // or\n\t         | interact(element).allowFrom('.handle');\n\t        \\*/\n\t    allowFrom: function allowFrom(newValue) {\n\t      if (trySelector(newValue)) {\n\t        // CSS selector to match event.target\n\t        this.options.allowFrom = newValue;\n\t        return this;\n\t      }\n\t\n\t      if (isElement(newValue)) {\n\t        // specific element\n\t        this.options.allowFrom = newValue;\n\t        return this;\n\t      }\n\t\n\t      return this.options.allowFrom;\n\t    },\n\t\n\t    /*\\\n\t         * Interactable.element\n\t         [ method ]\n\t         *\n\t         * If this is not a selector Interactable, it returns the element this\n\t         * interactable represents\n\t         *\n\t         = (Element) HTML / SVG Element\n\t        \\*/\n\t    element: function element() {\n\t      return this._element;\n\t    },\n\t\n\t    /*\\\n\t         * Interactable.fire\n\t         [ method ]\n\t         *\n\t         * Calls listeners for the given InteractEvent type bound globally\n\t         * and directly to this Interactable\n\t         *\n\t         - iEvent (InteractEvent) The InteractEvent object to be fired on this Interactable\n\t         = (Interactable) this Interactable\n\t        \\*/\n\t    fire: function fire(iEvent) {\n\t      if (!(iEvent && iEvent.type) || !contains(eventTypes, iEvent.type)) {\n\t        return this;\n\t      }\n\t\n\t      var listeners,\n\t          i,\n\t          len,\n\t          onEvent = 'on' + iEvent.type,\n\t          funcName = '';\n\t\n\t      // Interactable#on() listeners\n\t      if (iEvent.type in this._iEvents) {\n\t        listeners = this._iEvents[iEvent.type];\n\t\n\t        for (i = 0, len = listeners.length; i < len && !iEvent.immediatePropagationStopped; i++) {\n\t          funcName = listeners[i].name;\n\t          listeners[i](iEvent);\n\t        }\n\t      }\n\t\n\t      // interactable.onevent listener\n\t      if (isFunction(this[onEvent])) {\n\t        funcName = this[onEvent].name;\n\t        this[onEvent](iEvent);\n\t      }\n\t\n\t      // interact.on() listeners\n\t      if (iEvent.type in globalEvents && (listeners = globalEvents[iEvent.type])) {\n\t        for (i = 0, len = listeners.length; i < len && !iEvent.immediatePropagationStopped; i++) {\n\t          funcName = listeners[i].name;\n\t          listeners[i](iEvent);\n\t        }\n\t      }\n\t\n\t      return this;\n\t    },\n\t\n\t    /*\\\n\t         * Interactable.on\n\t         [ method ]\n\t         *\n\t         * Binds a listener for an InteractEvent or DOM event.\n\t         *\n\t         - eventType  (string | array | object) The types of events to listen for\n\t         - listener   (function) The function to be called on the given event(s)\n\t         - useCapture (boolean) #optional useCapture flag for addEventListener\n\t         = (object) This Interactable\n\t        \\*/\n\t    on: function on(eventType, listener, useCapture) {\n\t      var i;\n\t\n\t      if (isString(eventType) && eventType.search(' ') !== -1) {\n\t        eventType = eventType.trim().split(/ +/);\n\t      }\n\t\n\t      if (isArray(eventType)) {\n\t        for (i = 0; i < eventType.length; i++) {\n\t          this.on(eventType[i], listener, useCapture);\n\t        }\n\t\n\t        return this;\n\t      }\n\t\n\t      if (isObject(eventType)) {\n\t        for (var prop in eventType) {\n\t          this.on(prop, eventType[prop], listener);\n\t        }\n\t\n\t        return this;\n\t      }\n\t\n\t      if (eventType === 'wheel') {\n\t        eventType = wheelEvent;\n\t      }\n\t\n\t      // convert to boolean\n\t      useCapture = useCapture ? true : false;\n\t\n\t      if (contains(eventTypes, eventType)) {\n\t        // if this type of event was never bound to this Interactable\n\t        if (!(eventType in this._iEvents)) {\n\t          this._iEvents[eventType] = [listener];\n\t        } else {\n\t          this._iEvents[eventType].push(listener);\n\t        }\n\t      }\n\t      // delegated event for selector\n\t      else if (this.selector) {\n\t          if (!delegatedEvents[eventType]) {\n\t            delegatedEvents[eventType] = {\n\t              selectors: [],\n\t              contexts: [],\n\t              listeners: []\n\t            };\n\t\n\t            // add delegate listener functions\n\t            for (i = 0; i < documents.length; i++) {\n\t              events.add(documents[i], eventType, delegateListener);\n\t              events.add(documents[i], eventType, delegateUseCapture, true);\n\t            }\n\t          }\n\t\n\t          var delegated = delegatedEvents[eventType],\n\t              index;\n\t\n\t          for (index = delegated.selectors.length - 1; index >= 0; index--) {\n\t            if (delegated.selectors[index] === this.selector && delegated.contexts[index] === this._context) {\n\t              break;\n\t            }\n\t          }\n\t\n\t          if (index === -1) {\n\t            index = delegated.selectors.length;\n\t\n\t            delegated.selectors.push(this.selector);\n\t            delegated.contexts.push(this._context);\n\t            delegated.listeners.push([]);\n\t          }\n\t\n\t          // keep listener and useCapture flag\n\t          delegated.listeners[index].push([listener, useCapture]);\n\t        } else {\n\t          events.add(this._element, eventType, listener, useCapture);\n\t        }\n\t\n\t      return this;\n\t    },\n\t\n\t    /*\\\n\t         * Interactable.off\n\t         [ method ]\n\t         *\n\t         * Removes an InteractEvent or DOM event listener\n\t         *\n\t         - eventType  (string | array | object) The types of events that were listened for\n\t         - listener   (function) The listener function to be removed\n\t         - useCapture (boolean) #optional useCapture flag for removeEventListener\n\t         = (object) This Interactable\n\t        \\*/\n\t    off: function off(eventType, listener, useCapture) {\n\t      var i;\n\t\n\t      if (isString(eventType) && eventType.search(' ') !== -1) {\n\t        eventType = eventType.trim().split(/ +/);\n\t      }\n\t\n\t      if (isArray(eventType)) {\n\t        for (i = 0; i < eventType.length; i++) {\n\t          this.off(eventType[i], listener, useCapture);\n\t        }\n\t\n\t        return this;\n\t      }\n\t\n\t      if (isObject(eventType)) {\n\t        for (var prop in eventType) {\n\t          this.off(prop, eventType[prop], listener);\n\t        }\n\t\n\t        return this;\n\t      }\n\t\n\t      var eventList,\n\t          index = -1;\n\t\n\t      // convert to boolean\n\t      useCapture = useCapture ? true : false;\n\t\n\t      if (eventType === 'wheel') {\n\t        eventType = wheelEvent;\n\t      }\n\t\n\t      // if it is an action event type\n\t      if (contains(eventTypes, eventType)) {\n\t        eventList = this._iEvents[eventType];\n\t\n\t        if (eventList && (index = indexOf(eventList, listener)) !== -1) {\n\t          this._iEvents[eventType].splice(index, 1);\n\t        }\n\t      }\n\t      // delegated event\n\t      else if (this.selector) {\n\t          var delegated = delegatedEvents[eventType],\n\t              matchFound = false;\n\t\n\t          if (!delegated) {\n\t            return this;\n\t          }\n\t\n\t          // count from last index of delegated to 0\n\t          for (index = delegated.selectors.length - 1; index >= 0; index--) {\n\t            // look for matching selector and context Node\n\t            if (delegated.selectors[index] === this.selector && delegated.contexts[index] === this._context) {\n\t              var listeners = delegated.listeners[index];\n\t\n\t              // each item of the listeners array is an array: [function, useCaptureFlag]\n\t              for (i = listeners.length - 1; i >= 0; i--) {\n\t                var fn = listeners[i][0],\n\t                    useCap = listeners[i][1];\n\t\n\t                // check if the listener functions and useCapture flags match\n\t                if (fn === listener && useCap === useCapture) {\n\t                  // remove the listener from the array of listeners\n\t                  listeners.splice(i, 1);\n\t\n\t                  // if all listeners for this interactable have been removed\n\t                  // remove the interactable from the delegated arrays\n\t                  if (!listeners.length) {\n\t                    delegated.selectors.splice(index, 1);\n\t                    delegated.contexts.splice(index, 1);\n\t                    delegated.listeners.splice(index, 1);\n\t\n\t                    // remove delegate function from context\n\t                    events.remove(this._context, eventType, delegateListener);\n\t                    events.remove(this._context, eventType, delegateUseCapture, true);\n\t\n\t                    // remove the arrays if they are empty\n\t                    if (!delegated.selectors.length) {\n\t                      delegatedEvents[eventType] = null;\n\t                    }\n\t                  }\n\t\n\t                  // only remove one listener\n\t                  matchFound = true;\n\t                  break;\n\t                }\n\t              }\n\t\n\t              if (matchFound) {\n\t                break;\n\t              }\n\t            }\n\t          }\n\t        }\n\t        // remove listener from this Interatable's element\n\t        else {\n\t            events.remove(this._element, eventType, listener, useCapture);\n\t          }\n\t\n\t      return this;\n\t    },\n\t\n\t    /*\\\n\t         * Interactable.set\n\t         [ method ]\n\t         *\n\t         * Reset the options of this Interactable\n\t         - options (object) The new settings to apply\n\t         = (object) This Interactable\n\t        \\*/\n\t    set: function set(options) {\n\t      if (!isObject(options)) {\n\t        options = {};\n\t      }\n\t\n\t      this.options = extend({}, defaultOptions.base);\n\t\n\t      var i,\n\t          actions = ['drag', 'drop', 'resize', 'gesture'],\n\t          methods = ['draggable', 'dropzone', 'resizable', 'gesturable'],\n\t          perActions = extend(extend({}, defaultOptions.perAction), options[action] || {});\n\t\n\t      for (i = 0; i < actions.length; i++) {\n\t        var action = actions[i];\n\t\n\t        this.options[action] = extend({}, defaultOptions[action]);\n\t\n\t        this.setPerAction(action, perActions);\n\t\n\t        this[methods[i]](options[action]);\n\t      }\n\t\n\t      var settings = ['accept', 'actionChecker', 'allowFrom', 'deltaSource', 'dropChecker', 'ignoreFrom', 'origin', 'preventDefault', 'rectChecker', 'styleCursor'];\n\t\n\t      for (i = 0, len = settings.length; i < len; i++) {\n\t        var setting = settings[i];\n\t\n\t        this.options[setting] = defaultOptions.base[setting];\n\t\n\t        if (setting in options) {\n\t          this[setting](options[setting]);\n\t        }\n\t      }\n\t\n\t      return this;\n\t    },\n\t\n\t    /*\\\n\t         * Interactable.unset\n\t         [ method ]\n\t         *\n\t         * Remove this interactable from the list of interactables and remove\n\t         * it's drag, drop, resize and gesture capabilities\n\t         *\n\t         = (object) @interact\n\t        \\*/\n\t    unset: function unset() {\n\t      events.remove(this._element, 'all');\n\t\n\t      if (!isString(this.selector)) {\n\t        events.remove(this, 'all');\n\t        if (this.options.styleCursor) {\n\t          this._element.style.cursor = '';\n\t        }\n\t      } else {\n\t        // remove delegated events\n\t        for (var type in delegatedEvents) {\n\t          var delegated = delegatedEvents[type];\n\t\n\t          for (var i = 0; i < delegated.selectors.length; i++) {\n\t            if (delegated.selectors[i] === this.selector && delegated.contexts[i] === this._context) {\n\t              delegated.selectors.splice(i, 1);\n\t              delegated.contexts.splice(i, 1);\n\t              delegated.listeners.splice(i, 1);\n\t\n\t              // remove the arrays if they are empty\n\t              if (!delegated.selectors.length) {\n\t                delegatedEvents[type] = null;\n\t              }\n\t            }\n\t\n\t            events.remove(this._context, type, delegateListener);\n\t            events.remove(this._context, type, delegateUseCapture, true);\n\t\n\t            break;\n\t          }\n\t        }\n\t      }\n\t\n\t      this.dropzone(false);\n\t\n\t      interactables.splice(indexOf(interactables, this), 1);\n\t\n\t      return interact;\n\t    }\n\t  };\n\t\n\t  function warnOnce(method, message) {\n\t    var warned = false;\n\t\n\t    return function () {\n\t      if (!warned) {\n\t        window.console.warn(message);\n\t        warned = true;\n\t      }\n\t\n\t      return method.apply(this, arguments);\n\t    };\n\t  }\n\t\n\t  Interactable.prototype.snap = warnOnce(Interactable.prototype.snap, 'Interactable#snap is deprecated. See the new documentation for snapping at http://interactjs.io/docs/snapping');\n\t  Interactable.prototype.restrict = warnOnce(Interactable.prototype.restrict, 'Interactable#restrict is deprecated. See the new documentation for resticting at http://interactjs.io/docs/restriction');\n\t  Interactable.prototype.inertia = warnOnce(Interactable.prototype.inertia, 'Interactable#inertia is deprecated. See the new documentation for inertia at http://interactjs.io/docs/inertia');\n\t  Interactable.prototype.autoScroll = warnOnce(Interactable.prototype.autoScroll, 'Interactable#autoScroll is deprecated. See the new documentation for autoScroll at http://interactjs.io/docs/#autoscroll');\n\t  Interactable.prototype.squareResize = warnOnce(Interactable.prototype.squareResize, 'Interactable#squareResize is deprecated. See http://interactjs.io/docs/#resize-square');\n\t\n\t  Interactable.prototype.accept = warnOnce(Interactable.prototype.accept, 'Interactable#accept is deprecated. use Interactable#dropzone({ accept: target }) instead');\n\t  Interactable.prototype.dropChecker = warnOnce(Interactable.prototype.dropChecker, 'Interactable#dropChecker is deprecated. use Interactable#dropzone({ dropChecker: checkerFunction }) instead');\n\t  Interactable.prototype.context = warnOnce(Interactable.prototype.context, 'Interactable#context as a method is deprecated. It will soon be a DOM Node instead');\n\t\n\t  /*\\\n\t     * interact.isSet\n\t     [ method ]\n\t     *\n\t     * Check if an element has been set\n\t     - element (Element) The Element being searched for\n\t     = (boolean) Indicates if the element or CSS selector was previously passed to interact\n\t    \\*/\n\t  interact.isSet = function (element, options) {\n\t    return interactables.indexOfElement(element, options && options.context) !== -1;\n\t  };\n\t\n\t  /*\\\n\t     * interact.on\n\t     [ method ]\n\t     *\n\t     * Adds a global listener for an InteractEvent or adds a DOM event to\n\t     * `document`\n\t     *\n\t     - type       (string | array | object) The types of events to listen for\n\t     - listener   (function) The function to be called on the given event(s)\n\t     - useCapture (boolean) #optional useCapture flag for addEventListener\n\t     = (object) interact\n\t    \\*/\n\t  interact.on = function (type, listener, useCapture) {\n\t    if (isString(type) && type.search(' ') !== -1) {\n\t      type = type.trim().split(/ +/);\n\t    }\n\t\n\t    if (isArray(type)) {\n\t      for (var i = 0; i < type.length; i++) {\n\t        interact.on(type[i], listener, useCapture);\n\t      }\n\t\n\t      return interact;\n\t    }\n\t\n\t    if (isObject(type)) {\n\t      for (var prop in type) {\n\t        interact.on(prop, type[prop], listener);\n\t      }\n\t\n\t      return interact;\n\t    }\n\t\n\t    // if it is an InteractEvent type, add listener to globalEvents\n\t    if (contains(eventTypes, type)) {\n\t      // if this type of event was never bound\n\t      if (!globalEvents[type]) {\n\t        globalEvents[type] = [listener];\n\t      } else {\n\t        globalEvents[type].push(listener);\n\t      }\n\t    }\n\t    // If non InteractEvent type, addEventListener to document\n\t    else {\n\t        events.add(document, type, listener, useCapture);\n\t      }\n\t\n\t    return interact;\n\t  };\n\t\n\t  /*\\\n\t     * interact.off\n\t     [ method ]\n\t     *\n\t     * Removes a global InteractEvent listener or DOM event from `document`\n\t     *\n\t     - type       (string | array | object) The types of events that were listened for\n\t     - listener   (function) The listener function to be removed\n\t     - useCapture (boolean) #optional useCapture flag for removeEventListener\n\t     = (object) interact\n\t     \\*/\n\t  interact.off = function (type, listener, useCapture) {\n\t    if (isString(type) && type.search(' ') !== -1) {\n\t      type = type.trim().split(/ +/);\n\t    }\n\t\n\t    if (isArray(type)) {\n\t      for (var i = 0; i < type.length; i++) {\n\t        interact.off(type[i], listener, useCapture);\n\t      }\n\t\n\t      return interact;\n\t    }\n\t\n\t    if (isObject(type)) {\n\t      for (var prop in type) {\n\t        interact.off(prop, type[prop], listener);\n\t      }\n\t\n\t      return interact;\n\t    }\n\t\n\t    if (!contains(eventTypes, type)) {\n\t      events.remove(document, type, listener, useCapture);\n\t    } else {\n\t      var index;\n\t\n\t      if (type in globalEvents && (index = indexOf(globalEvents[type], listener)) !== -1) {\n\t        globalEvents[type].splice(index, 1);\n\t      }\n\t    }\n\t\n\t    return interact;\n\t  };\n\t\n\t  /*\\\n\t     * interact.enableDragging\n\t     [ method ]\n\t     *\n\t     * Deprecated.\n\t     *\n\t     * Returns or sets whether dragging is enabled for any Interactables\n\t     *\n\t     - newValue (boolean) #optional `true` to allow the action; `false` to disable action for all Interactables\n\t     = (boolean | object) The current setting or interact\n\t    \\*/\n\t  interact.enableDragging = warnOnce(function (newValue) {\n\t    if (newValue !== null && newValue !== undefined) {\n\t      actionIsEnabled.drag = newValue;\n\t\n\t      return interact;\n\t    }\n\t    return actionIsEnabled.drag;\n\t  }, 'interact.enableDragging is deprecated and will soon be removed.');\n\t\n\t  /*\\\n\t     * interact.enableResizing\n\t     [ method ]\n\t     *\n\t     * Deprecated.\n\t     *\n\t     * Returns or sets whether resizing is enabled for any Interactables\n\t     *\n\t     - newValue (boolean) #optional `true` to allow the action; `false` to disable action for all Interactables\n\t     = (boolean | object) The current setting or interact\n\t    \\*/\n\t  interact.enableResizing = warnOnce(function (newValue) {\n\t    if (newValue !== null && newValue !== undefined) {\n\t      actionIsEnabled.resize = newValue;\n\t\n\t      return interact;\n\t    }\n\t    return actionIsEnabled.resize;\n\t  }, 'interact.enableResizing is deprecated and will soon be removed.');\n\t\n\t  /*\\\n\t     * interact.enableGesturing\n\t     [ method ]\n\t     *\n\t     * Deprecated.\n\t     *\n\t     * Returns or sets whether gesturing is enabled for any Interactables\n\t     *\n\t     - newValue (boolean) #optional `true` to allow the action; `false` to disable action for all Interactables\n\t     = (boolean | object) The current setting or interact\n\t    \\*/\n\t  interact.enableGesturing = warnOnce(function (newValue) {\n\t    if (newValue !== null && newValue !== undefined) {\n\t      actionIsEnabled.gesture = newValue;\n\t\n\t      return interact;\n\t    }\n\t    return actionIsEnabled.gesture;\n\t  }, 'interact.enableGesturing is deprecated and will soon be removed.');\n\t\n\t  interact.eventTypes = eventTypes;\n\t\n\t  /*\\\n\t     * interact.debug\n\t     [ method ]\n\t     *\n\t     * Returns debugging data\n\t     = (object) An object with properties that outline the current state and expose internal functions and variables\n\t    \\*/\n\t  interact.debug = function () {\n\t    var interaction = interactions[0] || new Interaction();\n\t\n\t    return {\n\t      interactions: interactions,\n\t      target: interaction.target,\n\t      dragging: interaction.dragging,\n\t      resizing: interaction.resizing,\n\t      gesturing: interaction.gesturing,\n\t      prepared: interaction.prepared,\n\t      matches: interaction.matches,\n\t      matchElements: interaction.matchElements,\n\t\n\t      prevCoords: interaction.prevCoords,\n\t      startCoords: interaction.startCoords,\n\t\n\t      pointerIds: interaction.pointerIds,\n\t      pointers: interaction.pointers,\n\t      addPointer: listeners.addPointer,\n\t      removePointer: listeners.removePointer,\n\t      recordPointer: listeners.recordPointer,\n\t\n\t      snap: interaction.snapStatus,\n\t      restrict: interaction.restrictStatus,\n\t      inertia: interaction.inertiaStatus,\n\t\n\t      downTime: interaction.downTimes[0],\n\t      downEvent: interaction.downEvent,\n\t      downPointer: interaction.downPointer,\n\t      prevEvent: interaction.prevEvent,\n\t\n\t      Interactable: Interactable,\n\t      interactables: interactables,\n\t      pointerIsDown: interaction.pointerIsDown,\n\t      defaultOptions: defaultOptions,\n\t      defaultActionChecker: defaultActionChecker,\n\t\n\t      actionCursors: actionCursors,\n\t      dragMove: listeners.dragMove,\n\t      resizeMove: listeners.resizeMove,\n\t      gestureMove: listeners.gestureMove,\n\t      pointerUp: listeners.pointerUp,\n\t      pointerDown: listeners.pointerDown,\n\t      pointerMove: listeners.pointerMove,\n\t      pointerHover: listeners.pointerHover,\n\t\n\t      eventTypes: eventTypes,\n\t\n\t      events: events,\n\t      globalEvents: globalEvents,\n\t      delegatedEvents: delegatedEvents,\n\t\n\t      prefixedPropREs: prefixedPropREs\n\t    };\n\t  };\n\t\n\t  // expose the functions used to calculate multi-touch properties\n\t  interact.getPointerAverage = pointerAverage;\n\t  interact.getTouchBBox = touchBBox;\n\t  interact.getTouchDistance = touchDistance;\n\t  interact.getTouchAngle = touchAngle;\n\t\n\t  interact.getElementRect = getElementRect;\n\t  interact.getElementClientRect = getElementClientRect;\n\t  interact.matchesSelector = matchesSelector;\n\t  interact.closest = closest;\n\t\n\t  /*\\\n\t     * interact.margin\n\t     [ method ]\n\t     *\n\t     * Deprecated. Use `interact(target).resizable({ margin: number });` instead.\n\t     * Returns or sets the margin for autocheck resizing used in\n\t     * @Interactable.getAction. That is the distance from the bottom and right\n\t     * edges of an element clicking in which will start resizing\n\t     *\n\t     - newValue (number) #optional\n\t     = (number | interact) The current margin value or interact\n\t    \\*/\n\t  interact.margin = warnOnce(function (newvalue) {\n\t    if (isNumber(newvalue)) {\n\t      margin = newvalue;\n\t\n\t      return interact;\n\t    }\n\t    return margin;\n\t  }, 'interact.margin is deprecated. Use interact(target).resizable({ margin: number }); instead.');\n\t\n\t  /*\\\n\t     * interact.supportsTouch\n\t     [ method ]\n\t     *\n\t     = (boolean) Whether or not the browser supports touch input\n\t    \\*/\n\t  interact.supportsTouch = function () {\n\t    return supportsTouch;\n\t  };\n\t\n\t  /*\\\n\t     * interact.supportsPointerEvent\n\t     [ method ]\n\t     *\n\t     = (boolean) Whether or not the browser supports PointerEvents\n\t    \\*/\n\t  interact.supportsPointerEvent = function () {\n\t    return supportsPointerEvent;\n\t  };\n\t\n\t  /*\\\n\t     * interact.stop\n\t     [ method ]\n\t     *\n\t     * Cancels all interactions (end events are not fired)\n\t     *\n\t     - event (Event) An event on which to call preventDefault()\n\t     = (object) interact\n\t    \\*/\n\t  interact.stop = function (event) {\n\t    for (var i = interactions.length - 1; i >= 0; i--) {\n\t      interactions[i].stop(event);\n\t    }\n\t\n\t    return interact;\n\t  };\n\t\n\t  /*\\\n\t     * interact.dynamicDrop\n\t     [ method ]\n\t     *\n\t     * Returns or sets whether the dimensions of dropzone elements are\n\t     * calculated on every dragmove or only on dragstart for the default\n\t     * dropChecker\n\t     *\n\t     - newValue (boolean) #optional True to check on each move. False to check only before start\n\t     = (boolean | interact) The current setting or interact\n\t    \\*/\n\t  interact.dynamicDrop = function (newValue) {\n\t    if (isBool(newValue)) {\n\t      //if (dragging && dynamicDrop !== newValue && !newValue) {\n\t      //calcRects(dropzones);\n\t      //}\n\t\n\t      dynamicDrop = newValue;\n\t\n\t      return interact;\n\t    }\n\t    return dynamicDrop;\n\t  };\n\t\n\t  /*\\\n\t     * interact.pointerMoveTolerance\n\t     [ method ]\n\t     * Returns or sets the distance the pointer must be moved before an action\n\t     * sequence occurs. This also affects tolerance for tap events.\n\t     *\n\t     - newValue (number) #optional The movement from the start position must be greater than this value\n\t     = (number | Interactable) The current setting or interact\n\t    \\*/\n\t  interact.pointerMoveTolerance = function (newValue) {\n\t    if (isNumber(newValue)) {\n\t      pointerMoveTolerance = newValue;\n\t\n\t      return this;\n\t    }\n\t\n\t    return pointerMoveTolerance;\n\t  };\n\t\n\t  /*\\\n\t     * interact.maxInteractions\n\t     [ method ]\n\t     **\n\t     * Returns or sets the maximum number of concurrent interactions allowed.\n\t     * By default only 1 interaction is allowed at a time (for backwards\n\t     * compatibility). To allow multiple interactions on the same Interactables\n\t     * and elements, you need to enable it in the draggable, resizable and\n\t     * gesturable `'max'` and `'maxPerElement'` options.\n\t     **\n\t     - newValue (number) #optional Any number. newValue <= 0 means no interactions.\n\t    \\*/\n\t  interact.maxInteractions = function (newValue) {\n\t    if (isNumber(newValue)) {\n\t      maxInteractions = newValue;\n\t\n\t      return this;\n\t    }\n\t\n\t    return maxInteractions;\n\t  };\n\t\n\t  interact.createSnapGrid = function (grid) {\n\t    return function (x, y) {\n\t      var offsetX = 0,\n\t          offsetY = 0;\n\t\n\t      if (isObject(grid.offset)) {\n\t        offsetX = grid.offset.x;\n\t        offsetY = grid.offset.y;\n\t      }\n\t\n\t      var gridx = Math.round((x - offsetX) / grid.x),\n\t          gridy = Math.round((y - offsetY) / grid.y),\n\t          newX = gridx * grid.x + offsetX,\n\t          newY = gridy * grid.y + offsetY;\n\t\n\t      return {\n\t        x: newX,\n\t        y: newY,\n\t        range: grid.range\n\t      };\n\t    };\n\t  };\n\t\n\t  function endAllInteractions(event) {\n\t    for (var i = 0; i < interactions.length; i++) {\n\t      interactions[i].pointerEnd(event, event);\n\t    }\n\t  }\n\t\n\t  function listenToDocument(doc) {\n\t    if (contains(documents, doc)) {\n\t      return;\n\t    }\n\t\n\t    var win = doc.defaultView || doc.parentWindow;\n\t\n\t    // add delegate event listener\n\t    for (var eventType in delegatedEvents) {\n\t      events.add(doc, eventType, delegateListener);\n\t      events.add(doc, eventType, delegateUseCapture, true);\n\t    }\n\t\n\t    if (supportsPointerEvent) {\n\t      if (PointerEvent === win.MSPointerEvent) {\n\t        pEventTypes = {\n\t          up: 'MSPointerUp',\n\t          down: 'MSPointerDown',\n\t          over: 'mouseover',\n\t          out: 'mouseout',\n\t          move: 'MSPointerMove',\n\t          cancel: 'MSPointerCancel'\n\t        };\n\t      } else {\n\t        pEventTypes = {\n\t          up: 'pointerup',\n\t          down: 'pointerdown',\n\t          over: 'pointerover',\n\t          out: 'pointerout',\n\t          move: 'pointermove',\n\t          cancel: 'pointercancel'\n\t        };\n\t      }\n\t\n\t      events.add(doc, pEventTypes.down, listeners.selectorDown);\n\t      events.add(doc, pEventTypes.move, listeners.pointerMove);\n\t      events.add(doc, pEventTypes.over, listeners.pointerOver);\n\t      events.add(doc, pEventTypes.out, listeners.pointerOut);\n\t      events.add(doc, pEventTypes.up, listeners.pointerUp);\n\t      events.add(doc, pEventTypes.cancel, listeners.pointerCancel);\n\t\n\t      // autoscroll\n\t      events.add(doc, pEventTypes.move, listeners.autoScrollMove);\n\t    } else {\n\t      events.add(doc, 'mousedown', listeners.selectorDown);\n\t      events.add(doc, 'mousemove', listeners.pointerMove);\n\t      events.add(doc, 'mouseup', listeners.pointerUp);\n\t      events.add(doc, 'mouseover', listeners.pointerOver);\n\t      events.add(doc, 'mouseout', listeners.pointerOut);\n\t\n\t      events.add(doc, 'touchstart', listeners.selectorDown);\n\t      events.add(doc, 'touchmove', listeners.pointerMove);\n\t      events.add(doc, 'touchend', listeners.pointerUp);\n\t      events.add(doc, 'touchcancel', listeners.pointerCancel);\n\t\n\t      // autoscroll\n\t      events.add(doc, 'mousemove', listeners.autoScrollMove);\n\t      events.add(doc, 'touchmove', listeners.autoScrollMove);\n\t    }\n\t\n\t    events.add(win, 'blur', endAllInteractions);\n\t\n\t    try {\n\t      if (win.frameElement) {\n\t        var parentDoc = win.frameElement.ownerDocument,\n\t            parentWindow = parentDoc.defaultView;\n\t\n\t        events.add(parentDoc, 'mouseup', listeners.pointerEnd);\n\t        events.add(parentDoc, 'touchend', listeners.pointerEnd);\n\t        events.add(parentDoc, 'touchcancel', listeners.pointerEnd);\n\t        events.add(parentDoc, 'pointerup', listeners.pointerEnd);\n\t        events.add(parentDoc, 'MSPointerUp', listeners.pointerEnd);\n\t        events.add(parentWindow, 'blur', endAllInteractions);\n\t      }\n\t    } catch (error) {\n\t      interact.windowParentError = error;\n\t    }\n\t\n\t    // prevent native HTML5 drag on interact.js target elements\n\t    events.add(doc, 'dragstart', function (event) {\n\t      for (var i = 0; i < interactions.length; i++) {\n\t        var interaction = interactions[i];\n\t\n\t        if (interaction.element && (interaction.element === event.target || nodeContains(interaction.element, event.target))) {\n\t          interaction.checkAndPreventDefault(event, interaction.target, interaction.element);\n\t          return;\n\t        }\n\t      }\n\t    });\n\t\n\t    if (events.useAttachEvent) {\n\t      // For IE's lack of Event#preventDefault\n\t      events.add(doc, 'selectstart', function (event) {\n\t        var interaction = interactions[0];\n\t\n\t        if (interaction.currentAction()) {\n\t          interaction.checkAndPreventDefault(event);\n\t        }\n\t      });\n\t\n\t      // For IE's bad dblclick event sequence\n\t      events.add(doc, 'dblclick', doOnInteractions('ie8Dblclick'));\n\t    }\n\t\n\t    documents.push(doc);\n\t  }\n\t\n\t  listenToDocument(document);\n\t\n\t  function indexOf(array, target) {\n\t    for (var i = 0, len = array.length; i < len; i++) {\n\t      if (array[i] === target) {\n\t        return i;\n\t      }\n\t    }\n\t\n\t    return -1;\n\t  }\n\t\n\t  function contains(array, target) {\n\t    return indexOf(array, target) !== -1;\n\t  }\n\t\n\t  function matchesSelector(element, selector, nodeList) {\n\t    if (ie8MatchesSelector) {\n\t      return ie8MatchesSelector(element, selector, nodeList);\n\t    }\n\t\n\t    // remove /deep/ from selectors if shadowDOM polyfill is used\n\t    if (window !== realWindow) {\n\t      selector = selector.replace(/\\/deep\\//g, ' ');\n\t    }\n\t\n\t    return element[prefixedMatchesSelector](selector);\n\t  }\n\t\n\t  function matchesUpTo(element, selector, limit) {\n\t    while (isElement(element)) {\n\t      if (matchesSelector(element, selector)) {\n\t        return true;\n\t      }\n\t\n\t      element = parentElement(element);\n\t\n\t      if (element === limit) {\n\t        return matchesSelector(element, selector);\n\t      }\n\t    }\n\t\n\t    return false;\n\t  }\n\t\n\t  // For IE8's lack of an Element#matchesSelector\n\t  // taken from http://tanalin.com/en/blog/2012/12/matches-selector-ie8/ and modified\n\t  if (!(prefixedMatchesSelector in Element.prototype) || !isFunction(Element.prototype[prefixedMatchesSelector])) {\n\t    ie8MatchesSelector = function ie8MatchesSelector(element, selector, elems) {\n\t      elems = elems || element.parentNode.querySelectorAll(selector);\n\t\n\t      for (var i = 0, len = elems.length; i < len; i++) {\n\t        if (elems[i] === element) {\n\t          return true;\n\t        }\n\t      }\n\t\n\t      return false;\n\t    };\n\t  }\n\t\n\t  // requestAnimationFrame polyfill\n\t  (function () {\n\t    var lastTime = 0,\n\t        vendors = ['ms', 'moz', 'webkit', 'o'];\n\t\n\t    for (var x = 0; x < vendors.length && !realWindow.requestAnimationFrame; ++x) {\n\t      reqFrame = realWindow[vendors[x] + 'RequestAnimationFrame'];\n\t      cancelFrame = realWindow[vendors[x] + 'CancelAnimationFrame'] || realWindow[vendors[x] + 'CancelRequestAnimationFrame'];\n\t    }\n\t\n\t    if (!reqFrame) {\n\t      reqFrame = function reqFrame(callback) {\n\t        var currTime = new Date().getTime(),\n\t            timeToCall = Math.max(0, 16 - (currTime - lastTime)),\n\t            id = setTimeout(function () {\n\t          callback(currTime + timeToCall);\n\t        }, timeToCall);\n\t        lastTime = currTime + timeToCall;\n\t        return id;\n\t      };\n\t    }\n\t\n\t    if (!cancelFrame) {\n\t      cancelFrame = function cancelFrame(id) {\n\t        clearTimeout(id);\n\t      };\n\t    }\n\t  })();\n\t\n\t  /* global exports: true, module, define */\n\t\n\t  // http://documentcloud.github.io/underscore/docs/underscore.html#section-11\n\t  if (true) {\n\t    if (typeof module !== 'undefined' && module.exports) {\n\t      exports = module.exports = interact;\n\t    }\n\t    exports.interact = interact;\n\t  }\n\t  // AMD\n\t  else if (typeof define === 'function' && define.amd) {\n\t      define('interact', function () {\n\t        return interact;\n\t      });\n\t    } else {\n\t      realWindow.interact = interact;\n\t    }\n\t})(typeof window === 'undefined' ? undefined : window);\n\n/***/ })\n/******/ ]);\n\n\n// WEBPACK FOOTER //\n// interact.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 118ae0e52e5cacaf4382","/**\n * interact.js v1.2.6\n *\n * Copyright (c) 2012-2015 Taye Adeyemi <dev@taye.me>\n * Open source under the MIT License.\n * https://raw.github.com/taye/interact.js/master/LICENSE\n *\n * This file has been monkey patched to pass the originalEvent on to drag events\n */\n(function(realWindow) {\n  'use strict';\n\n  // return early if there's no window to work with (eg. Node.js)\n  if (!realWindow) {\n    return;\n  }\n\n  var // get wrapped window if using Shadow DOM polyfill\n    window = (function() {\n      // create a TextNode\n      var el = realWindow.document.createTextNode('');\n\n      // check if it's wrapped by a polyfill\n      if (\n        el.ownerDocument !== realWindow.document &&\n        typeof realWindow.wrap === 'function' &&\n        realWindow.wrap(el) === el\n      ) {\n        // return wrapped window\n        return realWindow.wrap(realWindow);\n      }\n\n      // no Shadow DOM polyfil or native implementation\n      return realWindow;\n    })(),\n    document = window.document,\n    DocumentFragment = window.DocumentFragment || blank,\n    SVGElement = window.SVGElement || blank,\n    SVGSVGElement = window.SVGSVGElement || blank,\n    SVGElementInstance = window.SVGElementInstance || blank,\n    HTMLElement = window.HTMLElement || window.Element,\n    PointerEvent = window.PointerEvent || window.MSPointerEvent,\n    pEventTypes,\n    hypot =\n      Math.hypot ||\n      function(x, y) {\n        return Math.sqrt(x * x + y * y);\n      },\n    tmpXY = {}, // reduce object creation in getXY()\n    documents = [], // all documents being listened to\n    interactables = [], // all set interactables\n    interactions = [], // all interactions\n    dynamicDrop = false,\n    // {\n    //      type: {\n    //          selectors: ['selector', ...],\n    //          contexts : [document, ...],\n    //          listeners: [[listener, useCapture], ...]\n    //      }\n    //  }\n    delegatedEvents = {},\n    defaultOptions = {\n      base: {\n        accept: null,\n        actionChecker: null,\n        styleCursor: true,\n        preventDefault: 'auto',\n        origin: {x: 0, y: 0},\n        deltaSource: 'page',\n        allowFrom: null,\n        ignoreFrom: null,\n        _context: document,\n        dropChecker: null\n      },\n\n      drag: {\n        enabled: false,\n        manualStart: true,\n        max: Infinity,\n        maxPerElement: 1,\n\n        snap: null,\n        restrict: null,\n        inertia: null,\n        autoScroll: null,\n\n        axis: 'xy'\n      },\n\n      drop: {\n        enabled: false,\n        accept: null,\n        overlap: 'pointer'\n      },\n\n      resize: {\n        enabled: false,\n        manualStart: false,\n        max: Infinity,\n        maxPerElement: 1,\n\n        snap: null,\n        restrict: null,\n        inertia: null,\n        autoScroll: null,\n\n        square: false,\n        preserveAspectRatio: false,\n        axis: 'xy',\n\n        // use default margin\n        margin: NaN,\n\n        // object with props left, right, top, bottom which are\n        // true/false values to resize when the pointer is over that edge,\n        // CSS selectors to match the handles for each direction\n        // or the Elements for each handle\n        edges: null,\n\n        // a value of 'none' will limit the resize rect to a minimum of 0x0\n        // 'negate' will alow the rect to have negative width/height\n        // 'reposition' will keep the width/height positive by swapping\n        // the top and bottom edges and/or swapping the left and right edges\n        invert: 'none'\n      },\n\n      gesture: {\n        manualStart: false,\n        enabled: false,\n        max: Infinity,\n        maxPerElement: 1,\n\n        restrict: null\n      },\n\n      perAction: {\n        manualStart: false,\n        max: Infinity,\n        maxPerElement: 1,\n\n        snap: {\n          enabled: false,\n          endOnly: false,\n          range: Infinity,\n          targets: null,\n          offsets: null,\n\n          relativePoints: null\n        },\n\n        restrict: {\n          enabled: false,\n          endOnly: false\n        },\n\n        autoScroll: {\n          enabled: false,\n          container: null, // the item that is scrolled (Window or HTMLElement)\n          margin: 60,\n          speed: 300 // the scroll speed in pixels per second\n        },\n\n        inertia: {\n          enabled: false,\n          resistance: 10, // the lambda in exponential decay\n          minSpeed: 100, // target speed must be above this for inertia to start\n          endSpeed: 10, // the speed at which inertia is slow enough to stop\n          allowResume: true, // allow resuming an action in inertia phase\n          zeroResumeDelta: true, // if an action is resumed after launch, set dx/dy to 0\n          smoothEndDuration: 300 // animate to snap/restrict endOnly if there's no inertia\n        }\n      },\n\n      _holdDuration: 600\n    },\n    // Things related to autoScroll\n    autoScroll = {\n      interaction: null,\n      i: null, // the handle returned by window.setInterval\n      x: 0,\n      y: 0, // Direction each pulse is to scroll in\n\n      // scroll the window by the values in scroll.x/y\n      scroll: function() {\n        var options =\n            autoScroll.interaction.target.options[\n              autoScroll.interaction.prepared.name\n            ].autoScroll,\n          container =\n            options.container || getWindow(autoScroll.interaction.element),\n          now = new Date().getTime(),\n          // change in time in seconds\n          dtx = (now - autoScroll.prevTimeX) / 1000,\n          dty = (now - autoScroll.prevTimeY) / 1000,\n          vx,\n          vy,\n          sx,\n          sy;\n\n        // displacement\n        if (options.velocity) {\n          vx = options.velocity.x;\n          vy = options.velocity.y;\n        } else {\n          vx = vy = options.speed;\n        }\n\n        sx = vx * dtx;\n        sy = vy * dty;\n\n        if (sx >= 1 || sy >= 1) {\n          if (isWindow(container)) {\n            container.scrollBy(autoScroll.x * sx, autoScroll.y * sy);\n          } else if (container) {\n            container.scrollLeft += autoScroll.x * sx;\n            container.scrollTop += autoScroll.y * sy;\n          }\n\n          if (sx >= 1) autoScroll.prevTimeX = now;\n          if (sy >= 1) autoScroll.prevTimeY = now;\n        }\n\n        if (autoScroll.isScrolling) {\n          cancelFrame(autoScroll.i);\n          autoScroll.i = reqFrame(autoScroll.scroll);\n        }\n      },\n\n      isScrolling: false,\n      prevTimeX: 0,\n      prevTimeY: 0,\n\n      start: function(interaction) {\n        autoScroll.isScrolling = true;\n        cancelFrame(autoScroll.i);\n\n        autoScroll.interaction = interaction;\n        autoScroll.prevTimeX = new Date().getTime();\n        autoScroll.prevTimeY = new Date().getTime();\n        autoScroll.i = reqFrame(autoScroll.scroll);\n      },\n\n      stop: function() {\n        autoScroll.isScrolling = false;\n        cancelFrame(autoScroll.i);\n      }\n    },\n    // Does the browser support touch input?\n    supportsTouch =\n      'ontouchstart' in window ||\n      (window.DocumentTouch && document instanceof window.DocumentTouch),\n    // Does the browser support PointerEvents\n    // Avoid PointerEvent bugs introduced in Chrome 55\n    supportsPointerEvent = PointerEvent && !/Chrome/.test(navigator.userAgent),\n    // Less Precision with touch input\n    margin = supportsTouch || supportsPointerEvent ? 20 : 10,\n    pointerMoveTolerance = 1,\n    // for ignoring browser's simulated mouse events\n    prevTouchTime = 0,\n    // Allow this many interactions to happen simultaneously\n    maxInteractions = Infinity,\n    // Check if is IE9 or older\n    actionCursors =\n      document.all && !window.atob\n        ? {\n            drag: 'move',\n            resizex: 'e-resize',\n            resizey: 's-resize',\n            resizexy: 'se-resize',\n\n            resizetop: 'n-resize',\n            resizeleft: 'w-resize',\n            resizebottom: 's-resize',\n            resizeright: 'e-resize',\n            resizetopleft: 'se-resize',\n            resizebottomright: 'se-resize',\n            resizetopright: 'ne-resize',\n            resizebottomleft: 'ne-resize',\n\n            gesture: ''\n          }\n        : {\n            drag: 'move',\n            resizex: 'ew-resize',\n            resizey: 'ns-resize',\n            resizexy: 'nwse-resize',\n\n            resizetop: 'ns-resize',\n            resizeleft: 'ew-resize',\n            resizebottom: 'ns-resize',\n            resizeright: 'ew-resize',\n            resizetopleft: 'nwse-resize',\n            resizebottomright: 'nwse-resize',\n            resizetopright: 'nesw-resize',\n            resizebottomleft: 'nesw-resize',\n\n            gesture: ''\n          },\n    actionIsEnabled = {\n      drag: true,\n      resize: true,\n      gesture: true\n    },\n    // because Webkit and Opera still use 'mousewheel' event type\n    wheelEvent = 'onmousewheel' in document ? 'mousewheel' : 'wheel',\n    eventTypes = [\n      'dragstart',\n      'dragmove',\n      'draginertiastart',\n      'dragend',\n      'dragenter',\n      'dragleave',\n      'dropactivate',\n      'dropdeactivate',\n      'dropmove',\n      'drop',\n      'resizestart',\n      'resizemove',\n      'resizeinertiastart',\n      'resizeend',\n      'gesturestart',\n      'gesturemove',\n      'gestureinertiastart',\n      'gestureend',\n\n      'down',\n      'move',\n      'up',\n      'cancel',\n      'tap',\n      'doubletap',\n      'hold'\n    ],\n    globalEvents = {},\n    // Opera Mobile must be handled differently\n    isOperaMobile =\n      navigator.appName == 'Opera' &&\n      supportsTouch &&\n      navigator.userAgent.match('Presto'),\n    // scrolling doesn't change the result of getClientRects on iOS 7\n    isIOS7 =\n      /iP(hone|od|ad)/.test(navigator.platform) &&\n      /OS 7[^\\d]/.test(navigator.appVersion),\n    // prefix matchesSelector\n    prefixedMatchesSelector =\n      'matches' in Element.prototype\n        ? 'matches'\n        : 'webkitMatchesSelector' in Element.prototype\n        ? 'webkitMatchesSelector'\n        : 'mozMatchesSelector' in Element.prototype\n        ? 'mozMatchesSelector'\n        : 'oMatchesSelector' in Element.prototype\n        ? 'oMatchesSelector'\n        : 'msMatchesSelector',\n    // will be polyfill function if browser is IE8\n    ie8MatchesSelector,\n    // native requestAnimationFrame or polyfill\n    reqFrame = realWindow.requestAnimationFrame,\n    cancelFrame = realWindow.cancelAnimationFrame,\n    // Events wrapper\n    events = (function() {\n      var useAttachEvent =\n          'attachEvent' in window && !('addEventListener' in window),\n        addEvent = useAttachEvent ? 'attachEvent' : 'addEventListener',\n        removeEvent = useAttachEvent ? 'detachEvent' : 'removeEventListener',\n        on = useAttachEvent ? 'on' : '',\n        elements = [],\n        targets = [],\n        attachedListeners = [];\n\n      function add(element, type, listener, useCapture) {\n        var elementIndex = indexOf(elements, element),\n          target = targets[elementIndex];\n\n        if (!target) {\n          target = {\n            events: {},\n            typeCount: 0\n          };\n\n          elementIndex = elements.push(element) - 1;\n          targets.push(target);\n\n          attachedListeners.push(\n            useAttachEvent\n              ? {\n                  supplied: [],\n                  wrapped: [],\n                  useCount: []\n                }\n              : null\n          );\n        }\n\n        if (!target.events[type]) {\n          target.events[type] = [];\n          target.typeCount++;\n        }\n\n        if (!contains(target.events[type], listener)) {\n          var ret;\n\n          if (useAttachEvent) {\n            var listeners = attachedListeners[elementIndex],\n              listenerIndex = indexOf(listeners.supplied, listener);\n\n            var wrapped =\n              listeners.wrapped[listenerIndex] ||\n              function(event) {\n                if (!event.immediatePropagationStopped) {\n                  event.target = event.srcElement;\n                  event.currentTarget = element;\n\n                  event.preventDefault = event.preventDefault || preventDef;\n                  event.stopPropagation = event.stopPropagation || stopProp;\n                  event.stopImmediatePropagation =\n                    event.stopImmediatePropagation || stopImmProp;\n\n                  if (/mouse|click/.test(event.type)) {\n                    event.pageX =\n                      event.clientX +\n                      getWindow(element).document.documentElement.scrollLeft;\n                    event.pageY =\n                      event.clientY +\n                      getWindow(element).document.documentElement.scrollTop;\n                  }\n\n                  listener(event);\n                }\n              };\n\n            ret = element[addEvent](on + type, wrapped, Boolean(useCapture));\n\n            if (listenerIndex === -1) {\n              listeners.supplied.push(listener);\n              listeners.wrapped.push(wrapped);\n              listeners.useCount.push(1);\n            } else {\n              listeners.useCount[listenerIndex]++;\n            }\n          } else {\n            ret = element[addEvent](type, listener, useCapture || false);\n          }\n          target.events[type].push(listener);\n\n          return ret;\n        }\n      }\n\n      function remove(element, type, listener, useCapture) {\n        var i,\n          elementIndex = indexOf(elements, element),\n          target = targets[elementIndex],\n          listeners,\n          listenerIndex,\n          wrapped = listener;\n\n        if (!target || !target.events) {\n          return;\n        }\n\n        if (useAttachEvent) {\n          listeners = attachedListeners[elementIndex];\n          listenerIndex = indexOf(listeners.supplied, listener);\n          wrapped = listeners.wrapped[listenerIndex];\n        }\n\n        if (type === 'all') {\n          for (type in target.events) {\n            if (target.events.hasOwnProperty(type)) {\n              remove(element, type, 'all');\n            }\n          }\n          return;\n        }\n\n        if (target.events[type]) {\n          var len = target.events[type].length;\n\n          if (listener === 'all') {\n            for (i = 0; i < len; i++) {\n              remove(\n                element,\n                type,\n                target.events[type][i],\n                Boolean(useCapture)\n              );\n            }\n            return;\n          } else {\n            for (i = 0; i < len; i++) {\n              if (target.events[type][i] === listener) {\n                element[removeEvent](on + type, wrapped, useCapture || false);\n                target.events[type].splice(i, 1);\n\n                if (useAttachEvent && listeners) {\n                  listeners.useCount[listenerIndex]--;\n                  if (listeners.useCount[listenerIndex] === 0) {\n                    listeners.supplied.splice(listenerIndex, 1);\n                    listeners.wrapped.splice(listenerIndex, 1);\n                    listeners.useCount.splice(listenerIndex, 1);\n                  }\n                }\n\n                break;\n              }\n            }\n          }\n\n          if (target.events[type] && target.events[type].length === 0) {\n            target.events[type] = null;\n            target.typeCount--;\n          }\n        }\n\n        if (!target.typeCount) {\n          targets.splice(elementIndex, 1);\n          elements.splice(elementIndex, 1);\n          attachedListeners.splice(elementIndex, 1);\n        }\n      }\n\n      function preventDef() {\n        this.returnValue = false;\n      }\n\n      function stopProp() {\n        this.cancelBubble = true;\n      }\n\n      function stopImmProp() {\n        this.cancelBubble = true;\n        this.immediatePropagationStopped = true;\n      }\n\n      return {\n        add: add,\n        remove: remove,\n        useAttachEvent: useAttachEvent,\n\n        _elements: elements,\n        _targets: targets,\n        _attachedListeners: attachedListeners\n      };\n    })();\n\n  function blank() {}\n\n  function isElement(o) {\n    if (!o || typeof o !== 'object') {\n      return false;\n    }\n\n    var _window = getWindow(o) || window;\n\n    return /object|function/.test(typeof _window.Element)\n      ? o instanceof _window.Element //DOM2\n      : o.nodeType === 1 && typeof o.nodeName === 'string';\n  }\n  function isWindow(thing) {\n    return (\n      thing === window ||\n      (!!(thing && thing.Window) && thing instanceof thing.Window)\n    );\n  }\n  function isDocFrag(thing) {\n    return !!thing && thing instanceof DocumentFragment;\n  }\n  function isArray(thing) {\n    return (\n      isObject(thing) &&\n      typeof thing.length !== undefined &&\n      isFunction(thing.splice)\n    );\n  }\n  function isObject(thing) {\n    return !!thing && typeof thing === 'object';\n  }\n  function isFunction(thing) {\n    return typeof thing === 'function';\n  }\n  function isNumber(thing) {\n    return typeof thing === 'number';\n  }\n  function isBool(thing) {\n    return typeof thing === 'boolean';\n  }\n  function isString(thing) {\n    return typeof thing === 'string';\n  }\n\n  function trySelector(value) {\n    if (!isString(value)) {\n      return false;\n    }\n\n    // an exception will be raised if it is invalid\n    document.querySelector(value);\n    return true;\n  }\n\n  function extend(dest, source) {\n    for (var prop in source) {\n      dest[prop] = source[prop];\n    }\n    return dest;\n  }\n\n  var prefixedPropREs = {\n    webkit: /(Movement[XY]|Radius[XY]|RotationAngle|Force)$/\n  };\n\n  function pointerExtend(dest, source) {\n    for (var prop in source) {\n      var deprecated = false;\n\n      // skip deprecated prefixed properties\n      for (var vendor in prefixedPropREs) {\n        if (prop.indexOf(vendor) === 0 && prefixedPropREs[vendor].test(prop)) {\n          deprecated = true;\n          break;\n        }\n      }\n\n      if (!deprecated) {\n        dest[prop] = source[prop];\n      }\n    }\n    return dest;\n  }\n\n  function copyCoords(dest, src) {\n    dest.page = dest.page || {};\n    dest.page.x = src.page.x;\n    dest.page.y = src.page.y;\n\n    dest.client = dest.client || {};\n    dest.client.x = src.client.x;\n    dest.client.y = src.client.y;\n\n    dest.timeStamp = src.timeStamp;\n  }\n\n  function setEventXY(targetObj, pointers, interaction) {\n    var pointer = pointers.length > 1 ? pointerAverage(pointers) : pointers[0];\n\n    getPageXY(pointer, tmpXY, interaction);\n    targetObj.page.x = tmpXY.x;\n    targetObj.page.y = tmpXY.y;\n\n    getClientXY(pointer, tmpXY, interaction);\n    targetObj.client.x = tmpXY.x;\n    targetObj.client.y = tmpXY.y;\n\n    targetObj.timeStamp = new Date().getTime();\n  }\n\n  function setEventDeltas(targetObj, prev, cur) {\n    targetObj.page.x = cur.page.x - prev.page.x;\n    targetObj.page.y = cur.page.y - prev.page.y;\n    targetObj.client.x = cur.client.x - prev.client.x;\n    targetObj.client.y = cur.client.y - prev.client.y;\n    targetObj.timeStamp = new Date().getTime() - prev.timeStamp;\n\n    // set pointer velocity\n    var dt = Math.max(targetObj.timeStamp / 1000, 0.001);\n    targetObj.page.speed = hypot(targetObj.page.x, targetObj.page.y) / dt;\n    targetObj.page.vx = targetObj.page.x / dt;\n    targetObj.page.vy = targetObj.page.y / dt;\n\n    targetObj.client.speed = hypot(targetObj.client.x, targetObj.page.y) / dt;\n    targetObj.client.vx = targetObj.client.x / dt;\n    targetObj.client.vy = targetObj.client.y / dt;\n  }\n\n  function isNativePointer(pointer) {\n    return (\n      pointer instanceof window.Event ||\n      (supportsTouch && window.Touch && pointer instanceof window.Touch)\n    );\n  }\n\n  // Get specified X/Y coords for mouse or event.touches[0]\n  function getXY(type, pointer, xy) {\n    xy = xy || {};\n    type = type || 'page';\n\n    xy.x = pointer[type + 'X'];\n    xy.y = pointer[type + 'Y'];\n\n    return xy;\n  }\n\n  function getPageXY(pointer, page) {\n    page = page || {};\n\n    // Opera Mobile handles the viewport and scrolling oddly\n    if (isOperaMobile && isNativePointer(pointer)) {\n      getXY('screen', pointer, page);\n\n      page.x += window.scrollX;\n      page.y += window.scrollY;\n    } else {\n      getXY('page', pointer, page);\n    }\n\n    return page;\n  }\n\n  function getClientXY(pointer, client) {\n    client = client || {};\n\n    if (isOperaMobile && isNativePointer(pointer)) {\n      // Opera Mobile handles the viewport and scrolling oddly\n      getXY('screen', pointer, client);\n    } else {\n      getXY('client', pointer, client);\n    }\n\n    return client;\n  }\n\n  function getScrollXY(win) {\n    win = win || window;\n    return {\n      x: win.scrollX || win.document.documentElement.scrollLeft,\n      y: win.scrollY || win.document.documentElement.scrollTop\n    };\n  }\n\n  function getPointerId(pointer) {\n    return isNumber(pointer.pointerId) ? pointer.pointerId : pointer.identifier;\n  }\n\n  function getActualElement(element) {\n    return element instanceof SVGElementInstance\n      ? element.correspondingUseElement\n      : element;\n  }\n\n  function getWindow(node) {\n    if (isWindow(node)) {\n      return node;\n    }\n\n    var rootNode = node.ownerDocument || node;\n\n    return rootNode.defaultView || rootNode.parentWindow || window;\n  }\n\n  function getElementClientRect(element) {\n    var clientRect =\n      element instanceof SVGElement\n        ? element.getBoundingClientRect()\n        : element.getClientRects()[0];\n\n    return (\n      clientRect && {\n        left: clientRect.left,\n        right: clientRect.right,\n        top: clientRect.top,\n        bottom: clientRect.bottom,\n        width: clientRect.width || clientRect.right - clientRect.left,\n        height: clientRect.height || clientRect.bottom - clientRect.top\n      }\n    );\n  }\n\n  function getElementRect(element) {\n    var clientRect = getElementClientRect(element);\n\n    if (!isIOS7 && clientRect) {\n      var scroll = getScrollXY(getWindow(element));\n\n      clientRect.left += scroll.x;\n      clientRect.right += scroll.x;\n      clientRect.top += scroll.y;\n      clientRect.bottom += scroll.y;\n    }\n\n    return clientRect;\n  }\n\n  function getTouchPair(event) {\n    var touches = [];\n\n    // array of touches is supplied\n    if (isArray(event)) {\n      touches[0] = event[0];\n      touches[1] = event[1];\n    }\n    // an event\n    else {\n      if (event.type === 'touchend') {\n        if (event.touches.length === 1) {\n          touches[0] = event.touches[0];\n          touches[1] = event.changedTouches[0];\n        } else if (event.touches.length === 0) {\n          touches[0] = event.changedTouches[0];\n          touches[1] = event.changedTouches[1];\n        }\n      } else {\n        touches[0] = event.touches[0];\n        touches[1] = event.touches[1];\n      }\n    }\n\n    return touches;\n  }\n\n  function pointerAverage(pointers) {\n    var average = {\n      pageX: 0,\n      pageY: 0,\n      clientX: 0,\n      clientY: 0,\n      screenX: 0,\n      screenY: 0\n    };\n    var prop;\n\n    for (var i = 0; i < pointers.length; i++) {\n      for (prop in average) {\n        average[prop] += pointers[i][prop];\n      }\n    }\n    for (prop in average) {\n      average[prop] /= pointers.length;\n    }\n\n    return average;\n  }\n\n  function touchBBox(event) {\n    if (!event.length && !(event.touches && event.touches.length > 1)) {\n      return;\n    }\n\n    var touches = getTouchPair(event),\n      minX = Math.min(touches[0].pageX, touches[1].pageX),\n      minY = Math.min(touches[0].pageY, touches[1].pageY),\n      maxX = Math.max(touches[0].pageX, touches[1].pageX),\n      maxY = Math.max(touches[0].pageY, touches[1].pageY);\n\n    return {\n      x: minX,\n      y: minY,\n      left: minX,\n      top: minY,\n      width: maxX - minX,\n      height: maxY - minY\n    };\n  }\n\n  function touchDistance(event, deltaSource) {\n    deltaSource = deltaSource || defaultOptions.deltaSource;\n\n    var sourceX = deltaSource + 'X',\n      sourceY = deltaSource + 'Y',\n      touches = getTouchPair(event);\n\n    var dx = touches[0][sourceX] - touches[1][sourceX],\n      dy = touches[0][sourceY] - touches[1][sourceY];\n\n    return hypot(dx, dy);\n  }\n\n  function touchAngle(event, prevAngle, deltaSource) {\n    deltaSource = deltaSource || defaultOptions.deltaSource;\n\n    var sourceX = deltaSource + 'X',\n      sourceY = deltaSource + 'Y',\n      touches = getTouchPair(event),\n      dx = touches[0][sourceX] - touches[1][sourceX],\n      dy = touches[0][sourceY] - touches[1][sourceY],\n      angle = (180 * Math.atan(dy / dx)) / Math.PI;\n\n    if (isNumber(prevAngle)) {\n      var dr = angle - prevAngle,\n        drClamped = dr % 360;\n\n      if (drClamped > 315) {\n        angle -= (360 + angle / 360) | (0 * 360);\n      } else if (drClamped > 135) {\n        angle -= (180 + angle / 360) | (0 * 360);\n      } else if (drClamped < -315) {\n        angle += (360 + angle / 360) | (0 * 360);\n      } else if (drClamped < -135) {\n        angle += (180 + angle / 360) | (0 * 360);\n      }\n    }\n\n    return angle;\n  }\n\n  function getOriginXY(interactable, element) {\n    var origin = interactable\n      ? interactable.options.origin\n      : defaultOptions.origin;\n\n    if (origin === 'parent') {\n      origin = parentElement(element);\n    } else if (origin === 'self') {\n      origin = interactable.getRect(element);\n    } else if (trySelector(origin)) {\n      origin = closest(element, origin) || {x: 0, y: 0};\n    }\n\n    if (isFunction(origin)) {\n      origin = origin(interactable && element);\n    }\n\n    if (isElement(origin)) {\n      origin = getElementRect(origin);\n    }\n\n    origin.x = 'x' in origin ? origin.x : origin.left;\n    origin.y = 'y' in origin ? origin.y : origin.top;\n\n    return origin;\n  }\n\n  // http://stackoverflow.com/a/5634528/2280888\n  function _getQBezierValue(t, p1, p2, p3) {\n    var iT = 1 - t;\n    return iT * iT * p1 + 2 * iT * t * p2 + t * t * p3;\n  }\n\n  function getQuadraticCurvePoint(\n    startX,\n    startY,\n    cpX,\n    cpY,\n    endX,\n    endY,\n    position\n  ) {\n    return {\n      x: _getQBezierValue(position, startX, cpX, endX),\n      y: _getQBezierValue(position, startY, cpY, endY)\n    };\n  }\n\n  // http://gizma.com/easing/\n  function easeOutQuad(t, b, c, d) {\n    t /= d;\n    return -c * t * (t - 2) + b;\n  }\n\n  function nodeContains(parent, child) {\n    while (child) {\n      if (child === parent) {\n        return true;\n      }\n\n      child = child.parentNode;\n    }\n\n    return false;\n  }\n\n  function closest(child, selector) {\n    var parent = parentElement(child);\n\n    while (isElement(parent)) {\n      if (matchesSelector(parent, selector)) {\n        return parent;\n      }\n\n      parent = parentElement(parent);\n    }\n\n    return null;\n  }\n\n  function parentElement(node) {\n    var parent = node.parentNode;\n\n    if (isDocFrag(parent)) {\n      // skip past #shado-root fragments\n      while ((parent = parent.host) && isDocFrag(parent)) {}\n\n      return parent;\n    }\n\n    return parent;\n  }\n\n  function inContext(interactable, element) {\n    return (\n      interactable._context === element.ownerDocument ||\n      nodeContains(interactable._context, element)\n    );\n  }\n\n  function testIgnore(interactable, interactableElement, element) {\n    var ignoreFrom = interactable.options.ignoreFrom;\n\n    if (!ignoreFrom || !isElement(element)) {\n      return false;\n    }\n\n    if (isString(ignoreFrom)) {\n      return matchesUpTo(element, ignoreFrom, interactableElement);\n    } else if (isElement(ignoreFrom)) {\n      return nodeContains(ignoreFrom, element);\n    }\n\n    return false;\n  }\n\n  function testAllow(interactable, interactableElement, element) {\n    var allowFrom = interactable.options.allowFrom;\n\n    if (!allowFrom) {\n      return true;\n    }\n\n    if (!isElement(element)) {\n      return false;\n    }\n\n    if (isString(allowFrom)) {\n      return matchesUpTo(element, allowFrom, interactableElement);\n    } else if (isElement(allowFrom)) {\n      return nodeContains(allowFrom, element);\n    }\n\n    return false;\n  }\n\n  function checkAxis(axis, interactable) {\n    if (!interactable) {\n      return false;\n    }\n\n    var thisAxis = interactable.options.drag.axis;\n\n    return axis === 'xy' || thisAxis === 'xy' || thisAxis === axis;\n  }\n\n  function checkSnap(interactable, action) {\n    var options = interactable.options;\n\n    if (/^resize/.test(action)) {\n      action = 'resize';\n    }\n\n    return options[action].snap && options[action].snap.enabled;\n  }\n\n  function checkRestrict(interactable, action) {\n    var options = interactable.options;\n\n    if (/^resize/.test(action)) {\n      action = 'resize';\n    }\n\n    return options[action].restrict && options[action].restrict.enabled;\n  }\n\n  function checkAutoScroll(interactable, action) {\n    var options = interactable.options;\n\n    if (/^resize/.test(action)) {\n      action = 'resize';\n    }\n\n    return options[action].autoScroll && options[action].autoScroll.enabled;\n  }\n\n  function withinInteractionLimit(interactable, element, action) {\n    var options = interactable.options,\n      maxActions = options[action.name].max,\n      maxPerElement = options[action.name].maxPerElement,\n      activeInteractions = 0,\n      targetCount = 0,\n      targetElementCount = 0;\n\n    for (var i = 0, len = interactions.length; i < len; i++) {\n      var interaction = interactions[i],\n        otherAction = interaction.prepared.name,\n        active = interaction.interacting();\n\n      if (!active) {\n        continue;\n      }\n\n      activeInteractions++;\n\n      if (activeInteractions >= maxInteractions) {\n        return false;\n      }\n\n      if (interaction.target !== interactable) {\n        continue;\n      }\n\n      targetCount += (otherAction === action.name) | 0;\n\n      if (targetCount >= maxActions) {\n        return false;\n      }\n\n      if (interaction.element === element) {\n        targetElementCount++;\n\n        if (\n          otherAction !== action.name ||\n          targetElementCount >= maxPerElement\n        ) {\n          return false;\n        }\n      }\n    }\n\n    return maxInteractions > 0;\n  }\n\n  // Test for the element that's \"above\" all other qualifiers\n  function indexOfDeepestElement(elements) {\n    var dropzone,\n      deepestZone = elements[0],\n      index = deepestZone ? 0 : -1,\n      parent,\n      deepestZoneParents = [],\n      dropzoneParents = [],\n      child,\n      i,\n      n;\n\n    for (i = 1; i < elements.length; i++) {\n      dropzone = elements[i];\n\n      // an element might belong to multiple selector dropzones\n      if (!dropzone || dropzone === deepestZone) {\n        continue;\n      }\n\n      if (!deepestZone) {\n        deepestZone = dropzone;\n        index = i;\n        continue;\n      }\n\n      // check if the deepest or current are document.documentElement or document.rootElement\n      // - if the current dropzone is, do nothing and continue\n      if (dropzone.parentNode === dropzone.ownerDocument) {\n        continue;\n      }\n      // - if deepest is, update with the current dropzone and continue to next\n      else if (deepestZone.parentNode === dropzone.ownerDocument) {\n        deepestZone = dropzone;\n        index = i;\n        continue;\n      }\n\n      if (!deepestZoneParents.length) {\n        parent = deepestZone;\n        while (\n          parent.parentNode &&\n          parent.parentNode !== parent.ownerDocument\n        ) {\n          deepestZoneParents.unshift(parent);\n          parent = parent.parentNode;\n        }\n      }\n\n      // if this element is an svg element and the current deepest is\n      // an HTMLElement\n      if (\n        deepestZone instanceof HTMLElement &&\n        dropzone instanceof SVGElement &&\n        !(dropzone instanceof SVGSVGElement)\n      ) {\n        if (dropzone === deepestZone.parentNode) {\n          continue;\n        }\n\n        parent = dropzone.ownerSVGElement;\n      } else {\n        parent = dropzone;\n      }\n\n      dropzoneParents = [];\n\n      while (parent.parentNode !== parent.ownerDocument) {\n        dropzoneParents.unshift(parent);\n        parent = parent.parentNode;\n      }\n\n      n = 0;\n\n      // get (position of last common ancestor) + 1\n      while (\n        dropzoneParents[n] &&\n        dropzoneParents[n] === deepestZoneParents[n]\n      ) {\n        n++;\n      }\n\n      var parents = [\n        dropzoneParents[n - 1],\n        dropzoneParents[n],\n        deepestZoneParents[n]\n      ];\n\n      child = parents[0].lastChild;\n\n      while (child) {\n        if (child === parents[1]) {\n          deepestZone = dropzone;\n          index = i;\n          deepestZoneParents = [];\n\n          break;\n        } else if (child === parents[2]) {\n          break;\n        }\n\n        child = child.previousSibling;\n      }\n    }\n\n    return index;\n  }\n\n  function Interaction() {\n    this.target = null; // current interactable being interacted with\n    this.element = null; // the target element of the interactable\n    this.dropTarget = null; // the dropzone a drag target might be dropped into\n    this.dropElement = null; // the element at the time of checking\n    this.prevDropTarget = null; // the dropzone that was recently dragged away from\n    this.prevDropElement = null; // the element at the time of checking\n\n    this.prepared = {\n      // action that's ready to be fired on next move event\n      name: null,\n      axis: null,\n      edges: null\n    };\n\n    this.matches = []; // all selectors that are matched by target element\n    this.matchElements = []; // corresponding elements\n\n    this.inertiaStatus = {\n      active: false,\n      smoothEnd: false,\n      ending: false,\n\n      startEvent: null,\n      upCoords: {},\n\n      xe: 0,\n      ye: 0,\n      sx: 0,\n      sy: 0,\n\n      t0: 0,\n      vx0: 0,\n      vys: 0,\n      duration: 0,\n\n      resumeDx: 0,\n      resumeDy: 0,\n\n      lambda_v0: 0,\n      one_ve_v0: 0,\n      i: null\n    };\n\n    if (isFunction(Function.prototype.bind)) {\n      this.boundInertiaFrame = this.inertiaFrame.bind(this);\n      this.boundSmoothEndFrame = this.smoothEndFrame.bind(this);\n    } else {\n      var that = this;\n\n      this.boundInertiaFrame = function() {\n        return that.inertiaFrame();\n      };\n      this.boundSmoothEndFrame = function() {\n        return that.smoothEndFrame();\n      };\n    }\n\n    this.activeDrops = {\n      dropzones: [], // the dropzones that are mentioned below\n      elements: [], // elements of dropzones that accept the target draggable\n      rects: [] // the rects of the elements mentioned above\n    };\n\n    // keep track of added pointers\n    this.pointers = [];\n    this.pointerIds = [];\n    this.downTargets = [];\n    this.downTimes = [];\n    this.holdTimers = [];\n\n    // Previous native pointer move event coordinates\n    this.prevCoords = {\n      page: {x: 0, y: 0},\n      client: {x: 0, y: 0},\n      timeStamp: 0\n    };\n    // current native pointer move event coordinates\n    this.curCoords = {\n      page: {x: 0, y: 0},\n      client: {x: 0, y: 0},\n      timeStamp: 0\n    };\n\n    // Starting InteractEvent pointer coordinates\n    this.startCoords = {\n      page: {x: 0, y: 0},\n      client: {x: 0, y: 0},\n      timeStamp: 0\n    };\n\n    // Change in coordinates and time of the pointer\n    this.pointerDelta = {\n      page: {x: 0, y: 0, vx: 0, vy: 0, speed: 0},\n      client: {x: 0, y: 0, vx: 0, vy: 0, speed: 0},\n      timeStamp: 0\n    };\n\n    this.downEvent = null; // pointerdown/mousedown/touchstart event\n    this.downPointer = {};\n\n    this._eventTarget = null;\n    this._curEventTarget = null;\n\n    this.prevEvent = null; // previous action event\n    this.tapTime = 0; // time of the most recent tap event\n    this.prevTap = null;\n\n    this.startOffset = {left: 0, right: 0, top: 0, bottom: 0};\n    this.restrictOffset = {left: 0, right: 0, top: 0, bottom: 0};\n    this.snapOffsets = [];\n\n    this.gesture = {\n      start: {x: 0, y: 0},\n\n      startDistance: 0, // distance between two touches of touchStart\n      prevDistance: 0,\n      distance: 0,\n\n      scale: 1, // gesture.distance / gesture.startDistance\n\n      startAngle: 0, // angle of line joining two touches\n      prevAngle: 0 // angle of the previous gesture event\n    };\n\n    this.snapStatus = {\n      x: 0,\n      y: 0,\n      dx: 0,\n      dy: 0,\n      realX: 0,\n      realY: 0,\n      snappedX: 0,\n      snappedY: 0,\n      targets: [],\n      locked: false,\n      changed: false\n    };\n\n    this.restrictStatus = {\n      dx: 0,\n      dy: 0,\n      restrictedX: 0,\n      restrictedY: 0,\n      snap: null,\n      restricted: false,\n      changed: false\n    };\n\n    this.restrictStatus.snap = this.snapStatus;\n\n    this.pointerIsDown = false;\n    this.pointerWasMoved = false;\n    this.gesturing = false;\n    this.dragging = false;\n    this.resizing = false;\n    this.resizeAxes = 'xy';\n\n    this.mouse = false;\n\n    interactions.push(this);\n  }\n\n  Interaction.prototype = {\n    getPageXY: function(pointer, xy) {\n      return getPageXY(pointer, xy, this);\n    },\n    getClientXY: function(pointer, xy) {\n      return getClientXY(pointer, xy, this);\n    },\n    setEventXY: function(target, ptr) {\n      return setEventXY(target, ptr, this);\n    },\n\n    pointerOver: function(pointer, event, eventTarget) {\n      if (this.prepared.name || !this.mouse) {\n        return;\n      }\n\n      var curMatches = [],\n        curMatchElements = [],\n        prevTargetElement = this.element;\n\n      this.addPointer(pointer);\n\n      if (\n        this.target &&\n        (testIgnore(this.target, this.element, eventTarget) ||\n          !testAllow(this.target, this.element, eventTarget))\n      ) {\n        // if the eventTarget should be ignored or shouldn't be allowed\n        // clear the previous target\n        this.target = null;\n        this.element = null;\n        this.matches = [];\n        this.matchElements = [];\n      }\n\n      var elementInteractable = interactables.get(eventTarget),\n        elementAction =\n          elementInteractable &&\n          !testIgnore(elementInteractable, eventTarget, eventTarget) &&\n          testAllow(elementInteractable, eventTarget, eventTarget) &&\n          validateAction(\n            elementInteractable.getAction(pointer, event, this, eventTarget),\n            elementInteractable\n          );\n\n      if (\n        elementAction &&\n        !withinInteractionLimit(elementInteractable, eventTarget, elementAction)\n      ) {\n        elementAction = null;\n      }\n\n      function pushCurMatches(interactable, selector) {\n        if (\n          interactable &&\n          inContext(interactable, eventTarget) &&\n          !testIgnore(interactable, eventTarget, eventTarget) &&\n          testAllow(interactable, eventTarget, eventTarget) &&\n          matchesSelector(eventTarget, selector)\n        ) {\n          curMatches.push(interactable);\n          curMatchElements.push(eventTarget);\n        }\n      }\n\n      if (elementAction) {\n        this.target = elementInteractable;\n        this.element = eventTarget;\n        this.matches = [];\n        this.matchElements = [];\n      } else {\n        interactables.forEachSelector(pushCurMatches);\n\n        if (\n          this.validateSelector(pointer, event, curMatches, curMatchElements)\n        ) {\n          this.matches = curMatches;\n          this.matchElements = curMatchElements;\n\n          this.pointerHover(pointer, event, this.matches, this.matchElements);\n          events.add(\n            eventTarget,\n            supportsPointerEvent ? pEventTypes.move : 'mousemove',\n            listeners.pointerHover\n          );\n        } else if (this.target) {\n          if (nodeContains(prevTargetElement, eventTarget)) {\n            this.pointerHover(pointer, event, this.matches, this.matchElements);\n            events.add(\n              this.element,\n              supportsPointerEvent ? pEventTypes.move : 'mousemove',\n              listeners.pointerHover\n            );\n          } else {\n            this.target = null;\n            this.element = null;\n            this.matches = [];\n            this.matchElements = [];\n          }\n        }\n      }\n    },\n\n    // Check what action would be performed on pointerMove target if a mouse\n    // button were pressed and change the cursor accordingly\n    pointerHover: function(\n      pointer,\n      event,\n      eventTarget,\n      curEventTarget,\n      matches,\n      matchElements\n    ) {\n      var target = this.target;\n\n      if (!this.prepared.name && this.mouse) {\n        var action;\n\n        // update pointer coords for defaultActionChecker to use\n        this.setEventXY(this.curCoords, [pointer]);\n\n        if (matches) {\n          action = this.validateSelector(\n            pointer,\n            event,\n            matches,\n            matchElements\n          );\n        } else if (target) {\n          action = validateAction(\n            target.getAction(this.pointers[0], event, this, this.element),\n            this.target\n          );\n        }\n\n        if (target && target.options.styleCursor) {\n          if (action) {\n            target._doc.documentElement.style.cursor = getActionCursor(action);\n          } else {\n            target._doc.documentElement.style.cursor = '';\n          }\n        }\n      } else if (this.prepared.name) {\n        this.checkAndPreventDefault(event, target, this.element);\n      }\n    },\n\n    pointerOut: function(pointer, event, eventTarget) {\n      if (this.prepared.name) {\n        return;\n      }\n\n      // Remove temporary event listeners for selector Interactables\n      if (!interactables.get(eventTarget)) {\n        events.remove(\n          eventTarget,\n          supportsPointerEvent ? pEventTypes.move : 'mousemove',\n          listeners.pointerHover\n        );\n      }\n\n      if (\n        this.target &&\n        this.target.options.styleCursor &&\n        !this.interacting()\n      ) {\n        this.target._doc.documentElement.style.cursor = '';\n      }\n    },\n\n    selectorDown: function(pointer, event, eventTarget, curEventTarget) {\n      var that = this,\n        // copy event to be used in timeout for IE8\n        eventCopy = events.useAttachEvent ? extend({}, event) : event,\n        element = eventTarget,\n        pointerIndex = this.addPointer(pointer),\n        action;\n\n      this.holdTimers[pointerIndex] = setTimeout(function() {\n        that.pointerHold(\n          events.useAttachEvent ? eventCopy : pointer,\n          eventCopy,\n          eventTarget,\n          curEventTarget\n        );\n      }, defaultOptions._holdDuration);\n\n      this.pointerIsDown = true;\n\n      // Check if the down event hits the current inertia target\n      if (this.inertiaStatus.active && this.target.selector) {\n        // climb up the DOM tree from the event target\n        while (isElement(element)) {\n          // if this element is the current inertia target element\n          if (\n            element === this.element &&\n            // and the prospective action is the same as the ongoing one\n            validateAction(\n              this.target.getAction(pointer, event, this, this.element),\n              this.target\n            ).name === this.prepared.name\n          ) {\n            // stop inertia so that the next move will be a normal one\n            cancelFrame(this.inertiaStatus.i);\n            this.inertiaStatus.active = false;\n\n            this.collectEventTargets(pointer, event, eventTarget, 'down');\n            return;\n          }\n          element = parentElement(element);\n        }\n      }\n\n      // do nothing if interacting\n      if (this.interacting()) {\n        this.collectEventTargets(pointer, event, eventTarget, 'down');\n        return;\n      }\n\n      function pushMatches(interactable, selector, context) {\n        var elements = ie8MatchesSelector\n          ? context.querySelectorAll(selector)\n          : undefined;\n\n        if (\n          inContext(interactable, element) &&\n          !testIgnore(interactable, element, eventTarget) &&\n          testAllow(interactable, element, eventTarget) &&\n          matchesSelector(element, selector, elements)\n        ) {\n          that.matches.push(interactable);\n          that.matchElements.push(element);\n        }\n      }\n\n      // update pointer coords for defaultActionChecker to use\n      this.setEventXY(this.curCoords, [pointer]);\n      this.downEvent = event;\n\n      while (isElement(element) && !action) {\n        this.matches = [];\n        this.matchElements = [];\n\n        interactables.forEachSelector(pushMatches);\n\n        action = this.validateSelector(\n          pointer,\n          event,\n          this.matches,\n          this.matchElements\n        );\n        element = parentElement(element);\n      }\n\n      if (action) {\n        this.prepared.name = action.name;\n        this.prepared.axis = action.axis;\n        this.prepared.edges = action.edges;\n\n        this.collectEventTargets(pointer, event, eventTarget, 'down');\n\n        return this.pointerDown(\n          pointer,\n          event,\n          eventTarget,\n          curEventTarget,\n          action\n        );\n      } else {\n        // do these now since pointerDown isn't being called from here\n        this.downTimes[pointerIndex] = new Date().getTime();\n        this.downTargets[pointerIndex] = eventTarget;\n        pointerExtend(this.downPointer, pointer);\n\n        copyCoords(this.prevCoords, this.curCoords);\n        this.pointerWasMoved = false;\n      }\n\n      this.collectEventTargets(pointer, event, eventTarget, 'down');\n    },\n\n    // Determine action to be performed on next pointerMove and add appropriate\n    // style and event Listeners\n    pointerDown: function(\n      pointer,\n      event,\n      eventTarget,\n      curEventTarget,\n      forceAction\n    ) {\n      if (\n        !forceAction &&\n        !this.inertiaStatus.active &&\n        this.pointerWasMoved &&\n        this.prepared.name\n      ) {\n        this.checkAndPreventDefault(event, this.target, this.element);\n\n        return;\n      }\n\n      this.pointerIsDown = true;\n      this.downEvent = event;\n\n      var pointerIndex = this.addPointer(pointer),\n        action;\n\n      // If it is the second touch of a multi-touch gesture, keep the\n      // target the same and get a new action if a target was set by the\n      // first touch\n      if (this.pointerIds.length > 1 && this.target._element === this.element) {\n        var newAction = validateAction(\n          forceAction ||\n            this.target.getAction(pointer, event, this, this.element),\n          this.target\n        );\n\n        if (withinInteractionLimit(this.target, this.element, newAction)) {\n          action = newAction;\n        }\n\n        this.prepared.name = null;\n      }\n      // Otherwise, set the target if there is no action prepared\n      else if (!this.prepared.name) {\n        var interactable = interactables.get(curEventTarget);\n\n        if (\n          interactable &&\n          !testIgnore(interactable, curEventTarget, eventTarget) &&\n          testAllow(interactable, curEventTarget, eventTarget) &&\n          (action = validateAction(\n            forceAction ||\n              interactable.getAction(pointer, event, this, curEventTarget),\n            interactable,\n            eventTarget\n          )) &&\n          withinInteractionLimit(interactable, curEventTarget, action)\n        ) {\n          this.target = interactable;\n          this.element = curEventTarget;\n        }\n      }\n\n      var target = this.target,\n        options = target && target.options;\n\n      if (target && (forceAction || !this.prepared.name)) {\n        action =\n          action ||\n          validateAction(\n            forceAction ||\n              target.getAction(pointer, event, this, curEventTarget),\n            target,\n            this.element\n          );\n\n        this.setEventXY(this.startCoords, this.pointers);\n\n        if (!action) {\n          return;\n        }\n\n        if (options.styleCursor) {\n          target._doc.documentElement.style.cursor = getActionCursor(action);\n        }\n\n        this.resizeAxes = action.name === 'resize' ? action.axis : null;\n\n        if (action === 'gesture' && this.pointerIds.length < 2) {\n          action = null;\n        }\n\n        this.prepared.name = action.name;\n        this.prepared.axis = action.axis;\n        this.prepared.edges = action.edges;\n\n        this.snapStatus.snappedX = this.snapStatus.snappedY = this.restrictStatus.restrictedX = this.restrictStatus.restrictedY = NaN;\n\n        this.downTimes[pointerIndex] = new Date().getTime();\n        this.downTargets[pointerIndex] = eventTarget;\n        pointerExtend(this.downPointer, pointer);\n\n        copyCoords(this.prevCoords, this.startCoords);\n        this.pointerWasMoved = false;\n\n        this.checkAndPreventDefault(event, target, this.element);\n      }\n      // if inertia is active try to resume action\n      else if (\n        this.inertiaStatus.active &&\n        curEventTarget === this.element &&\n        validateAction(\n          target.getAction(pointer, event, this, this.element),\n          target\n        ).name === this.prepared.name\n      ) {\n        cancelFrame(this.inertiaStatus.i);\n        this.inertiaStatus.active = false;\n\n        this.checkAndPreventDefault(event, target, this.element);\n      }\n    },\n\n    setModifications: function(coords, preEnd) {\n      var target = this.target,\n        shouldMove = true,\n        shouldSnap =\n          checkSnap(target, this.prepared.name) &&\n          (!target.options[this.prepared.name].snap.endOnly || preEnd),\n        shouldRestrict =\n          checkRestrict(target, this.prepared.name) &&\n          (!target.options[this.prepared.name].restrict.endOnly || preEnd);\n\n      if (shouldSnap) {\n        this.setSnapping(coords);\n      } else {\n        this.snapStatus.locked = false;\n      }\n      if (shouldRestrict) {\n        this.setRestriction(coords);\n      } else {\n        this.restrictStatus.restricted = false;\n      }\n\n      if (shouldSnap && this.snapStatus.locked && !this.snapStatus.changed) {\n        shouldMove =\n          shouldRestrict &&\n          this.restrictStatus.restricted &&\n          this.restrictStatus.changed;\n      } else if (\n        shouldRestrict &&\n        this.restrictStatus.restricted &&\n        !this.restrictStatus.changed\n      ) {\n        shouldMove = false;\n      }\n\n      return shouldMove;\n    },\n\n    setStartOffsets: function(action, interactable, element) {\n      var rect = interactable.getRect(element),\n        origin = getOriginXY(interactable, element),\n        snap = interactable.options[this.prepared.name].snap,\n        restrict = interactable.options[this.prepared.name].restrict,\n        width,\n        height;\n\n      if (rect) {\n        this.startOffset.left = this.startCoords.page.x - rect.left;\n        this.startOffset.top = this.startCoords.page.y - rect.top;\n\n        this.startOffset.right = rect.right - this.startCoords.page.x;\n        this.startOffset.bottom = rect.bottom - this.startCoords.page.y;\n\n        if ('width' in rect) {\n          width = rect.width;\n        } else {\n          width = rect.right - rect.left;\n        }\n        if ('height' in rect) {\n          height = rect.height;\n        } else {\n          height = rect.bottom - rect.top;\n        }\n      } else {\n        this.startOffset.left = this.startOffset.top = this.startOffset.right = this.startOffset.bottom = 0;\n      }\n\n      this.snapOffsets.splice(0);\n\n      var snapOffset =\n        snap && snap.offset === 'startCoords'\n          ? {\n              x: this.startCoords.page.x - origin.x,\n              y: this.startCoords.page.y - origin.y\n            }\n          : (snap && snap.offset) || {x: 0, y: 0};\n\n      if (rect && snap && snap.relativePoints && snap.relativePoints.length) {\n        for (var i = 0; i < snap.relativePoints.length; i++) {\n          this.snapOffsets.push({\n            x:\n              this.startOffset.left -\n              width * snap.relativePoints[i].x +\n              snapOffset.x,\n            y:\n              this.startOffset.top -\n              height * snap.relativePoints[i].y +\n              snapOffset.y\n          });\n        }\n      } else {\n        this.snapOffsets.push(snapOffset);\n      }\n\n      if (rect && restrict.elementRect) {\n        this.restrictOffset.left =\n          this.startOffset.left - width * restrict.elementRect.left;\n        this.restrictOffset.top =\n          this.startOffset.top - height * restrict.elementRect.top;\n\n        this.restrictOffset.right =\n          this.startOffset.right - width * (1 - restrict.elementRect.right);\n        this.restrictOffset.bottom =\n          this.startOffset.bottom - height * (1 - restrict.elementRect.bottom);\n      } else {\n        this.restrictOffset.left = this.restrictOffset.top = this.restrictOffset.right = this.restrictOffset.bottom = 0;\n      }\n    },\n\n    /*\\\n         * Interaction.start\n         [ method ]\n         *\n         * Start an action with the given Interactable and Element as tartgets. The\n         * action must be enabled for the target Interactable and an appropriate number\n         * of pointers must be held down – 1 for drag/resize, 2 for gesture.\n         *\n         * Use it with `interactable.<action>able({ manualStart: false })` to always\n         * [start actions manually](https://github.com/taye/interact.js/issues/114)\n         *\n         - action       (object)  The action to be performed - drag, resize, etc.\n         - interactable (Interactable) The Interactable to target\n         - element      (Element) The DOM Element to target\n         = (object) interact\n         **\n         | interact(target)\n         |   .draggable({\n         |     // disable the default drag start by down->move\n         |     manualStart: true\n         |   })\n         |   // start dragging after the user holds the pointer down\n         |   .on('hold', function (event) {\n         |     var interaction = event.interaction;\n         |\n         |     if (!interaction.interacting()) {\n         |       interaction.start({ name: 'drag' },\n         |                         event.interactable,\n         |                         event.currentTarget);\n         |     }\n         | });\n        \\*/\n    start: function(action, interactable, element) {\n      if (\n        this.interacting() ||\n        !this.pointerIsDown ||\n        this.pointerIds.length < (action.name === 'gesture' ? 2 : 1)\n      ) {\n        return;\n      }\n\n      // if this interaction had been removed after stopping\n      // add it back\n      if (indexOf(interactions, this) === -1) {\n        interactions.push(this);\n      }\n\n      // set the startCoords if there was no prepared action\n      if (!this.prepared.name) {\n        this.setEventXY(this.startCoords, this.pointers);\n      }\n\n      this.prepared.name = action.name;\n      this.prepared.axis = action.axis;\n      this.prepared.edges = action.edges;\n      this.target = interactable;\n      this.element = element;\n\n      this.setStartOffsets(action.name, interactable, element);\n      this.setModifications(this.startCoords.page);\n\n      this.prevEvent = this[this.prepared.name + 'Start'](this.downEvent);\n    },\n\n    pointerMove: function(pointer, event, eventTarget, curEventTarget, preEnd) {\n      if (this.inertiaStatus.active) {\n        var pageUp = this.inertiaStatus.upCoords.page;\n        var clientUp = this.inertiaStatus.upCoords.client;\n\n        var inertiaPosition = {\n          pageX: pageUp.x + this.inertiaStatus.sx,\n          pageY: pageUp.y + this.inertiaStatus.sy,\n          clientX: clientUp.x + this.inertiaStatus.sx,\n          clientY: clientUp.y + this.inertiaStatus.sy\n        };\n\n        this.setEventXY(this.curCoords, [inertiaPosition]);\n      } else {\n        this.recordPointer(pointer);\n        this.setEventXY(this.curCoords, this.pointers);\n      }\n\n      var duplicateMove =\n        this.curCoords.page.x === this.prevCoords.page.x &&\n        this.curCoords.page.y === this.prevCoords.page.y &&\n        this.curCoords.client.x === this.prevCoords.client.x &&\n        this.curCoords.client.y === this.prevCoords.client.y;\n\n      var dx,\n        dy,\n        pointerIndex = this.mouse\n          ? 0\n          : indexOf(this.pointerIds, getPointerId(pointer));\n\n      // register movement greater than pointerMoveTolerance\n      if (this.pointerIsDown && !this.pointerWasMoved) {\n        dx = this.curCoords.client.x - this.startCoords.client.x;\n        dy = this.curCoords.client.y - this.startCoords.client.y;\n\n        this.pointerWasMoved = hypot(dx, dy) > pointerMoveTolerance;\n      }\n\n      if (!duplicateMove && (!this.pointerIsDown || this.pointerWasMoved)) {\n        if (this.pointerIsDown) {\n          clearTimeout(this.holdTimers[pointerIndex]);\n        }\n\n        this.collectEventTargets(pointer, event, eventTarget, 'move');\n      }\n\n      if (!this.pointerIsDown) {\n        return;\n      }\n\n      if (duplicateMove && this.pointerWasMoved && !preEnd) {\n        this.checkAndPreventDefault(event, this.target, this.element);\n        return;\n      }\n\n      // set pointer coordinate, time changes and speeds\n      setEventDeltas(this.pointerDelta, this.prevCoords, this.curCoords);\n\n      if (!this.prepared.name) {\n        return;\n      }\n\n      if (\n        this.pointerWasMoved &&\n        // ignore movement while inertia is active\n        (!this.inertiaStatus.active ||\n          (pointer instanceof InteractEvent &&\n            /inertiastart/.test(pointer.type)))\n      ) {\n        // if just starting an action, calculate the pointer speed now\n        if (!this.interacting()) {\n          setEventDeltas(this.pointerDelta, this.prevCoords, this.curCoords);\n\n          // check if a drag is in the correct axis\n          if (this.prepared.name === 'drag') {\n            var absX = Math.abs(dx),\n              absY = Math.abs(dy),\n              targetAxis = this.target.options.drag.axis,\n              axis = absX > absY ? 'x' : absX < absY ? 'y' : 'xy';\n\n            // if the movement isn't in the axis of the interactable\n            if (axis !== 'xy' && targetAxis !== 'xy' && targetAxis !== axis) {\n              // cancel the prepared action\n              this.prepared.name = null;\n\n              // then try to get a drag from another ineractable\n\n              var element = eventTarget;\n\n              // check element interactables\n              while (isElement(element)) {\n                var elementInteractable = interactables.get(element);\n\n                if (\n                  elementInteractable &&\n                  elementInteractable !== this.target &&\n                  !elementInteractable.options.drag.manualStart &&\n                  (\n                    elementInteractable.getAction(\n                      this.downPointer,\n                      this.downEvent,\n                      this,\n                      element\n                    ) || {}\n                  ).name === 'drag' &&\n                  checkAxis(axis, elementInteractable)\n                ) {\n                  this.prepared.name = 'drag';\n                  this.target = elementInteractable;\n                  this.element = element;\n                  break;\n                }\n\n                element = parentElement(element);\n              }\n\n              // if there's no drag from element interactables,\n              // check the selector interactables\n              if (!this.prepared.name) {\n                var thisInteraction = this;\n\n                var getDraggable = function(interactable, selector, context) {\n                  var elements = ie8MatchesSelector\n                    ? context.querySelectorAll(selector)\n                    : undefined;\n\n                  if (interactable === thisInteraction.target) {\n                    return;\n                  }\n\n                  if (\n                    inContext(interactable, eventTarget) &&\n                    !interactable.options.drag.manualStart &&\n                    !testIgnore(interactable, element, eventTarget) &&\n                    testAllow(interactable, element, eventTarget) &&\n                    matchesSelector(element, selector, elements) &&\n                    interactable.getAction(\n                      thisInteraction.downPointer,\n                      thisInteraction.downEvent,\n                      thisInteraction,\n                      element\n                    ).name === 'drag' &&\n                    checkAxis(axis, interactable) &&\n                    withinInteractionLimit(interactable, element, 'drag')\n                  ) {\n                    return interactable;\n                  }\n                };\n\n                element = eventTarget;\n\n                while (isElement(element)) {\n                  var selectorInteractable = interactables.forEachSelector(\n                    getDraggable\n                  );\n\n                  if (selectorInteractable) {\n                    this.prepared.name = 'drag';\n                    this.target = selectorInteractable;\n                    this.element = element;\n                    break;\n                  }\n\n                  element = parentElement(element);\n                }\n              }\n            }\n          }\n        }\n\n        var starting = !!this.prepared.name && !this.interacting();\n\n        if (\n          starting &&\n          (this.target.options[this.prepared.name].manualStart ||\n            !withinInteractionLimit(this.target, this.element, this.prepared))\n        ) {\n          this.stop(event);\n          return;\n        }\n\n        if (this.prepared.name && this.target) {\n          if (starting) {\n            this.start(this.prepared, this.target, this.element);\n          }\n\n          var shouldMove = this.setModifications(this.curCoords.page, preEnd);\n\n          // move if snapping or restriction doesn't prevent it\n          if (shouldMove || starting) {\n            this.prevEvent = this[this.prepared.name + 'Move'](event);\n          }\n\n          this.checkAndPreventDefault(event, this.target, this.element);\n        }\n      }\n\n      copyCoords(this.prevCoords, this.curCoords);\n\n      if (this.dragging || this.resizing) {\n        this.autoScrollMove(pointer);\n      }\n    },\n\n    dragStart: function(event) {\n      var dragEvent = new InteractEvent(\n        this,\n        event,\n        'drag',\n        'start',\n        this.element\n      );\n\n      dragEvent.originalEvent = event;\n      this.dragging = true;\n      this.target.fire(dragEvent);\n\n      // reset active dropzones\n      this.activeDrops.dropzones = [];\n      this.activeDrops.elements = [];\n      this.activeDrops.rects = [];\n\n      if (!this.dynamicDrop) {\n        this.setActiveDrops(this.element);\n      }\n\n      var dropEvents = this.getDropEvents(event, dragEvent);\n\n      if (dropEvents.activate) {\n        this.fireActiveDrops(dropEvents.activate);\n      }\n\n      return dragEvent;\n    },\n\n    dragMove: function(event) {\n      var target = this.target,\n        dragEvent = new InteractEvent(\n          this,\n          event,\n          'drag',\n          'move',\n          this.element\n        ),\n        draggableElement = this.element,\n        drop = this.getDrop(dragEvent, event, draggableElement);\n\n      dragEvent.originalEvent = event;\n\n      this.dropTarget = drop.dropzone;\n      this.dropElement = drop.element;\n\n      var dropEvents = this.getDropEvents(event, dragEvent);\n\n      target.fire(dragEvent);\n\n      if (dropEvents.leave) {\n        this.prevDropTarget.fire(dropEvents.leave);\n      }\n      if (dropEvents.enter) {\n        this.dropTarget.fire(dropEvents.enter);\n      }\n      if (dropEvents.move) {\n        this.dropTarget.fire(dropEvents.move);\n      }\n\n      this.prevDropTarget = this.dropTarget;\n      this.prevDropElement = this.dropElement;\n\n      return dragEvent;\n    },\n\n    resizeStart: function(event) {\n      var resizeEvent = new InteractEvent(\n        this,\n        event,\n        'resize',\n        'start',\n        this.element\n      );\n\n      if (this.prepared.edges) {\n        var startRect = this.target.getRect(this.element);\n\n        /*\n         * When using the `resizable.square` or `resizable.preserveAspectRatio` options, resizing from one edge\n         * will affect another. E.g. with `resizable.square`, resizing to make the right edge larger will make\n         * the bottom edge larger by the same amount. We call these 'linked' edges. Any linked edges will depend\n         * on the active edges and the edge being interacted with.\n         */\n        if (\n          this.target.options.resize.square ||\n          this.target.options.resize.preserveAspectRatio\n        ) {\n          var linkedEdges = extend({}, this.prepared.edges);\n\n          linkedEdges.top =\n            linkedEdges.top || (linkedEdges.left && !linkedEdges.bottom);\n          linkedEdges.left =\n            linkedEdges.left || (linkedEdges.top && !linkedEdges.right);\n          linkedEdges.bottom =\n            linkedEdges.bottom || (linkedEdges.right && !linkedEdges.top);\n          linkedEdges.right =\n            linkedEdges.right || (linkedEdges.bottom && !linkedEdges.left);\n\n          this.prepared._linkedEdges = linkedEdges;\n        } else {\n          this.prepared._linkedEdges = null;\n        }\n\n        // if using `resizable.preserveAspectRatio` option, record aspect ratio at the start of the resize\n        if (this.target.options.resize.preserveAspectRatio) {\n          this.resizeStartAspectRatio = startRect.width / startRect.height;\n        }\n\n        this.resizeRects = {\n          start: startRect,\n          current: extend({}, startRect),\n          restricted: extend({}, startRect),\n          previous: extend({}, startRect),\n          delta: {\n            left: 0,\n            right: 0,\n            width: 0,\n            top: 0,\n            bottom: 0,\n            height: 0\n          }\n        };\n\n        resizeEvent.rect = this.resizeRects.restricted;\n        resizeEvent.deltaRect = this.resizeRects.delta;\n      }\n\n      this.target.fire(resizeEvent);\n\n      this.resizing = true;\n\n      return resizeEvent;\n    },\n\n    resizeMove: function(event) {\n      var resizeEvent = new InteractEvent(\n        this,\n        event,\n        'resize',\n        'move',\n        this.element\n      );\n\n      var edges = this.prepared.edges,\n        invert = this.target.options.resize.invert,\n        invertible = invert === 'reposition' || invert === 'negate';\n\n      if (edges) {\n        var dx = resizeEvent.dx,\n          dy = resizeEvent.dy,\n          start = this.resizeRects.start,\n          current = this.resizeRects.current,\n          restricted = this.resizeRects.restricted,\n          delta = this.resizeRects.delta,\n          previous = extend(this.resizeRects.previous, restricted),\n          originalEdges = edges;\n\n        // `resize.preserveAspectRatio` takes precedence over `resize.square`\n        if (this.target.options.resize.preserveAspectRatio) {\n          var resizeStartAspectRatio = this.resizeStartAspectRatio;\n\n          edges = this.prepared._linkedEdges;\n\n          if (\n            (originalEdges.left && originalEdges.bottom) ||\n            (originalEdges.right && originalEdges.top)\n          ) {\n            dy = -dx / resizeStartAspectRatio;\n          } else if (originalEdges.left || originalEdges.right) {\n            dy = dx / resizeStartAspectRatio;\n          } else if (originalEdges.top || originalEdges.bottom) {\n            dx = dy * resizeStartAspectRatio;\n          }\n        } else if (this.target.options.resize.square) {\n          edges = this.prepared._linkedEdges;\n\n          if (\n            (originalEdges.left && originalEdges.bottom) ||\n            (originalEdges.right && originalEdges.top)\n          ) {\n            dy = -dx;\n          } else if (originalEdges.left || originalEdges.right) {\n            dy = dx;\n          } else if (originalEdges.top || originalEdges.bottom) {\n            dx = dy;\n          }\n        }\n\n        // update the 'current' rect without modifications\n        if (edges.top) {\n          current.top += dy;\n        }\n        if (edges.bottom) {\n          current.bottom += dy;\n        }\n        if (edges.left) {\n          current.left += dx;\n        }\n        if (edges.right) {\n          current.right += dx;\n        }\n\n        if (invertible) {\n          // if invertible, copy the current rect\n          extend(restricted, current);\n\n          if (invert === 'reposition') {\n            // swap edge values if necessary to keep width/height positive\n            var swap;\n\n            if (restricted.top > restricted.bottom) {\n              swap = restricted.top;\n\n              restricted.top = restricted.bottom;\n              restricted.bottom = swap;\n            }\n            if (restricted.left > restricted.right) {\n              swap = restricted.left;\n\n              restricted.left = restricted.right;\n              restricted.right = swap;\n            }\n          }\n        } else {\n          // if not invertible, restrict to minimum of 0x0 rect\n          restricted.top = Math.min(current.top, start.bottom);\n          restricted.bottom = Math.max(current.bottom, start.top);\n          restricted.left = Math.min(current.left, start.right);\n          restricted.right = Math.max(current.right, start.left);\n        }\n\n        restricted.width = restricted.right - restricted.left;\n        restricted.height = restricted.bottom - restricted.top;\n\n        for (var edge in restricted) {\n          delta[edge] = restricted[edge] - previous[edge];\n        }\n\n        resizeEvent.edges = this.prepared.edges;\n        resizeEvent.rect = restricted;\n        resizeEvent.deltaRect = delta;\n      }\n\n      this.target.fire(resizeEvent);\n\n      return resizeEvent;\n    },\n\n    gestureStart: function(event) {\n      var gestureEvent = new InteractEvent(\n        this,\n        event,\n        'gesture',\n        'start',\n        this.element\n      );\n\n      gestureEvent.ds = 0;\n\n      this.gesture.startDistance = this.gesture.prevDistance =\n        gestureEvent.distance;\n      this.gesture.startAngle = this.gesture.prevAngle = gestureEvent.angle;\n      this.gesture.scale = 1;\n\n      this.gesturing = true;\n\n      this.target.fire(gestureEvent);\n\n      return gestureEvent;\n    },\n\n    gestureMove: function(event) {\n      if (!this.pointerIds.length) {\n        return this.prevEvent;\n      }\n\n      var gestureEvent;\n\n      gestureEvent = new InteractEvent(\n        this,\n        event,\n        'gesture',\n        'move',\n        this.element\n      );\n      gestureEvent.ds = gestureEvent.scale - this.gesture.scale;\n\n      this.target.fire(gestureEvent);\n\n      this.gesture.prevAngle = gestureEvent.angle;\n      this.gesture.prevDistance = gestureEvent.distance;\n\n      if (\n        gestureEvent.scale !== Infinity &&\n        gestureEvent.scale !== null &&\n        gestureEvent.scale !== undefined &&\n        !isNaN(gestureEvent.scale)\n      ) {\n        this.gesture.scale = gestureEvent.scale;\n      }\n\n      return gestureEvent;\n    },\n\n    pointerHold: function(pointer, event, eventTarget) {\n      this.collectEventTargets(pointer, event, eventTarget, 'hold');\n    },\n\n    pointerUp: function(pointer, event, eventTarget, curEventTarget) {\n      var pointerIndex = this.mouse\n        ? 0\n        : indexOf(this.pointerIds, getPointerId(pointer));\n\n      clearTimeout(this.holdTimers[pointerIndex]);\n\n      this.collectEventTargets(pointer, event, eventTarget, 'up');\n      this.collectEventTargets(pointer, event, eventTarget, 'tap');\n\n      this.pointerEnd(pointer, event, eventTarget, curEventTarget);\n\n      this.removePointer(pointer);\n    },\n\n    pointerCancel: function(pointer, event, eventTarget, curEventTarget) {\n      var pointerIndex = this.mouse\n        ? 0\n        : indexOf(this.pointerIds, getPointerId(pointer));\n\n      clearTimeout(this.holdTimers[pointerIndex]);\n\n      this.collectEventTargets(pointer, event, eventTarget, 'cancel');\n      this.pointerEnd(pointer, event, eventTarget, curEventTarget);\n\n      this.removePointer(pointer);\n    },\n\n    // http://www.quirksmode.org/dom/events/click.html\n    // >Events leading to dblclick\n    //\n    // IE8 doesn't fire down event before dblclick.\n    // This workaround tries to fire a tap and doubletap after dblclick\n    ie8Dblclick: function(pointer, event, eventTarget) {\n      if (\n        this.prevTap &&\n        event.clientX === this.prevTap.clientX &&\n        event.clientY === this.prevTap.clientY &&\n        eventTarget === this.prevTap.target\n      ) {\n        this.downTargets[0] = eventTarget;\n        this.downTimes[0] = new Date().getTime();\n        this.collectEventTargets(pointer, event, eventTarget, 'tap');\n      }\n    },\n\n    // End interact move events and stop auto-scroll unless inertia is enabled\n    pointerEnd: function(pointer, event, eventTarget, curEventTarget) {\n      var endEvent,\n        target = this.target,\n        options = target && target.options,\n        inertiaOptions =\n          options && this.prepared.name && options[this.prepared.name].inertia,\n        inertiaStatus = this.inertiaStatus;\n\n      if (this.interacting()) {\n        if (inertiaStatus.active && !inertiaStatus.ending) {\n          return;\n        }\n\n        var pointerSpeed,\n          now = new Date().getTime(),\n          inertiaPossible = false,\n          inertia = false,\n          smoothEnd = false,\n          endSnap =\n            checkSnap(target, this.prepared.name) &&\n            options[this.prepared.name].snap.endOnly,\n          endRestrict =\n            checkRestrict(target, this.prepared.name) &&\n            options[this.prepared.name].restrict.endOnly,\n          dx = 0,\n          dy = 0,\n          startEvent;\n\n        if (this.dragging) {\n          if (options.drag.axis === 'x') {\n            pointerSpeed = Math.abs(this.pointerDelta.client.vx);\n          } else if (options.drag.axis === 'y') {\n            pointerSpeed = Math.abs(this.pointerDelta.client.vy);\n          } /*options.drag.axis === 'xy'*/ else {\n            pointerSpeed = this.pointerDelta.client.speed;\n          }\n        } else {\n          pointerSpeed = this.pointerDelta.client.speed;\n        }\n\n        // check if inertia should be started\n        inertiaPossible =\n          inertiaOptions &&\n          inertiaOptions.enabled &&\n          this.prepared.name !== 'gesture' &&\n          event !== inertiaStatus.startEvent;\n\n        inertia =\n          inertiaPossible &&\n          now - this.curCoords.timeStamp < 50 &&\n          pointerSpeed > inertiaOptions.minSpeed &&\n          pointerSpeed > inertiaOptions.endSpeed;\n\n        if (inertiaPossible && !inertia && (endSnap || endRestrict)) {\n          var snapRestrict = {};\n\n          snapRestrict.snap = snapRestrict.restrict = snapRestrict;\n\n          if (endSnap) {\n            this.setSnapping(this.curCoords.page, snapRestrict);\n            if (snapRestrict.locked) {\n              dx += snapRestrict.dx;\n              dy += snapRestrict.dy;\n            }\n          }\n\n          if (endRestrict) {\n            this.setRestriction(this.curCoords.page, snapRestrict);\n            if (snapRestrict.restricted) {\n              dx += snapRestrict.dx;\n              dy += snapRestrict.dy;\n            }\n          }\n\n          if (dx || dy) {\n            smoothEnd = true;\n          }\n        }\n\n        if (inertia || smoothEnd) {\n          copyCoords(inertiaStatus.upCoords, this.curCoords);\n\n          this.pointers[0] = inertiaStatus.startEvent = startEvent = new InteractEvent(\n            this,\n            event,\n            this.prepared.name,\n            'inertiastart',\n            this.element\n          );\n\n          inertiaStatus.t0 = now;\n\n          target.fire(inertiaStatus.startEvent);\n\n          if (inertia) {\n            inertiaStatus.vx0 = this.pointerDelta.client.vx;\n            inertiaStatus.vy0 = this.pointerDelta.client.vy;\n            inertiaStatus.v0 = pointerSpeed;\n\n            this.calcInertia(inertiaStatus);\n\n            var page = extend({}, this.curCoords.page),\n              origin = getOriginXY(target, this.element),\n              statusObject;\n\n            page.x = page.x + inertiaStatus.xe - origin.x;\n            page.y = page.y + inertiaStatus.ye - origin.y;\n\n            statusObject = {\n              useStatusXY: true,\n              x: page.x,\n              y: page.y,\n              dx: 0,\n              dy: 0,\n              snap: null\n            };\n\n            statusObject.snap = statusObject;\n\n            dx = dy = 0;\n\n            if (endSnap) {\n              var snap = this.setSnapping(this.curCoords.page, statusObject);\n\n              if (snap.locked) {\n                dx += snap.dx;\n                dy += snap.dy;\n              }\n            }\n\n            if (endRestrict) {\n              var restrict = this.setRestriction(\n                this.curCoords.page,\n                statusObject\n              );\n\n              if (restrict.restricted) {\n                dx += restrict.dx;\n                dy += restrict.dy;\n              }\n            }\n\n            inertiaStatus.modifiedXe += dx;\n            inertiaStatus.modifiedYe += dy;\n\n            inertiaStatus.i = reqFrame(this.boundInertiaFrame);\n          } else {\n            inertiaStatus.smoothEnd = true;\n            inertiaStatus.xe = dx;\n            inertiaStatus.ye = dy;\n\n            inertiaStatus.sx = inertiaStatus.sy = 0;\n\n            inertiaStatus.i = reqFrame(this.boundSmoothEndFrame);\n          }\n\n          inertiaStatus.active = true;\n          return;\n        }\n\n        if (endSnap || endRestrict) {\n          // fire a move event at the snapped coordinates\n          this.pointerMove(pointer, event, eventTarget, curEventTarget, true);\n        }\n      }\n\n      if (this.dragging) {\n        endEvent = new InteractEvent(this, event, 'drag', 'end', this.element);\n\n        var draggableElement = this.element,\n          drop = this.getDrop(endEvent, event, draggableElement);\n\n        this.dropTarget = drop.dropzone;\n        this.dropElement = drop.element;\n\n        var dropEvents = this.getDropEvents(event, endEvent);\n\n        if (dropEvents.leave) {\n          this.prevDropTarget.fire(dropEvents.leave);\n        }\n        if (dropEvents.enter) {\n          this.dropTarget.fire(dropEvents.enter);\n        }\n        if (dropEvents.drop) {\n          this.dropTarget.fire(dropEvents.drop);\n        }\n        if (dropEvents.deactivate) {\n          this.fireActiveDrops(dropEvents.deactivate);\n        }\n\n        target.fire(endEvent);\n      } else if (this.resizing) {\n        endEvent = new InteractEvent(\n          this,\n          event,\n          'resize',\n          'end',\n          this.element\n        );\n        target.fire(endEvent);\n      } else if (this.gesturing) {\n        endEvent = new InteractEvent(\n          this,\n          event,\n          'gesture',\n          'end',\n          this.element\n        );\n        target.fire(endEvent);\n      }\n\n      this.stop(event);\n    },\n\n    collectDrops: function(element) {\n      var drops = [],\n        elements = [],\n        i;\n\n      element = element || this.element;\n\n      // collect all dropzones and their elements which qualify for a drop\n      for (i = 0; i < interactables.length; i++) {\n        if (!interactables[i].options.drop.enabled) {\n          continue;\n        }\n\n        var current = interactables[i],\n          accept = current.options.drop.accept;\n\n        // test the draggable element against the dropzone's accept setting\n        if (\n          (isElement(accept) && accept !== element) ||\n          (isString(accept) && !matchesSelector(element, accept))\n        ) {\n          continue;\n        }\n\n        // query for new elements if necessary\n        var dropElements = current.selector\n          ? current._context.querySelectorAll(current.selector)\n          : [current._element];\n\n        for (var j = 0, len = dropElements.length; j < len; j++) {\n          var currentElement = dropElements[j];\n\n          if (currentElement === element) {\n            continue;\n          }\n\n          drops.push(current);\n          elements.push(currentElement);\n        }\n      }\n\n      return {\n        dropzones: drops,\n        elements: elements\n      };\n    },\n\n    fireActiveDrops: function(event) {\n      var i, current, currentElement, prevElement;\n\n      // loop through all active dropzones and trigger event\n      for (i = 0; i < this.activeDrops.dropzones.length; i++) {\n        current = this.activeDrops.dropzones[i];\n        currentElement = this.activeDrops.elements[i];\n\n        // prevent trigger of duplicate events on same element\n        if (currentElement !== prevElement) {\n          // set current element as event target\n          event.target = currentElement;\n          current.fire(event);\n        }\n        prevElement = currentElement;\n      }\n    },\n\n    // Collect a new set of possible drops and save them in activeDrops.\n    // setActiveDrops should always be called when a drag has just started or a\n    // drag event happens while dynamicDrop is true\n    setActiveDrops: function(dragElement) {\n      // get dropzones and their elements that could receive the draggable\n      var possibleDrops = this.collectDrops(dragElement, true);\n\n      this.activeDrops.dropzones = possibleDrops.dropzones;\n      this.activeDrops.elements = possibleDrops.elements;\n      this.activeDrops.rects = [];\n\n      for (var i = 0; i < this.activeDrops.dropzones.length; i++) {\n        this.activeDrops.rects[i] = this.activeDrops.dropzones[i].getRect(\n          this.activeDrops.elements[i]\n        );\n      }\n    },\n\n    getDrop: function(dragEvent, event, dragElement) {\n      var validDrops = [];\n\n      if (dynamicDrop) {\n        this.setActiveDrops(dragElement);\n      }\n\n      // collect all dropzones and their elements which qualify for a drop\n      for (var j = 0; j < this.activeDrops.dropzones.length; j++) {\n        var current = this.activeDrops.dropzones[j],\n          currentElement = this.activeDrops.elements[j],\n          rect = this.activeDrops.rects[j];\n\n        validDrops.push(\n          current.dropCheck(\n            dragEvent,\n            event,\n            this.target,\n            dragElement,\n            currentElement,\n            rect\n          )\n            ? currentElement\n            : null\n        );\n      }\n\n      // get the most appropriate dropzone based on DOM depth and order\n      var dropIndex = indexOfDeepestElement(validDrops),\n        dropzone = this.activeDrops.dropzones[dropIndex] || null,\n        element = this.activeDrops.elements[dropIndex] || null;\n\n      return {\n        dropzone: dropzone,\n        element: element\n      };\n    },\n\n    getDropEvents: function(pointerEvent, dragEvent) {\n      var dropEvents = {\n        enter: null,\n        leave: null,\n        activate: null,\n        deactivate: null,\n        move: null,\n        drop: null\n      };\n\n      if (this.dropElement !== this.prevDropElement) {\n        // if there was a prevDropTarget, create a dragleave event\n        if (this.prevDropTarget) {\n          dropEvents.leave = {\n            target: this.prevDropElement,\n            dropzone: this.prevDropTarget,\n            relatedTarget: dragEvent.target,\n            draggable: dragEvent.interactable,\n            dragEvent: dragEvent,\n            interaction: this,\n            timeStamp: dragEvent.timeStamp,\n            type: 'dragleave'\n          };\n\n          dragEvent.dragLeave = this.prevDropElement;\n          dragEvent.prevDropzone = this.prevDropTarget;\n        }\n        // if the dropTarget is not null, create a dragenter event\n        if (this.dropTarget) {\n          dropEvents.enter = {\n            target: this.dropElement,\n            dropzone: this.dropTarget,\n            relatedTarget: dragEvent.target,\n            draggable: dragEvent.interactable,\n            dragEvent: dragEvent,\n            interaction: this,\n            timeStamp: dragEvent.timeStamp,\n            type: 'dragenter'\n          };\n\n          dragEvent.dragEnter = this.dropElement;\n          dragEvent.dropzone = this.dropTarget;\n        }\n      }\n\n      if (dragEvent.type === 'dragend' && this.dropTarget) {\n        dropEvents.drop = {\n          target: this.dropElement,\n          dropzone: this.dropTarget,\n          relatedTarget: dragEvent.target,\n          draggable: dragEvent.interactable,\n          dragEvent: dragEvent,\n          interaction: this,\n          timeStamp: dragEvent.timeStamp,\n          type: 'drop'\n        };\n\n        dragEvent.dropzone = this.dropTarget;\n      }\n      if (dragEvent.type === 'dragstart') {\n        dropEvents.activate = {\n          target: null,\n          dropzone: null,\n          relatedTarget: dragEvent.target,\n          draggable: dragEvent.interactable,\n          dragEvent: dragEvent,\n          interaction: this,\n          timeStamp: dragEvent.timeStamp,\n          type: 'dropactivate'\n        };\n      }\n      if (dragEvent.type === 'dragend') {\n        dropEvents.deactivate = {\n          target: null,\n          dropzone: null,\n          relatedTarget: dragEvent.target,\n          draggable: dragEvent.interactable,\n          dragEvent: dragEvent,\n          interaction: this,\n          timeStamp: dragEvent.timeStamp,\n          type: 'dropdeactivate'\n        };\n      }\n      if (dragEvent.type === 'dragmove' && this.dropTarget) {\n        dropEvents.move = {\n          target: this.dropElement,\n          dropzone: this.dropTarget,\n          relatedTarget: dragEvent.target,\n          draggable: dragEvent.interactable,\n          dragEvent: dragEvent,\n          interaction: this,\n          dragmove: dragEvent,\n          timeStamp: dragEvent.timeStamp,\n          type: 'dropmove'\n        };\n        dragEvent.dropzone = this.dropTarget;\n      }\n\n      return dropEvents;\n    },\n\n    currentAction: function() {\n      return (\n        (this.dragging && 'drag') ||\n        (this.resizing && 'resize') ||\n        (this.gesturing && 'gesture') ||\n        null\n      );\n    },\n\n    interacting: function() {\n      return this.dragging || this.resizing || this.gesturing;\n    },\n\n    clearTargets: function() {\n      this.target = this.element = null;\n\n      this.dropTarget = this.dropElement = this.prevDropTarget = this.prevDropElement = null;\n    },\n\n    stop: function(event) {\n      if (this.interacting()) {\n        autoScroll.stop();\n        this.matches = [];\n        this.matchElements = [];\n\n        var target = this.target;\n\n        if (target.options.styleCursor) {\n          target._doc.documentElement.style.cursor = '';\n        }\n\n        // prevent Default only if were previously interacting\n        if (event && isFunction(event.preventDefault)) {\n          this.checkAndPreventDefault(event, target, this.element);\n        }\n\n        if (this.dragging) {\n          this.activeDrops.dropzones = this.activeDrops.elements = this.activeDrops.rects = null;\n        }\n      }\n\n      this.clearTargets();\n\n      this.pointerIsDown = this.snapStatus.locked = this.dragging = this.resizing = this.gesturing = false;\n      this.prepared.name = this.prevEvent = null;\n      this.inertiaStatus.resumeDx = this.inertiaStatus.resumeDy = 0;\n\n      // remove pointers if their ID isn't in this.pointerIds\n      for (var i = 0; i < this.pointers.length; i++) {\n        if (indexOf(this.pointerIds, getPointerId(this.pointers[i])) === -1) {\n          this.pointers.splice(i, 1);\n        }\n      }\n    },\n\n    inertiaFrame: function() {\n      var inertiaStatus = this.inertiaStatus,\n        options = this.target.options[this.prepared.name].inertia,\n        lambda = options.resistance,\n        t = new Date().getTime() / 1000 - inertiaStatus.t0;\n\n      if (t < inertiaStatus.te) {\n        var progress =\n          1 -\n          (Math.exp(-lambda * t) - inertiaStatus.lambda_v0) /\n            inertiaStatus.one_ve_v0;\n\n        if (\n          inertiaStatus.modifiedXe === inertiaStatus.xe &&\n          inertiaStatus.modifiedYe === inertiaStatus.ye\n        ) {\n          inertiaStatus.sx = inertiaStatus.xe * progress;\n          inertiaStatus.sy = inertiaStatus.ye * progress;\n        } else {\n          var quadPoint = getQuadraticCurvePoint(\n            0,\n            0,\n            inertiaStatus.xe,\n            inertiaStatus.ye,\n            inertiaStatus.modifiedXe,\n            inertiaStatus.modifiedYe,\n            progress\n          );\n\n          inertiaStatus.sx = quadPoint.x;\n          inertiaStatus.sy = quadPoint.y;\n        }\n\n        this.pointerMove(inertiaStatus.startEvent, inertiaStatus.startEvent);\n\n        inertiaStatus.i = reqFrame(this.boundInertiaFrame);\n      } else {\n        inertiaStatus.ending = true;\n\n        inertiaStatus.sx = inertiaStatus.modifiedXe;\n        inertiaStatus.sy = inertiaStatus.modifiedYe;\n\n        this.pointerMove(inertiaStatus.startEvent, inertiaStatus.startEvent);\n        this.pointerEnd(inertiaStatus.startEvent, inertiaStatus.startEvent);\n\n        inertiaStatus.active = inertiaStatus.ending = false;\n      }\n    },\n\n    smoothEndFrame: function() {\n      var inertiaStatus = this.inertiaStatus,\n        t = new Date().getTime() - inertiaStatus.t0,\n        duration = this.target.options[this.prepared.name].inertia\n          .smoothEndDuration;\n\n      if (t < duration) {\n        inertiaStatus.sx = easeOutQuad(t, 0, inertiaStatus.xe, duration);\n        inertiaStatus.sy = easeOutQuad(t, 0, inertiaStatus.ye, duration);\n\n        this.pointerMove(inertiaStatus.startEvent, inertiaStatus.startEvent);\n\n        inertiaStatus.i = reqFrame(this.boundSmoothEndFrame);\n      } else {\n        inertiaStatus.ending = true;\n\n        inertiaStatus.sx = inertiaStatus.xe;\n        inertiaStatus.sy = inertiaStatus.ye;\n\n        this.pointerMove(inertiaStatus.startEvent, inertiaStatus.startEvent);\n        this.pointerEnd(inertiaStatus.startEvent, inertiaStatus.startEvent);\n\n        inertiaStatus.smoothEnd = inertiaStatus.active = inertiaStatus.ending = false;\n      }\n    },\n\n    addPointer: function(pointer) {\n      var id = getPointerId(pointer),\n        index = this.mouse ? 0 : indexOf(this.pointerIds, id);\n\n      if (index === -1) {\n        index = this.pointerIds.length;\n      }\n\n      this.pointerIds[index] = id;\n      this.pointers[index] = pointer;\n\n      return index;\n    },\n\n    removePointer: function(pointer) {\n      var id = getPointerId(pointer),\n        index = this.mouse ? 0 : indexOf(this.pointerIds, id);\n\n      if (index === -1) {\n        return;\n      }\n\n      this.pointers.splice(index, 1);\n      this.pointerIds.splice(index, 1);\n      this.downTargets.splice(index, 1);\n      this.downTimes.splice(index, 1);\n      this.holdTimers.splice(index, 1);\n    },\n\n    recordPointer: function(pointer) {\n      var index = this.mouse\n        ? 0\n        : indexOf(this.pointerIds, getPointerId(pointer));\n\n      if (index === -1) {\n        return;\n      }\n\n      this.pointers[index] = pointer;\n    },\n\n    collectEventTargets: function(pointer, event, eventTarget, eventType) {\n      var pointerIndex = this.mouse\n        ? 0\n        : indexOf(this.pointerIds, getPointerId(pointer));\n\n      // do not fire a tap event if the pointer was moved before being lifted\n      if (\n        eventType === 'tap' &&\n        (this.pointerWasMoved ||\n          // or if the pointerup target is different to the pointerdown target\n          !(\n            this.downTargets[pointerIndex] &&\n            this.downTargets[pointerIndex] === eventTarget\n          ))\n      ) {\n        return;\n      }\n\n      var targets = [],\n        elements = [],\n        element = eventTarget;\n\n      function collectSelectors(interactable, selector, context) {\n        var els = ie8MatchesSelector\n          ? context.querySelectorAll(selector)\n          : undefined;\n\n        if (\n          interactable._iEvents[eventType] &&\n          isElement(element) &&\n          inContext(interactable, element) &&\n          !testIgnore(interactable, element, eventTarget) &&\n          testAllow(interactable, element, eventTarget) &&\n          matchesSelector(element, selector, els)\n        ) {\n          targets.push(interactable);\n          elements.push(element);\n        }\n      }\n\n      while (element) {\n        if (interact.isSet(element) && interact(element)._iEvents[eventType]) {\n          targets.push(interact(element));\n          elements.push(element);\n        }\n\n        interactables.forEachSelector(collectSelectors);\n\n        element = parentElement(element);\n      }\n\n      // create the tap event even if there are no listeners so that\n      // doubletap can still be created and fired\n      if (targets.length || eventType === 'tap') {\n        this.firePointers(\n          pointer,\n          event,\n          eventTarget,\n          targets,\n          elements,\n          eventType\n        );\n      }\n    },\n\n    firePointers: function(\n      pointer,\n      event,\n      eventTarget,\n      targets,\n      elements,\n      eventType\n    ) {\n      var pointerIndex = this.mouse\n          ? 0\n          : indexOf(this.pointerIds, getPointerId(pointer)),\n        pointerEvent = {},\n        i,\n        // for tap events\n        interval,\n        createNewDoubleTap;\n\n      // if it's a doubletap then the event properties would have been\n      // copied from the tap event and provided as the pointer argument\n      if (eventType === 'doubletap') {\n        pointerEvent = pointer;\n      } else {\n        pointerExtend(pointerEvent, event);\n        if (event !== pointer) {\n          pointerExtend(pointerEvent, pointer);\n        }\n\n        pointerEvent.preventDefault = preventOriginalDefault;\n        pointerEvent.stopPropagation = InteractEvent.prototype.stopPropagation;\n        pointerEvent.stopImmediatePropagation =\n          InteractEvent.prototype.stopImmediatePropagation;\n        pointerEvent.interaction = this;\n\n        pointerEvent.timeStamp = new Date().getTime();\n        pointerEvent.originalEvent = event;\n        pointerEvent.originalPointer = pointer;\n        pointerEvent.type = eventType;\n        pointerEvent.pointerId = getPointerId(pointer);\n        pointerEvent.pointerType = this.mouse\n          ? 'mouse'\n          : !supportsPointerEvent\n          ? 'touch'\n          : isString(pointer.pointerType)\n          ? pointer.pointerType\n          : [, , 'touch', 'pen', 'mouse'][pointer.pointerType];\n      }\n\n      if (eventType === 'tap') {\n        pointerEvent.dt = pointerEvent.timeStamp - this.downTimes[pointerIndex];\n\n        interval = pointerEvent.timeStamp - this.tapTime;\n        createNewDoubleTap = !!(\n          this.prevTap &&\n          this.prevTap.type !== 'doubletap' &&\n          this.prevTap.target === pointerEvent.target &&\n          interval < 500\n        );\n\n        pointerEvent.double = createNewDoubleTap;\n\n        this.tapTime = pointerEvent.timeStamp;\n      }\n\n      for (i = 0; i < targets.length; i++) {\n        pointerEvent.currentTarget = elements[i];\n        pointerEvent.interactable = targets[i];\n        targets[i].fire(pointerEvent);\n\n        if (\n          pointerEvent.immediatePropagationStopped ||\n          (pointerEvent.propagationStopped &&\n            elements[i + 1] !== pointerEvent.currentTarget)\n        ) {\n          break;\n        }\n      }\n\n      if (createNewDoubleTap) {\n        var doubleTap = {};\n\n        extend(doubleTap, pointerEvent);\n\n        doubleTap.dt = interval;\n        doubleTap.type = 'doubletap';\n\n        this.collectEventTargets(doubleTap, event, eventTarget, 'doubletap');\n\n        this.prevTap = doubleTap;\n      } else if (eventType === 'tap') {\n        this.prevTap = pointerEvent;\n      }\n    },\n\n    validateSelector: function(pointer, event, matches, matchElements) {\n      for (var i = 0, len = matches.length; i < len; i++) {\n        var match = matches[i],\n          matchElement = matchElements[i],\n          action = validateAction(\n            match.getAction(pointer, event, this, matchElement),\n            match\n          );\n\n        if (action && withinInteractionLimit(match, matchElement, action)) {\n          this.target = match;\n          this.element = matchElement;\n\n          return action;\n        }\n      }\n    },\n\n    setSnapping: function(pageCoords, status) {\n      var snap = this.target.options[this.prepared.name].snap,\n        targets = [],\n        target,\n        page,\n        i;\n\n      status = status || this.snapStatus;\n\n      if (status.useStatusXY) {\n        page = {x: status.x, y: status.y};\n      } else {\n        var origin = getOriginXY(this.target, this.element);\n\n        page = extend({}, pageCoords);\n\n        page.x -= origin.x;\n        page.y -= origin.y;\n      }\n\n      status.realX = page.x;\n      status.realY = page.y;\n\n      page.x = page.x - this.inertiaStatus.resumeDx;\n      page.y = page.y - this.inertiaStatus.resumeDy;\n\n      var len = snap.targets ? snap.targets.length : 0;\n\n      for (var relIndex = 0; relIndex < this.snapOffsets.length; relIndex++) {\n        var relative = {\n          x: page.x - this.snapOffsets[relIndex].x,\n          y: page.y - this.snapOffsets[relIndex].y\n        };\n\n        for (i = 0; i < len; i++) {\n          if (isFunction(snap.targets[i])) {\n            target = snap.targets[i](relative.x, relative.y, this);\n          } else {\n            target = snap.targets[i];\n          }\n\n          if (!target) {\n            continue;\n          }\n\n          targets.push({\n            x: isNumber(target.x)\n              ? target.x + this.snapOffsets[relIndex].x\n              : relative.x,\n            y: isNumber(target.y)\n              ? target.y + this.snapOffsets[relIndex].y\n              : relative.y,\n\n            range: isNumber(target.range) ? target.range : snap.range\n          });\n        }\n      }\n\n      var closest = {\n        target: null,\n        inRange: false,\n        distance: 0,\n        range: 0,\n        dx: 0,\n        dy: 0\n      };\n\n      for (i = 0, len = targets.length; i < len; i++) {\n        target = targets[i];\n\n        var range = target.range,\n          dx = target.x - page.x,\n          dy = target.y - page.y,\n          distance = hypot(dx, dy),\n          inRange = distance <= range;\n\n        // Infinite targets count as being out of range\n        // compared to non infinite ones that are in range\n        if (\n          range === Infinity &&\n          closest.inRange &&\n          closest.range !== Infinity\n        ) {\n          inRange = false;\n        }\n\n        if (\n          !closest.target ||\n          (inRange\n            ? // is the closest target in range?\n              closest.inRange && range !== Infinity\n              ? // the pointer is relatively deeper in this target\n                distance / range < closest.distance / closest.range\n              : // this target has Infinite range and the closest doesn't\n                (range === Infinity && closest.range !== Infinity) ||\n                // OR this target is closer that the previous closest\n                distance < closest.distance\n            : // The other is not in range and the pointer is closer to this target\n              !closest.inRange && distance < closest.distance)\n        ) {\n          if (range === Infinity) {\n            inRange = true;\n          }\n\n          closest.target = target;\n          closest.distance = distance;\n          closest.range = range;\n          closest.inRange = inRange;\n          closest.dx = dx;\n          closest.dy = dy;\n\n          status.range = range;\n        }\n      }\n\n      var snapChanged;\n\n      if (closest.target) {\n        snapChanged =\n          status.snappedX !== closest.target.x ||\n          status.snappedY !== closest.target.y;\n\n        status.snappedX = closest.target.x;\n        status.snappedY = closest.target.y;\n      } else {\n        snapChanged = true;\n\n        status.snappedX = NaN;\n        status.snappedY = NaN;\n      }\n\n      status.dx = closest.dx;\n      status.dy = closest.dy;\n\n      status.changed = snapChanged || (closest.inRange && !status.locked);\n      status.locked = closest.inRange;\n\n      return status;\n    },\n\n    setRestriction: function(pageCoords, status) {\n      var target = this.target,\n        restrict = target && target.options[this.prepared.name].restrict,\n        restriction = restrict && restrict.restriction,\n        page;\n\n      if (!restriction) {\n        return status;\n      }\n\n      status = status || this.restrictStatus;\n\n      page = status.useStatusXY\n        ? (page = {x: status.x, y: status.y})\n        : (page = extend({}, pageCoords));\n\n      if (status.snap && status.snap.locked) {\n        page.x += status.snap.dx || 0;\n        page.y += status.snap.dy || 0;\n      }\n\n      page.x -= this.inertiaStatus.resumeDx;\n      page.y -= this.inertiaStatus.resumeDy;\n\n      status.dx = 0;\n      status.dy = 0;\n      status.restricted = false;\n\n      var rect, restrictedX, restrictedY;\n\n      if (isString(restriction)) {\n        if (restriction === 'parent') {\n          restriction = parentElement(this.element);\n        } else if (restriction === 'self') {\n          restriction = target.getRect(this.element);\n        } else {\n          restriction = closest(this.element, restriction);\n        }\n\n        if (!restriction) {\n          return status;\n        }\n      }\n\n      if (isFunction(restriction)) {\n        restriction = restriction(page.x, page.y, this.element);\n      }\n\n      if (isElement(restriction)) {\n        restriction = getElementRect(restriction);\n      }\n\n      rect = restriction;\n\n      if (!restriction) {\n        restrictedX = page.x;\n        restrictedY = page.y;\n      }\n      // object is assumed to have\n      // x, y, width, height or\n      // left, top, right, bottom\n      else if ('x' in restriction && 'y' in restriction) {\n        restrictedX = Math.max(\n          Math.min(rect.x + rect.width - this.restrictOffset.right, page.x),\n          rect.x + this.restrictOffset.left\n        );\n        restrictedY = Math.max(\n          Math.min(rect.y + rect.height - this.restrictOffset.bottom, page.y),\n          rect.y + this.restrictOffset.top\n        );\n      } else {\n        restrictedX = Math.max(\n          Math.min(rect.right - this.restrictOffset.right, page.x),\n          rect.left + this.restrictOffset.left\n        );\n        restrictedY = Math.max(\n          Math.min(rect.bottom - this.restrictOffset.bottom, page.y),\n          rect.top + this.restrictOffset.top\n        );\n      }\n\n      status.dx = restrictedX - page.x;\n      status.dy = restrictedY - page.y;\n\n      status.changed =\n        status.restrictedX !== restrictedX ||\n        status.restrictedY !== restrictedY;\n      status.restricted = !!(status.dx || status.dy);\n\n      status.restrictedX = restrictedX;\n      status.restrictedY = restrictedY;\n\n      return status;\n    },\n\n    checkAndPreventDefault: function(event, interactable, element) {\n      if (!(interactable = interactable || this.target)) {\n        return;\n      }\n\n      var options = interactable.options,\n        prevent = options.preventDefault;\n\n      if (\n        prevent === 'auto' &&\n        element &&\n        !/^(input|select|textarea)$/i.test(event.target.nodeName)\n      ) {\n        // do not preventDefault on pointerdown if the prepared action is a drag\n        // and dragging can only start from a certain direction - this allows\n        // a touch to pan the viewport if a drag isn't in the right direction\n        if (\n          /down|start/i.test(event.type) &&\n          this.prepared.name === 'drag' &&\n          options.drag.axis !== 'xy'\n        ) {\n          return;\n        }\n\n        // with manualStart, only preventDefault while interacting\n        if (\n          options[this.prepared.name] &&\n          options[this.prepared.name].manualStart &&\n          !this.interacting()\n        ) {\n          return;\n        }\n\n        event.preventDefault();\n        return;\n      }\n\n      if (prevent === 'always') {\n        event.preventDefault();\n        return;\n      }\n    },\n\n    calcInertia: function(status) {\n      var inertiaOptions = this.target.options[this.prepared.name].inertia,\n        lambda = inertiaOptions.resistance,\n        inertiaDur = -Math.log(inertiaOptions.endSpeed / status.v0) / lambda;\n\n      status.x0 = this.prevEvent.pageX;\n      status.y0 = this.prevEvent.pageY;\n      status.t0 = status.startEvent.timeStamp / 1000;\n      status.sx = status.sy = 0;\n\n      status.modifiedXe = status.xe = (status.vx0 - inertiaDur) / lambda;\n      status.modifiedYe = status.ye = (status.vy0 - inertiaDur) / lambda;\n      status.te = inertiaDur;\n\n      status.lambda_v0 = lambda / status.v0;\n      status.one_ve_v0 = 1 - inertiaOptions.endSpeed / status.v0;\n    },\n\n    autoScrollMove: function(pointer) {\n      if (\n        !(\n          this.interacting() && checkAutoScroll(this.target, this.prepared.name)\n        )\n      ) {\n        return;\n      }\n\n      if (this.inertiaStatus.active) {\n        autoScroll.x = autoScroll.y = 0;\n        return;\n      }\n\n      var top,\n        right,\n        bottom,\n        left,\n        options = this.target.options[this.prepared.name].autoScroll,\n        container = options.container || getWindow(this.element);\n\n      if (isWindow(container)) {\n        left = pointer.clientX < autoScroll.margin;\n        top = pointer.clientY < autoScroll.margin;\n        right = pointer.clientX > container.innerWidth - autoScroll.margin;\n        bottom = pointer.clientY > container.innerHeight - autoScroll.margin;\n      } else {\n        var rect = getElementClientRect(container);\n\n        left = pointer.clientX < rect.left + autoScroll.margin;\n        top = pointer.clientY < rect.top + autoScroll.margin;\n        right = pointer.clientX > rect.right - autoScroll.margin;\n        bottom = pointer.clientY > rect.bottom - autoScroll.margin;\n      }\n\n      autoScroll.x = right ? 1 : left ? -1 : 0;\n      autoScroll.y = bottom ? 1 : top ? -1 : 0;\n\n      if (!autoScroll.isScrolling) {\n        // set the autoScroll properties to those of the target\n        autoScroll.margin = options.margin;\n        autoScroll.speed = options.speed;\n\n        autoScroll.start(this);\n      }\n    },\n\n    _updateEventTargets: function(target, currentTarget) {\n      this._eventTarget = target;\n      this._curEventTarget = currentTarget;\n    }\n  };\n\n  function getInteractionFromPointer(pointer, eventType, eventTarget) {\n    var i = 0,\n      len = interactions.length,\n      mouseEvent =\n        /mouse/i.test(pointer.pointerType || eventType) ||\n        // MSPointerEvent.MSPOINTER_TYPE_MOUSE\n        pointer.pointerType === 4,\n      interaction;\n\n    var id = getPointerId(pointer);\n\n    // try to resume inertia with a new pointer\n    if (/down|start/i.test(eventType)) {\n      for (i = 0; i < len; i++) {\n        interaction = interactions[i];\n\n        var element = eventTarget;\n\n        if (\n          interaction.inertiaStatus.active &&\n          interaction.target.options[interaction.prepared.name].inertia\n            .allowResume &&\n          interaction.mouse === mouseEvent\n        ) {\n          while (element) {\n            // if the element is the interaction element\n            if (element === interaction.element) {\n              return interaction;\n            }\n            element = parentElement(element);\n          }\n        }\n      }\n    }\n\n    // if it's a mouse interaction\n    if (mouseEvent || !(supportsTouch || supportsPointerEvent)) {\n      // find a mouse interaction that's not in inertia phase\n      for (i = 0; i < len; i++) {\n        if (interactions[i].mouse && !interactions[i].inertiaStatus.active) {\n          return interactions[i];\n        }\n      }\n\n      // find any interaction specifically for mouse.\n      // if the eventType is a mousedown, and inertia is active\n      // ignore the interaction\n      for (i = 0; i < len; i++) {\n        if (\n          interactions[i].mouse &&\n          !(/down/.test(eventType) && interactions[i].inertiaStatus.active)\n        ) {\n          return interaction;\n        }\n      }\n\n      // create a new interaction for mouse\n      interaction = new Interaction();\n      interaction.mouse = true;\n\n      return interaction;\n    }\n\n    // get interaction that has this pointer\n    for (i = 0; i < len; i++) {\n      if (contains(interactions[i].pointerIds, id)) {\n        return interactions[i];\n      }\n    }\n\n    // at this stage, a pointerUp should not return an interaction\n    if (/up|end|out/i.test(eventType)) {\n      return null;\n    }\n\n    // get first idle interaction\n    for (i = 0; i < len; i++) {\n      interaction = interactions[i];\n\n      if (\n        (!interaction.prepared.name ||\n          interaction.target.options.gesture.enabled) &&\n        !interaction.interacting() &&\n        !(!mouseEvent && interaction.mouse)\n      ) {\n        return interaction;\n      }\n    }\n\n    return new Interaction();\n  }\n\n  function doOnInteractions(method) {\n    return function(event) {\n      var interaction,\n        eventTarget = getActualElement(\n          event.path ? event.path[0] : event.target\n        ),\n        curEventTarget = getActualElement(event.currentTarget),\n        i;\n\n      if (supportsTouch && /touch/.test(event.type)) {\n        prevTouchTime = new Date().getTime();\n\n        for (i = 0; i < event.changedTouches.length; i++) {\n          var pointer = event.changedTouches[i];\n\n          interaction = getInteractionFromPointer(\n            pointer,\n            event.type,\n            eventTarget\n          );\n\n          if (!interaction) {\n            continue;\n          }\n\n          interaction._updateEventTargets(eventTarget, curEventTarget);\n\n          interaction[method](pointer, event, eventTarget, curEventTarget);\n        }\n      } else {\n        if (!supportsPointerEvent && /mouse/.test(event.type)) {\n          // ignore mouse events while touch interactions are active\n          for (i = 0; i < interactions.length; i++) {\n            if (!interactions[i].mouse && interactions[i].pointerIsDown) {\n              return;\n            }\n          }\n\n          // try to ignore mouse events that are simulated by the browser\n          // after a touch event\n          if (new Date().getTime() - prevTouchTime < 500) {\n            return;\n          }\n        }\n\n        interaction = getInteractionFromPointer(event, event.type, eventTarget);\n\n        if (!interaction) {\n          return;\n        }\n\n        interaction._updateEventTargets(eventTarget, curEventTarget);\n\n        interaction[method](event, event, eventTarget, curEventTarget);\n      }\n    };\n  }\n\n  function InteractEvent(interaction, event, action, phase, element, related) {\n    var client,\n      page,\n      target = interaction.target,\n      snapStatus = interaction.snapStatus,\n      restrictStatus = interaction.restrictStatus,\n      pointers = interaction.pointers,\n      deltaSource = ((target && target.options) || defaultOptions).deltaSource,\n      sourceX = deltaSource + 'X',\n      sourceY = deltaSource + 'Y',\n      options = target ? target.options : defaultOptions,\n      origin = getOriginXY(target, element),\n      starting = phase === 'start',\n      ending = phase === 'end',\n      coords = starting ? interaction.startCoords : interaction.curCoords;\n\n    element = element || interaction.element;\n\n    page = extend({}, coords.page);\n    client = extend({}, coords.client);\n\n    page.x -= origin.x;\n    page.y -= origin.y;\n\n    client.x -= origin.x;\n    client.y -= origin.y;\n\n    var relativePoints =\n      options[action].snap && options[action].snap.relativePoints;\n\n    if (\n      checkSnap(target, action) &&\n      !(starting && relativePoints && relativePoints.length)\n    ) {\n      this.snap = {\n        range: snapStatus.range,\n        locked: snapStatus.locked,\n        x: snapStatus.snappedX,\n        y: snapStatus.snappedY,\n        realX: snapStatus.realX,\n        realY: snapStatus.realY,\n        dx: snapStatus.dx,\n        dy: snapStatus.dy\n      };\n\n      if (snapStatus.locked) {\n        page.x += snapStatus.dx;\n        page.y += snapStatus.dy;\n        client.x += snapStatus.dx;\n        client.y += snapStatus.dy;\n      }\n    }\n\n    if (\n      checkRestrict(target, action) &&\n      !(starting && options[action].restrict.elementRect) &&\n      restrictStatus.restricted\n    ) {\n      page.x += restrictStatus.dx;\n      page.y += restrictStatus.dy;\n      client.x += restrictStatus.dx;\n      client.y += restrictStatus.dy;\n\n      this.restrict = {\n        dx: restrictStatus.dx,\n        dy: restrictStatus.dy\n      };\n    }\n\n    this.pageX = page.x;\n    this.pageY = page.y;\n    this.clientX = client.x;\n    this.clientY = client.y;\n\n    this.x0 = interaction.startCoords.page.x - origin.x;\n    this.y0 = interaction.startCoords.page.y - origin.y;\n    this.clientX0 = interaction.startCoords.client.x - origin.x;\n    this.clientY0 = interaction.startCoords.client.y - origin.y;\n    this.ctrlKey = event.ctrlKey;\n    this.altKey = event.altKey;\n    this.shiftKey = event.shiftKey;\n    this.metaKey = event.metaKey;\n    this.button = event.button;\n    this.buttons = event.buttons;\n    this.target = element;\n    this.t0 = interaction.downTimes[0];\n    this.type = action + (phase || '');\n\n    this.interaction = interaction;\n    this.interactable = target;\n\n    var inertiaStatus = interaction.inertiaStatus;\n\n    if (inertiaStatus.active) {\n      this.detail = 'inertia';\n    }\n\n    if (related) {\n      this.relatedTarget = related;\n    }\n\n    // end event dx, dy is difference between start and end points\n    if (ending) {\n      if (deltaSource === 'client') {\n        this.dx = client.x - interaction.startCoords.client.x;\n        this.dy = client.y - interaction.startCoords.client.y;\n      } else {\n        this.dx = page.x - interaction.startCoords.page.x;\n        this.dy = page.y - interaction.startCoords.page.y;\n      }\n    } else if (starting) {\n      this.dx = 0;\n      this.dy = 0;\n    }\n    // copy properties from previousmove if starting inertia\n    else if (phase === 'inertiastart') {\n      this.dx = interaction.prevEvent.dx;\n      this.dy = interaction.prevEvent.dy;\n    } else {\n      if (deltaSource === 'client') {\n        this.dx = client.x - interaction.prevEvent.clientX;\n        this.dy = client.y - interaction.prevEvent.clientY;\n      } else {\n        this.dx = page.x - interaction.prevEvent.pageX;\n        this.dy = page.y - interaction.prevEvent.pageY;\n      }\n    }\n    if (\n      interaction.prevEvent &&\n      interaction.prevEvent.detail === 'inertia' &&\n      !inertiaStatus.active &&\n      options[action].inertia &&\n      options[action].inertia.zeroResumeDelta\n    ) {\n      inertiaStatus.resumeDx += this.dx;\n      inertiaStatus.resumeDy += this.dy;\n\n      this.dx = this.dy = 0;\n    }\n\n    if (action === 'resize' && interaction.resizeAxes) {\n      if (options.resize.square) {\n        if (interaction.resizeAxes === 'y') {\n          this.dx = this.dy;\n        } else {\n          this.dy = this.dx;\n        }\n        this.axes = 'xy';\n      } else {\n        this.axes = interaction.resizeAxes;\n\n        if (interaction.resizeAxes === 'x') {\n          this.dy = 0;\n        } else if (interaction.resizeAxes === 'y') {\n          this.dx = 0;\n        }\n      }\n    } else if (action === 'gesture') {\n      this.touches = [pointers[0], pointers[1]];\n\n      if (starting) {\n        this.distance = touchDistance(pointers, deltaSource);\n        this.box = touchBBox(pointers);\n        this.scale = 1;\n        this.ds = 0;\n        this.angle = touchAngle(pointers, undefined, deltaSource);\n        this.da = 0;\n      } else if (ending || event instanceof InteractEvent) {\n        this.distance = interaction.prevEvent.distance;\n        this.box = interaction.prevEvent.box;\n        this.scale = interaction.prevEvent.scale;\n        this.ds = this.scale - 1;\n        this.angle = interaction.prevEvent.angle;\n        this.da = this.angle - interaction.gesture.startAngle;\n      } else {\n        this.distance = touchDistance(pointers, deltaSource);\n        this.box = touchBBox(pointers);\n        this.scale = this.distance / interaction.gesture.startDistance;\n        this.angle = touchAngle(\n          pointers,\n          interaction.gesture.prevAngle,\n          deltaSource\n        );\n\n        this.ds = this.scale - interaction.gesture.prevScale;\n        this.da = this.angle - interaction.gesture.prevAngle;\n      }\n    }\n\n    if (starting) {\n      this.timeStamp = interaction.downTimes[0];\n      this.dt = 0;\n      this.duration = 0;\n      this.speed = 0;\n      this.velocityX = 0;\n      this.velocityY = 0;\n    } else if (phase === 'inertiastart') {\n      this.timeStamp = interaction.prevEvent.timeStamp;\n      this.dt = interaction.prevEvent.dt;\n      this.duration = interaction.prevEvent.duration;\n      this.speed = interaction.prevEvent.speed;\n      this.velocityX = interaction.prevEvent.velocityX;\n      this.velocityY = interaction.prevEvent.velocityY;\n    } else {\n      this.timeStamp = new Date().getTime();\n      this.dt = this.timeStamp - interaction.prevEvent.timeStamp;\n      this.duration = this.timeStamp - interaction.downTimes[0];\n\n      if (event instanceof InteractEvent) {\n        var dx = this[sourceX] - interaction.prevEvent[sourceX],\n          dy = this[sourceY] - interaction.prevEvent[sourceY],\n          dt = this.dt / 1000;\n\n        this.speed = hypot(dx, dy) / dt;\n        this.velocityX = dx / dt;\n        this.velocityY = dy / dt;\n      }\n      // if normal move or end event, use previous user event coords\n      else {\n        // speed and velocity in pixels per second\n        this.speed = interaction.pointerDelta[deltaSource].speed;\n        this.velocityX = interaction.pointerDelta[deltaSource].vx;\n        this.velocityY = interaction.pointerDelta[deltaSource].vy;\n      }\n    }\n\n    if (\n      (ending || phase === 'inertiastart') &&\n      interaction.prevEvent.speed > 600 &&\n      this.timeStamp - interaction.prevEvent.timeStamp < 150\n    ) {\n      var angle =\n          (180 *\n            Math.atan2(\n              interaction.prevEvent.velocityY,\n              interaction.prevEvent.velocityX\n            )) /\n          Math.PI,\n        overlap = 22.5;\n\n      if (angle < 0) {\n        angle += 360;\n      }\n\n      var left = 135 - overlap <= angle && angle < 225 + overlap,\n        up = 225 - overlap <= angle && angle < 315 + overlap,\n        right = !left && (315 - overlap <= angle || angle < 45 + overlap),\n        down = !up && 45 - overlap <= angle && angle < 135 + overlap;\n\n      this.swipe = {\n        up: up,\n        down: down,\n        left: left,\n        right: right,\n        angle: angle,\n        speed: interaction.prevEvent.speed,\n        velocity: {\n          x: interaction.prevEvent.velocityX,\n          y: interaction.prevEvent.velocityY\n        }\n      };\n    }\n  }\n\n  InteractEvent.prototype = {\n    preventDefault: blank,\n    stopImmediatePropagation: function() {\n      this.immediatePropagationStopped = this.propagationStopped = true;\n    },\n    stopPropagation: function() {\n      this.propagationStopped = true;\n    }\n  };\n\n  function preventOriginalDefault() {\n    this.originalEvent.preventDefault();\n  }\n\n  function getActionCursor(action) {\n    var cursor = '';\n\n    if (action.name === 'drag') {\n      cursor = actionCursors.drag;\n    }\n    if (action.name === 'resize') {\n      if (action.axis) {\n        cursor = actionCursors[action.name + action.axis];\n      } else if (action.edges) {\n        var cursorKey = 'resize',\n          edgeNames = ['top', 'bottom', 'left', 'right'];\n\n        for (var i = 0; i < 4; i++) {\n          if (action.edges[edgeNames[i]]) {\n            cursorKey += edgeNames[i];\n          }\n        }\n\n        cursor = actionCursors[cursorKey];\n      }\n    }\n\n    return cursor;\n  }\n\n  function checkResizeEdge(\n    name,\n    value,\n    page,\n    element,\n    interactableElement,\n    rect,\n    margin\n  ) {\n    // false, '', undefined, null\n    if (!value) {\n      return false;\n    }\n\n    // true value, use pointer coords and element rect\n    if (value === true) {\n      // if dimensions are negative, \"switch\" edges\n      var width = isNumber(rect.width) ? rect.width : rect.right - rect.left,\n        height = isNumber(rect.height) ? rect.height : rect.bottom - rect.top;\n\n      if (width < 0) {\n        if (name === 'left') {\n          name = 'right';\n        } else if (name === 'right') {\n          name = 'left';\n        }\n      }\n      if (height < 0) {\n        if (name === 'top') {\n          name = 'bottom';\n        } else if (name === 'bottom') {\n          name = 'top';\n        }\n      }\n\n      if (name === 'left') {\n        return page.x < (width >= 0 ? rect.left : rect.right) + margin;\n      }\n      if (name === 'top') {\n        return page.y < (height >= 0 ? rect.top : rect.bottom) + margin;\n      }\n\n      if (name === 'right') {\n        return page.x > (width >= 0 ? rect.right : rect.left) - margin;\n      }\n      if (name === 'bottom') {\n        return page.y > (height >= 0 ? rect.bottom : rect.top) - margin;\n      }\n    }\n\n    // the remaining checks require an element\n    if (!isElement(element)) {\n      return false;\n    }\n\n    return isElement(value)\n      ? // the value is an element to use as a resize handle\n        value === element\n      : // otherwise check if element matches value as selector\n        matchesUpTo(element, value, interactableElement);\n  }\n\n  function defaultActionChecker(pointer, interaction, element) {\n    var rect = this.getRect(element),\n      shouldResize = false,\n      action = null,\n      resizeAxes = null,\n      resizeEdges,\n      page = extend({}, interaction.curCoords.page),\n      options = this.options;\n\n    if (!rect) {\n      return null;\n    }\n\n    if (actionIsEnabled.resize && options.resize.enabled) {\n      var resizeOptions = options.resize;\n\n      resizeEdges = {\n        left: false,\n        right: false,\n        top: false,\n        bottom: false\n      };\n\n      // if using resize.edges\n      if (isObject(resizeOptions.edges)) {\n        for (var edge in resizeEdges) {\n          resizeEdges[edge] = checkResizeEdge(\n            edge,\n            resizeOptions.edges[edge],\n            page,\n            interaction._eventTarget,\n            element,\n            rect,\n            resizeOptions.margin || margin\n          );\n        }\n\n        resizeEdges.left = resizeEdges.left && !resizeEdges.right;\n        resizeEdges.top = resizeEdges.top && !resizeEdges.bottom;\n\n        shouldResize =\n          resizeEdges.left ||\n          resizeEdges.right ||\n          resizeEdges.top ||\n          resizeEdges.bottom;\n      } else {\n        var right = options.resize.axis !== 'y' && page.x > rect.right - margin,\n          bottom = options.resize.axis !== 'x' && page.y > rect.bottom - margin;\n\n        shouldResize = right || bottom;\n        resizeAxes = (right ? 'x' : '') + (bottom ? 'y' : '');\n      }\n    }\n\n    action = shouldResize\n      ? 'resize'\n      : actionIsEnabled.drag && options.drag.enabled\n      ? 'drag'\n      : null;\n\n    if (\n      actionIsEnabled.gesture &&\n      interaction.pointerIds.length >= 2 &&\n      !(interaction.dragging || interaction.resizing)\n    ) {\n      action = 'gesture';\n    }\n\n    if (action) {\n      return {\n        name: action,\n        axis: resizeAxes,\n        edges: resizeEdges\n      };\n    }\n\n    return null;\n  }\n\n  // Check if action is enabled globally and the current target supports it\n  // If so, return the validated action. Otherwise, return null\n  function validateAction(action, interactable) {\n    if (!isObject(action)) {\n      return null;\n    }\n\n    var actionName = action.name,\n      options = interactable.options;\n\n    if (\n      ((actionName === 'resize' && options.resize.enabled) ||\n        (actionName === 'drag' && options.drag.enabled) ||\n        (actionName === 'gesture' && options.gesture.enabled)) &&\n      actionIsEnabled[actionName]\n    ) {\n      if (actionName === 'resize' || actionName === 'resizeyx') {\n        actionName = 'resizexy';\n      }\n\n      return action;\n    }\n    return null;\n  }\n\n  var listeners = {},\n    interactionListeners = [\n      'dragStart',\n      'dragMove',\n      'resizeStart',\n      'resizeMove',\n      'gestureStart',\n      'gestureMove',\n      'pointerOver',\n      'pointerOut',\n      'pointerHover',\n      'selectorDown',\n      'pointerDown',\n      'pointerMove',\n      'pointerUp',\n      'pointerCancel',\n      'pointerEnd',\n      'addPointer',\n      'removePointer',\n      'recordPointer',\n      'autoScrollMove'\n    ];\n\n  for (var i = 0, len = interactionListeners.length; i < len; i++) {\n    var name = interactionListeners[i];\n\n    listeners[name] = doOnInteractions(name);\n  }\n\n  // bound to the interactable context when a DOM event\n  // listener is added to a selector interactable\n  function delegateListener(event, useCapture) {\n    var fakeEvent = {},\n      delegated = delegatedEvents[event.type],\n      eventTarget = getActualElement(event.path ? event.path[0] : event.target),\n      element = eventTarget;\n\n    useCapture = useCapture ? true : false;\n\n    // duplicate the event so that currentTarget can be changed\n    for (var prop in event) {\n      fakeEvent[prop] = event[prop];\n    }\n\n    fakeEvent.originalEvent = event;\n    fakeEvent.preventDefault = preventOriginalDefault;\n\n    // climb up document tree looking for selector matches\n    while (isElement(element)) {\n      for (var i = 0; i < delegated.selectors.length; i++) {\n        var selector = delegated.selectors[i],\n          context = delegated.contexts[i];\n\n        if (\n          matchesSelector(element, selector) &&\n          nodeContains(context, eventTarget) &&\n          nodeContains(context, element)\n        ) {\n          var listeners = delegated.listeners[i];\n\n          fakeEvent.currentTarget = element;\n\n          for (var j = 0; j < listeners.length; j++) {\n            if (listeners[j][1] === useCapture) {\n              listeners[j][0](fakeEvent);\n            }\n          }\n        }\n      }\n\n      element = parentElement(element);\n    }\n  }\n\n  function delegateUseCapture(event) {\n    return delegateListener.call(this, event, true);\n  }\n\n  interactables.indexOfElement = function indexOfElement(element, context) {\n    context = context || document;\n\n    for (var i = 0; i < this.length; i++) {\n      var interactable = this[i];\n\n      if (\n        (interactable.selector === element &&\n          interactable._context === context) ||\n        (!interactable.selector && interactable._element === element)\n      ) {\n        return i;\n      }\n    }\n    return -1;\n  };\n\n  interactables.get = function interactableGet(element, options) {\n    return this[this.indexOfElement(element, options && options.context)];\n  };\n\n  interactables.forEachSelector = function(callback) {\n    for (var i = 0; i < this.length; i++) {\n      var interactable = this[i];\n\n      if (!interactable.selector) {\n        continue;\n      }\n\n      var ret = callback(\n        interactable,\n        interactable.selector,\n        interactable._context,\n        i,\n        this\n      );\n\n      if (ret !== undefined) {\n        return ret;\n      }\n    }\n  };\n\n  /*\\\n     * interact\n     [ method ]\n     *\n     * The methods of this variable can be used to set elements as\n     * interactables and also to change various default settings.\n     *\n     * Calling it as a function and passing an element or a valid CSS selector\n     * string returns an Interactable object which has various methods to\n     * configure it.\n     *\n     - element (Element | string) The HTML or SVG Element to interact with or CSS selector\n     = (object) An @Interactable\n     *\n     > Usage\n     | interact(document.getElementById('draggable')).draggable(true);\n     |\n     | var rectables = interact('rect');\n     | rectables\n     |     .gesturable(true)\n     |     .on('gesturemove', function (event) {\n     |         // something cool...\n     |     })\n     |     .autoScroll(true);\n    \\*/\n  function interact(element, options) {\n    return (\n      interactables.get(element, options) || new Interactable(element, options)\n    );\n  }\n\n  /*\\\n     * Interactable\n     [ property ]\n     **\n     * Object type returned by @interact\n    \\*/\n  function Interactable(element, options) {\n    this._element = element;\n    this._iEvents = this._iEvents || {};\n\n    var _window;\n\n    if (trySelector(element)) {\n      this.selector = element;\n\n      var context = options && options.context;\n\n      _window = context ? getWindow(context) : window;\n\n      if (\n        context &&\n        (_window.Node\n          ? context instanceof _window.Node\n          : isElement(context) || context === _window.document)\n      ) {\n        this._context = context;\n      }\n    } else {\n      _window = getWindow(element);\n\n      if (isElement(element, _window)) {\n        if (supportsPointerEvent) {\n          events.add(this._element, pEventTypes.down, listeners.pointerDown);\n          events.add(this._element, pEventTypes.move, listeners.pointerHover);\n        } else {\n          events.add(this._element, 'mousedown', listeners.pointerDown);\n          events.add(this._element, 'mousemove', listeners.pointerHover);\n          events.add(this._element, 'touchstart', listeners.pointerDown);\n          events.add(this._element, 'touchmove', listeners.pointerHover);\n        }\n      }\n    }\n\n    this._doc = _window.document;\n\n    if (!contains(documents, this._doc)) {\n      listenToDocument(this._doc);\n    }\n\n    interactables.push(this);\n\n    this.set(options);\n  }\n\n  Interactable.prototype = {\n    setOnEvents: function(action, phases) {\n      if (action === 'drop') {\n        if (isFunction(phases.ondrop)) {\n          this.ondrop = phases.ondrop;\n        }\n        if (isFunction(phases.ondropactivate)) {\n          this.ondropactivate = phases.ondropactivate;\n        }\n        if (isFunction(phases.ondropdeactivate)) {\n          this.ondropdeactivate = phases.ondropdeactivate;\n        }\n        if (isFunction(phases.ondragenter)) {\n          this.ondragenter = phases.ondragenter;\n        }\n        if (isFunction(phases.ondragleave)) {\n          this.ondragleave = phases.ondragleave;\n        }\n        if (isFunction(phases.ondropmove)) {\n          this.ondropmove = phases.ondropmove;\n        }\n      } else {\n        action = 'on' + action;\n\n        if (isFunction(phases.onstart)) {\n          this[action + 'start'] = phases.onstart;\n        }\n        if (isFunction(phases.onmove)) {\n          this[action + 'move'] = phases.onmove;\n        }\n        if (isFunction(phases.onend)) {\n          this[action + 'end'] = phases.onend;\n        }\n        if (isFunction(phases.oninertiastart)) {\n          this[action + 'inertiastart'] = phases.oninertiastart;\n        }\n      }\n\n      return this;\n    },\n\n    /*\\\n         * Interactable.draggable\n         [ method ]\n         *\n         * Gets or sets whether drag actions can be performed on the\n         * Interactable\n         *\n         = (boolean) Indicates if this can be the target of drag events\n         | var isDraggable = interact('ul li').draggable();\n         * or\n         - options (boolean | object) #optional true/false or An object with event listeners to be fired on drag events (object makes the Interactable draggable)\n         = (object) This Interactable\n         | interact(element).draggable({\n         |     onstart: function (event) {},\n         |     onmove : function (event) {},\n         |     onend  : function (event) {},\n         |\n         |     // the axis in which the first movement must be\n         |     // for the drag sequence to start\n         |     // 'xy' by default - any direction\n         |     axis: 'x' || 'y' || 'xy',\n         |\n         |     // max number of drags that can happen concurrently\n         |     // with elements of this Interactable. Infinity by default\n         |     max: Infinity,\n         |\n         |     // max number of drags that can target the same element+Interactable\n         |     // 1 by default\n         |     maxPerElement: 2\n         | });\n        \\*/\n    draggable: function(options) {\n      if (isObject(options)) {\n        this.options.drag.enabled = options.enabled === false ? false : true;\n        this.setPerAction('drag', options);\n        this.setOnEvents('drag', options);\n\n        if (/^x$|^y$|^xy$/.test(options.axis)) {\n          this.options.drag.axis = options.axis;\n        } else if (options.axis === null) {\n          delete this.options.drag.axis;\n        }\n\n        return this;\n      }\n\n      if (isBool(options)) {\n        this.options.drag.enabled = options;\n\n        return this;\n      }\n\n      return this.options.drag;\n    },\n\n    setPerAction: function(action, options) {\n      // for all the default per-action options\n      for (var option in options) {\n        // if this option exists for this action\n        if (option in defaultOptions[action]) {\n          // if the option in the options arg is an object value\n          if (isObject(options[option])) {\n            // duplicate the object\n            this.options[action][option] = extend(\n              this.options[action][option] || {},\n              options[option]\n            );\n\n            if (\n              isObject(defaultOptions.perAction[option]) &&\n              'enabled' in defaultOptions.perAction[option]\n            ) {\n              this.options[action][option].enabled =\n                options[option].enabled === false ? false : true;\n            }\n          } else if (\n            isBool(options[option]) &&\n            isObject(defaultOptions.perAction[option])\n          ) {\n            this.options[action][option].enabled = options[option];\n          } else if (options[option] !== undefined) {\n            // or if it's not undefined, do a plain assignment\n            this.options[action][option] = options[option];\n          }\n        }\n      }\n    },\n\n    /*\\\n         * Interactable.dropzone\n         [ method ]\n         *\n         * Returns or sets whether elements can be dropped onto this\n         * Interactable to trigger drop events\n         *\n         * Dropzones can receive the following events:\n         *  - `dropactivate` and `dropdeactivate` when an acceptable drag starts and ends\n         *  - `dragenter` and `dragleave` when a draggable enters and leaves the dropzone\n         *  - `dragmove` when a draggable that has entered the dropzone is moved\n         *  - `drop` when a draggable is dropped into this dropzone\n         *\n         *  Use the `accept` option to allow only elements that match the given CSS selector or element.\n         *\n         *  Use the `overlap` option to set how drops are checked for. The allowed values are:\n         *   - `'pointer'`, the pointer must be over the dropzone (default)\n         *   - `'center'`, the draggable element's center must be over the dropzone\n         *   - a number from 0-1 which is the `(intersection area) / (draggable area)`.\n         *       e.g. `0.5` for drop to happen when half of the area of the\n         *       draggable is over the dropzone\n         *\n         - options (boolean | object | null) #optional The new value to be set.\n         | interact('.drop').dropzone({\n         |   accept: '.can-drop' || document.getElementById('single-drop'),\n         |   overlap: 'pointer' || 'center' || zeroToOne\n         | }\n         = (boolean | object) The current setting or this Interactable\n        \\*/\n    dropzone: function(options) {\n      if (isObject(options)) {\n        this.options.drop.enabled = options.enabled === false ? false : true;\n        this.setOnEvents('drop', options);\n\n        if (/^(pointer|center)$/.test(options.overlap)) {\n          this.options.drop.overlap = options.overlap;\n        } else if (isNumber(options.overlap)) {\n          this.options.drop.overlap = Math.max(Math.min(1, options.overlap), 0);\n        }\n        if ('accept' in options) {\n          this.options.drop.accept = options.accept;\n        }\n        if ('checker' in options) {\n          this.options.drop.checker = options.checker;\n        }\n\n        return this;\n      }\n\n      if (isBool(options)) {\n        this.options.drop.enabled = options;\n\n        return this;\n      }\n\n      return this.options.drop;\n    },\n\n    dropCheck: function(\n      dragEvent,\n      event,\n      draggable,\n      draggableElement,\n      dropElement,\n      rect\n    ) {\n      var dropped = false;\n\n      // if the dropzone has no rect (eg. display: none)\n      // call the custom dropChecker or just return false\n      if (!(rect = rect || this.getRect(dropElement))) {\n        return this.options.drop.checker\n          ? this.options.drop.checker(\n              dragEvent,\n              event,\n              dropped,\n              this,\n              dropElement,\n              draggable,\n              draggableElement\n            )\n          : false;\n      }\n\n      var dropOverlap = this.options.drop.overlap;\n\n      if (dropOverlap === 'pointer') {\n        var page = getPageXY(dragEvent),\n          origin = getOriginXY(draggable, draggableElement),\n          horizontal,\n          vertical;\n\n        page.x += origin.x;\n        page.y += origin.y;\n\n        horizontal = page.x > rect.left && page.x < rect.right;\n        vertical = page.y > rect.top && page.y < rect.bottom;\n\n        dropped = horizontal && vertical;\n      }\n\n      var dragRect = draggable.getRect(draggableElement);\n\n      if (dropOverlap === 'center') {\n        var cx = dragRect.left + dragRect.width / 2,\n          cy = dragRect.top + dragRect.height / 2;\n\n        dropped =\n          cx >= rect.left &&\n          cx <= rect.right &&\n          cy >= rect.top &&\n          cy <= rect.bottom;\n      }\n\n      if (isNumber(dropOverlap)) {\n        var overlapArea =\n            Math.max(\n              0,\n              Math.min(rect.right, dragRect.right) -\n                Math.max(rect.left, dragRect.left)\n            ) *\n            Math.max(\n              0,\n              Math.min(rect.bottom, dragRect.bottom) -\n                Math.max(rect.top, dragRect.top)\n            ),\n          overlapRatio = overlapArea / (dragRect.width * dragRect.height);\n\n        dropped = overlapRatio >= dropOverlap;\n      }\n\n      if (this.options.drop.checker) {\n        dropped = this.options.drop.checker(\n          dragEvent,\n          event,\n          dropped,\n          this,\n          dropElement,\n          draggable,\n          draggableElement\n        );\n      }\n\n      return dropped;\n    },\n\n    /*\\\n         * Interactable.dropChecker\n         [ method ]\n         *\n         * DEPRECATED. Use interactable.dropzone({ checker: function... }) instead.\n         *\n         * Gets or sets the function used to check if a dragged element is\n         * over this Interactable.\n         *\n         - checker (function) #optional The function that will be called when checking for a drop\n         = (Function | Interactable) The checker function or this Interactable\n         *\n         * The checker function takes the following arguments:\n         *\n         - dragEvent (InteractEvent) The related dragmove or dragend event\n         - event (TouchEvent | PointerEvent | MouseEvent) The user move/up/end Event related to the dragEvent\n         - dropped (boolean) The value from the default drop checker\n         - dropzone (Interactable) The dropzone interactable\n         - dropElement (Element) The dropzone element\n         - draggable (Interactable) The Interactable being dragged\n         - draggableElement (Element) The actual element that's being dragged\n         *\n         > Usage:\n         | interact(target)\n         | .dropChecker(function(dragEvent,         // related dragmove or dragend event\n         |                       event,             // TouchEvent/PointerEvent/MouseEvent\n         |                       dropped,           // bool result of the default checker\n         |                       dropzone,          // dropzone Interactable\n         |                       dropElement,       // dropzone elemnt\n         |                       draggable,         // draggable Interactable\n         |                       draggableElement) {// draggable element\n         |\n         |   return dropped && event.target.hasAttribute('allow-drop');\n         | }\n        \\*/\n    dropChecker: function(checker) {\n      if (isFunction(checker)) {\n        this.options.drop.checker = checker;\n\n        return this;\n      }\n      if (checker === null) {\n        delete this.options.getRect;\n\n        return this;\n      }\n\n      return this.options.drop.checker;\n    },\n\n    /*\\\n         * Interactable.accept\n         [ method ]\n         *\n         * Deprecated. add an `accept` property to the options object passed to\n         * @Interactable.dropzone instead.\n         *\n         * Gets or sets the Element or CSS selector match that this\n         * Interactable accepts if it is a dropzone.\n         *\n         - newValue (Element | string | null) #optional\n         * If it is an Element, then only that element can be dropped into this dropzone.\n         * If it is a string, the element being dragged must match it as a selector.\n         * If it is null, the accept options is cleared - it accepts any element.\n         *\n         = (string | Element | null | Interactable) The current accept option if given `undefined` or this Interactable\n        \\*/\n    accept: function(newValue) {\n      if (isElement(newValue)) {\n        this.options.drop.accept = newValue;\n\n        return this;\n      }\n\n      // test if it is a valid CSS selector\n      if (trySelector(newValue)) {\n        this.options.drop.accept = newValue;\n\n        return this;\n      }\n\n      if (newValue === null) {\n        delete this.options.drop.accept;\n\n        return this;\n      }\n\n      return this.options.drop.accept;\n    },\n\n    /*\\\n         * Interactable.resizable\n         [ method ]\n         *\n         * Gets or sets whether resize actions can be performed on the\n         * Interactable\n         *\n         = (boolean) Indicates if this can be the target of resize elements\n         | var isResizeable = interact('input[type=text]').resizable();\n         * or\n         - options (boolean | object) #optional true/false or An object with event listeners to be fired on resize events (object makes the Interactable resizable)\n         = (object) This Interactable\n         | interact(element).resizable({\n         |     onstart: function (event) {},\n         |     onmove : function (event) {},\n         |     onend  : function (event) {},\n         |\n         |     edges: {\n         |       top   : true,       // Use pointer coords to check for resize.\n         |       left  : false,      // Disable resizing from left edge.\n         |       bottom: '.resize-s',// Resize if pointer target matches selector\n         |       right : handleEl    // Resize if pointer target is the given Element\n         |     },\n         |\n         |     // Width and height can be adjusted independently. When `true`, width and\n         |     // height are adjusted at a 1:1 ratio.\n         |     square: false,\n         |\n         |     // Width and height can be adjusted independently. When `true`, width and\n         |     // height maintain the aspect ratio they had when resizing started.\n         |     preserveAspectRatio: false,\n         |\n         |     // a value of 'none' will limit the resize rect to a minimum of 0x0\n         |     // 'negate' will allow the rect to have negative width/height\n         |     // 'reposition' will keep the width/height positive by swapping\n         |     // the top and bottom edges and/or swapping the left and right edges\n         |     invert: 'none' || 'negate' || 'reposition'\n         |\n         |     // limit multiple resizes.\n         |     // See the explanation in the @Interactable.draggable example\n         |     max: Infinity,\n         |     maxPerElement: 1,\n         | });\n        \\*/\n    resizable: function(options) {\n      if (isObject(options)) {\n        this.options.resize.enabled = options.enabled === false ? false : true;\n        this.setPerAction('resize', options);\n        this.setOnEvents('resize', options);\n\n        if (/^x$|^y$|^xy$/.test(options.axis)) {\n          this.options.resize.axis = options.axis;\n        } else if (options.axis === null) {\n          this.options.resize.axis = defaultOptions.resize.axis;\n        }\n\n        if (isBool(options.preserveAspectRatio)) {\n          this.options.resize.preserveAspectRatio = options.preserveAspectRatio;\n        } else if (isBool(options.square)) {\n          this.options.resize.square = options.square;\n        }\n\n        return this;\n      }\n      if (isBool(options)) {\n        this.options.resize.enabled = options;\n\n        return this;\n      }\n      return this.options.resize;\n    },\n\n    /*\\\n         * Interactable.squareResize\n         [ method ]\n         *\n         * Deprecated. Add a `square: true || false` property to @Interactable.resizable instead\n         *\n         * Gets or sets whether resizing is forced 1:1 aspect\n         *\n         = (boolean) Current setting\n         *\n         * or\n         *\n         - newValue (boolean) #optional\n         = (object) this Interactable\n        \\*/\n    squareResize: function(newValue) {\n      if (isBool(newValue)) {\n        this.options.resize.square = newValue;\n\n        return this;\n      }\n\n      if (newValue === null) {\n        delete this.options.resize.square;\n\n        return this;\n      }\n\n      return this.options.resize.square;\n    },\n\n    /*\\\n         * Interactable.gesturable\n         [ method ]\n         *\n         * Gets or sets whether multitouch gestures can be performed on the\n         * Interactable's element\n         *\n         = (boolean) Indicates if this can be the target of gesture events\n         | var isGestureable = interact(element).gesturable();\n         * or\n         - options (boolean | object) #optional true/false or An object with event listeners to be fired on gesture events (makes the Interactable gesturable)\n         = (object) this Interactable\n         | interact(element).gesturable({\n         |     onstart: function (event) {},\n         |     onmove : function (event) {},\n         |     onend  : function (event) {},\n         |\n         |     // limit multiple gestures.\n         |     // See the explanation in @Interactable.draggable example\n         |     max: Infinity,\n         |     maxPerElement: 1,\n         | });\n        \\*/\n    gesturable: function(options) {\n      if (isObject(options)) {\n        this.options.gesture.enabled = options.enabled === false ? false : true;\n        this.setPerAction('gesture', options);\n        this.setOnEvents('gesture', options);\n\n        return this;\n      }\n\n      if (isBool(options)) {\n        this.options.gesture.enabled = options;\n\n        return this;\n      }\n\n      return this.options.gesture;\n    },\n\n    /*\\\n         * Interactable.autoScroll\n         [ method ]\n         **\n         * Deprecated. Add an `autoscroll` property to the options object\n         * passed to @Interactable.draggable or @Interactable.resizable instead.\n         *\n         * Returns or sets whether dragging and resizing near the edges of the\n         * window/container trigger autoScroll for this Interactable\n         *\n         = (object) Object with autoScroll properties\n         *\n         * or\n         *\n         - options (object | boolean) #optional\n         * options can be:\n         * - an object with margin, distance and interval properties,\n         * - true or false to enable or disable autoScroll or\n         = (Interactable) this Interactable\n        \\*/\n    autoScroll: function(options) {\n      if (isObject(options)) {\n        options = extend({actions: ['drag', 'resize']}, options);\n      } else if (isBool(options)) {\n        options = {actions: ['drag', 'resize'], enabled: options};\n      }\n\n      return this.setOptions('autoScroll', options);\n    },\n\n    /*\\\n         * Interactable.snap\n         [ method ]\n         **\n         * Deprecated. Add a `snap` property to the options object passed\n         * to @Interactable.draggable or @Interactable.resizable instead.\n         *\n         * Returns or sets if and how action coordinates are snapped. By\n         * default, snapping is relative to the pointer coordinates. You can\n         * change this by setting the\n         * [`elementOrigin`](https://github.com/taye/interact.js/pull/72).\n         **\n         = (boolean | object) `false` if snap is disabled; object with snap properties if snap is enabled\n         **\n         * or\n         **\n         - options (object | boolean | null) #optional\n         = (Interactable) this Interactable\n         > Usage\n         | interact(document.querySelector('#thing')).snap({\n         |     targets: [\n         |         // snap to this specific point\n         |         {\n         |             x: 100,\n         |             y: 100,\n         |             range: 25\n         |         },\n         |         // give this function the x and y page coords and snap to the object returned\n         |         function (x, y) {\n         |             return {\n         |                 x: x,\n         |                 y: (75 + 50 * Math.sin(x * 0.04)),\n         |                 range: 40\n         |             };\n         |         },\n         |         // create a function that snaps to a grid\n         |         interact.createSnapGrid({\n         |             x: 50,\n         |             y: 50,\n         |             range: 10,              // optional\n         |             offset: { x: 5, y: 10 } // optional\n         |         })\n         |     ],\n         |     // do not snap during normal movement.\n         |     // Instead, trigger only one snapped move event\n         |     // immediately before the end event.\n         |     endOnly: true,\n         |\n         |     relativePoints: [\n         |         { x: 0, y: 0 },  // snap relative to the top left of the element\n         |         { x: 1, y: 1 },  // and also to the bottom right\n         |     ],\n         |\n         |     // offset the snap target coordinates\n         |     // can be an object with x/y or 'startCoords'\n         |     offset: { x: 50, y: 50 }\n         |   }\n         | });\n        \\*/\n    snap: function(options) {\n      var ret = this.setOptions('snap', options);\n\n      if (ret === this) {\n        return this;\n      }\n\n      return ret.drag;\n    },\n\n    setOptions: function(option, options) {\n      var actions =\n        options && isArray(options.actions) ? options.actions : ['drag'];\n\n      var i;\n\n      if (isObject(options) || isBool(options)) {\n        for (i = 0; i < actions.length; i++) {\n          var action = /resize/.test(actions[i]) ? 'resize' : actions[i];\n\n          if (!isObject(this.options[action])) {\n            continue;\n          }\n\n          var thisOption = this.options[action][option];\n\n          if (isObject(options)) {\n            extend(thisOption, options);\n            thisOption.enabled = options.enabled === false ? false : true;\n\n            if (option === 'snap') {\n              if (thisOption.mode === 'grid') {\n                thisOption.targets = [\n                  interact.createSnapGrid(\n                    extend(\n                      {\n                        offset: thisOption.gridOffset || {x: 0, y: 0}\n                      },\n                      thisOption.grid || {}\n                    )\n                  )\n                ];\n              } else if (thisOption.mode === 'anchor') {\n                thisOption.targets = thisOption.anchors;\n              } else if (thisOption.mode === 'path') {\n                thisOption.targets = thisOption.paths;\n              }\n\n              if ('elementOrigin' in options) {\n                thisOption.relativePoints = [options.elementOrigin];\n              }\n            }\n          } else if (isBool(options)) {\n            thisOption.enabled = options;\n          }\n        }\n\n        return this;\n      }\n\n      var ret = {},\n        allActions = ['drag', 'resize', 'gesture'];\n\n      for (i = 0; i < allActions.length; i++) {\n        if (option in defaultOptions[allActions[i]]) {\n          ret[allActions[i]] = this.options[allActions[i]][option];\n        }\n      }\n\n      return ret;\n    },\n\n    /*\\\n         * Interactable.inertia\n         [ method ]\n         **\n         * Deprecated. Add an `inertia` property to the options object passed\n         * to @Interactable.draggable or @Interactable.resizable instead.\n         *\n         * Returns or sets if and how events continue to run after the pointer is released\n         **\n         = (boolean | object) `false` if inertia is disabled; `object` with inertia properties if inertia is enabled\n         **\n         * or\n         **\n         - options (object | boolean | null) #optional\n         = (Interactable) this Interactable\n         > Usage\n         | // enable and use default settings\n         | interact(element).inertia(true);\n         |\n         | // enable and use custom settings\n         | interact(element).inertia({\n         |     // value greater than 0\n         |     // high values slow the object down more quickly\n         |     resistance     : 16,\n         |\n         |     // the minimum launch speed (pixels per second) that results in inertia start\n         |     minSpeed       : 200,\n         |\n         |     // inertia will stop when the object slows down to this speed\n         |     endSpeed       : 20,\n         |\n         |     // boolean; should actions be resumed when the pointer goes down during inertia\n         |     allowResume    : true,\n         |\n         |     // boolean; should the jump when resuming from inertia be ignored in event.dx/dy\n         |     zeroResumeDelta: false,\n         |\n         |     // if snap/restrict are set to be endOnly and inertia is enabled, releasing\n         |     // the pointer without triggering inertia will animate from the release\n         |     // point to the snaped/restricted point in the given amount of time (ms)\n         |     smoothEndDuration: 300,\n         |\n         |     // an array of action types that can have inertia (no gesture)\n         |     actions        : ['drag', 'resize']\n         | });\n         |\n         | // reset custom settings and use all defaults\n         | interact(element).inertia(null);\n        \\*/\n    inertia: function(options) {\n      var ret = this.setOptions('inertia', options);\n\n      if (ret === this) {\n        return this;\n      }\n\n      return ret.drag;\n    },\n\n    getAction: function(pointer, event, interaction, element) {\n      var action = this.defaultActionChecker(pointer, interaction, element);\n\n      if (this.options.actionChecker) {\n        return this.options.actionChecker(\n          pointer,\n          event,\n          action,\n          this,\n          element,\n          interaction\n        );\n      }\n\n      return action;\n    },\n\n    defaultActionChecker: defaultActionChecker,\n\n    /*\\\n         * Interactable.actionChecker\n         [ method ]\n         *\n         * Gets or sets the function used to check action to be performed on\n         * pointerDown\n         *\n         - checker (function | null) #optional A function which takes a pointer event, defaultAction string, interactable, element and interaction as parameters and returns an object with name property 'drag' 'resize' or 'gesture' and optionally an `edges` object with boolean 'top', 'left', 'bottom' and right props.\n         = (Function | Interactable) The checker function or this Interactable\n         *\n         | interact('.resize-drag')\n         |   .resizable(true)\n         |   .draggable(true)\n         |   .actionChecker(function (pointer, event, action, interactable, element, interaction) {\n         |\n         |   if (interact.matchesSelector(event.target, '.drag-handle') {\n         |     // force drag with handle target\n         |     action.name = drag;\n         |   }\n         |   else {\n         |     // resize from the top and right edges\n         |     action.name  = 'resize';\n         |     action.edges = { top: true, right: true };\n         |   }\n         |\n         |   return action;\n         | });\n        \\*/\n    actionChecker: function(checker) {\n      if (isFunction(checker)) {\n        this.options.actionChecker = checker;\n\n        return this;\n      }\n\n      if (checker === null) {\n        delete this.options.actionChecker;\n\n        return this;\n      }\n\n      return this.options.actionChecker;\n    },\n\n    /*\\\n         * Interactable.getRect\n         [ method ]\n         *\n         * The default function to get an Interactables bounding rect. Can be\n         * overridden using @Interactable.rectChecker.\n         *\n         - element (Element) #optional The element to measure.\n         = (object) The object's bounding rectangle.\n         o {\n         o     top   : 0,\n         o     left  : 0,\n         o     bottom: 0,\n         o     right : 0,\n         o     width : 0,\n         o     height: 0\n         o }\n        \\*/\n    getRect: function rectCheck(element) {\n      element = element || this._element;\n\n      if (this.selector && !isElement(element)) {\n        element = this._context.querySelector(this.selector);\n      }\n\n      return getElementRect(element);\n    },\n\n    /*\\\n         * Interactable.rectChecker\n         [ method ]\n         *\n         * Returns or sets the function used to calculate the interactable's\n         * element's rectangle\n         *\n         - checker (function) #optional A function which returns this Interactable's bounding rectangle. See @Interactable.getRect\n         = (function | object) The checker function or this Interactable\n        \\*/\n    rectChecker: function(checker) {\n      if (isFunction(checker)) {\n        this.getRect = checker;\n\n        return this;\n      }\n\n      if (checker === null) {\n        delete this.options.getRect;\n\n        return this;\n      }\n\n      return this.getRect;\n    },\n\n    /*\\\n         * Interactable.styleCursor\n         [ method ]\n         *\n         * Returns or sets whether the action that would be performed when the\n         * mouse on the element are checked on `mousemove` so that the cursor\n         * may be styled appropriately\n         *\n         - newValue (boolean) #optional\n         = (boolean | Interactable) The current setting or this Interactable\n        \\*/\n    styleCursor: function(newValue) {\n      if (isBool(newValue)) {\n        this.options.styleCursor = newValue;\n\n        return this;\n      }\n\n      if (newValue === null) {\n        delete this.options.styleCursor;\n\n        return this;\n      }\n\n      return this.options.styleCursor;\n    },\n\n    /*\\\n         * Interactable.preventDefault\n         [ method ]\n         *\n         * Returns or sets whether to prevent the browser's default behaviour\n         * in response to pointer events. Can be set to:\n         *  - `'always'` to always prevent\n         *  - `'never'` to never prevent\n         *  - `'auto'` to let interact.js try to determine what would be best\n         *\n         - newValue (string) #optional `true`, `false` or `'auto'`\n         = (string | Interactable) The current setting or this Interactable\n        \\*/\n    preventDefault: function(newValue) {\n      if (/^(always|never|auto)$/.test(newValue)) {\n        this.options.preventDefault = newValue;\n        return this;\n      }\n\n      if (isBool(newValue)) {\n        this.options.preventDefault = newValue ? 'always' : 'never';\n        return this;\n      }\n\n      return this.options.preventDefault;\n    },\n\n    /*\\\n         * Interactable.origin\n         [ method ]\n         *\n         * Gets or sets the origin of the Interactable's element.  The x and y\n         * of the origin will be subtracted from action event coordinates.\n         *\n         - origin (object | string) #optional An object eg. { x: 0, y: 0 } or string 'parent', 'self' or any CSS selector\n         * OR\n         - origin (Element) #optional An HTML or SVG Element whose rect will be used\n         **\n         = (object) The current origin or this Interactable\n        \\*/\n    origin: function(newValue) {\n      if (trySelector(newValue)) {\n        this.options.origin = newValue;\n        return this;\n      } else if (isObject(newValue)) {\n        this.options.origin = newValue;\n        return this;\n      }\n\n      return this.options.origin;\n    },\n\n    /*\\\n         * Interactable.deltaSource\n         [ method ]\n         *\n         * Returns or sets the mouse coordinate types used to calculate the\n         * movement of the pointer.\n         *\n         - newValue (string) #optional Use 'client' if you will be scrolling while interacting; Use 'page' if you want autoScroll to work\n         = (string | object) The current deltaSource or this Interactable\n        \\*/\n    deltaSource: function(newValue) {\n      if (newValue === 'page' || newValue === 'client') {\n        this.options.deltaSource = newValue;\n\n        return this;\n      }\n\n      return this.options.deltaSource;\n    },\n\n    /*\\\n         * Interactable.restrict\n         [ method ]\n         **\n         * Deprecated. Add a `restrict` property to the options object passed to\n         * @Interactable.draggable, @Interactable.resizable or @Interactable.gesturable instead.\n         *\n         * Returns or sets the rectangles within which actions on this\n         * interactable (after snap calculations) are restricted. By default,\n         * restricting is relative to the pointer coordinates. You can change\n         * this by setting the\n         * [`elementRect`](https://github.com/taye/interact.js/pull/72).\n         **\n         - options (object) #optional an object with keys drag, resize, and/or gesture whose values are rects, Elements, CSS selectors, or 'parent' or 'self'\n         = (object) The current restrictions object or this Interactable\n         **\n         | interact(element).restrict({\n         |     // the rect will be `interact.getElementRect(element.parentNode)`\n         |     drag: element.parentNode,\n         |\n         |     // x and y are relative to the the interactable's origin\n         |     resize: { x: 100, y: 100, width: 200, height: 200 }\n         | })\n         |\n         | interact('.draggable').restrict({\n         |     // the rect will be the selected element's parent\n         |     drag: 'parent',\n         |\n         |     // do not restrict during normal movement.\n         |     // Instead, trigger only one restricted move event\n         |     // immediately before the end event.\n         |     endOnly: true,\n         |\n         |     // https://github.com/taye/interact.js/pull/72#issue-41813493\n         |     elementRect: { top: 0, left: 0, bottom: 1, right: 1 }\n         | });\n        \\*/\n    restrict: function(options) {\n      if (!isObject(options)) {\n        return this.setOptions('restrict', options);\n      }\n\n      var actions = ['drag', 'resize', 'gesture'],\n        ret;\n\n      for (var i = 0; i < actions.length; i++) {\n        var action = actions[i];\n\n        if (action in options) {\n          var perAction = extend(\n            {\n              actions: [action],\n              restriction: options[action]\n            },\n            options\n          );\n\n          ret = this.setOptions('restrict', perAction);\n        }\n      }\n\n      return ret;\n    },\n\n    /*\\\n         * Interactable.context\n         [ method ]\n         *\n         * Gets the selector context Node of the Interactable. The default is `window.document`.\n         *\n         = (Node) The context Node of this Interactable\n         **\n        \\*/\n    context: function() {\n      return this._context;\n    },\n\n    _context: document,\n\n    /*\\\n         * Interactable.ignoreFrom\n         [ method ]\n         *\n         * If the target of the `mousedown`, `pointerdown` or `touchstart`\n         * event or any of it's parents match the given CSS selector or\n         * Element, no drag/resize/gesture is started.\n         *\n         - newValue (string | Element | null) #optional a CSS selector string, an Element or `null` to not ignore any elements\n         = (string | Element | object) The current ignoreFrom value or this Interactable\n         **\n         | interact(element, { ignoreFrom: document.getElementById('no-action') });\n         | // or\n         | interact(element).ignoreFrom('input, textarea, a');\n        \\*/\n    ignoreFrom: function(newValue) {\n      if (trySelector(newValue)) {\n        // CSS selector to match event.target\n        this.options.ignoreFrom = newValue;\n        return this;\n      }\n\n      if (isElement(newValue)) {\n        // specific element\n        this.options.ignoreFrom = newValue;\n        return this;\n      }\n\n      return this.options.ignoreFrom;\n    },\n\n    /*\\\n         * Interactable.allowFrom\n         [ method ]\n         *\n         * A drag/resize/gesture is started only If the target of the\n         * `mousedown`, `pointerdown` or `touchstart` event or any of it's\n         * parents match the given CSS selector or Element.\n         *\n         - newValue (string | Element | null) #optional a CSS selector string, an Element or `null` to allow from any element\n         = (string | Element | object) The current allowFrom value or this Interactable\n         **\n         | interact(element, { allowFrom: document.getElementById('drag-handle') });\n         | // or\n         | interact(element).allowFrom('.handle');\n        \\*/\n    allowFrom: function(newValue) {\n      if (trySelector(newValue)) {\n        // CSS selector to match event.target\n        this.options.allowFrom = newValue;\n        return this;\n      }\n\n      if (isElement(newValue)) {\n        // specific element\n        this.options.allowFrom = newValue;\n        return this;\n      }\n\n      return this.options.allowFrom;\n    },\n\n    /*\\\n         * Interactable.element\n         [ method ]\n         *\n         * If this is not a selector Interactable, it returns the element this\n         * interactable represents\n         *\n         = (Element) HTML / SVG Element\n        \\*/\n    element: function() {\n      return this._element;\n    },\n\n    /*\\\n         * Interactable.fire\n         [ method ]\n         *\n         * Calls listeners for the given InteractEvent type bound globally\n         * and directly to this Interactable\n         *\n         - iEvent (InteractEvent) The InteractEvent object to be fired on this Interactable\n         = (Interactable) this Interactable\n        \\*/\n    fire: function(iEvent) {\n      if (!(iEvent && iEvent.type) || !contains(eventTypes, iEvent.type)) {\n        return this;\n      }\n\n      var listeners,\n        i,\n        len,\n        onEvent = 'on' + iEvent.type,\n        funcName = '';\n\n      // Interactable#on() listeners\n      if (iEvent.type in this._iEvents) {\n        listeners = this._iEvents[iEvent.type];\n\n        for (\n          i = 0, len = listeners.length;\n          i < len && !iEvent.immediatePropagationStopped;\n          i++\n        ) {\n          funcName = listeners[i].name;\n          listeners[i](iEvent);\n        }\n      }\n\n      // interactable.onevent listener\n      if (isFunction(this[onEvent])) {\n        funcName = this[onEvent].name;\n        this[onEvent](iEvent);\n      }\n\n      // interact.on() listeners\n      if (\n        iEvent.type in globalEvents &&\n        (listeners = globalEvents[iEvent.type])\n      ) {\n        for (\n          i = 0, len = listeners.length;\n          i < len && !iEvent.immediatePropagationStopped;\n          i++\n        ) {\n          funcName = listeners[i].name;\n          listeners[i](iEvent);\n        }\n      }\n\n      return this;\n    },\n\n    /*\\\n         * Interactable.on\n         [ method ]\n         *\n         * Binds a listener for an InteractEvent or DOM event.\n         *\n         - eventType  (string | array | object) The types of events to listen for\n         - listener   (function) The function to be called on the given event(s)\n         - useCapture (boolean) #optional useCapture flag for addEventListener\n         = (object) This Interactable\n        \\*/\n    on: function(eventType, listener, useCapture) {\n      var i;\n\n      if (isString(eventType) && eventType.search(' ') !== -1) {\n        eventType = eventType.trim().split(/ +/);\n      }\n\n      if (isArray(eventType)) {\n        for (i = 0; i < eventType.length; i++) {\n          this.on(eventType[i], listener, useCapture);\n        }\n\n        return this;\n      }\n\n      if (isObject(eventType)) {\n        for (var prop in eventType) {\n          this.on(prop, eventType[prop], listener);\n        }\n\n        return this;\n      }\n\n      if (eventType === 'wheel') {\n        eventType = wheelEvent;\n      }\n\n      // convert to boolean\n      useCapture = useCapture ? true : false;\n\n      if (contains(eventTypes, eventType)) {\n        // if this type of event was never bound to this Interactable\n        if (!(eventType in this._iEvents)) {\n          this._iEvents[eventType] = [listener];\n        } else {\n          this._iEvents[eventType].push(listener);\n        }\n      }\n      // delegated event for selector\n      else if (this.selector) {\n        if (!delegatedEvents[eventType]) {\n          delegatedEvents[eventType] = {\n            selectors: [],\n            contexts: [],\n            listeners: []\n          };\n\n          // add delegate listener functions\n          for (i = 0; i < documents.length; i++) {\n            events.add(documents[i], eventType, delegateListener);\n            events.add(documents[i], eventType, delegateUseCapture, true);\n          }\n        }\n\n        var delegated = delegatedEvents[eventType],\n          index;\n\n        for (index = delegated.selectors.length - 1; index >= 0; index--) {\n          if (\n            delegated.selectors[index] === this.selector &&\n            delegated.contexts[index] === this._context\n          ) {\n            break;\n          }\n        }\n\n        if (index === -1) {\n          index = delegated.selectors.length;\n\n          delegated.selectors.push(this.selector);\n          delegated.contexts.push(this._context);\n          delegated.listeners.push([]);\n        }\n\n        // keep listener and useCapture flag\n        delegated.listeners[index].push([listener, useCapture]);\n      } else {\n        events.add(this._element, eventType, listener, useCapture);\n      }\n\n      return this;\n    },\n\n    /*\\\n         * Interactable.off\n         [ method ]\n         *\n         * Removes an InteractEvent or DOM event listener\n         *\n         - eventType  (string | array | object) The types of events that were listened for\n         - listener   (function) The listener function to be removed\n         - useCapture (boolean) #optional useCapture flag for removeEventListener\n         = (object) This Interactable\n        \\*/\n    off: function(eventType, listener, useCapture) {\n      var i;\n\n      if (isString(eventType) && eventType.search(' ') !== -1) {\n        eventType = eventType.trim().split(/ +/);\n      }\n\n      if (isArray(eventType)) {\n        for (i = 0; i < eventType.length; i++) {\n          this.off(eventType[i], listener, useCapture);\n        }\n\n        return this;\n      }\n\n      if (isObject(eventType)) {\n        for (var prop in eventType) {\n          this.off(prop, eventType[prop], listener);\n        }\n\n        return this;\n      }\n\n      var eventList,\n        index = -1;\n\n      // convert to boolean\n      useCapture = useCapture ? true : false;\n\n      if (eventType === 'wheel') {\n        eventType = wheelEvent;\n      }\n\n      // if it is an action event type\n      if (contains(eventTypes, eventType)) {\n        eventList = this._iEvents[eventType];\n\n        if (eventList && (index = indexOf(eventList, listener)) !== -1) {\n          this._iEvents[eventType].splice(index, 1);\n        }\n      }\n      // delegated event\n      else if (this.selector) {\n        var delegated = delegatedEvents[eventType],\n          matchFound = false;\n\n        if (!delegated) {\n          return this;\n        }\n\n        // count from last index of delegated to 0\n        for (index = delegated.selectors.length - 1; index >= 0; index--) {\n          // look for matching selector and context Node\n          if (\n            delegated.selectors[index] === this.selector &&\n            delegated.contexts[index] === this._context\n          ) {\n            var listeners = delegated.listeners[index];\n\n            // each item of the listeners array is an array: [function, useCaptureFlag]\n            for (i = listeners.length - 1; i >= 0; i--) {\n              var fn = listeners[i][0],\n                useCap = listeners[i][1];\n\n              // check if the listener functions and useCapture flags match\n              if (fn === listener && useCap === useCapture) {\n                // remove the listener from the array of listeners\n                listeners.splice(i, 1);\n\n                // if all listeners for this interactable have been removed\n                // remove the interactable from the delegated arrays\n                if (!listeners.length) {\n                  delegated.selectors.splice(index, 1);\n                  delegated.contexts.splice(index, 1);\n                  delegated.listeners.splice(index, 1);\n\n                  // remove delegate function from context\n                  events.remove(this._context, eventType, delegateListener);\n                  events.remove(\n                    this._context,\n                    eventType,\n                    delegateUseCapture,\n                    true\n                  );\n\n                  // remove the arrays if they are empty\n                  if (!delegated.selectors.length) {\n                    delegatedEvents[eventType] = null;\n                  }\n                }\n\n                // only remove one listener\n                matchFound = true;\n                break;\n              }\n            }\n\n            if (matchFound) {\n              break;\n            }\n          }\n        }\n      }\n      // remove listener from this Interatable's element\n      else {\n        events.remove(this._element, eventType, listener, useCapture);\n      }\n\n      return this;\n    },\n\n    /*\\\n         * Interactable.set\n         [ method ]\n         *\n         * Reset the options of this Interactable\n         - options (object) The new settings to apply\n         = (object) This Interactable\n        \\*/\n    set: function(options) {\n      if (!isObject(options)) {\n        options = {};\n      }\n\n      this.options = extend({}, defaultOptions.base);\n\n      var i,\n        actions = ['drag', 'drop', 'resize', 'gesture'],\n        methods = ['draggable', 'dropzone', 'resizable', 'gesturable'],\n        perActions = extend(\n          extend({}, defaultOptions.perAction),\n          options[action] || {}\n        );\n\n      for (i = 0; i < actions.length; i++) {\n        var action = actions[i];\n\n        this.options[action] = extend({}, defaultOptions[action]);\n\n        this.setPerAction(action, perActions);\n\n        this[methods[i]](options[action]);\n      }\n\n      var settings = [\n        'accept',\n        'actionChecker',\n        'allowFrom',\n        'deltaSource',\n        'dropChecker',\n        'ignoreFrom',\n        'origin',\n        'preventDefault',\n        'rectChecker',\n        'styleCursor'\n      ];\n\n      for (i = 0, len = settings.length; i < len; i++) {\n        var setting = settings[i];\n\n        this.options[setting] = defaultOptions.base[setting];\n\n        if (setting in options) {\n          this[setting](options[setting]);\n        }\n      }\n\n      return this;\n    },\n\n    /*\\\n         * Interactable.unset\n         [ method ]\n         *\n         * Remove this interactable from the list of interactables and remove\n         * it's drag, drop, resize and gesture capabilities\n         *\n         = (object) @interact\n        \\*/\n    unset: function() {\n      events.remove(this._element, 'all');\n\n      if (!isString(this.selector)) {\n        events.remove(this, 'all');\n        if (this.options.styleCursor) {\n          this._element.style.cursor = '';\n        }\n      } else {\n        // remove delegated events\n        for (var type in delegatedEvents) {\n          var delegated = delegatedEvents[type];\n\n          for (var i = 0; i < delegated.selectors.length; i++) {\n            if (\n              delegated.selectors[i] === this.selector &&\n              delegated.contexts[i] === this._context\n            ) {\n              delegated.selectors.splice(i, 1);\n              delegated.contexts.splice(i, 1);\n              delegated.listeners.splice(i, 1);\n\n              // remove the arrays if they are empty\n              if (!delegated.selectors.length) {\n                delegatedEvents[type] = null;\n              }\n            }\n\n            events.remove(this._context, type, delegateListener);\n            events.remove(this._context, type, delegateUseCapture, true);\n\n            break;\n          }\n        }\n      }\n\n      this.dropzone(false);\n\n      interactables.splice(indexOf(interactables, this), 1);\n\n      return interact;\n    }\n  };\n\n  function warnOnce(method, message) {\n    var warned = false;\n\n    return function() {\n      if (!warned) {\n        window.console.warn(message);\n        warned = true;\n      }\n\n      return method.apply(this, arguments);\n    };\n  }\n\n  Interactable.prototype.snap = warnOnce(\n    Interactable.prototype.snap,\n    'Interactable#snap is deprecated. See the new documentation for snapping at http://interactjs.io/docs/snapping'\n  );\n  Interactable.prototype.restrict = warnOnce(\n    Interactable.prototype.restrict,\n    'Interactable#restrict is deprecated. See the new documentation for resticting at http://interactjs.io/docs/restriction'\n  );\n  Interactable.prototype.inertia = warnOnce(\n    Interactable.prototype.inertia,\n    'Interactable#inertia is deprecated. See the new documentation for inertia at http://interactjs.io/docs/inertia'\n  );\n  Interactable.prototype.autoScroll = warnOnce(\n    Interactable.prototype.autoScroll,\n    'Interactable#autoScroll is deprecated. See the new documentation for autoScroll at http://interactjs.io/docs/#autoscroll'\n  );\n  Interactable.prototype.squareResize = warnOnce(\n    Interactable.prototype.squareResize,\n    'Interactable#squareResize is deprecated. See http://interactjs.io/docs/#resize-square'\n  );\n\n  Interactable.prototype.accept = warnOnce(\n    Interactable.prototype.accept,\n    'Interactable#accept is deprecated. use Interactable#dropzone({ accept: target }) instead'\n  );\n  Interactable.prototype.dropChecker = warnOnce(\n    Interactable.prototype.dropChecker,\n    'Interactable#dropChecker is deprecated. use Interactable#dropzone({ dropChecker: checkerFunction }) instead'\n  );\n  Interactable.prototype.context = warnOnce(\n    Interactable.prototype.context,\n    'Interactable#context as a method is deprecated. It will soon be a DOM Node instead'\n  );\n\n  /*\\\n     * interact.isSet\n     [ method ]\n     *\n     * Check if an element has been set\n     - element (Element) The Element being searched for\n     = (boolean) Indicates if the element or CSS selector was previously passed to interact\n    \\*/\n  interact.isSet = function(element, options) {\n    return (\n      interactables.indexOfElement(element, options && options.context) !== -1\n    );\n  };\n\n  /*\\\n     * interact.on\n     [ method ]\n     *\n     * Adds a global listener for an InteractEvent or adds a DOM event to\n     * `document`\n     *\n     - type       (string | array | object) The types of events to listen for\n     - listener   (function) The function to be called on the given event(s)\n     - useCapture (boolean) #optional useCapture flag for addEventListener\n     = (object) interact\n    \\*/\n  interact.on = function(type, listener, useCapture) {\n    if (isString(type) && type.search(' ') !== -1) {\n      type = type.trim().split(/ +/);\n    }\n\n    if (isArray(type)) {\n      for (var i = 0; i < type.length; i++) {\n        interact.on(type[i], listener, useCapture);\n      }\n\n      return interact;\n    }\n\n    if (isObject(type)) {\n      for (var prop in type) {\n        interact.on(prop, type[prop], listener);\n      }\n\n      return interact;\n    }\n\n    // if it is an InteractEvent type, add listener to globalEvents\n    if (contains(eventTypes, type)) {\n      // if this type of event was never bound\n      if (!globalEvents[type]) {\n        globalEvents[type] = [listener];\n      } else {\n        globalEvents[type].push(listener);\n      }\n    }\n    // If non InteractEvent type, addEventListener to document\n    else {\n      events.add(document, type, listener, useCapture);\n    }\n\n    return interact;\n  };\n\n  /*\\\n     * interact.off\n     [ method ]\n     *\n     * Removes a global InteractEvent listener or DOM event from `document`\n     *\n     - type       (string | array | object) The types of events that were listened for\n     - listener   (function) The listener function to be removed\n     - useCapture (boolean) #optional useCapture flag for removeEventListener\n     = (object) interact\n     \\*/\n  interact.off = function(type, listener, useCapture) {\n    if (isString(type) && type.search(' ') !== -1) {\n      type = type.trim().split(/ +/);\n    }\n\n    if (isArray(type)) {\n      for (var i = 0; i < type.length; i++) {\n        interact.off(type[i], listener, useCapture);\n      }\n\n      return interact;\n    }\n\n    if (isObject(type)) {\n      for (var prop in type) {\n        interact.off(prop, type[prop], listener);\n      }\n\n      return interact;\n    }\n\n    if (!contains(eventTypes, type)) {\n      events.remove(document, type, listener, useCapture);\n    } else {\n      var index;\n\n      if (\n        type in globalEvents &&\n        (index = indexOf(globalEvents[type], listener)) !== -1\n      ) {\n        globalEvents[type].splice(index, 1);\n      }\n    }\n\n    return interact;\n  };\n\n  /*\\\n     * interact.enableDragging\n     [ method ]\n     *\n     * Deprecated.\n     *\n     * Returns or sets whether dragging is enabled for any Interactables\n     *\n     - newValue (boolean) #optional `true` to allow the action; `false` to disable action for all Interactables\n     = (boolean | object) The current setting or interact\n    \\*/\n  interact.enableDragging = warnOnce(function(newValue) {\n    if (newValue !== null && newValue !== undefined) {\n      actionIsEnabled.drag = newValue;\n\n      return interact;\n    }\n    return actionIsEnabled.drag;\n  }, 'interact.enableDragging is deprecated and will soon be removed.');\n\n  /*\\\n     * interact.enableResizing\n     [ method ]\n     *\n     * Deprecated.\n     *\n     * Returns or sets whether resizing is enabled for any Interactables\n     *\n     - newValue (boolean) #optional `true` to allow the action; `false` to disable action for all Interactables\n     = (boolean | object) The current setting or interact\n    \\*/\n  interact.enableResizing = warnOnce(function(newValue) {\n    if (newValue !== null && newValue !== undefined) {\n      actionIsEnabled.resize = newValue;\n\n      return interact;\n    }\n    return actionIsEnabled.resize;\n  }, 'interact.enableResizing is deprecated and will soon be removed.');\n\n  /*\\\n     * interact.enableGesturing\n     [ method ]\n     *\n     * Deprecated.\n     *\n     * Returns or sets whether gesturing is enabled for any Interactables\n     *\n     - newValue (boolean) #optional `true` to allow the action; `false` to disable action for all Interactables\n     = (boolean | object) The current setting or interact\n    \\*/\n  interact.enableGesturing = warnOnce(function(newValue) {\n    if (newValue !== null && newValue !== undefined) {\n      actionIsEnabled.gesture = newValue;\n\n      return interact;\n    }\n    return actionIsEnabled.gesture;\n  }, 'interact.enableGesturing is deprecated and will soon be removed.');\n\n  interact.eventTypes = eventTypes;\n\n  /*\\\n     * interact.debug\n     [ method ]\n     *\n     * Returns debugging data\n     = (object) An object with properties that outline the current state and expose internal functions and variables\n    \\*/\n  interact.debug = function() {\n    var interaction = interactions[0] || new Interaction();\n\n    return {\n      interactions: interactions,\n      target: interaction.target,\n      dragging: interaction.dragging,\n      resizing: interaction.resizing,\n      gesturing: interaction.gesturing,\n      prepared: interaction.prepared,\n      matches: interaction.matches,\n      matchElements: interaction.matchElements,\n\n      prevCoords: interaction.prevCoords,\n      startCoords: interaction.startCoords,\n\n      pointerIds: interaction.pointerIds,\n      pointers: interaction.pointers,\n      addPointer: listeners.addPointer,\n      removePointer: listeners.removePointer,\n      recordPointer: listeners.recordPointer,\n\n      snap: interaction.snapStatus,\n      restrict: interaction.restrictStatus,\n      inertia: interaction.inertiaStatus,\n\n      downTime: interaction.downTimes[0],\n      downEvent: interaction.downEvent,\n      downPointer: interaction.downPointer,\n      prevEvent: interaction.prevEvent,\n\n      Interactable: Interactable,\n      interactables: interactables,\n      pointerIsDown: interaction.pointerIsDown,\n      defaultOptions: defaultOptions,\n      defaultActionChecker: defaultActionChecker,\n\n      actionCursors: actionCursors,\n      dragMove: listeners.dragMove,\n      resizeMove: listeners.resizeMove,\n      gestureMove: listeners.gestureMove,\n      pointerUp: listeners.pointerUp,\n      pointerDown: listeners.pointerDown,\n      pointerMove: listeners.pointerMove,\n      pointerHover: listeners.pointerHover,\n\n      eventTypes: eventTypes,\n\n      events: events,\n      globalEvents: globalEvents,\n      delegatedEvents: delegatedEvents,\n\n      prefixedPropREs: prefixedPropREs\n    };\n  };\n\n  // expose the functions used to calculate multi-touch properties\n  interact.getPointerAverage = pointerAverage;\n  interact.getTouchBBox = touchBBox;\n  interact.getTouchDistance = touchDistance;\n  interact.getTouchAngle = touchAngle;\n\n  interact.getElementRect = getElementRect;\n  interact.getElementClientRect = getElementClientRect;\n  interact.matchesSelector = matchesSelector;\n  interact.closest = closest;\n\n  /*\\\n     * interact.margin\n     [ method ]\n     *\n     * Deprecated. Use `interact(target).resizable({ margin: number });` instead.\n     * Returns or sets the margin for autocheck resizing used in\n     * @Interactable.getAction. That is the distance from the bottom and right\n     * edges of an element clicking in which will start resizing\n     *\n     - newValue (number) #optional\n     = (number | interact) The current margin value or interact\n    \\*/\n  interact.margin = warnOnce(function(newvalue) {\n    if (isNumber(newvalue)) {\n      margin = newvalue;\n\n      return interact;\n    }\n    return margin;\n  }, 'interact.margin is deprecated. Use interact(target).resizable({ margin: number }); instead.');\n\n  /*\\\n     * interact.supportsTouch\n     [ method ]\n     *\n     = (boolean) Whether or not the browser supports touch input\n    \\*/\n  interact.supportsTouch = function() {\n    return supportsTouch;\n  };\n\n  /*\\\n     * interact.supportsPointerEvent\n     [ method ]\n     *\n     = (boolean) Whether or not the browser supports PointerEvents\n    \\*/\n  interact.supportsPointerEvent = function() {\n    return supportsPointerEvent;\n  };\n\n  /*\\\n     * interact.stop\n     [ method ]\n     *\n     * Cancels all interactions (end events are not fired)\n     *\n     - event (Event) An event on which to call preventDefault()\n     = (object) interact\n    \\*/\n  interact.stop = function(event) {\n    for (var i = interactions.length - 1; i >= 0; i--) {\n      interactions[i].stop(event);\n    }\n\n    return interact;\n  };\n\n  /*\\\n     * interact.dynamicDrop\n     [ method ]\n     *\n     * Returns or sets whether the dimensions of dropzone elements are\n     * calculated on every dragmove or only on dragstart for the default\n     * dropChecker\n     *\n     - newValue (boolean) #optional True to check on each move. False to check only before start\n     = (boolean | interact) The current setting or interact\n    \\*/\n  interact.dynamicDrop = function(newValue) {\n    if (isBool(newValue)) {\n      //if (dragging && dynamicDrop !== newValue && !newValue) {\n      //calcRects(dropzones);\n      //}\n\n      dynamicDrop = newValue;\n\n      return interact;\n    }\n    return dynamicDrop;\n  };\n\n  /*\\\n     * interact.pointerMoveTolerance\n     [ method ]\n     * Returns or sets the distance the pointer must be moved before an action\n     * sequence occurs. This also affects tolerance for tap events.\n     *\n     - newValue (number) #optional The movement from the start position must be greater than this value\n     = (number | Interactable) The current setting or interact\n    \\*/\n  interact.pointerMoveTolerance = function(newValue) {\n    if (isNumber(newValue)) {\n      pointerMoveTolerance = newValue;\n\n      return this;\n    }\n\n    return pointerMoveTolerance;\n  };\n\n  /*\\\n     * interact.maxInteractions\n     [ method ]\n     **\n     * Returns or sets the maximum number of concurrent interactions allowed.\n     * By default only 1 interaction is allowed at a time (for backwards\n     * compatibility). To allow multiple interactions on the same Interactables\n     * and elements, you need to enable it in the draggable, resizable and\n     * gesturable `'max'` and `'maxPerElement'` options.\n     **\n     - newValue (number) #optional Any number. newValue <= 0 means no interactions.\n    \\*/\n  interact.maxInteractions = function(newValue) {\n    if (isNumber(newValue)) {\n      maxInteractions = newValue;\n\n      return this;\n    }\n\n    return maxInteractions;\n  };\n\n  interact.createSnapGrid = function(grid) {\n    return function(x, y) {\n      var offsetX = 0,\n        offsetY = 0;\n\n      if (isObject(grid.offset)) {\n        offsetX = grid.offset.x;\n        offsetY = grid.offset.y;\n      }\n\n      var gridx = Math.round((x - offsetX) / grid.x),\n        gridy = Math.round((y - offsetY) / grid.y),\n        newX = gridx * grid.x + offsetX,\n        newY = gridy * grid.y + offsetY;\n\n      return {\n        x: newX,\n        y: newY,\n        range: grid.range\n      };\n    };\n  };\n\n  function endAllInteractions(event) {\n    for (var i = 0; i < interactions.length; i++) {\n      interactions[i].pointerEnd(event, event);\n    }\n  }\n\n  function listenToDocument(doc) {\n    if (contains(documents, doc)) {\n      return;\n    }\n\n    var win = doc.defaultView || doc.parentWindow;\n\n    // add delegate event listener\n    for (var eventType in delegatedEvents) {\n      events.add(doc, eventType, delegateListener);\n      events.add(doc, eventType, delegateUseCapture, true);\n    }\n\n    if (supportsPointerEvent) {\n      if (PointerEvent === win.MSPointerEvent) {\n        pEventTypes = {\n          up: 'MSPointerUp',\n          down: 'MSPointerDown',\n          over: 'mouseover',\n          out: 'mouseout',\n          move: 'MSPointerMove',\n          cancel: 'MSPointerCancel'\n        };\n      } else {\n        pEventTypes = {\n          up: 'pointerup',\n          down: 'pointerdown',\n          over: 'pointerover',\n          out: 'pointerout',\n          move: 'pointermove',\n          cancel: 'pointercancel'\n        };\n      }\n\n      events.add(doc, pEventTypes.down, listeners.selectorDown);\n      events.add(doc, pEventTypes.move, listeners.pointerMove);\n      events.add(doc, pEventTypes.over, listeners.pointerOver);\n      events.add(doc, pEventTypes.out, listeners.pointerOut);\n      events.add(doc, pEventTypes.up, listeners.pointerUp);\n      events.add(doc, pEventTypes.cancel, listeners.pointerCancel);\n\n      // autoscroll\n      events.add(doc, pEventTypes.move, listeners.autoScrollMove);\n    } else {\n      events.add(doc, 'mousedown', listeners.selectorDown);\n      events.add(doc, 'mousemove', listeners.pointerMove);\n      events.add(doc, 'mouseup', listeners.pointerUp);\n      events.add(doc, 'mouseover', listeners.pointerOver);\n      events.add(doc, 'mouseout', listeners.pointerOut);\n\n      events.add(doc, 'touchstart', listeners.selectorDown);\n      events.add(doc, 'touchmove', listeners.pointerMove);\n      events.add(doc, 'touchend', listeners.pointerUp);\n      events.add(doc, 'touchcancel', listeners.pointerCancel);\n\n      // autoscroll\n      events.add(doc, 'mousemove', listeners.autoScrollMove);\n      events.add(doc, 'touchmove', listeners.autoScrollMove);\n    }\n\n    events.add(win, 'blur', endAllInteractions);\n\n    try {\n      if (win.frameElement) {\n        var parentDoc = win.frameElement.ownerDocument,\n          parentWindow = parentDoc.defaultView;\n\n        events.add(parentDoc, 'mouseup', listeners.pointerEnd);\n        events.add(parentDoc, 'touchend', listeners.pointerEnd);\n        events.add(parentDoc, 'touchcancel', listeners.pointerEnd);\n        events.add(parentDoc, 'pointerup', listeners.pointerEnd);\n        events.add(parentDoc, 'MSPointerUp', listeners.pointerEnd);\n        events.add(parentWindow, 'blur', endAllInteractions);\n      }\n    } catch (error) {\n      interact.windowParentError = error;\n    }\n\n    // prevent native HTML5 drag on interact.js target elements\n    events.add(doc, 'dragstart', function(event) {\n      for (var i = 0; i < interactions.length; i++) {\n        var interaction = interactions[i];\n\n        if (\n          interaction.element &&\n          (interaction.element === event.target ||\n            nodeContains(interaction.element, event.target))\n        ) {\n          interaction.checkAndPreventDefault(\n            event,\n            interaction.target,\n            interaction.element\n          );\n          return;\n        }\n      }\n    });\n\n    if (events.useAttachEvent) {\n      // For IE's lack of Event#preventDefault\n      events.add(doc, 'selectstart', function(event) {\n        var interaction = interactions[0];\n\n        if (interaction.currentAction()) {\n          interaction.checkAndPreventDefault(event);\n        }\n      });\n\n      // For IE's bad dblclick event sequence\n      events.add(doc, 'dblclick', doOnInteractions('ie8Dblclick'));\n    }\n\n    documents.push(doc);\n  }\n\n  listenToDocument(document);\n\n  function indexOf(array, target) {\n    for (var i = 0, len = array.length; i < len; i++) {\n      if (array[i] === target) {\n        return i;\n      }\n    }\n\n    return -1;\n  }\n\n  function contains(array, target) {\n    return indexOf(array, target) !== -1;\n  }\n\n  function matchesSelector(element, selector, nodeList) {\n    if (ie8MatchesSelector) {\n      return ie8MatchesSelector(element, selector, nodeList);\n    }\n\n    // remove /deep/ from selectors if shadowDOM polyfill is used\n    if (window !== realWindow) {\n      selector = selector.replace(/\\/deep\\//g, ' ');\n    }\n\n    return element[prefixedMatchesSelector](selector);\n  }\n\n  function matchesUpTo(element, selector, limit) {\n    while (isElement(element)) {\n      if (matchesSelector(element, selector)) {\n        return true;\n      }\n\n      element = parentElement(element);\n\n      if (element === limit) {\n        return matchesSelector(element, selector);\n      }\n    }\n\n    return false;\n  }\n\n  // For IE8's lack of an Element#matchesSelector\n  // taken from http://tanalin.com/en/blog/2012/12/matches-selector-ie8/ and modified\n  if (\n    !(prefixedMatchesSelector in Element.prototype) ||\n    !isFunction(Element.prototype[prefixedMatchesSelector])\n  ) {\n    ie8MatchesSelector = function(element, selector, elems) {\n      elems = elems || element.parentNode.querySelectorAll(selector);\n\n      for (var i = 0, len = elems.length; i < len; i++) {\n        if (elems[i] === element) {\n          return true;\n        }\n      }\n\n      return false;\n    };\n  }\n\n  // requestAnimationFrame polyfill\n  (function() {\n    var lastTime = 0,\n      vendors = ['ms', 'moz', 'webkit', 'o'];\n\n    for (\n      var x = 0;\n      x < vendors.length && !realWindow.requestAnimationFrame;\n      ++x\n    ) {\n      reqFrame = realWindow[vendors[x] + 'RequestAnimationFrame'];\n      cancelFrame =\n        realWindow[vendors[x] + 'CancelAnimationFrame'] ||\n        realWindow[vendors[x] + 'CancelRequestAnimationFrame'];\n    }\n\n    if (!reqFrame) {\n      reqFrame = function(callback) {\n        var currTime = new Date().getTime(),\n          timeToCall = Math.max(0, 16 - (currTime - lastTime)),\n          id = setTimeout(function() {\n            callback(currTime + timeToCall);\n          }, timeToCall);\n        lastTime = currTime + timeToCall;\n        return id;\n      };\n    }\n\n    if (!cancelFrame) {\n      cancelFrame = function(id) {\n        clearTimeout(id);\n      };\n    }\n  })();\n\n  /* global exports: true, module, define */\n\n  // http://documentcloud.github.io/underscore/docs/underscore.html#section-11\n  if (typeof exports !== 'undefined') {\n    if (typeof module !== 'undefined' && module.exports) {\n      exports = module.exports = interact;\n    }\n    exports.interact = interact;\n  }\n  // AMD\n  else if (typeof define === 'function' && define.amd) {\n    define('interact', function() {\n      return interact;\n    });\n  } else {\n    realWindow.interact = interact;\n  }\n})(typeof window === 'undefined' ? undefined : window);\n\n\n\n// WEBPACK FOOTER //\n// ./src/interact.js"],"sourceRoot":""}