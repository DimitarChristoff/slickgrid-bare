{"version":3,"sources":["webpack:///data.js","webpack:///webpack/bootstrap 0b760b7e5612043079fd?4477","webpack:///./src/slick.core.js?591b","webpack:///external \"jquery\"?0b76","webpack:///./src/slick.dataview.js?5f73","webpack:///./src/slick.groupmetadataprovider.js?8752"],"names":["module","exports","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","EventData","isPropagationStopped","isImmediatePropagationStopped","this","stopPropagation","stopImmediatePropagation","Event","handlers","subscribe","fn","push","unsubscribe","i","length","splice","notify","args","e","scope","returnValue","EventHandler","event","handler","unsubscribeAll","Range","fromRow","fromCell","toRow","toCell","undefined","Math","min","max","isSingleRow","isSingleCell","contains","row","cell","toString","NonDataItem","__nonDataRow","Group","__group","level","count","value","title","collapsed","totals","rows","groups","groupingKey","GroupTotals","__groupTotals","group","initialized","EditorLock","activeEditController","isActive","editController","activate","commitCurrentEdit","cancelCurrentEdit","deactivate","TreeColumns","treeColumns","init","mapToId","columns","forEach","column","columnsById","filter","node","condition","valid","sort","grid","a","b","indexA","getOrDefault","getColumnIndex","indexB","getDepth","getColumnsInDepth","depth","current","n","extractColumns","concat","result","hasOwnProperty","cloneTreeColumns","$","extend","hasDepth","getTreeColumns","getColumnsInGroup","visibleColumns","visible","reOrder","getById","getInIds","ids","map","Object","defineProperty","Slick","NonDataRow","GlobalEditorLock","keyCode","BACKSPACE","DELETE","DOWN","END","ENTER","ESCAPE","HOME","INSERT","LEFT","PAGE_DOWN","PAGE_UP","RIGHT","TAB","UP","SPACE","default","prototype","equals","require","_interopRequireDefault","obj","__esModule","DataView","options","beginUpdate","suspend","endUpdate","refresh","setRefreshHints","hints","refreshHints","setFilterArgs","filterArgs","updateIdxById","startingIndex","l","items","idProperty","idxById","ensureIdUniqueness","getItems","setItems","data","objectIdProperty","filteredItems","setPagingOptions","pageSize","pagesize","pagenum","ceil","totalRows","pageNum","onPagingInfoChanged","getPagingInfo","self","totalPages","dataView","comparer","ascending","sortAsc","sortComparer","fastSortField","reverse","fastSort","field","oldToString","reSort","setFilter","filterFn","inlineFilters","compiledFilter","compileFilter","compiledFilterWithCaching","compileFilterWithCaching","getGrouping","groupingInfos","setGrouping","groupingInfo","groupItemMetadataProvider","GroupItemMetadataProvider","toggledGroupsByLevel","Array","gi","groupingInfoDefaults","getterIsAFn","getter","compiledAccumulators","idx","aggregators","compileAccumulatorLoop","groupBy","valueGetter","valueFormatter","formatter","setAggregators","groupAggregators","includeCollapsed","Error","aggregateCollapsed","getItemByIdx","getIdxById","ensureRowsByIdCache","rowsById","getRowById","getItemById","mapIdsToRows","idArray","mapRowsToIds","rowArray","updateItem","item","updated","insertItem","insertBefore","addItem","deleteItem","getLength","getItem","displayTotalsRow","calculateTotals","getItemMetadata","getGroupRowMetadata","getTotalsRowMetadata","expandCollapseAllGroups","collapse","collapseAllGroups","expandAllGroups","expandCollapseGroup","collapseGroup","letArgs","slice","arguments","arg0","indexOf","groupingDelimiter","split","join","expandGroup","getGroups","extractGroups","parentGroup","val","groupsByVal","r","predefinedValues","isLeafLevel","agg","aggregateChildGroups","storeResult","addGroupTotals","lazyTotalsCalculation","addTotals","groupCollapsed","toggledGroups","g","aggregateEmpty","flattenGroupedRows","groupedRows","gl","j","jj","getFunctionInfo","fnRegex","matches","match","params","body","aggregator","accumulatorInfo","accumulate","Function","displayName","filterInfo","filterPath1","filterPath2","filterBody","replace","tpl","uncompiledFilter","retval","ii","uncompiledFilterWithCaching","cache","getFilteredAndPagedItems","batchFilter","batchFilterWithCaching","isFilterNarrowing","isFilterExpanding","filterCache","isFilterUnchanged","paged","floor","getRowDiffs","newRows","eitherIsNonData","diff","from","to","ignoreDiffsBefore","ignoreDiffsAfter","rl","recalc","_items","prevRefreshHints","countBefore","totalRowsBefore","onRowCountChanged","previous","onRowsChanged","syncGridSelection","preserveHidden","preserveHiddenOnSelectionChange","setSelectedRowIds","rowIds","selectedRowIds","onSelectedRowIdsChanged","update","inHandler","selectedRows","setSelectedRows","getSelectedRows","onSelectedRowsChanged","newSelectedRowIds","getOptions","multiSelect","existing","grep","syncGridCellCssStyles","key","storeCellCssStyles","hash","hashById","newHash","setCellCssStyles","getCellCssStyles","onCellCssStylesChanged","defaults","AvgAggregator","field_","count_","nonNullCount_","sum_","isNaN","parseFloat","groupTotals","avg","MinAggregator","min_","MaxAggregator","max_","SumAggregator","sum","_slick","_slick2","_jquery","_jquery2","_slick3","_slick4","Aggregators","Avg","Min","Max","Sum","Data","GroupMetaDataProvider","GroupItemMetaDataProvider","defaultGroupCellFormatter","columnDef","enableExpandCollapse","indentation","toggleCssClass","toggleCollapsedCssClass","toggleExpandedCssClass","groupTitleCssClass","defaultTotalsCellFormatter","groupTotalsFormatter","_grid","onClick","handleGridClick","onKeyDown","handleGridKeyDown","destroy","getDataItem","target","hasClass","range","getRenderedRange","getData","top","bottom","preventDefault","which","activeCell","getActiveCell","selectable","focusable","groupFocusable","cssClasses","groupCssClass","0","colspan","groupFormatter","editor","totalsFocusable","totalsCssClass","totalsFormatter","_defaults"],"mappings":"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","file":"data.js","sourcesContent":["module.exports =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"/\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(5);\n\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t/** *\n\t * Contains core SlickGrid classes.\n\t * @module Core\n\t * @namespace Slick\n\t */\n\tvar Slick = {\n\t  Event: Event,\n\t  EventData: EventData,\n\t  EventHandler: EventHandler,\n\t  Range: Range,\n\t  NonDataRow: NonDataItem,\n\t  Group: Group,\n\t  GroupTotals: GroupTotals,\n\t  EditorLock: EditorLock,\n\t  /** *\n\t   * A global singleton editor lock.\n\t   * @class GlobalEditorLock\n\t   * @static\n\t   * @constructor\n\t   */\n\t  GlobalEditorLock: new EditorLock(),\n\t  TreeColumns: TreeColumns,\n\t\n\t  keyCode: {\n\t    BACKSPACE: 8,\n\t    DELETE: 46,\n\t    DOWN: 40,\n\t    END: 35,\n\t    ENTER: 13,\n\t    ESCAPE: 27,\n\t    HOME: 36,\n\t    INSERT: 45,\n\t    LEFT: 37,\n\t    PAGE_DOWN: 34,\n\t    PAGE_UP: 33,\n\t    RIGHT: 39,\n\t    TAB: 9,\n\t    UP: 38,\n\t    SPACE: 32\n\t  }\n\t};\n\t\n\texports.default = Slick;\n\t\n\t/***\n\t * An event object for passing data to event handlers and letting them control propagation.\n\t * <p>This is pretty much identical to how W3C and jQuery implement events.</p>\n\t * @class EventData\n\t * @constructor\n\t */\n\t\n\tfunction EventData() {\n\t  var isPropagationStopped = false;\n\t  var isImmediatePropagationStopped = false;\n\t\n\t  /***\n\t   * Stops event from propagating up the DOM tree.\n\t   * @method stopPropagation\n\t   */\n\t  this.stopPropagation = function () {\n\t    isPropagationStopped = true;\n\t  };\n\t\n\t  /***\n\t   * Returns whether stopPropagation was called on this event object.\n\t   * @method isPropagationStopped\n\t   * @return {Boolean}\n\t   */\n\t  this.isPropagationStopped = function () {\n\t    return isPropagationStopped;\n\t  };\n\t\n\t  /***\n\t   * Prevents the rest of the handlers from being executed.\n\t   * @method stopImmediatePropagation\n\t   */\n\t  this.stopImmediatePropagation = function () {\n\t    isImmediatePropagationStopped = true;\n\t  };\n\t\n\t  /***\n\t   * Returns whether stopImmediatePropagation was called on this event object.\\\n\t   * @method isImmediatePropagationStopped\n\t   * @return {Boolean}\n\t   */\n\t  this.isImmediatePropagationStopped = function () {\n\t    return isImmediatePropagationStopped;\n\t  };\n\t}\n\t\n\t/***\n\t * A simple publisher-subscriber implementation.\n\t * @class Event\n\t * @constructor\n\t */\n\tfunction Event() {\n\t  var handlers = [];\n\t\n\t  /***\n\t   * Adds an event handler to be called when the event is fired.\n\t   * <p>Event handler will receive two arguments - an <code>EventData</code> and the <code>data</code>\n\t   * object the event was fired with.<p>\n\t   * @method subscribe\n\t   * @param fn {Function} Event handler.\n\t   */\n\t  this.subscribe = function (fn) {\n\t    handlers.push(fn);\n\t  };\n\t\n\t  /***\n\t   * Removes an event handler added with <code>subscribe(fn)</code>.\n\t   * @method unsubscribe\n\t   * @param fn {Function} Event handler to be removed.\n\t   */\n\t  this.unsubscribe = function (fn) {\n\t    for (var i = handlers.length - 1; i >= 0; i--) {\n\t      if (handlers[i] === fn) {\n\t        handlers.splice(i, 1);\n\t      }\n\t    }\n\t  };\n\t\n\t  /***\n\t   * Fires an event notifying all subscribers.\n\t   * @method notify\n\t   * @param args {Object} Additional data object to be passed to all handlers.\n\t   * @param e {EventData}\n\t   *      Optional.\n\t   *      An <code>EventData</code> object to be passed to all handlers.\n\t   *      For DOM events, an existing W3C/jQuery event object can be passed in.\n\t   * @param scope {Object}\n\t   *      Optional.\n\t   *      The scope (\"this\") within which the handler will be executed.\n\t   *      If not specified, the scope will be set to the <code>Event</code> instance.\n\t   */\n\t  this.notify = function (args, e, scope) {\n\t    e = e || new EventData();\n\t    scope = scope || this;\n\t\n\t    var returnValue;\n\t    for (var i = 0; i < handlers.length && !(e.isPropagationStopped() || e.isImmediatePropagationStopped()); i++) {\n\t      returnValue = handlers[i].call(scope, e, args);\n\t    }\n\t\n\t    return returnValue;\n\t  };\n\t}\n\t\n\tfunction EventHandler() {\n\t  var handlers = [];\n\t\n\t  this.subscribe = function (event, handler) {\n\t    handlers.push({\n\t      event: event,\n\t      handler: handler\n\t    });\n\t    event.subscribe(handler);\n\t\n\t    return this; // allow chaining\n\t  };\n\t\n\t  this.unsubscribe = function (event, handler) {\n\t    var i = handlers.length;\n\t    while (i--) {\n\t      if (handlers[i].event === event && handlers[i].handler === handler) {\n\t        handlers.splice(i, 1);\n\t        event.unsubscribe(handler);\n\t        return;\n\t      }\n\t    }\n\t\n\t    return this; // allow chaining\n\t  };\n\t\n\t  this.unsubscribeAll = function () {\n\t    var i = handlers.length;\n\t    while (i--) {\n\t      handlers[i].event.unsubscribe(handlers[i].handler);\n\t    }\n\t    handlers = [];\n\t\n\t    return this; // allow chaining\n\t  };\n\t}\n\t\n\t/***\n\t * A structure containing a range of cells.\n\t * @class Range\n\t * @constructor\n\t * @param fromRow {Integer} Starting row.\n\t * @param fromCell {Integer} Starting cell.\n\t * @param toRow {Integer} Optional. Ending row. Defaults to <code>fromRow</code>.\n\t * @param toCell {Integer} Optional. Ending cell. Defaults to <code>fromCell</code>.\n\t */\n\tfunction Range(fromRow, fromCell, toRow, toCell) {\n\t  if (toRow === undefined && toCell === undefined) {\n\t    toRow = fromRow;\n\t    toCell = fromCell;\n\t  }\n\t\n\t  /***\n\t   * @property fromRow\n\t   * @type {Integer}\n\t   */\n\t  this.fromRow = Math.min(fromRow, toRow);\n\t\n\t  /***\n\t   * @property fromCell\n\t   * @type {Integer}\n\t   */\n\t  this.fromCell = Math.min(fromCell, toCell);\n\t\n\t  /***\n\t   * @property toRow\n\t   * @type {Integer}\n\t   */\n\t  this.toRow = Math.max(fromRow, toRow);\n\t\n\t  /***\n\t   * @property toCell\n\t   * @type {Integer}\n\t   */\n\t  this.toCell = Math.max(fromCell, toCell);\n\t\n\t  /***\n\t   * Returns whether a range represents a single row.\n\t   * @method isSingleRow\n\t   * @return {Boolean}\n\t   */\n\t  this.isSingleRow = function () {\n\t    return this.fromRow == this.toRow;\n\t  };\n\t\n\t  /***\n\t   * Returns whether a range represents a single cell.\n\t   * @method isSingleCell\n\t   * @return {Boolean}\n\t   */\n\t  this.isSingleCell = function () {\n\t    return this.fromRow == this.toRow && this.fromCell == this.toCell;\n\t  };\n\t\n\t  /***\n\t   * Returns whether a range contains a given cell.\n\t   * @method contains\n\t   * @param row {Integer}\n\t   * @param cell {Integer}\n\t   * @return {Boolean}\n\t   */\n\t  this.contains = function (row, cell) {\n\t    return row >= this.fromRow && row <= this.toRow && cell >= this.fromCell && cell <= this.toCell;\n\t  };\n\t\n\t  /***\n\t   * Returns a readable representation of a range.\n\t   * @method toString\n\t   * @return {String}\n\t   */\n\t  this.toString = function () {\n\t    if (this.isSingleCell()) {\n\t      return '(' + this.fromRow + ':' + this.fromCell + ')';\n\t    } else {\n\t      return '(' + this.fromRow + ':' + this.fromCell + ' - ' + this.toRow + ':' + this.toCell + ')';\n\t    }\n\t  };\n\t}\n\t\n\t/***\n\t * A base class that all special / non-data rows (like Group and GroupTotals) derive from.\n\t * @class NonDataItem\n\t * @constructor\n\t */\n\tfunction NonDataItem() {\n\t  this.__nonDataRow = true;\n\t}\n\t\n\t/***\n\t * Information about a group of rows.\n\t * @class Group\n\t * @extends Slick.NonDataItem\n\t * @constructor\n\t */\n\tfunction Group() {\n\t  this.__group = true;\n\t\n\t  /**\n\t   * Grouping level, starting with 0.\n\t   * @property level\n\t   * @type {Number}\n\t   */\n\t  this.level = 0;\n\t\n\t  /***\n\t   * Number of rows in the group.\n\t   * @property count\n\t   * @type {Integer}\n\t   */\n\t  this.count = 0;\n\t\n\t  /***\n\t   * Grouping value.\n\t   * @property value\n\t   * @type {Object}\n\t   */\n\t  this.value = null;\n\t\n\t  /***\n\t   * Formatted display value of the group.\n\t   * @property title\n\t   * @type {String}\n\t   */\n\t  this.title = null;\n\t\n\t  /***\n\t   * Whether a group is collapsed.\n\t   * @property collapsed\n\t   * @type {Boolean}\n\t   */\n\t  this.collapsed = false;\n\t\n\t  /***\n\t   * GroupTotals, if any.\n\t   * @property totals\n\t   * @type {GroupTotals}\n\t   */\n\t  this.totals = null;\n\t\n\t  /**\n\t   * Rows that are part of the group.\n\t   * @property rows\n\t   * @type {Array}\n\t   */\n\t  this.rows = [];\n\t\n\t  /**\n\t   * Sub-groups that are part of the group.\n\t   * @property groups\n\t   * @type {Array}\n\t   */\n\t  this.groups = null;\n\t\n\t  /**\n\t   * A unique key used to identify the group.  This key can be used in calls to DataView\n\t   * collapseGroup() or expandGroup().\n\t   * @property groupingKey\n\t   * @type {Object}\n\t   */\n\t  this.groupingKey = null;\n\t}\n\t\n\tGroup.prototype = new NonDataItem();\n\t\n\t/***\n\t * Compares two Group instances.\n\t * @method equals\n\t * @return {Boolean}\n\t * @param group {Group} Group instance to compare to.\n\t */\n\tGroup.prototype.equals = function (group) {\n\t  return this.value === group.value && this.count === group.count && this.collapsed === group.collapsed && this.title === group.title;\n\t};\n\t\n\t/***\n\t * Information about group totals.\n\t * An instance of GroupTotals will be created for each totals row and passed to the aggregators\n\t * so that they can store arbitrary data in it.  That data can later be accessed by group totals\n\t * formatters during the display.\n\t * @class GroupTotals\n\t * @extends Slick.NonDataItem\n\t * @constructor\n\t */\n\tfunction GroupTotals() {\n\t  this.__groupTotals = true;\n\t\n\t  /***\n\t   * Parent Group.\n\t   * @param group\n\t   * @type {Group}\n\t   */\n\t  this.group = null;\n\t\n\t  /***\n\t   * Whether the totals have been fully initialized / calculated.\n\t   * Will be set to false for lazy-calculated group totals.\n\t   * @param initialized\n\t   * @type {Boolean}\n\t   */\n\t  this.initialized = false;\n\t}\n\t\n\tGroupTotals.prototype = new NonDataItem();\n\t\n\t/***\n\t * A locking helper to track the active edit controller and ensure that only a single controller\n\t * can be active at a time.  This prevents a whole class of state and validation synchronization\n\t * issues.  An edit controller (such as SlickGrid) can query if an active edit is in progress\n\t * and attempt a commit or cancel before proceeding.\n\t * @class EditorLock\n\t * @constructor\n\t */\n\tfunction EditorLock() {\n\t  var activeEditController = null;\n\t\n\t  /***\n\t   * Returns true if a specified edit controller is active (has the edit lock).\n\t   * If the parameter is not specified, returns true if any edit controller is active.\n\t   * @method isActive\n\t   * @param editController {EditController}\n\t   * @return {Boolean}\n\t   */\n\t  this.isActive = function (editController) {\n\t    return editController ? activeEditController === editController : activeEditController !== null;\n\t  };\n\t\n\t  /***\n\t   * Sets the specified edit controller as the active edit controller (acquire edit lock).\n\t   * If another edit controller is already active, and exception will be thrown.\n\t   * @method activate\n\t   * @param editController {EditController} edit controller acquiring the lock\n\t   */\n\t  this.activate = function (editController) {\n\t    if (editController === activeEditController) {\n\t      // already activated?\n\t      return;\n\t    }\n\t    if (activeEditController !== null) {\n\t      throw \"SlickGrid.EditorLock.activate: an editController is still active, can't activate another editController\";\n\t    }\n\t    if (!editController.commitCurrentEdit) {\n\t      throw 'SlickGrid.EditorLock.activate: editController must implement .commitCurrentEdit()';\n\t    }\n\t    if (!editController.cancelCurrentEdit) {\n\t      throw 'SlickGrid.EditorLock.activate: editController must implement .cancelCurrentEdit()';\n\t    }\n\t    activeEditController = editController;\n\t  };\n\t\n\t  /***\n\t   * Unsets the specified edit controller as the active edit controller (release edit lock).\n\t   * If the specified edit controller is not the active one, an exception will be thrown.\n\t   * @method deactivate\n\t   * @param editController {EditController} edit controller releasing the lock\n\t   */\n\t  this.deactivate = function (editController) {\n\t    if (activeEditController !== editController) {\n\t      throw 'SlickGrid.EditorLock.deactivate: specified editController is not the currently active one';\n\t    }\n\t    activeEditController = null;\n\t  };\n\t\n\t  /***\n\t   * Attempts to commit the current edit by calling \"commitCurrentEdit\" method on the active edit\n\t   * controller and returns whether the commit attempt was successful (commit may fail due to validation\n\t   * errors, etc.).  Edit controller's \"commitCurrentEdit\" must return true if the commit has succeeded\n\t   * and false otherwise.  If no edit controller is active, returns true.\n\t   * @method commitCurrentEdit\n\t   * @return {Boolean}\n\t   */\n\t  this.commitCurrentEdit = function () {\n\t    return activeEditController ? activeEditController.commitCurrentEdit() : true;\n\t  };\n\t\n\t  /***\n\t   * Attempts to cancel the current edit by calling \"cancelCurrentEdit\" method on the active edit\n\t   * controller and returns whether the edit was successfully cancelled.  If no edit controller is\n\t   * active, returns true.\n\t   * @method cancelCurrentEdit\n\t   * @return {Boolean}\n\t   */\n\t  this.cancelCurrentEdit = function cancelCurrentEdit() {\n\t    return activeEditController ? activeEditController.cancelCurrentEdit() : true;\n\t  };\n\t}\n\t\n\t/**\n\t *\n\t * @param {Array} treeColumns Array com levels of columns\n\t * @returns {{hasDepth: 'hasDepth', getTreeColumns: 'getTreeColumns', extractColumns: 'extractColumns', getDepth: 'getDepth', getColumnsInDepth: 'getColumnsInDepth', getColumnsInGroup: 'getColumnsInGroup', visibleColumns: 'visibleColumns', filter: 'filter', reOrder: reOrder}}\n\t * @constructor\n\t */\n\tfunction TreeColumns(treeColumns) {\n\t  var columnsById = {};\n\t\n\t  function init() {\n\t    mapToId(treeColumns);\n\t  }\n\t\n\t  function mapToId(columns) {\n\t    columns.forEach(function (column) {\n\t      columnsById[column.id] = column;\n\t\n\t      if (column.columns) mapToId(column.columns);\n\t    });\n\t  }\n\t\n\t  function filter(node, condition) {\n\t    return node.filter(function (column) {\n\t      var valid = condition.call(column);\n\t\n\t      if (valid && column.columns) column.columns = filter(column.columns, condition);\n\t\n\t      return valid && (!column.columns || column.columns.length);\n\t    });\n\t  }\n\t\n\t  function sort(columns, grid) {\n\t    columns.sort(function (a, b) {\n\t      var indexA = getOrDefault(grid.getColumnIndex(a.id)),\n\t          indexB = getOrDefault(grid.getColumnIndex(b.id));\n\t\n\t      return indexA - indexB;\n\t    }).forEach(function (column) {\n\t      if (column.columns) sort(column.columns, grid);\n\t    });\n\t  }\n\t\n\t  function getOrDefault(value) {\n\t    return typeof value === 'undefined' ? -1 : value;\n\t  }\n\t\n\t  function getDepth(node) {\n\t    if (node.length) for (var i in node) {\n\t      return getDepth(node[i]);\n\t    } else if (node.columns) return 1 + getDepth(node.columns);else return 1;\n\t  }\n\t\n\t  function getColumnsInDepth(node, depth, current) {\n\t    var columns = [];\n\t    current = current || 0;\n\t\n\t    if (depth == current) {\n\t      if (node.length) node.forEach(function (n) {\n\t        if (n.columns) n.extractColumns = function () {\n\t          return extractColumns(n);\n\t        };\n\t      });\n\t\n\t      return node;\n\t    } else for (var i in node) {\n\t      if (node[i].columns) {\n\t        columns = columns.concat(getColumnsInDepth(node[i].columns, depth, current + 1));\n\t      }\n\t    }return columns;\n\t  }\n\t\n\t  function extractColumns(node) {\n\t    var result = [];\n\t\n\t    if (node.hasOwnProperty('length')) {\n\t      for (var i = 0; i < node.length; i++) {\n\t        result = result.concat(extractColumns(node[i]));\n\t      }\n\t    } else {\n\t      if (node.hasOwnProperty('columns')) result = result.concat(extractColumns(node.columns));else return node;\n\t    }\n\t\n\t    return result;\n\t  }\n\t\n\t  function cloneTreeColumns() {\n\t    return $.extend(true, [], treeColumns);\n\t  }\n\t\n\t  init();\n\t\n\t  this.hasDepth = function () {\n\t    for (var i in treeColumns) {\n\t      if (treeColumns[i].hasOwnProperty('columns')) return true;\n\t    }return false;\n\t  };\n\t\n\t  this.getTreeColumns = function () {\n\t    return treeColumns;\n\t  };\n\t\n\t  this.extractColumns = function () {\n\t    return this.hasDepth() ? extractColumns(treeColumns) : treeColumns;\n\t  };\n\t\n\t  this.getDepth = function () {\n\t    return getDepth(treeColumns);\n\t  };\n\t\n\t  this.getColumnsInDepth = function (depth) {\n\t    return getColumnsInDepth(treeColumns, depth);\n\t  };\n\t\n\t  this.getColumnsInGroup = function (groups) {\n\t    return extractColumns(groups);\n\t  };\n\t\n\t  this.visibleColumns = function () {\n\t    return filter(cloneTreeColumns(), function () {\n\t      return this.visible;\n\t    });\n\t  };\n\t\n\t  this.filter = function (condition) {\n\t    return filter(cloneTreeColumns(), condition);\n\t  };\n\t\n\t  this.reOrder = function (grid) {\n\t    return sort(treeColumns, grid);\n\t  };\n\t\n\t  this.getById = function (id) {\n\t    return columnsById[id];\n\t  };\n\t\n\t  this.getInIds = function (ids) {\n\t    return ids.map(function (id) {\n\t      return columnsById[id];\n\t    });\n\t  };\n\t}\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports) {\n\n\tmodule.exports = require(\"jquery\");\n\n/***/ }),\n/* 3 */,\n/* 4 */,\n/* 5 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _slick = __webpack_require__(1);\n\t\n\tvar _slick2 = _interopRequireDefault(_slick);\n\t\n\tvar _jquery = __webpack_require__(2);\n\t\n\tvar _jquery2 = _interopRequireDefault(_jquery);\n\t\n\tvar _slick3 = __webpack_require__(7);\n\t\n\tvar _slick4 = _interopRequireDefault(_slick3);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tvar Aggregators = {\n\t  Avg: AvgAggregator,\n\t  Min: MinAggregator,\n\t  Max: MaxAggregator,\n\t  Sum: SumAggregator\n\t};\n\t\n\tvar Data = {\n\t  DataView: DataView,\n\t  GroupMetaDataProvider: _slick4.default,\n\t  Aggregators: Aggregators\n\t};\n\t\n\texports.default = Data;\n\t\n\t/** *\n\t * A sample Model implementation.\n\t * Provides a filtered view of the underlying data.\n\t *\n\t * Relies on the data item having an \"id\" property uniquely identifying it.\n\t */\n\t\n\tfunction DataView(options) {\n\t  var self = this;\n\t\n\t  var defaults = {\n\t    groupItemMetadataProvider: null,\n\t    inlineFilters: false\n\t  };\n\t\n\t  // private\n\t  var idProperty = 'id'; // property holding a unique row id\n\t  var items = []; // data by index\n\t  var rows = []; // data by row\n\t  var idxById = {}; // indexes by id\n\t  var rowsById = null; // rows by id; lazy-calculated\n\t  var filter = null; // filter function\n\t  var updated = null; // updated item ids\n\t  var suspend = false; // suspends the recalculation\n\t  var sortAsc = true;\n\t  var fastSortField = void 0;\n\t  var sortComparer = void 0;\n\t  var refreshHints = {};\n\t  var prevRefreshHints = {};\n\t  var filterArgs = void 0;\n\t  var filteredItems = [];\n\t  var compiledFilter = void 0;\n\t  var compiledFilterWithCaching = void 0;\n\t  var filterCache = [];\n\t\n\t  // grouping\n\t  var groupingInfoDefaults = {\n\t    getter: null,\n\t    formatter: null,\n\t    comparer: function comparer(a, b) {\n\t      return a.value === b.value ? 0 : a.value > b.value ? 1 : -1;\n\t    },\n\t    predefinedValues: [],\n\t    aggregators: [],\n\t    aggregateEmpty: false,\n\t    aggregateCollapsed: false,\n\t    aggregateChildGroups: false,\n\t    collapsed: false,\n\t    displayTotalsRow: true,\n\t    lazyTotalsCalculation: false\n\t  };\n\t  var groupingInfos = [];\n\t  var groups = [];\n\t  var toggledGroupsByLevel = [];\n\t  var groupingDelimiter = ':|:';\n\t\n\t  var pagesize = 0;\n\t  var pagenum = 0;\n\t  var totalRows = 0;\n\t\n\t  // events\n\t  var onRowCountChanged = new _slick2.default.Event();\n\t  var onRowsChanged = new _slick2.default.Event();\n\t  var onPagingInfoChanged = new _slick2.default.Event();\n\t\n\t  options = _jquery2.default.extend(true, {}, defaults, options);\n\t\n\t  function beginUpdate() {\n\t    suspend = true;\n\t  }\n\t\n\t  function endUpdate() {\n\t    suspend = false;\n\t    refresh();\n\t  }\n\t\n\t  function setRefreshHints(hints) {\n\t    refreshHints = hints;\n\t  }\n\t\n\t  function setFilterArgs(args) {\n\t    filterArgs = args;\n\t  }\n\t\n\t  function updateIdxById(startingIndex) {\n\t    startingIndex = startingIndex || 0;\n\t    var id = void 0;\n\t    for (var i = startingIndex, l = items.length; i < l; i++) {\n\t      id = items[i][idProperty];\n\t      if (id === undefined) {\n\t        throw \"Each data element must implement a unique 'id' property\";\n\t      }\n\t      idxById[id] = i;\n\t    }\n\t  }\n\t\n\t  function ensureIdUniqueness() {\n\t    var id = void 0;\n\t    for (var i = 0, l = items.length; i < l; i++) {\n\t      id = items[i][idProperty];\n\t      if (id === undefined || idxById[id] !== i) {\n\t        throw \"Each data element must implement a unique 'id' property\";\n\t      }\n\t    }\n\t  }\n\t\n\t  function getItems() {\n\t    return items;\n\t  }\n\t\n\t  function setItems(data, objectIdProperty) {\n\t    if (objectIdProperty !== undefined) {\n\t      idProperty = objectIdProperty;\n\t    }\n\t    items = filteredItems = data;\n\t    idxById = {};\n\t    updateIdxById();\n\t    ensureIdUniqueness();\n\t    refresh();\n\t  }\n\t\n\t  function setPagingOptions(args) {\n\t    if (args.pageSize != undefined) {\n\t      pagesize = args.pageSize;\n\t      pagenum = pagesize ? Math.min(pagenum, Math.max(0, Math.ceil(totalRows / pagesize) - 1)) : 0;\n\t    }\n\t\n\t    if (args.pageNum != undefined) {\n\t      pagenum = Math.min(args.pageNum, Math.max(0, Math.ceil(totalRows / pagesize) - 1));\n\t    }\n\t\n\t    onPagingInfoChanged.notify(getPagingInfo(), null, self);\n\t\n\t    refresh();\n\t  }\n\t\n\t  function getPagingInfo() {\n\t    var totalPages = pagesize ? Math.max(1, Math.ceil(totalRows / pagesize)) : 1;\n\t    return {\n\t      pageSize: pagesize,\n\t      pageNum: pagenum,\n\t      totalRows: totalRows,\n\t      totalPages: totalPages,\n\t      dataView: self\n\t    };\n\t  }\n\t\n\t  function sort(comparer, ascending) {\n\t    sortAsc = ascending;\n\t    sortComparer = comparer;\n\t    fastSortField = null;\n\t    if (ascending === false) {\n\t      items.reverse();\n\t    }\n\t    items.sort(comparer);\n\t    if (ascending === false) {\n\t      items.reverse();\n\t    }\n\t    idxById = {};\n\t    updateIdxById();\n\t    refresh();\n\t  }\n\t\n\t  /** *\n\t   * Provides a workaround for the extremely slow sorting in IE.\n\t   * Does a [lexicographic] sort on a give column by temporarily overriding Object.prototype.toString\n\t   * to return the value of that field and then doing a native Array.sort().\n\t   */\n\t  function fastSort(field, ascending) {\n\t    sortAsc = ascending;\n\t    fastSortField = field;\n\t    sortComparer = null;\n\t    var oldToString = Object.prototype.toString;\n\t    Object.prototype.toString = typeof field == 'function' ? field : function () {\n\t      return this[field];\n\t    };\n\t    // an extra reversal for descending sort keeps the sort stable\n\t    // (assuming a stable native sort implementation, which isn't true in some cases)\n\t    if (ascending === false) {\n\t      items.reverse();\n\t    }\n\t    items.sort();\n\t    Object.prototype.toString = oldToString;\n\t    if (ascending === false) {\n\t      items.reverse();\n\t    }\n\t    idxById = {};\n\t    updateIdxById();\n\t    refresh();\n\t  }\n\t\n\t  function reSort() {\n\t    if (sortComparer) {\n\t      sort(sortComparer, sortAsc);\n\t    } else if (fastSortField) {\n\t      fastSort(fastSortField, sortAsc);\n\t    }\n\t  }\n\t\n\t  function setFilter(filterFn) {\n\t    filter = filterFn;\n\t    if (options.inlineFilters) {\n\t      compiledFilter = compileFilter();\n\t      compiledFilterWithCaching = compileFilterWithCaching();\n\t    }\n\t    refresh();\n\t  }\n\t\n\t  function getGrouping() {\n\t    return groupingInfos;\n\t  }\n\t\n\t  function setGrouping(groupingInfo) {\n\t    if (!options.groupItemMetadataProvider) {\n\t      options.groupItemMetadataProvider = GroupItemMetadataProvider();\n\t    }\n\t\n\t    groups = [];\n\t    toggledGroupsByLevel = [];\n\t    groupingInfo = groupingInfo || [];\n\t    groupingInfos = groupingInfo instanceof Array ? groupingInfo : [groupingInfo];\n\t\n\t    for (var i = 0; i < groupingInfos.length; i++) {\n\t      var gi = groupingInfos[i] = _jquery2.default.extend(true, {}, groupingInfoDefaults, groupingInfos[i]);\n\t      gi.getterIsAFn = typeof gi.getter === 'function';\n\t\n\t      // pre-compile accumulator loops\n\t      gi.compiledAccumulators = [];\n\t      var idx = gi.aggregators.length;\n\t      while (idx--) {\n\t        gi.compiledAccumulators[idx] = compileAccumulatorLoop(gi.aggregators[idx]);\n\t      }\n\t\n\t      toggledGroupsByLevel[i] = {};\n\t    }\n\t\n\t    refresh();\n\t  }\n\t\n\t  /**\n\t   * @deprecated Please use {@link setGrouping}.\n\t   */\n\t  function groupBy(valueGetter, valueFormatter, sortComparer) {\n\t    if (valueGetter == null) {\n\t      setGrouping([]);\n\t      return;\n\t    }\n\t\n\t    setGrouping({\n\t      getter: valueGetter,\n\t      formatter: valueFormatter,\n\t      comparer: sortComparer\n\t    });\n\t  }\n\t\n\t  /**\n\t   * @deprecated Please use {@link setGrouping}.\n\t   */\n\t  function setAggregators(groupAggregators, includeCollapsed) {\n\t    if (!groupingInfos.length) {\n\t      throw new Error('At least one grouping must be specified before calling setAggregators().');\n\t    }\n\t\n\t    groupingInfos[0].aggregators = groupAggregators;\n\t    groupingInfos[0].aggregateCollapsed = includeCollapsed;\n\t\n\t    setGrouping(groupingInfos);\n\t  }\n\t\n\t  function getItemByIdx(i) {\n\t    return items[i];\n\t  }\n\t\n\t  function getIdxById(id) {\n\t    return idxById[id];\n\t  }\n\t\n\t  function ensureRowsByIdCache() {\n\t    if (!rowsById) {\n\t      rowsById = {};\n\t      for (var i = 0, l = rows.length; i < l; i++) {\n\t        rowsById[rows[i][idProperty]] = i;\n\t      }\n\t    }\n\t  }\n\t\n\t  function getRowById(id) {\n\t    ensureRowsByIdCache();\n\t    return rowsById[id];\n\t  }\n\t\n\t  function getItemById(id) {\n\t    return items[idxById[id]];\n\t  }\n\t\n\t  function mapIdsToRows(idArray) {\n\t    var rows = [];\n\t    ensureRowsByIdCache();\n\t    for (var i = 0, l = idArray.length; i < l; i++) {\n\t      var row = rowsById[idArray[i]];\n\t      if (row != null) {\n\t        rows[rows.length] = row;\n\t      }\n\t    }\n\t    return rows;\n\t  }\n\t\n\t  function mapRowsToIds(rowArray) {\n\t    var ids = [];\n\t    for (var i = 0, l = rowArray.length; i < l; i++) {\n\t      if (rowArray[i] < rows.length) {\n\t        ids[ids.length] = rows[rowArray[i]][idProperty];\n\t      }\n\t    }\n\t    return ids;\n\t  }\n\t\n\t  function updateItem(id, item) {\n\t    if (idxById[id] === undefined || id !== item[idProperty]) {\n\t      throw 'Invalid or non-matching id';\n\t    }\n\t    items[idxById[id]] = item;\n\t    if (!updated) {\n\t      updated = {};\n\t    }\n\t    updated[id] = true;\n\t    refresh();\n\t  }\n\t\n\t  function insertItem(insertBefore, item) {\n\t    items.splice(insertBefore, 0, item);\n\t    updateIdxById(insertBefore);\n\t    refresh();\n\t  }\n\t\n\t  function addItem(item) {\n\t    items.push(item);\n\t    updateIdxById(items.length - 1);\n\t    refresh();\n\t  }\n\t\n\t  function deleteItem(id) {\n\t    var idx = idxById[id];\n\t    if (idx === undefined) {\n\t      throw 'Invalid id';\n\t    }\n\t    delete idxById[id];\n\t    items.splice(idx, 1);\n\t    updateIdxById(idx);\n\t    refresh();\n\t  }\n\t\n\t  function getLength() {\n\t    return rows.length;\n\t  }\n\t\n\t  function getItem(i) {\n\t    var item = rows[i];\n\t\n\t    // if this is a group row, make sure totals are calculated and update the title\n\t    if (item && item.__group && item.totals && !item.totals.initialized) {\n\t      var gi = groupingInfos[item.level];\n\t      if (!gi.displayTotalsRow) {\n\t        calculateTotals(item.totals);\n\t        item.title = gi.formatter ? gi.formatter(item) : item.value;\n\t      }\n\t    }\n\t    // if this is a totals row, make sure it's calculated\n\t    else if (item && item.__groupTotals && !item.initialized) {\n\t        calculateTotals(item);\n\t      }\n\t\n\t    return item;\n\t  }\n\t\n\t  function getItemMetadata(i) {\n\t    var item = rows[i];\n\t    if (item === undefined) {\n\t      return null;\n\t    }\n\t\n\t    // overrides for grouping rows\n\t    if (item.__group) {\n\t      return options.groupItemMetadataProvider.getGroupRowMetadata(item);\n\t    }\n\t\n\t    // overrides for totals rows\n\t    if (item.__groupTotals) {\n\t      return options.groupItemMetadataProvider.getTotalsRowMetadata(item);\n\t    }\n\t\n\t    return null;\n\t  }\n\t\n\t  function expandCollapseAllGroups(level, collapse) {\n\t    if (level == null) {\n\t      for (var i = 0; i < groupingInfos.length; i++) {\n\t        toggledGroupsByLevel[i] = {};\n\t        groupingInfos[i].collapsed = collapse;\n\t      }\n\t    } else {\n\t      toggledGroupsByLevel[level] = {};\n\t      groupingInfos[level].collapsed = collapse;\n\t    }\n\t    refresh();\n\t  }\n\t\n\t  /**\n\t   * @param level {Number} Optional level to collapse.  If not specified, applies to all levels.\n\t   */\n\t  function collapseAllGroups(level) {\n\t    expandCollapseAllGroups(level, true);\n\t  }\n\t\n\t  /**\n\t   * @param level {Number} Optional level to expand.  If not specified, applies to all levels.\n\t   */\n\t  function expandAllGroups(level) {\n\t    expandCollapseAllGroups(level, false);\n\t  }\n\t\n\t  function expandCollapseGroup(level, groupingKey, collapse) {\n\t    toggledGroupsByLevel[level][groupingKey] = groupingInfos[level].collapsed ^ collapse;\n\t    refresh();\n\t  }\n\t\n\t  /**\n\t   * @param letArgs Either a Slick.Group's \"groupingKey\" property, or a\n\t   *     letiable argument list of grouping values denoting a unique path to the row.  For\n\t   *     example, calling collapseGroup('high', '10%') will collapse the '10%' subgroup of\n\t   *     the 'high' group.\n\t   */\n\t  function collapseGroup(letArgs) {\n\t    var args = Array.prototype.slice.call(arguments);\n\t    var arg0 = args[0];\n\t    if (args.length == 1 && arg0.indexOf(groupingDelimiter) != -1) {\n\t      expandCollapseGroup(arg0.split(groupingDelimiter).length - 1, arg0, true);\n\t    } else {\n\t      expandCollapseGroup(args.length - 1, args.join(groupingDelimiter), true);\n\t    }\n\t  }\n\t\n\t  /**\n\t   * @param letArgs Either a Slick.Group's \"groupingKey\" property, or a\n\t   *     letiable argument list of grouping values denoting a unique path to the row.  For\n\t   *     example, calling expandGroup('high', '10%') will expand the '10%' subgroup of\n\t   *     the 'high' group.\n\t   */\n\t  function expandGroup(letArgs) {\n\t    var args = Array.prototype.slice.call(arguments);\n\t    var arg0 = args[0];\n\t    if (args.length == 1 && arg0.indexOf(groupingDelimiter) != -1) {\n\t      expandCollapseGroup(arg0.split(groupingDelimiter).length - 1, arg0, false);\n\t    } else {\n\t      expandCollapseGroup(args.length - 1, args.join(groupingDelimiter), false);\n\t    }\n\t  }\n\t\n\t  function getGroups() {\n\t    return groups;\n\t  }\n\t\n\t  function extractGroups(rows, parentGroup) {\n\t    var group = void 0;\n\t    var val = void 0;\n\t    var groups = [];\n\t    var groupsByVal = {};\n\t    var r = void 0;\n\t    var level = parentGroup ? parentGroup.level + 1 : 0;\n\t    var gi = groupingInfos[level];\n\t\n\t    for (var i = 0, l = gi.predefinedValues.length; i < l; i++) {\n\t      val = gi.predefinedValues[i];\n\t      group = groupsByVal[val];\n\t      if (!group) {\n\t        group = new _slick2.default.Group();\n\t        group.value = val;\n\t        group.level = level;\n\t        group.groupingKey = (parentGroup ? parentGroup.groupingKey + groupingDelimiter : '') + val;\n\t        groups[groups.length] = group;\n\t        groupsByVal[val] = group;\n\t      }\n\t    }\n\t\n\t    for (var _i = 0, _l = rows.length; _i < _l; _i++) {\n\t      r = rows[_i];\n\t      val = gi.getterIsAFn ? gi.getter(r) : r[gi.getter];\n\t      group = groupsByVal[val];\n\t      if (!group) {\n\t        group = new _slick2.default.Group();\n\t        group.value = val;\n\t        group.level = level;\n\t        group.groupingKey = (parentGroup ? parentGroup.groupingKey + groupingDelimiter : '') + val;\n\t        groups[groups.length] = group;\n\t        groupsByVal[val] = group;\n\t      }\n\t\n\t      group.rows[group.count++] = r;\n\t    }\n\t\n\t    if (level < groupingInfos.length - 1) {\n\t      for (var _i2 = 0; _i2 < groups.length; _i2++) {\n\t        group = groups[_i2];\n\t        group.groups = extractGroups(group.rows, group);\n\t      }\n\t    }\n\t\n\t    groups.sort(groupingInfos[level].comparer);\n\t\n\t    return groups;\n\t  }\n\t\n\t  function calculateTotals(totals) {\n\t    var group = totals.group;\n\t    var gi = groupingInfos[group.level];\n\t    var isLeafLevel = group.level == groupingInfos.length;\n\t    var agg = void 0,\n\t        idx = gi.aggregators.length;\n\t\n\t    if (!isLeafLevel && gi.aggregateChildGroups) {\n\t      // make sure all the subgroups are calculated\n\t      var i = group.groups.length;\n\t      while (i--) {\n\t        if (!group.groups[i].totals.initialized) {\n\t          calculateTotals(group.groups[i].totals);\n\t        }\n\t      }\n\t    }\n\t\n\t    while (idx--) {\n\t      agg = gi.aggregators[idx];\n\t      agg.init();\n\t      if (!isLeafLevel && gi.aggregateChildGroups) {\n\t        gi.compiledAccumulators[idx].call(agg, group.groups);\n\t      } else {\n\t        gi.compiledAccumulators[idx].call(agg, group.rows);\n\t      }\n\t      agg.storeResult(totals);\n\t    }\n\t    totals.initialized = true;\n\t  }\n\t\n\t  function addGroupTotals(group) {\n\t    var gi = groupingInfos[group.level];\n\t    var totals = new _slick2.default.GroupTotals();\n\t    totals.group = group;\n\t    group.totals = totals;\n\t    if (!gi.lazyTotalsCalculation) {\n\t      calculateTotals(totals);\n\t    }\n\t  }\n\t\n\t  function addTotals(groups, level) {\n\t    level = level || 0;\n\t    var gi = groupingInfos[level];\n\t    var groupCollapsed = gi.collapsed;\n\t    var toggledGroups = toggledGroupsByLevel[level];\n\t    var idx = groups.length,\n\t        g = void 0;\n\t    while (idx--) {\n\t      g = groups[idx];\n\t\n\t      if (g.collapsed && !gi.aggregateCollapsed) {\n\t        continue;\n\t      }\n\t\n\t      // Do a depth-first aggregation so that parent group aggregators can access subgroup totals.\n\t      if (g.groups) {\n\t        addTotals(g.groups, level + 1);\n\t      }\n\t\n\t      if (gi.aggregators.length && (gi.aggregateEmpty || g.rows.length || g.groups && g.groups.length)) {\n\t        addGroupTotals(g);\n\t      }\n\t\n\t      g.collapsed = groupCollapsed ^ toggledGroups[g.groupingKey];\n\t      g.title = gi.formatter ? gi.formatter(g) : g.value;\n\t    }\n\t  }\n\t\n\t  function flattenGroupedRows(groups, level) {\n\t    level = level || 0;\n\t    var gi = groupingInfos[level];\n\t    var groupedRows = [],\n\t        rows = void 0,\n\t        gl = 0,\n\t        g = void 0;\n\t    for (var i = 0, l = groups.length; i < l; i++) {\n\t      g = groups[i];\n\t      groupedRows[gl++] = g;\n\t\n\t      if (!g.collapsed) {\n\t        rows = g.groups ? flattenGroupedRows(g.groups, level + 1) : g.rows;\n\t        for (var j = 0, jj = rows.length; j < jj; j++) {\n\t          groupedRows[gl++] = rows[j];\n\t        }\n\t      }\n\t\n\t      if (g.totals && gi.displayTotalsRow && (!g.collapsed || gi.aggregateCollapsed)) {\n\t        groupedRows[gl++] = g.totals;\n\t      }\n\t    }\n\t    return groupedRows;\n\t  }\n\t\n\t  function getFunctionInfo(fn) {\n\t    var fnRegex = /^function[^(]*\\(([^)]*)\\)\\s*{([\\s\\S]*)}$/;\n\t    var matches = fn.toString().match(fnRegex);\n\t    return {\n\t      params: matches[1].split(','),\n\t      body: matches[2]\n\t    };\n\t  }\n\t\n\t  function compileAccumulatorLoop(aggregator) {\n\t    var accumulatorInfo = getFunctionInfo(aggregator.accumulate);\n\t    var fn = new Function('_items', 'for (let ' + accumulatorInfo.params[0] + ', _i=0, _il=_items.length; _i<_il; _i++) {' + accumulatorInfo.params[0] + ' = _items[_i]; ' + accumulatorInfo.body + '}');\n\t    fn.displayName = 'compiledAccumulatorLoop';\n\t    return fn;\n\t  }\n\t\n\t  function compileFilter() {\n\t    var filterInfo = getFunctionInfo(filter);\n\t\n\t    var filterPath1 = '{ continue _coreloop; }$1';\n\t    var filterPath2 = '{ _retval[_idx++] = $item$; continue _coreloop; }$1';\n\t    // make some allowances for minification - there's only so far we can go with RegEx\n\t    var filterBody = filterInfo.body.replace(/return false\\s*([;}]|\\}|$)/gi, filterPath1).replace(/return!1([;}]|\\}|$)/gi, filterPath1).replace(/return true\\s*([;}]|\\}|$)/gi, filterPath2).replace(/return!0([;}]|\\}|$)/gi, filterPath2).replace(/return ([^;}]+?)\\s*([;}]|$)/gi, '{ if ($1) { _retval[_idx++] = $item$; }; continue _coreloop; }$2');\n\t\n\t    // This preserves the function template code after JS compression,\n\t    // so that replace() commands still work as expected.\n\t    var tpl = [\n\t    // \"function(_items, _args) { \",\n\t    'let _retval = [], _idx = 0; ', 'let $item$, $args$ = _args; ', '_coreloop: ', 'for (let _i = 0, _il = _items.length; _i < _il; _i++) { ', '$item$ = _items[_i]; ', '$filter$; ', '} ', 'return _retval; '\n\t    // \"}\"\n\t    ].join('');\n\t    tpl = tpl.replace(/\\$filter\\$/gi, filterBody);\n\t    tpl = tpl.replace(/\\$item\\$/gi, filterInfo.params[0]);\n\t    tpl = tpl.replace(/\\$args\\$/gi, filterInfo.params[1]);\n\t\n\t    var fn = new Function('_items,_args', tpl);\n\t    fn.displayName = 'compiledFilter';\n\t\n\t    return fn;\n\t  }\n\t\n\t  function compileFilterWithCaching() {\n\t    var filterInfo = getFunctionInfo(filter);\n\t\n\t    var filterPath1 = '{ continue _coreloop; }$1';\n\t    var filterPath2 = '{ _cache[_i] = true;_retval[_idx++] = $item$; continue _coreloop; }$1';\n\t    // make some allowances for minification - there's only so far we can go with RegEx\n\t    var filterBody = filterInfo.body.replace(/return false\\s*([;}]|\\}|$)/gi, filterPath1).replace(/return!1([;}]|\\}|$)/gi, filterPath1).replace(/return true\\s*([;}]|\\}|$)/gi, filterPath2).replace(/return!0([;}]|\\}|$)/gi, filterPath2).replace(/return ([^;}]+?)\\s*([;}]|$)/gi, '{ if ((_cache[_i] = $1)) { _retval[_idx++] = $item$; }; continue _coreloop; }$2');\n\t\n\t    // This preserves the function template code after JS compression,\n\t    // so that replace() commands still work as expected.\n\t    var tpl = [\n\t    // \"function(_items, _args, _cache) { \",\n\t    'let _retval = [], _idx = 0; ', 'let $item$, $args$ = _args; ', '_coreloop: ', 'for (let _i = 0, _il = _items.length; _i < _il; _i++) { ', '$item$ = _items[_i]; ', 'if (_cache[_i]) { ', '_retval[_idx++] = $item$; ', 'continue _coreloop; ', '} ', '$filter$; ', '} ', 'return _retval; '\n\t    // \"}\"\n\t    ].join('');\n\t    tpl = tpl.replace(/\\$filter\\$/gi, filterBody);\n\t    tpl = tpl.replace(/\\$item\\$/gi, filterInfo.params[0]);\n\t    tpl = tpl.replace(/\\$args\\$/gi, filterInfo.params[1]);\n\t\n\t    var fn = new Function('_items,_args,_cache', tpl);\n\t    fn.displayName = 'compiledFilterWithCaching';\n\t    return fn;\n\t  }\n\t\n\t  function uncompiledFilter(items, args) {\n\t    var retval = [],\n\t        idx = 0;\n\t\n\t    for (var i = 0, ii = items.length; i < ii; i++) {\n\t      if (filter(items[i], args)) {\n\t        retval[idx++] = items[i];\n\t      }\n\t    }\n\t\n\t    return retval;\n\t  }\n\t\n\t  function uncompiledFilterWithCaching(items, args, cache) {\n\t    var retval = [],\n\t        idx = 0,\n\t        item = void 0;\n\t\n\t    for (var i = 0, ii = items.length; i < ii; i++) {\n\t      item = items[i];\n\t      if (cache[i]) {\n\t        retval[idx++] = item;\n\t      } else if (filter(item, args)) {\n\t        retval[idx++] = item;\n\t        cache[i] = true;\n\t      }\n\t    }\n\t\n\t    return retval;\n\t  }\n\t\n\t  function getFilteredAndPagedItems(items) {\n\t    if (filter) {\n\t      var batchFilter = options.inlineFilters ? compiledFilter : uncompiledFilter;\n\t      var batchFilterWithCaching = options.inlineFilters ? compiledFilterWithCaching : uncompiledFilterWithCaching;\n\t\n\t      if (refreshHints.isFilterNarrowing) {\n\t        filteredItems = batchFilter(filteredItems, filterArgs);\n\t      } else if (refreshHints.isFilterExpanding) {\n\t        filteredItems = batchFilterWithCaching(items, filterArgs, filterCache);\n\t      } else if (!refreshHints.isFilterUnchanged) {\n\t        filteredItems = batchFilter(items, filterArgs);\n\t      }\n\t    } else {\n\t      // special case:  if not filtering and not paging, the resulting\n\t      // rows collection needs to be a copy so that changes due to sort\n\t      // can be caught\n\t      filteredItems = pagesize ? items : items.concat();\n\t    }\n\t\n\t    // get the current page\n\t    var paged = void 0;\n\t    if (pagesize) {\n\t      if (filteredItems.length < pagenum * pagesize) {\n\t        pagenum = Math.floor(filteredItems.length / pagesize);\n\t      }\n\t      paged = filteredItems.slice(pagesize * pagenum, pagesize * pagenum + pagesize);\n\t    } else {\n\t      paged = filteredItems;\n\t    }\n\t\n\t    return { totalRows: filteredItems.length, rows: paged };\n\t  }\n\t\n\t  function getRowDiffs(rows, newRows) {\n\t    var item = void 0,\n\t        r = void 0,\n\t        eitherIsNonData = void 0,\n\t        diff = [];\n\t    var from = 0,\n\t        to = newRows.length;\n\t\n\t    if (refreshHints && refreshHints.ignoreDiffsBefore) {\n\t      from = Math.max(0, Math.min(newRows.length, refreshHints.ignoreDiffsBefore));\n\t    }\n\t\n\t    if (refreshHints && refreshHints.ignoreDiffsAfter) {\n\t      to = Math.min(newRows.length, Math.max(0, refreshHints.ignoreDiffsAfter));\n\t    }\n\t\n\t    for (var i = from, rl = rows.length; i < to; i++) {\n\t      if (i >= rl) {\n\t        diff[diff.length] = i;\n\t      } else {\n\t        item = newRows[i];\n\t        r = rows[i];\n\t\n\t        if (groupingInfos.length && (eitherIsNonData = item.__nonDataRow || r.__nonDataRow) && item.__group !== r.__group || item.__group && !item.equals(r) || eitherIsNonData && (\n\t        // no good way to compare totals since they are arbitrary DTOs\n\t        // deep object comparison is pretty expensive\n\t        // always considering them 'dirty' seems easier for the time being\n\t        item.__groupTotals || r.__groupTotals) || item[idProperty] != r[idProperty] || updated && updated[item[idProperty]]) {\n\t          diff[diff.length] = i;\n\t        }\n\t      }\n\t    }\n\t    return diff;\n\t  }\n\t\n\t  function recalc(_items) {\n\t    rowsById = null;\n\t\n\t    if (refreshHints.isFilterNarrowing != prevRefreshHints.isFilterNarrowing || refreshHints.isFilterExpanding != prevRefreshHints.isFilterExpanding) {\n\t      filterCache = [];\n\t    }\n\t\n\t    var filteredItems = getFilteredAndPagedItems(_items);\n\t    totalRows = filteredItems.totalRows;\n\t    var newRows = filteredItems.rows;\n\t\n\t    groups = [];\n\t    if (groupingInfos.length) {\n\t      groups = extractGroups(newRows);\n\t      if (groups.length) {\n\t        addTotals(groups);\n\t        newRows = flattenGroupedRows(groups);\n\t      }\n\t    }\n\t\n\t    var diff = getRowDiffs(rows, newRows);\n\t\n\t    rows = newRows;\n\t\n\t    return diff;\n\t  }\n\t\n\t  function refresh() {\n\t    if (suspend) {\n\t      return;\n\t    }\n\t\n\t    var countBefore = rows.length;\n\t    var totalRowsBefore = totalRows;\n\t\n\t    var diff = recalc(items, filter); // pass as direct refs to avoid closure perf hit\n\t\n\t    // if the current page is no longer valid, go to last page and recalc\n\t    // we suffer a performance penalty here, but the main loop (recalc) remains highly optimized\n\t    if (pagesize && totalRows < pagenum * pagesize) {\n\t      pagenum = Math.max(0, Math.ceil(totalRows / pagesize) - 1);\n\t      diff = recalc(items, filter);\n\t    }\n\t\n\t    updated = null;\n\t    prevRefreshHints = refreshHints;\n\t    refreshHints = {};\n\t\n\t    if (totalRowsBefore !== totalRows) {\n\t      onPagingInfoChanged.notify(getPagingInfo(), null, self);\n\t    }\n\t    if (countBefore !== rows.length) {\n\t      onRowCountChanged.notify({ previous: countBefore, current: rows.length, dataView: self }, null, self);\n\t    }\n\t    if (diff.length > 0) {\n\t      onRowsChanged.notify({ rows: diff, dataView: self }, null, self);\n\t    }\n\t  }\n\t\n\t  /** *\n\t   * Wires the grid and the DataView together to keep row selection tied to item ids.\n\t   * This is useful since, without it, the grid only knows about rows, so if the items\n\t   * move around, the same rows stay selected instead of the selection moving along\n\t   * with the items.\n\t   *\n\t   * NOTE:  This doesn't work with cell selection model.\n\t   *\n\t   * @param grid {Slick.Grid} The grid to sync selection with.\n\t   * @param preserveHidden {Boolean} Whether to keep selected items that go out of the\n\t   *     view due to them getting filtered out.\n\t   * @param preserveHiddenOnSelectionChange {Boolean} Whether to keep selected items\n\t   *     that are currently out of the view (see preserveHidden) as selected when selection\n\t   *     changes.\n\t   * @return {Slick.Event} An event that notifies when an internal list of selected row ids\n\t   *     changes.  This is useful since, in combination with the above two options, it allows\n\t   *     access to the full list selected row ids, and not just the ones visible to the grid.\n\t   * @method syncGridSelection\n\t   */\n\t  function syncGridSelection(grid, preserveHidden, preserveHiddenOnSelectionChange) {\n\t    var self = this;\n\t    var inHandler = void 0;\n\t    var selectedRowIds = self.mapRowsToIds(grid.getSelectedRows());\n\t    var onSelectedRowIdsChanged = new _slick2.default.Event();\n\t\n\t    function setSelectedRowIds(rowIds) {\n\t      if (selectedRowIds.join(',') == rowIds.join(',')) {\n\t        return;\n\t      }\n\t\n\t      selectedRowIds = rowIds;\n\t\n\t      onSelectedRowIdsChanged.notify({\n\t        grid: grid,\n\t        ids: selectedRowIds,\n\t        dataView: self\n\t      }, new _slick2.default.EventData(), self);\n\t    }\n\t\n\t    function update() {\n\t      if (selectedRowIds.length > 0) {\n\t        inHandler = true;\n\t        var selectedRows = self.mapIdsToRows(selectedRowIds);\n\t        if (!preserveHidden) {\n\t          setSelectedRowIds(self.mapRowsToIds(selectedRows));\n\t        }\n\t        grid.setSelectedRows(selectedRows);\n\t        inHandler = false;\n\t      }\n\t    }\n\t\n\t    grid.onSelectedRowsChanged.subscribe(function (e, args) {\n\t      if (inHandler) {\n\t        return;\n\t      }\n\t      var newSelectedRowIds = self.mapRowsToIds(grid.getSelectedRows());\n\t      if (!preserveHiddenOnSelectionChange || !grid.getOptions().multiSelect) {\n\t        setSelectedRowIds(newSelectedRowIds);\n\t      } else {\n\t        // keep the ones that are hidden\n\t        var existing = _jquery2.default.grep(selectedRowIds, function (id) {\n\t          return self.getRowById(id) === undefined;\n\t        });\n\t        // add the newly selected ones\n\t        setSelectedRowIds(existing.concat(newSelectedRowIds));\n\t      }\n\t    });\n\t\n\t    this.onRowsChanged.subscribe(update);\n\t\n\t    this.onRowCountChanged.subscribe(update);\n\t\n\t    return onSelectedRowIdsChanged;\n\t  }\n\t\n\t  function syncGridCellCssStyles(grid, key) {\n\t    var hashById = void 0;\n\t    var inHandler = void 0;\n\t\n\t    // since this method can be called after the cell styles have been set,\n\t    // get the existing ones right away\n\t    storeCellCssStyles(grid.getCellCssStyles(key));\n\t\n\t    function storeCellCssStyles(hash) {\n\t      hashById = {};\n\t      for (var row in hash) {\n\t        var id = rows[row][idProperty];\n\t        hashById[id] = hash[row];\n\t      }\n\t    }\n\t\n\t    function update() {\n\t      if (hashById) {\n\t        inHandler = true;\n\t        ensureRowsByIdCache();\n\t        var newHash = {};\n\t        for (var id in hashById) {\n\t          var row = rowsById[id];\n\t          if (row != undefined) {\n\t            newHash[row] = hashById[id];\n\t          }\n\t        }\n\t        grid.setCellCssStyles(key, newHash);\n\t        inHandler = false;\n\t      }\n\t    }\n\t\n\t    grid.onCellCssStylesChanged.subscribe(function (e, args) {\n\t      if (inHandler) {\n\t        return;\n\t      }\n\t      if (key != args.key) {\n\t        return;\n\t      }\n\t      if (args.hash) {\n\t        storeCellCssStyles(args.hash);\n\t      }\n\t    });\n\t\n\t    this.onRowsChanged.subscribe(update);\n\t\n\t    this.onRowCountChanged.subscribe(update);\n\t  }\n\t\n\t  _jquery2.default.extend(this, {\n\t    // methods\n\t    beginUpdate: beginUpdate,\n\t    endUpdate: endUpdate,\n\t    setPagingOptions: setPagingOptions,\n\t    getPagingInfo: getPagingInfo,\n\t    getItems: getItems,\n\t    setItems: setItems,\n\t    setFilter: setFilter,\n\t    sort: sort,\n\t    fastSort: fastSort,\n\t    reSort: reSort,\n\t    setGrouping: setGrouping,\n\t    getGrouping: getGrouping,\n\t    groupBy: groupBy,\n\t    setAggregators: setAggregators,\n\t    collapseAllGroups: collapseAllGroups,\n\t    expandAllGroups: expandAllGroups,\n\t    collapseGroup: collapseGroup,\n\t    expandGroup: expandGroup,\n\t    getGroups: getGroups,\n\t    getIdxById: getIdxById,\n\t    getRowById: getRowById,\n\t    getItemById: getItemById,\n\t    getItemByIdx: getItemByIdx,\n\t    mapRowsToIds: mapRowsToIds,\n\t    mapIdsToRows: mapIdsToRows,\n\t    setRefreshHints: setRefreshHints,\n\t    setFilterArgs: setFilterArgs,\n\t    refresh: refresh,\n\t    updateItem: updateItem,\n\t    insertItem: insertItem,\n\t    addItem: addItem,\n\t    deleteItem: deleteItem,\n\t    syncGridSelection: syncGridSelection,\n\t    syncGridCellCssStyles: syncGridCellCssStyles,\n\t\n\t    // data provider methods\n\t    getLength: getLength,\n\t    getItem: getItem,\n\t    getItemMetadata: getItemMetadata,\n\t\n\t    // events\n\t    onRowCountChanged: onRowCountChanged,\n\t    onRowsChanged: onRowsChanged,\n\t    onPagingInfoChanged: onPagingInfoChanged\n\t  });\n\t}\n\t\n\tfunction AvgAggregator(field) {\n\t  this.field_ = field;\n\t\n\t  this.init = function () {\n\t    this.count_ = 0;\n\t    this.nonNullCount_ = 0;\n\t    this.sum_ = 0;\n\t  };\n\t\n\t  this.accumulate = function (item) {\n\t    var val = item[this.field_];\n\t    this.count_++;\n\t    if (val != null && val !== '' && !isNaN(val)) {\n\t      this.nonNullCount_++;\n\t      this.sum_ += parseFloat(val);\n\t    }\n\t  };\n\t\n\t  this.storeResult = function (groupTotals) {\n\t    if (!groupTotals.avg) {\n\t      groupTotals.avg = {};\n\t    }\n\t    if (this.nonNullCount_ != 0) {\n\t      groupTotals.avg[this.field_] = this.sum_ / this.nonNullCount_;\n\t    }\n\t  };\n\t}\n\t\n\tfunction MinAggregator(field) {\n\t  this.field_ = field;\n\t\n\t  this.init = function () {\n\t    this.min_ = null;\n\t  };\n\t\n\t  this.accumulate = function (item) {\n\t    var val = item[this.field_];\n\t    if (val != null && val !== '' && !isNaN(val)) {\n\t      if (this.min_ == null || val < this.min_) {\n\t        this.min_ = val;\n\t      }\n\t    }\n\t  };\n\t\n\t  this.storeResult = function (groupTotals) {\n\t    if (!groupTotals.min) {\n\t      groupTotals.min = {};\n\t    }\n\t    groupTotals.min[this.field_] = this.min_;\n\t  };\n\t}\n\t\n\tfunction MaxAggregator(field) {\n\t  this.field_ = field;\n\t\n\t  this.init = function () {\n\t    this.max_ = null;\n\t  };\n\t\n\t  this.accumulate = function (item) {\n\t    var val = item[this.field_];\n\t    if (val != null && val !== '' && !isNaN(val)) {\n\t      if (this.max_ == null || val > this.max_) {\n\t        this.max_ = val;\n\t      }\n\t    }\n\t  };\n\t\n\t  this.storeResult = function (groupTotals) {\n\t    if (!groupTotals.max) {\n\t      groupTotals.max = {};\n\t    }\n\t    groupTotals.max[this.field_] = this.max_;\n\t  };\n\t}\n\t\n\tfunction SumAggregator(field) {\n\t  this.field_ = field;\n\t\n\t  this.init = function () {\n\t    this.sum_ = null;\n\t  };\n\t\n\t  this.accumulate = function (item) {\n\t    var val = item[this.field_];\n\t    if (val != null && val !== '' && !isNaN(val)) {\n\t      this.sum_ += parseFloat(val);\n\t    }\n\t  };\n\t\n\t  this.storeResult = function (groupTotals) {\n\t    if (!groupTotals.sum) {\n\t      groupTotals.sum = {};\n\t    }\n\t    groupTotals.sum[this.field_] = this.sum_;\n\t  };\n\t}\n\n/***/ }),\n/* 6 */,\n/* 7 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _jquery = __webpack_require__(2);\n\t\n\tvar _jquery2 = _interopRequireDefault(_jquery);\n\t\n\tvar _slick = __webpack_require__(1);\n\t\n\tvar _slick2 = _interopRequireDefault(_slick);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\texports.default = GroupItemMetadataProvider;\n\t\n\t/***\n\t * Provides item metadata for group (Slick.Group) and totals (Slick.Totals) rows produced by the DataView.\n\t * This metadata overrides the default behavior and formatting of those rows so that they appear and function\n\t * correctly when processed by the grid.\n\t *\n\t * This class also acts as a grid plugin providing event handlers to expand & collapse groups.\n\t * If \"grid.registerPlugin(...)\" is not called, expand & collapse will not work.\n\t *\n\t * @class GroupItemMetadataProvider\n\t * @module Data\n\t * @namespace Slick.Data\n\t * @constructor\n\t * @param options\n\t */\n\t\n\tfunction GroupItemMetadataProvider(options) {\n\t  var _grid = void 0;\n\t  var _defaults = {\n\t    groupCssClass: 'slick-group',\n\t    groupTitleCssClass: 'slick-group-title',\n\t    totalsCssClass: 'slick-group-totals',\n\t    groupFocusable: true,\n\t    totalsFocusable: false,\n\t    toggleCssClass: 'slick-group-toggle',\n\t    toggleExpandedCssClass: 'expanded',\n\t    toggleCollapsedCssClass: 'collapsed',\n\t    enableExpandCollapse: true,\n\t    groupFormatter: defaultGroupCellFormatter,\n\t    totalsFormatter: defaultTotalsCellFormatter\n\t  };\n\t\n\t  options = _jquery2.default.extend(true, {}, _defaults, options);\n\t\n\t  function defaultGroupCellFormatter(row, cell, value, columnDef, item) {\n\t    if (!options.enableExpandCollapse) {\n\t      return item.title;\n\t    }\n\t\n\t    var indentation = item.level * 15 + 'px';\n\t\n\t    return \"<span class='\" + options.toggleCssClass + ' ' + (item.collapsed ? options.toggleCollapsedCssClass : options.toggleExpandedCssClass) + \"' style='margin-left:\" + indentation + \"'>\" + '</span>' + \"<span class='\" + options.groupTitleCssClass + \"' level='\" + item.level + \"'>\" + item.title + '</span>';\n\t  }\n\t\n\t  function defaultTotalsCellFormatter(row, cell, value, columnDef, item) {\n\t    return columnDef.groupTotalsFormatter && columnDef.groupTotalsFormatter(item, columnDef) || '';\n\t  }\n\t\n\t  function init(grid) {\n\t    _grid = grid;\n\t    _grid.onClick.subscribe(handleGridClick);\n\t    _grid.onKeyDown.subscribe(handleGridKeyDown);\n\t  }\n\t\n\t  function destroy() {\n\t    if (_grid) {\n\t      _grid.onClick.unsubscribe(handleGridClick);\n\t      _grid.onKeyDown.unsubscribe(handleGridKeyDown);\n\t    }\n\t  }\n\t\n\t  function handleGridClick(e, args) {\n\t    var item = this.getDataItem(args.row);\n\t    if (item && item instanceof _slick2.default.Group && (0, _jquery2.default)(e.target).hasClass(options.toggleCssClass)) {\n\t      var range = _grid.getRenderedRange();\n\t      this.getData().setRefreshHints({\n\t        ignoreDiffsBefore: range.top,\n\t        ignoreDiffsAfter: range.bottom + 1\n\t      });\n\t\n\t      if (item.collapsed) {\n\t        this.getData().expandGroup(item.groupingKey);\n\t      } else {\n\t        this.getData().collapseGroup(item.groupingKey);\n\t      }\n\t\n\t      e.stopImmediatePropagation();\n\t      e.preventDefault();\n\t    }\n\t  }\n\t\n\t  // TODO:  add -/+ handling\n\t  function handleGridKeyDown(e) {\n\t    if (options.enableExpandCollapse && e.which == _slick2.default.keyCode.SPACE) {\n\t      var activeCell = this.getActiveCell();\n\t      if (activeCell) {\n\t        var item = this.getDataItem(activeCell.row);\n\t        if (item && item instanceof _slick2.default.Group) {\n\t          var range = _grid.getRenderedRange();\n\t          this.getData().setRefreshHints({\n\t            ignoreDiffsBefore: range.top,\n\t            ignoreDiffsAfter: range.bottom + 1\n\t          });\n\t\n\t          if (item.collapsed) {\n\t            this.getData().expandGroup(item.groupingKey);\n\t          } else {\n\t            this.getData().collapseGroup(item.groupingKey);\n\t          }\n\t\n\t          e.stopImmediatePropagation();\n\t          e.preventDefault();\n\t        }\n\t      }\n\t    }\n\t  }\n\t\n\t  function getGroupRowMetadata(item) {\n\t    return {\n\t      selectable: false,\n\t      focusable: options.groupFocusable,\n\t      cssClasses: options.groupCssClass,\n\t      columns: {\n\t        0: {\n\t          colspan: '*',\n\t          formatter: options.groupFormatter,\n\t          editor: null\n\t        }\n\t      }\n\t    };\n\t  }\n\t\n\t  function getTotalsRowMetadata(item) {\n\t    return {\n\t      selectable: false,\n\t      focusable: options.totalsFocusable,\n\t      cssClasses: options.totalsCssClass,\n\t      formatter: options.totalsFormatter,\n\t      editor: null\n\t    };\n\t  }\n\t\n\t  return {\n\t    init: init,\n\t    destroy: destroy,\n\t    getGroupRowMetadata: getGroupRowMetadata,\n\t    getTotalsRowMetadata: getTotalsRowMetadata\n\t  };\n\t}\n\n/***/ })\n/******/ ]);\n\n\n// WEBPACK FOOTER //\n// data.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 0b760b7e5612043079fd","/** *\n * Contains core SlickGrid classes.\n * @module Core\n * @namespace Slick\n */\nconst Slick = {\n  Event: Event,\n  EventData: EventData,\n  EventHandler: EventHandler,\n  Range: Range,\n  NonDataRow: NonDataItem,\n  Group: Group,\n  GroupTotals: GroupTotals,\n  EditorLock: EditorLock,\n  /** *\n   * A global singleton editor lock.\n   * @class GlobalEditorLock\n   * @static\n   * @constructor\n   */\n  GlobalEditorLock: new EditorLock(),\n  TreeColumns: TreeColumns,\n\n  keyCode: {\n    BACKSPACE: 8,\n    DELETE: 46,\n    DOWN: 40,\n    END: 35,\n    ENTER: 13,\n    ESCAPE: 27,\n    HOME: 36,\n    INSERT: 45,\n    LEFT: 37,\n    PAGE_DOWN: 34,\n    PAGE_UP: 33,\n    RIGHT: 39,\n    TAB: 9,\n    UP: 38,\n    SPACE: 32\n  }\n};\n\nexport default Slick;\n\n/***\n * An event object for passing data to event handlers and letting them control propagation.\n * <p>This is pretty much identical to how W3C and jQuery implement events.</p>\n * @class EventData\n * @constructor\n */\nfunction EventData() {\n  var isPropagationStopped = false;\n  var isImmediatePropagationStopped = false;\n\n  /***\n   * Stops event from propagating up the DOM tree.\n   * @method stopPropagation\n   */\n  this.stopPropagation = function() {\n    isPropagationStopped = true;\n  };\n\n  /***\n   * Returns whether stopPropagation was called on this event object.\n   * @method isPropagationStopped\n   * @return {Boolean}\n   */\n  this.isPropagationStopped = function() {\n    return isPropagationStopped;\n  };\n\n  /***\n   * Prevents the rest of the handlers from being executed.\n   * @method stopImmediatePropagation\n   */\n  this.stopImmediatePropagation = function() {\n    isImmediatePropagationStopped = true;\n  };\n\n  /***\n   * Returns whether stopImmediatePropagation was called on this event object.\\\n   * @method isImmediatePropagationStopped\n   * @return {Boolean}\n   */\n  this.isImmediatePropagationStopped = function() {\n    return isImmediatePropagationStopped;\n  };\n}\n\n/***\n * A simple publisher-subscriber implementation.\n * @class Event\n * @constructor\n */\nfunction Event() {\n  var handlers = [];\n\n  /***\n   * Adds an event handler to be called when the event is fired.\n   * <p>Event handler will receive two arguments - an <code>EventData</code> and the <code>data</code>\n   * object the event was fired with.<p>\n   * @method subscribe\n   * @param fn {Function} Event handler.\n   */\n  this.subscribe = function(fn) {\n    handlers.push(fn);\n  };\n\n  /***\n   * Removes an event handler added with <code>subscribe(fn)</code>.\n   * @method unsubscribe\n   * @param fn {Function} Event handler to be removed.\n   */\n  this.unsubscribe = function(fn) {\n    for (var i = handlers.length - 1; i >= 0; i--) {\n      if (handlers[i] === fn) {\n        handlers.splice(i, 1);\n      }\n    }\n  };\n\n  /***\n   * Fires an event notifying all subscribers.\n   * @method notify\n   * @param args {Object} Additional data object to be passed to all handlers.\n   * @param e {EventData}\n   *      Optional.\n   *      An <code>EventData</code> object to be passed to all handlers.\n   *      For DOM events, an existing W3C/jQuery event object can be passed in.\n   * @param scope {Object}\n   *      Optional.\n   *      The scope (\"this\") within which the handler will be executed.\n   *      If not specified, the scope will be set to the <code>Event</code> instance.\n   */\n  this.notify = function(args, e, scope) {\n    e = e || new EventData();\n    scope = scope || this;\n\n    var returnValue;\n    for (\n      var i = 0;\n      i < handlers.length &&\n      !(e.isPropagationStopped() || e.isImmediatePropagationStopped());\n      i++\n    ) {\n      returnValue = handlers[i].call(scope, e, args);\n    }\n\n    return returnValue;\n  };\n}\n\nfunction EventHandler() {\n  var handlers = [];\n\n  this.subscribe = function(event, handler) {\n    handlers.push({\n      event: event,\n      handler: handler\n    });\n    event.subscribe(handler);\n\n    return this; // allow chaining\n  };\n\n  this.unsubscribe = function(event, handler) {\n    var i = handlers.length;\n    while (i--) {\n      if (handlers[i].event === event && handlers[i].handler === handler) {\n        handlers.splice(i, 1);\n        event.unsubscribe(handler);\n        return;\n      }\n    }\n\n    return this; // allow chaining\n  };\n\n  this.unsubscribeAll = function() {\n    var i = handlers.length;\n    while (i--) {\n      handlers[i].event.unsubscribe(handlers[i].handler);\n    }\n    handlers = [];\n\n    return this; // allow chaining\n  };\n}\n\n/***\n * A structure containing a range of cells.\n * @class Range\n * @constructor\n * @param fromRow {Integer} Starting row.\n * @param fromCell {Integer} Starting cell.\n * @param toRow {Integer} Optional. Ending row. Defaults to <code>fromRow</code>.\n * @param toCell {Integer} Optional. Ending cell. Defaults to <code>fromCell</code>.\n */\nfunction Range(fromRow, fromCell, toRow, toCell) {\n  if (toRow === undefined && toCell === undefined) {\n    toRow = fromRow;\n    toCell = fromCell;\n  }\n\n  /***\n   * @property fromRow\n   * @type {Integer}\n   */\n  this.fromRow = Math.min(fromRow, toRow);\n\n  /***\n   * @property fromCell\n   * @type {Integer}\n   */\n  this.fromCell = Math.min(fromCell, toCell);\n\n  /***\n   * @property toRow\n   * @type {Integer}\n   */\n  this.toRow = Math.max(fromRow, toRow);\n\n  /***\n   * @property toCell\n   * @type {Integer}\n   */\n  this.toCell = Math.max(fromCell, toCell);\n\n  /***\n   * Returns whether a range represents a single row.\n   * @method isSingleRow\n   * @return {Boolean}\n   */\n  this.isSingleRow = function() {\n    return this.fromRow == this.toRow;\n  };\n\n  /***\n   * Returns whether a range represents a single cell.\n   * @method isSingleCell\n   * @return {Boolean}\n   */\n  this.isSingleCell = function() {\n    return this.fromRow == this.toRow && this.fromCell == this.toCell;\n  };\n\n  /***\n   * Returns whether a range contains a given cell.\n   * @method contains\n   * @param row {Integer}\n   * @param cell {Integer}\n   * @return {Boolean}\n   */\n  this.contains = function(row, cell) {\n    return (\n      row >= this.fromRow &&\n      row <= this.toRow &&\n      cell >= this.fromCell &&\n      cell <= this.toCell\n    );\n  };\n\n  /***\n   * Returns a readable representation of a range.\n   * @method toString\n   * @return {String}\n   */\n  this.toString = function() {\n    if (this.isSingleCell()) {\n      return '(' + this.fromRow + ':' + this.fromCell + ')';\n    } else {\n      return (\n        '(' +\n        this.fromRow +\n        ':' +\n        this.fromCell +\n        ' - ' +\n        this.toRow +\n        ':' +\n        this.toCell +\n        ')'\n      );\n    }\n  };\n}\n\n/***\n * A base class that all special / non-data rows (like Group and GroupTotals) derive from.\n * @class NonDataItem\n * @constructor\n */\nfunction NonDataItem() {\n  this.__nonDataRow = true;\n}\n\n/***\n * Information about a group of rows.\n * @class Group\n * @extends Slick.NonDataItem\n * @constructor\n */\nfunction Group() {\n  this.__group = true;\n\n  /**\n   * Grouping level, starting with 0.\n   * @property level\n   * @type {Number}\n   */\n  this.level = 0;\n\n  /***\n   * Number of rows in the group.\n   * @property count\n   * @type {Integer}\n   */\n  this.count = 0;\n\n  /***\n   * Grouping value.\n   * @property value\n   * @type {Object}\n   */\n  this.value = null;\n\n  /***\n   * Formatted display value of the group.\n   * @property title\n   * @type {String}\n   */\n  this.title = null;\n\n  /***\n   * Whether a group is collapsed.\n   * @property collapsed\n   * @type {Boolean}\n   */\n  this.collapsed = false;\n\n  /***\n   * GroupTotals, if any.\n   * @property totals\n   * @type {GroupTotals}\n   */\n  this.totals = null;\n\n  /**\n   * Rows that are part of the group.\n   * @property rows\n   * @type {Array}\n   */\n  this.rows = [];\n\n  /**\n   * Sub-groups that are part of the group.\n   * @property groups\n   * @type {Array}\n   */\n  this.groups = null;\n\n  /**\n   * A unique key used to identify the group.  This key can be used in calls to DataView\n   * collapseGroup() or expandGroup().\n   * @property groupingKey\n   * @type {Object}\n   */\n  this.groupingKey = null;\n}\n\nGroup.prototype = new NonDataItem();\n\n/***\n * Compares two Group instances.\n * @method equals\n * @return {Boolean}\n * @param group {Group} Group instance to compare to.\n */\nGroup.prototype.equals = function(group) {\n  return (\n    this.value === group.value &&\n    this.count === group.count &&\n    this.collapsed === group.collapsed &&\n    this.title === group.title\n  );\n};\n\n/***\n * Information about group totals.\n * An instance of GroupTotals will be created for each totals row and passed to the aggregators\n * so that they can store arbitrary data in it.  That data can later be accessed by group totals\n * formatters during the display.\n * @class GroupTotals\n * @extends Slick.NonDataItem\n * @constructor\n */\nfunction GroupTotals() {\n  this.__groupTotals = true;\n\n  /***\n   * Parent Group.\n   * @param group\n   * @type {Group}\n   */\n  this.group = null;\n\n  /***\n   * Whether the totals have been fully initialized / calculated.\n   * Will be set to false for lazy-calculated group totals.\n   * @param initialized\n   * @type {Boolean}\n   */\n  this.initialized = false;\n}\n\nGroupTotals.prototype = new NonDataItem();\n\n/***\n * A locking helper to track the active edit controller and ensure that only a single controller\n * can be active at a time.  This prevents a whole class of state and validation synchronization\n * issues.  An edit controller (such as SlickGrid) can query if an active edit is in progress\n * and attempt a commit or cancel before proceeding.\n * @class EditorLock\n * @constructor\n */\nfunction EditorLock() {\n  var activeEditController = null;\n\n  /***\n   * Returns true if a specified edit controller is active (has the edit lock).\n   * If the parameter is not specified, returns true if any edit controller is active.\n   * @method isActive\n   * @param editController {EditController}\n   * @return {Boolean}\n   */\n  this.isActive = function(editController) {\n    return editController\n      ? activeEditController === editController\n      : activeEditController !== null;\n  };\n\n  /***\n   * Sets the specified edit controller as the active edit controller (acquire edit lock).\n   * If another edit controller is already active, and exception will be thrown.\n   * @method activate\n   * @param editController {EditController} edit controller acquiring the lock\n   */\n  this.activate = function(editController) {\n    if (editController === activeEditController) {\n      // already activated?\n      return;\n    }\n    if (activeEditController !== null) {\n      throw \"SlickGrid.EditorLock.activate: an editController is still active, can't activate another editController\";\n    }\n    if (!editController.commitCurrentEdit) {\n      throw 'SlickGrid.EditorLock.activate: editController must implement .commitCurrentEdit()';\n    }\n    if (!editController.cancelCurrentEdit) {\n      throw 'SlickGrid.EditorLock.activate: editController must implement .cancelCurrentEdit()';\n    }\n    activeEditController = editController;\n  };\n\n  /***\n   * Unsets the specified edit controller as the active edit controller (release edit lock).\n   * If the specified edit controller is not the active one, an exception will be thrown.\n   * @method deactivate\n   * @param editController {EditController} edit controller releasing the lock\n   */\n  this.deactivate = function(editController) {\n    if (activeEditController !== editController) {\n      throw 'SlickGrid.EditorLock.deactivate: specified editController is not the currently active one';\n    }\n    activeEditController = null;\n  };\n\n  /***\n   * Attempts to commit the current edit by calling \"commitCurrentEdit\" method on the active edit\n   * controller and returns whether the commit attempt was successful (commit may fail due to validation\n   * errors, etc.).  Edit controller's \"commitCurrentEdit\" must return true if the commit has succeeded\n   * and false otherwise.  If no edit controller is active, returns true.\n   * @method commitCurrentEdit\n   * @return {Boolean}\n   */\n  this.commitCurrentEdit = function() {\n    return activeEditController\n      ? activeEditController.commitCurrentEdit()\n      : true;\n  };\n\n  /***\n   * Attempts to cancel the current edit by calling \"cancelCurrentEdit\" method on the active edit\n   * controller and returns whether the edit was successfully cancelled.  If no edit controller is\n   * active, returns true.\n   * @method cancelCurrentEdit\n   * @return {Boolean}\n   */\n  this.cancelCurrentEdit = function cancelCurrentEdit() {\n    return activeEditController\n      ? activeEditController.cancelCurrentEdit()\n      : true;\n  };\n}\n\n/**\n *\n * @param {Array} treeColumns Array com levels of columns\n * @returns {{hasDepth: 'hasDepth', getTreeColumns: 'getTreeColumns', extractColumns: 'extractColumns', getDepth: 'getDepth', getColumnsInDepth: 'getColumnsInDepth', getColumnsInGroup: 'getColumnsInGroup', visibleColumns: 'visibleColumns', filter: 'filter', reOrder: reOrder}}\n * @constructor\n */\nfunction TreeColumns(treeColumns) {\n  var columnsById = {};\n\n  function init() {\n    mapToId(treeColumns);\n  }\n\n  function mapToId(columns) {\n    columns.forEach(function(column) {\n      columnsById[column.id] = column;\n\n      if (column.columns) mapToId(column.columns);\n    });\n  }\n\n  function filter(node, condition) {\n    return node.filter(function(column) {\n      var valid = condition.call(column);\n\n      if (valid && column.columns)\n        column.columns = filter(column.columns, condition);\n\n      return valid && (!column.columns || column.columns.length);\n    });\n  }\n\n  function sort(columns, grid) {\n    columns\n      .sort(function(a, b) {\n        var indexA = getOrDefault(grid.getColumnIndex(a.id)),\n          indexB = getOrDefault(grid.getColumnIndex(b.id));\n\n        return indexA - indexB;\n      })\n      .forEach(function(column) {\n        if (column.columns) sort(column.columns, grid);\n      });\n  }\n\n  function getOrDefault(value) {\n    return typeof value === 'undefined' ? -1 : value;\n  }\n\n  function getDepth(node) {\n    if (node.length) for (var i in node) return getDepth(node[i]);\n    else if (node.columns) return 1 + getDepth(node.columns);\n    else return 1;\n  }\n\n  function getColumnsInDepth(node, depth, current) {\n    var columns = [];\n    current = current || 0;\n\n    if (depth == current) {\n      if (node.length)\n        node.forEach(function(n) {\n          if (n.columns)\n            n.extractColumns = function() {\n              return extractColumns(n);\n            };\n        });\n\n      return node;\n    } else\n      for (var i in node)\n        if (node[i].columns) {\n          columns = columns.concat(\n            getColumnsInDepth(node[i].columns, depth, current + 1)\n          );\n        }\n\n    return columns;\n  }\n\n  function extractColumns(node) {\n    var result = [];\n\n    if (node.hasOwnProperty('length')) {\n      for (var i = 0; i < node.length; i++)\n        result = result.concat(extractColumns(node[i]));\n    } else {\n      if (node.hasOwnProperty('columns'))\n        result = result.concat(extractColumns(node.columns));\n      else return node;\n    }\n\n    return result;\n  }\n\n  function cloneTreeColumns() {\n    return $.extend(true, [], treeColumns);\n  }\n\n  init();\n\n  this.hasDepth = function() {\n    for (var i in treeColumns)\n      if (treeColumns[i].hasOwnProperty('columns')) return true;\n\n    return false;\n  };\n\n  this.getTreeColumns = function() {\n    return treeColumns;\n  };\n\n  this.extractColumns = function() {\n    return this.hasDepth() ? extractColumns(treeColumns) : treeColumns;\n  };\n\n  this.getDepth = function() {\n    return getDepth(treeColumns);\n  };\n\n  this.getColumnsInDepth = function(depth) {\n    return getColumnsInDepth(treeColumns, depth);\n  };\n\n  this.getColumnsInGroup = function(groups) {\n    return extractColumns(groups);\n  };\n\n  this.visibleColumns = function() {\n    return filter(cloneTreeColumns(), function() {\n      return this.visible;\n    });\n  };\n\n  this.filter = function(condition) {\n    return filter(cloneTreeColumns(), condition);\n  };\n\n  this.reOrder = function(grid) {\n    return sort(treeColumns, grid);\n  };\n\n  this.getById = function(id) {\n    return columnsById[id];\n  };\n\n  this.getInIds = function(ids) {\n    return ids.map(function(id) {\n      return columnsById[id];\n    });\n  };\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/slick.core.js","module.exports = require(\"jquery\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"jquery\"\n// module id = 2\n// module chunks = 0 1 2 3","import Slick from './slick.core';\nimport $ from 'jquery';\nimport GroupItemMetaDataProvider from './slick.groupmetadataprovider';\n\nconst Aggregators = {\n  Avg: AvgAggregator,\n  Min: MinAggregator,\n  Max: MaxAggregator,\n  Sum: SumAggregator\n};\n\nconst Data = {\n  DataView,\n  GroupMetaDataProvider: GroupItemMetaDataProvider,\n  Aggregators\n};\n\nexport default Data;\n\n/** *\n * A sample Model implementation.\n * Provides a filtered view of the underlying data.\n *\n * Relies on the data item having an \"id\" property uniquely identifying it.\n */\nfunction DataView(options) {\n  let self = this;\n\n  let defaults = {\n    groupItemMetadataProvider: null,\n    inlineFilters: false\n  };\n\n  // private\n  let idProperty = 'id'; // property holding a unique row id\n  let items = []; // data by index\n  let rows = []; // data by row\n  let idxById = {}; // indexes by id\n  let rowsById = null; // rows by id; lazy-calculated\n  let filter = null; // filter function\n  let updated = null; // updated item ids\n  let suspend = false; // suspends the recalculation\n  let sortAsc = true;\n  let fastSortField;\n  let sortComparer;\n  let refreshHints = {};\n  let prevRefreshHints = {};\n  let filterArgs;\n  let filteredItems = [];\n  let compiledFilter;\n  let compiledFilterWithCaching;\n  let filterCache = [];\n\n  // grouping\n  let groupingInfoDefaults = {\n    getter: null,\n    formatter: null,\n    comparer: function(a, b) {\n      return a.value === b.value ? 0 : a.value > b.value ? 1 : -1;\n    },\n    predefinedValues: [],\n    aggregators: [],\n    aggregateEmpty: false,\n    aggregateCollapsed: false,\n    aggregateChildGroups: false,\n    collapsed: false,\n    displayTotalsRow: true,\n    lazyTotalsCalculation: false\n  };\n  let groupingInfos = [];\n  let groups = [];\n  let toggledGroupsByLevel = [];\n  let groupingDelimiter = ':|:';\n\n  let pagesize = 0;\n  let pagenum = 0;\n  let totalRows = 0;\n\n  // events\n  let onRowCountChanged = new Slick.Event();\n  let onRowsChanged = new Slick.Event();\n  let onPagingInfoChanged = new Slick.Event();\n\n  options = $.extend(true, {}, defaults, options);\n\n  function beginUpdate() {\n    suspend = true;\n  }\n\n  function endUpdate() {\n    suspend = false;\n    refresh();\n  }\n\n  function setRefreshHints(hints) {\n    refreshHints = hints;\n  }\n\n  function setFilterArgs(args) {\n    filterArgs = args;\n  }\n\n  function updateIdxById(startingIndex) {\n    startingIndex = startingIndex || 0;\n    let id;\n    for (let i = startingIndex, l = items.length; i < l; i++) {\n      id = items[i][idProperty];\n      if (id === undefined) {\n        throw \"Each data element must implement a unique 'id' property\";\n      }\n      idxById[id] = i;\n    }\n  }\n\n  function ensureIdUniqueness() {\n    let id;\n    for (let i = 0, l = items.length; i < l; i++) {\n      id = items[i][idProperty];\n      if (id === undefined || idxById[id] !== i) {\n        throw \"Each data element must implement a unique 'id' property\";\n      }\n    }\n  }\n\n  function getItems() {\n    return items;\n  }\n\n  function setItems(data, objectIdProperty) {\n    if (objectIdProperty !== undefined) {\n      idProperty = objectIdProperty;\n    }\n    items = filteredItems = data;\n    idxById = {};\n    updateIdxById();\n    ensureIdUniqueness();\n    refresh();\n  }\n\n  function setPagingOptions(args) {\n    if (args.pageSize != undefined) {\n      pagesize = args.pageSize;\n      pagenum = pagesize\n        ? Math.min(pagenum, Math.max(0, Math.ceil(totalRows / pagesize) - 1))\n        : 0;\n    }\n\n    if (args.pageNum != undefined) {\n      pagenum = Math.min(\n        args.pageNum,\n        Math.max(0, Math.ceil(totalRows / pagesize) - 1)\n      );\n    }\n\n    onPagingInfoChanged.notify(getPagingInfo(), null, self);\n\n    refresh();\n  }\n\n  function getPagingInfo() {\n    let totalPages = pagesize\n      ? Math.max(1, Math.ceil(totalRows / pagesize))\n      : 1;\n    return {\n      pageSize: pagesize,\n      pageNum: pagenum,\n      totalRows: totalRows,\n      totalPages: totalPages,\n      dataView: self\n    };\n  }\n\n  function sort(comparer, ascending) {\n    sortAsc = ascending;\n    sortComparer = comparer;\n    fastSortField = null;\n    if (ascending === false) {\n      items.reverse();\n    }\n    items.sort(comparer);\n    if (ascending === false) {\n      items.reverse();\n    }\n    idxById = {};\n    updateIdxById();\n    refresh();\n  }\n\n  /** *\n   * Provides a workaround for the extremely slow sorting in IE.\n   * Does a [lexicographic] sort on a give column by temporarily overriding Object.prototype.toString\n   * to return the value of that field and then doing a native Array.sort().\n   */\n  function fastSort(field, ascending) {\n    sortAsc = ascending;\n    fastSortField = field;\n    sortComparer = null;\n    let oldToString = Object.prototype.toString;\n    Object.prototype.toString =\n      typeof field == 'function'\n        ? field\n        : function() {\n            return this[field];\n          };\n    // an extra reversal for descending sort keeps the sort stable\n    // (assuming a stable native sort implementation, which isn't true in some cases)\n    if (ascending === false) {\n      items.reverse();\n    }\n    items.sort();\n    Object.prototype.toString = oldToString;\n    if (ascending === false) {\n      items.reverse();\n    }\n    idxById = {};\n    updateIdxById();\n    refresh();\n  }\n\n  function reSort() {\n    if (sortComparer) {\n      sort(sortComparer, sortAsc);\n    } else if (fastSortField) {\n      fastSort(fastSortField, sortAsc);\n    }\n  }\n\n  function setFilter(filterFn) {\n    filter = filterFn;\n    if (options.inlineFilters) {\n      compiledFilter = compileFilter();\n      compiledFilterWithCaching = compileFilterWithCaching();\n    }\n    refresh();\n  }\n\n  function getGrouping() {\n    return groupingInfos;\n  }\n\n  function setGrouping(groupingInfo) {\n    if (!options.groupItemMetadataProvider) {\n      options.groupItemMetadataProvider = GroupItemMetadataProvider();\n    }\n\n    groups = [];\n    toggledGroupsByLevel = [];\n    groupingInfo = groupingInfo || [];\n    groupingInfos =\n      groupingInfo instanceof Array ? groupingInfo : [groupingInfo];\n\n    for (let i = 0; i < groupingInfos.length; i++) {\n      let gi = (groupingInfos[i] = $.extend(\n        true,\n        {},\n        groupingInfoDefaults,\n        groupingInfos[i]\n      ));\n      gi.getterIsAFn = typeof gi.getter === 'function';\n\n      // pre-compile accumulator loops\n      gi.compiledAccumulators = [];\n      let idx = gi.aggregators.length;\n      while (idx--) {\n        gi.compiledAccumulators[idx] = compileAccumulatorLoop(\n          gi.aggregators[idx]\n        );\n      }\n\n      toggledGroupsByLevel[i] = {};\n    }\n\n    refresh();\n  }\n\n  /**\n   * @deprecated Please use {@link setGrouping}.\n   */\n  function groupBy(valueGetter, valueFormatter, sortComparer) {\n    if (valueGetter == null) {\n      setGrouping([]);\n      return;\n    }\n\n    setGrouping({\n      getter: valueGetter,\n      formatter: valueFormatter,\n      comparer: sortComparer\n    });\n  }\n\n  /**\n   * @deprecated Please use {@link setGrouping}.\n   */\n  function setAggregators(groupAggregators, includeCollapsed) {\n    if (!groupingInfos.length) {\n      throw new Error(\n        'At least one grouping must be specified before calling setAggregators().'\n      );\n    }\n\n    groupingInfos[0].aggregators = groupAggregators;\n    groupingInfos[0].aggregateCollapsed = includeCollapsed;\n\n    setGrouping(groupingInfos);\n  }\n\n  function getItemByIdx(i) {\n    return items[i];\n  }\n\n  function getIdxById(id) {\n    return idxById[id];\n  }\n\n  function ensureRowsByIdCache() {\n    if (!rowsById) {\n      rowsById = {};\n      for (let i = 0, l = rows.length; i < l; i++) {\n        rowsById[rows[i][idProperty]] = i;\n      }\n    }\n  }\n\n  function getRowById(id) {\n    ensureRowsByIdCache();\n    return rowsById[id];\n  }\n\n  function getItemById(id) {\n    return items[idxById[id]];\n  }\n\n  function mapIdsToRows(idArray) {\n    let rows = [];\n    ensureRowsByIdCache();\n    for (let i = 0, l = idArray.length; i < l; i++) {\n      let row = rowsById[idArray[i]];\n      if (row != null) {\n        rows[rows.length] = row;\n      }\n    }\n    return rows;\n  }\n\n  function mapRowsToIds(rowArray) {\n    let ids = [];\n    for (let i = 0, l = rowArray.length; i < l; i++) {\n      if (rowArray[i] < rows.length) {\n        ids[ids.length] = rows[rowArray[i]][idProperty];\n      }\n    }\n    return ids;\n  }\n\n  function updateItem(id, item) {\n    if (idxById[id] === undefined || id !== item[idProperty]) {\n      throw 'Invalid or non-matching id';\n    }\n    items[idxById[id]] = item;\n    if (!updated) {\n      updated = {};\n    }\n    updated[id] = true;\n    refresh();\n  }\n\n  function insertItem(insertBefore, item) {\n    items.splice(insertBefore, 0, item);\n    updateIdxById(insertBefore);\n    refresh();\n  }\n\n  function addItem(item) {\n    items.push(item);\n    updateIdxById(items.length - 1);\n    refresh();\n  }\n\n  function deleteItem(id) {\n    let idx = idxById[id];\n    if (idx === undefined) {\n      throw 'Invalid id';\n    }\n    delete idxById[id];\n    items.splice(idx, 1);\n    updateIdxById(idx);\n    refresh();\n  }\n\n  function getLength() {\n    return rows.length;\n  }\n\n  function getItem(i) {\n    let item = rows[i];\n\n    // if this is a group row, make sure totals are calculated and update the title\n    if (item && item.__group && item.totals && !item.totals.initialized) {\n      let gi = groupingInfos[item.level];\n      if (!gi.displayTotalsRow) {\n        calculateTotals(item.totals);\n        item.title = gi.formatter ? gi.formatter(item) : item.value;\n      }\n    }\n    // if this is a totals row, make sure it's calculated\n    else if (item && item.__groupTotals && !item.initialized) {\n      calculateTotals(item);\n    }\n\n    return item;\n  }\n\n  function getItemMetadata(i) {\n    let item = rows[i];\n    if (item === undefined) {\n      return null;\n    }\n\n    // overrides for grouping rows\n    if (item.__group) {\n      return options.groupItemMetadataProvider.getGroupRowMetadata(item);\n    }\n\n    // overrides for totals rows\n    if (item.__groupTotals) {\n      return options.groupItemMetadataProvider.getTotalsRowMetadata(item);\n    }\n\n    return null;\n  }\n\n  function expandCollapseAllGroups(level, collapse) {\n    if (level == null) {\n      for (let i = 0; i < groupingInfos.length; i++) {\n        toggledGroupsByLevel[i] = {};\n        groupingInfos[i].collapsed = collapse;\n      }\n    } else {\n      toggledGroupsByLevel[level] = {};\n      groupingInfos[level].collapsed = collapse;\n    }\n    refresh();\n  }\n\n  /**\n   * @param level {Number} Optional level to collapse.  If not specified, applies to all levels.\n   */\n  function collapseAllGroups(level) {\n    expandCollapseAllGroups(level, true);\n  }\n\n  /**\n   * @param level {Number} Optional level to expand.  If not specified, applies to all levels.\n   */\n  function expandAllGroups(level) {\n    expandCollapseAllGroups(level, false);\n  }\n\n  function expandCollapseGroup(level, groupingKey, collapse) {\n    toggledGroupsByLevel[level][groupingKey] =\n      groupingInfos[level].collapsed ^ collapse;\n    refresh();\n  }\n\n  /**\n   * @param letArgs Either a Slick.Group's \"groupingKey\" property, or a\n   *     letiable argument list of grouping values denoting a unique path to the row.  For\n   *     example, calling collapseGroup('high', '10%') will collapse the '10%' subgroup of\n   *     the 'high' group.\n   */\n  function collapseGroup(letArgs) {\n    let args = Array.prototype.slice.call(arguments);\n    let arg0 = args[0];\n    if (args.length == 1 && arg0.indexOf(groupingDelimiter) != -1) {\n      expandCollapseGroup(arg0.split(groupingDelimiter).length - 1, arg0, true);\n    } else {\n      expandCollapseGroup(args.length - 1, args.join(groupingDelimiter), true);\n    }\n  }\n\n  /**\n   * @param letArgs Either a Slick.Group's \"groupingKey\" property, or a\n   *     letiable argument list of grouping values denoting a unique path to the row.  For\n   *     example, calling expandGroup('high', '10%') will expand the '10%' subgroup of\n   *     the 'high' group.\n   */\n  function expandGroup(letArgs) {\n    let args = Array.prototype.slice.call(arguments);\n    let arg0 = args[0];\n    if (args.length == 1 && arg0.indexOf(groupingDelimiter) != -1) {\n      expandCollapseGroup(\n        arg0.split(groupingDelimiter).length - 1,\n        arg0,\n        false\n      );\n    } else {\n      expandCollapseGroup(args.length - 1, args.join(groupingDelimiter), false);\n    }\n  }\n\n  function getGroups() {\n    return groups;\n  }\n\n  function extractGroups(rows, parentGroup) {\n    let group;\n    let val;\n    let groups = [];\n    let groupsByVal = {};\n    let r;\n    let level = parentGroup ? parentGroup.level + 1 : 0;\n    let gi = groupingInfos[level];\n\n    for (let i = 0, l = gi.predefinedValues.length; i < l; i++) {\n      val = gi.predefinedValues[i];\n      group = groupsByVal[val];\n      if (!group) {\n        group = new Slick.Group();\n        group.value = val;\n        group.level = level;\n        group.groupingKey =\n          (parentGroup ? parentGroup.groupingKey + groupingDelimiter : '') +\n          val;\n        groups[groups.length] = group;\n        groupsByVal[val] = group;\n      }\n    }\n\n    for (let i = 0, l = rows.length; i < l; i++) {\n      r = rows[i];\n      val = gi.getterIsAFn ? gi.getter(r) : r[gi.getter];\n      group = groupsByVal[val];\n      if (!group) {\n        group = new Slick.Group();\n        group.value = val;\n        group.level = level;\n        group.groupingKey =\n          (parentGroup ? parentGroup.groupingKey + groupingDelimiter : '') +\n          val;\n        groups[groups.length] = group;\n        groupsByVal[val] = group;\n      }\n\n      group.rows[group.count++] = r;\n    }\n\n    if (level < groupingInfos.length - 1) {\n      for (let i = 0; i < groups.length; i++) {\n        group = groups[i];\n        group.groups = extractGroups(group.rows, group);\n      }\n    }\n\n    groups.sort(groupingInfos[level].comparer);\n\n    return groups;\n  }\n\n  function calculateTotals(totals) {\n    let group = totals.group;\n    let gi = groupingInfos[group.level];\n    let isLeafLevel = group.level == groupingInfos.length;\n    let agg,\n      idx = gi.aggregators.length;\n\n    if (!isLeafLevel && gi.aggregateChildGroups) {\n      // make sure all the subgroups are calculated\n      let i = group.groups.length;\n      while (i--) {\n        if (!group.groups[i].totals.initialized) {\n          calculateTotals(group.groups[i].totals);\n        }\n      }\n    }\n\n    while (idx--) {\n      agg = gi.aggregators[idx];\n      agg.init();\n      if (!isLeafLevel && gi.aggregateChildGroups) {\n        gi.compiledAccumulators[idx].call(agg, group.groups);\n      } else {\n        gi.compiledAccumulators[idx].call(agg, group.rows);\n      }\n      agg.storeResult(totals);\n    }\n    totals.initialized = true;\n  }\n\n  function addGroupTotals(group) {\n    let gi = groupingInfos[group.level];\n    let totals = new Slick.GroupTotals();\n    totals.group = group;\n    group.totals = totals;\n    if (!gi.lazyTotalsCalculation) {\n      calculateTotals(totals);\n    }\n  }\n\n  function addTotals(groups, level) {\n    level = level || 0;\n    let gi = groupingInfos[level];\n    let groupCollapsed = gi.collapsed;\n    let toggledGroups = toggledGroupsByLevel[level];\n    let idx = groups.length,\n      g;\n    while (idx--) {\n      g = groups[idx];\n\n      if (g.collapsed && !gi.aggregateCollapsed) {\n        continue;\n      }\n\n      // Do a depth-first aggregation so that parent group aggregators can access subgroup totals.\n      if (g.groups) {\n        addTotals(g.groups, level + 1);\n      }\n\n      if (\n        gi.aggregators.length &&\n        (gi.aggregateEmpty || g.rows.length || (g.groups && g.groups.length))\n      ) {\n        addGroupTotals(g);\n      }\n\n      g.collapsed = groupCollapsed ^ toggledGroups[g.groupingKey];\n      g.title = gi.formatter ? gi.formatter(g) : g.value;\n    }\n  }\n\n  function flattenGroupedRows(groups, level) {\n    level = level || 0;\n    let gi = groupingInfos[level];\n    let groupedRows = [],\n      rows,\n      gl = 0,\n      g;\n    for (let i = 0, l = groups.length; i < l; i++) {\n      g = groups[i];\n      groupedRows[gl++] = g;\n\n      if (!g.collapsed) {\n        rows = g.groups ? flattenGroupedRows(g.groups, level + 1) : g.rows;\n        for (let j = 0, jj = rows.length; j < jj; j++) {\n          groupedRows[gl++] = rows[j];\n        }\n      }\n\n      if (\n        g.totals &&\n        gi.displayTotalsRow &&\n        (!g.collapsed || gi.aggregateCollapsed)\n      ) {\n        groupedRows[gl++] = g.totals;\n      }\n    }\n    return groupedRows;\n  }\n\n  function getFunctionInfo(fn) {\n    let fnRegex = /^function[^(]*\\(([^)]*)\\)\\s*{([\\s\\S]*)}$/;\n    let matches = fn.toString().match(fnRegex);\n    return {\n      params: matches[1].split(','),\n      body: matches[2]\n    };\n  }\n\n  function compileAccumulatorLoop(aggregator) {\n    let accumulatorInfo = getFunctionInfo(aggregator.accumulate);\n    let fn = new Function(\n      '_items',\n      'for (let ' +\n        accumulatorInfo.params[0] +\n        ', _i=0, _il=_items.length; _i<_il; _i++) {' +\n        accumulatorInfo.params[0] +\n        ' = _items[_i]; ' +\n        accumulatorInfo.body +\n        '}'\n    );\n    fn.displayName = 'compiledAccumulatorLoop';\n    return fn;\n  }\n\n  function compileFilter() {\n    let filterInfo = getFunctionInfo(filter);\n\n    let filterPath1 = '{ continue _coreloop; }$1';\n    let filterPath2 = '{ _retval[_idx++] = $item$; continue _coreloop; }$1';\n    // make some allowances for minification - there's only so far we can go with RegEx\n    let filterBody = filterInfo.body\n      .replace(/return false\\s*([;}]|\\}|$)/gi, filterPath1)\n      .replace(/return!1([;}]|\\}|$)/gi, filterPath1)\n      .replace(/return true\\s*([;}]|\\}|$)/gi, filterPath2)\n      .replace(/return!0([;}]|\\}|$)/gi, filterPath2)\n      .replace(\n        /return ([^;}]+?)\\s*([;}]|$)/gi,\n        '{ if ($1) { _retval[_idx++] = $item$; }; continue _coreloop; }$2'\n      );\n\n    // This preserves the function template code after JS compression,\n    // so that replace() commands still work as expected.\n    let tpl = [\n      // \"function(_items, _args) { \",\n      'let _retval = [], _idx = 0; ',\n      'let $item$, $args$ = _args; ',\n      '_coreloop: ',\n      'for (let _i = 0, _il = _items.length; _i < _il; _i++) { ',\n      '$item$ = _items[_i]; ',\n      '$filter$; ',\n      '} ',\n      'return _retval; '\n      // \"}\"\n    ].join('');\n    tpl = tpl.replace(/\\$filter\\$/gi, filterBody);\n    tpl = tpl.replace(/\\$item\\$/gi, filterInfo.params[0]);\n    tpl = tpl.replace(/\\$args\\$/gi, filterInfo.params[1]);\n\n    let fn = new Function('_items,_args', tpl);\n    fn.displayName = 'compiledFilter';\n\n    return fn;\n  }\n\n  function compileFilterWithCaching() {\n    let filterInfo = getFunctionInfo(filter);\n\n    let filterPath1 = '{ continue _coreloop; }$1';\n    let filterPath2 =\n      '{ _cache[_i] = true;_retval[_idx++] = $item$; continue _coreloop; }$1';\n    // make some allowances for minification - there's only so far we can go with RegEx\n    let filterBody = filterInfo.body\n      .replace(/return false\\s*([;}]|\\}|$)/gi, filterPath1)\n      .replace(/return!1([;}]|\\}|$)/gi, filterPath1)\n      .replace(/return true\\s*([;}]|\\}|$)/gi, filterPath2)\n      .replace(/return!0([;}]|\\}|$)/gi, filterPath2)\n      .replace(\n        /return ([^;}]+?)\\s*([;}]|$)/gi,\n        '{ if ((_cache[_i] = $1)) { _retval[_idx++] = $item$; }; continue _coreloop; }$2'\n      );\n\n    // This preserves the function template code after JS compression,\n    // so that replace() commands still work as expected.\n    let tpl = [\n      // \"function(_items, _args, _cache) { \",\n      'let _retval = [], _idx = 0; ',\n      'let $item$, $args$ = _args; ',\n      '_coreloop: ',\n      'for (let _i = 0, _il = _items.length; _i < _il; _i++) { ',\n      '$item$ = _items[_i]; ',\n      'if (_cache[_i]) { ',\n      '_retval[_idx++] = $item$; ',\n      'continue _coreloop; ',\n      '} ',\n      '$filter$; ',\n      '} ',\n      'return _retval; '\n      // \"}\"\n    ].join('');\n    tpl = tpl.replace(/\\$filter\\$/gi, filterBody);\n    tpl = tpl.replace(/\\$item\\$/gi, filterInfo.params[0]);\n    tpl = tpl.replace(/\\$args\\$/gi, filterInfo.params[1]);\n\n    let fn = new Function('_items,_args,_cache', tpl);\n    fn.displayName = 'compiledFilterWithCaching';\n    return fn;\n  }\n\n  function uncompiledFilter(items, args) {\n    let retval = [],\n      idx = 0;\n\n    for (let i = 0, ii = items.length; i < ii; i++) {\n      if (filter(items[i], args)) {\n        retval[idx++] = items[i];\n      }\n    }\n\n    return retval;\n  }\n\n  function uncompiledFilterWithCaching(items, args, cache) {\n    let retval = [],\n      idx = 0,\n      item;\n\n    for (let i = 0, ii = items.length; i < ii; i++) {\n      item = items[i];\n      if (cache[i]) {\n        retval[idx++] = item;\n      } else if (filter(item, args)) {\n        retval[idx++] = item;\n        cache[i] = true;\n      }\n    }\n\n    return retval;\n  }\n\n  function getFilteredAndPagedItems(items) {\n    if (filter) {\n      let batchFilter = options.inlineFilters\n        ? compiledFilter\n        : uncompiledFilter;\n      let batchFilterWithCaching = options.inlineFilters\n        ? compiledFilterWithCaching\n        : uncompiledFilterWithCaching;\n\n      if (refreshHints.isFilterNarrowing) {\n        filteredItems = batchFilter(filteredItems, filterArgs);\n      } else if (refreshHints.isFilterExpanding) {\n        filteredItems = batchFilterWithCaching(items, filterArgs, filterCache);\n      } else if (!refreshHints.isFilterUnchanged) {\n        filteredItems = batchFilter(items, filterArgs);\n      }\n    } else {\n      // special case:  if not filtering and not paging, the resulting\n      // rows collection needs to be a copy so that changes due to sort\n      // can be caught\n      filteredItems = pagesize ? items : items.concat();\n    }\n\n    // get the current page\n    let paged;\n    if (pagesize) {\n      if (filteredItems.length < pagenum * pagesize) {\n        pagenum = Math.floor(filteredItems.length / pagesize);\n      }\n      paged = filteredItems.slice(\n        pagesize * pagenum,\n        pagesize * pagenum + pagesize\n      );\n    } else {\n      paged = filteredItems;\n    }\n\n    return {totalRows: filteredItems.length, rows: paged};\n  }\n\n  function getRowDiffs(rows, newRows) {\n    let item,\n      r,\n      eitherIsNonData,\n      diff = [];\n    let from = 0,\n      to = newRows.length;\n\n    if (refreshHints && refreshHints.ignoreDiffsBefore) {\n      from = Math.max(\n        0,\n        Math.min(newRows.length, refreshHints.ignoreDiffsBefore)\n      );\n    }\n\n    if (refreshHints && refreshHints.ignoreDiffsAfter) {\n      to = Math.min(newRows.length, Math.max(0, refreshHints.ignoreDiffsAfter));\n    }\n\n    for (let i = from, rl = rows.length; i < to; i++) {\n      if (i >= rl) {\n        diff[diff.length] = i;\n      } else {\n        item = newRows[i];\n        r = rows[i];\n\n        if (\n          (groupingInfos.length &&\n            (eitherIsNonData = item.__nonDataRow || r.__nonDataRow) &&\n            item.__group !== r.__group) ||\n          (item.__group && !item.equals(r)) ||\n          (eitherIsNonData &&\n            // no good way to compare totals since they are arbitrary DTOs\n            // deep object comparison is pretty expensive\n            // always considering them 'dirty' seems easier for the time being\n            (item.__groupTotals || r.__groupTotals)) ||\n          item[idProperty] != r[idProperty] ||\n          (updated && updated[item[idProperty]])\n        ) {\n          diff[diff.length] = i;\n        }\n      }\n    }\n    return diff;\n  }\n\n  function recalc(_items) {\n    rowsById = null;\n\n    if (\n      refreshHints.isFilterNarrowing != prevRefreshHints.isFilterNarrowing ||\n      refreshHints.isFilterExpanding != prevRefreshHints.isFilterExpanding\n    ) {\n      filterCache = [];\n    }\n\n    let filteredItems = getFilteredAndPagedItems(_items);\n    totalRows = filteredItems.totalRows;\n    let newRows = filteredItems.rows;\n\n    groups = [];\n    if (groupingInfos.length) {\n      groups = extractGroups(newRows);\n      if (groups.length) {\n        addTotals(groups);\n        newRows = flattenGroupedRows(groups);\n      }\n    }\n\n    let diff = getRowDiffs(rows, newRows);\n\n    rows = newRows;\n\n    return diff;\n  }\n\n  function refresh() {\n    if (suspend) {\n      return;\n    }\n\n    let countBefore = rows.length;\n    let totalRowsBefore = totalRows;\n\n    let diff = recalc(items, filter); // pass as direct refs to avoid closure perf hit\n\n    // if the current page is no longer valid, go to last page and recalc\n    // we suffer a performance penalty here, but the main loop (recalc) remains highly optimized\n    if (pagesize && totalRows < pagenum * pagesize) {\n      pagenum = Math.max(0, Math.ceil(totalRows / pagesize) - 1);\n      diff = recalc(items, filter);\n    }\n\n    updated = null;\n    prevRefreshHints = refreshHints;\n    refreshHints = {};\n\n    if (totalRowsBefore !== totalRows) {\n      onPagingInfoChanged.notify(getPagingInfo(), null, self);\n    }\n    if (countBefore !== rows.length) {\n      onRowCountChanged.notify(\n        {previous: countBefore, current: rows.length, dataView: self},\n        null,\n        self\n      );\n    }\n    if (diff.length > 0) {\n      onRowsChanged.notify({rows: diff, dataView: self}, null, self);\n    }\n  }\n\n  /** *\n   * Wires the grid and the DataView together to keep row selection tied to item ids.\n   * This is useful since, without it, the grid only knows about rows, so if the items\n   * move around, the same rows stay selected instead of the selection moving along\n   * with the items.\n   *\n   * NOTE:  This doesn't work with cell selection model.\n   *\n   * @param grid {Slick.Grid} The grid to sync selection with.\n   * @param preserveHidden {Boolean} Whether to keep selected items that go out of the\n   *     view due to them getting filtered out.\n   * @param preserveHiddenOnSelectionChange {Boolean} Whether to keep selected items\n   *     that are currently out of the view (see preserveHidden) as selected when selection\n   *     changes.\n   * @return {Slick.Event} An event that notifies when an internal list of selected row ids\n   *     changes.  This is useful since, in combination with the above two options, it allows\n   *     access to the full list selected row ids, and not just the ones visible to the grid.\n   * @method syncGridSelection\n   */\n  function syncGridSelection(\n    grid,\n    preserveHidden,\n    preserveHiddenOnSelectionChange\n  ) {\n    let self = this;\n    let inHandler;\n    let selectedRowIds = self.mapRowsToIds(grid.getSelectedRows());\n    let onSelectedRowIdsChanged = new Slick.Event();\n\n    function setSelectedRowIds(rowIds) {\n      if (selectedRowIds.join(',') == rowIds.join(',')) {\n        return;\n      }\n\n      selectedRowIds = rowIds;\n\n      onSelectedRowIdsChanged.notify(\n        {\n          grid: grid,\n          ids: selectedRowIds,\n          dataView: self\n        },\n        new Slick.EventData(),\n        self\n      );\n    }\n\n    function update() {\n      if (selectedRowIds.length > 0) {\n        inHandler = true;\n        let selectedRows = self.mapIdsToRows(selectedRowIds);\n        if (!preserveHidden) {\n          setSelectedRowIds(self.mapRowsToIds(selectedRows));\n        }\n        grid.setSelectedRows(selectedRows);\n        inHandler = false;\n      }\n    }\n\n    grid.onSelectedRowsChanged.subscribe(function(e, args) {\n      if (inHandler) {\n        return;\n      }\n      let newSelectedRowIds = self.mapRowsToIds(grid.getSelectedRows());\n      if (!preserveHiddenOnSelectionChange || !grid.getOptions().multiSelect) {\n        setSelectedRowIds(newSelectedRowIds);\n      } else {\n        // keep the ones that are hidden\n        let existing = $.grep(selectedRowIds, function(id) {\n          return self.getRowById(id) === undefined;\n        });\n        // add the newly selected ones\n        setSelectedRowIds(existing.concat(newSelectedRowIds));\n      }\n    });\n\n    this.onRowsChanged.subscribe(update);\n\n    this.onRowCountChanged.subscribe(update);\n\n    return onSelectedRowIdsChanged;\n  }\n\n  function syncGridCellCssStyles(grid, key) {\n    let hashById;\n    let inHandler;\n\n    // since this method can be called after the cell styles have been set,\n    // get the existing ones right away\n    storeCellCssStyles(grid.getCellCssStyles(key));\n\n    function storeCellCssStyles(hash) {\n      hashById = {};\n      for (let row in hash) {\n        let id = rows[row][idProperty];\n        hashById[id] = hash[row];\n      }\n    }\n\n    function update() {\n      if (hashById) {\n        inHandler = true;\n        ensureRowsByIdCache();\n        let newHash = {};\n        for (let id in hashById) {\n          let row = rowsById[id];\n          if (row != undefined) {\n            newHash[row] = hashById[id];\n          }\n        }\n        grid.setCellCssStyles(key, newHash);\n        inHandler = false;\n      }\n    }\n\n    grid.onCellCssStylesChanged.subscribe(function(e, args) {\n      if (inHandler) {\n        return;\n      }\n      if (key != args.key) {\n        return;\n      }\n      if (args.hash) {\n        storeCellCssStyles(args.hash);\n      }\n    });\n\n    this.onRowsChanged.subscribe(update);\n\n    this.onRowCountChanged.subscribe(update);\n  }\n\n  $.extend(this, {\n    // methods\n    beginUpdate: beginUpdate,\n    endUpdate: endUpdate,\n    setPagingOptions: setPagingOptions,\n    getPagingInfo: getPagingInfo,\n    getItems: getItems,\n    setItems: setItems,\n    setFilter: setFilter,\n    sort: sort,\n    fastSort: fastSort,\n    reSort: reSort,\n    setGrouping: setGrouping,\n    getGrouping: getGrouping,\n    groupBy: groupBy,\n    setAggregators: setAggregators,\n    collapseAllGroups: collapseAllGroups,\n    expandAllGroups: expandAllGroups,\n    collapseGroup: collapseGroup,\n    expandGroup: expandGroup,\n    getGroups: getGroups,\n    getIdxById: getIdxById,\n    getRowById: getRowById,\n    getItemById: getItemById,\n    getItemByIdx: getItemByIdx,\n    mapRowsToIds: mapRowsToIds,\n    mapIdsToRows: mapIdsToRows,\n    setRefreshHints: setRefreshHints,\n    setFilterArgs: setFilterArgs,\n    refresh: refresh,\n    updateItem: updateItem,\n    insertItem: insertItem,\n    addItem: addItem,\n    deleteItem: deleteItem,\n    syncGridSelection: syncGridSelection,\n    syncGridCellCssStyles: syncGridCellCssStyles,\n\n    // data provider methods\n    getLength: getLength,\n    getItem: getItem,\n    getItemMetadata: getItemMetadata,\n\n    // events\n    onRowCountChanged: onRowCountChanged,\n    onRowsChanged: onRowsChanged,\n    onPagingInfoChanged: onPagingInfoChanged\n  });\n}\n\nfunction AvgAggregator(field) {\n  this.field_ = field;\n\n  this.init = function() {\n    this.count_ = 0;\n    this.nonNullCount_ = 0;\n    this.sum_ = 0;\n  };\n\n  this.accumulate = function(item) {\n    let val = item[this.field_];\n    this.count_++;\n    if (val != null && val !== '' && !isNaN(val)) {\n      this.nonNullCount_++;\n      this.sum_ += parseFloat(val);\n    }\n  };\n\n  this.storeResult = function(groupTotals) {\n    if (!groupTotals.avg) {\n      groupTotals.avg = {};\n    }\n    if (this.nonNullCount_ != 0) {\n      groupTotals.avg[this.field_] = this.sum_ / this.nonNullCount_;\n    }\n  };\n}\n\nfunction MinAggregator(field) {\n  this.field_ = field;\n\n  this.init = function() {\n    this.min_ = null;\n  };\n\n  this.accumulate = function(item) {\n    let val = item[this.field_];\n    if (val != null && val !== '' && !isNaN(val)) {\n      if (this.min_ == null || val < this.min_) {\n        this.min_ = val;\n      }\n    }\n  };\n\n  this.storeResult = function(groupTotals) {\n    if (!groupTotals.min) {\n      groupTotals.min = {};\n    }\n    groupTotals.min[this.field_] = this.min_;\n  };\n}\n\nfunction MaxAggregator(field) {\n  this.field_ = field;\n\n  this.init = function() {\n    this.max_ = null;\n  };\n\n  this.accumulate = function(item) {\n    let val = item[this.field_];\n    if (val != null && val !== '' && !isNaN(val)) {\n      if (this.max_ == null || val > this.max_) {\n        this.max_ = val;\n      }\n    }\n  };\n\n  this.storeResult = function(groupTotals) {\n    if (!groupTotals.max) {\n      groupTotals.max = {};\n    }\n    groupTotals.max[this.field_] = this.max_;\n  };\n}\n\nfunction SumAggregator(field) {\n  this.field_ = field;\n\n  this.init = function() {\n    this.sum_ = null;\n  };\n\n  this.accumulate = function(item) {\n    let val = item[this.field_];\n    if (val != null && val !== '' && !isNaN(val)) {\n      this.sum_ += parseFloat(val);\n    }\n  };\n\n  this.storeResult = function(groupTotals) {\n    if (!groupTotals.sum) {\n      groupTotals.sum = {};\n    }\n    groupTotals.sum[this.field_] = this.sum_;\n  };\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/slick.dataview.js","import $ from 'jquery';\nimport Slick from './slick.core';\n\nexport default GroupItemMetadataProvider;\n\n/***\n * Provides item metadata for group (Slick.Group) and totals (Slick.Totals) rows produced by the DataView.\n * This metadata overrides the default behavior and formatting of those rows so that they appear and function\n * correctly when processed by the grid.\n *\n * This class also acts as a grid plugin providing event handlers to expand & collapse groups.\n * If \"grid.registerPlugin(...)\" is not called, expand & collapse will not work.\n *\n * @class GroupItemMetadataProvider\n * @module Data\n * @namespace Slick.Data\n * @constructor\n * @param options\n */\nfunction GroupItemMetadataProvider(options) {\n  let _grid;\n  let _defaults = {\n    groupCssClass: 'slick-group',\n    groupTitleCssClass: 'slick-group-title',\n    totalsCssClass: 'slick-group-totals',\n    groupFocusable: true,\n    totalsFocusable: false,\n    toggleCssClass: 'slick-group-toggle',\n    toggleExpandedCssClass: 'expanded',\n    toggleCollapsedCssClass: 'collapsed',\n    enableExpandCollapse: true,\n    groupFormatter: defaultGroupCellFormatter,\n    totalsFormatter: defaultTotalsCellFormatter\n  };\n\n  options = $.extend(true, {}, _defaults, options);\n\n  function defaultGroupCellFormatter(row, cell, value, columnDef, item) {\n    if (!options.enableExpandCollapse) {\n      return item.title;\n    }\n\n    let indentation = item.level * 15 + 'px';\n\n    return (\n      \"<span class='\" +\n      options.toggleCssClass +\n      ' ' +\n      (item.collapsed\n        ? options.toggleCollapsedCssClass\n        : options.toggleExpandedCssClass) +\n      \"' style='margin-left:\" +\n      indentation +\n      \"'>\" +\n      '</span>' +\n      \"<span class='\" +\n      options.groupTitleCssClass +\n      \"' level='\" +\n      item.level +\n      \"'>\" +\n      item.title +\n      '</span>'\n    );\n  }\n\n  function defaultTotalsCellFormatter(row, cell, value, columnDef, item) {\n    return (\n      (columnDef.groupTotalsFormatter &&\n        columnDef.groupTotalsFormatter(item, columnDef)) ||\n      ''\n    );\n  }\n\n  function init(grid) {\n    _grid = grid;\n    _grid.onClick.subscribe(handleGridClick);\n    _grid.onKeyDown.subscribe(handleGridKeyDown);\n  }\n\n  function destroy() {\n    if (_grid) {\n      _grid.onClick.unsubscribe(handleGridClick);\n      _grid.onKeyDown.unsubscribe(handleGridKeyDown);\n    }\n  }\n\n  function handleGridClick(e, args) {\n    let item = this.getDataItem(args.row);\n    if (\n      item &&\n      item instanceof Slick.Group &&\n      $(e.target).hasClass(options.toggleCssClass)\n    ) {\n      let range = _grid.getRenderedRange();\n      this.getData().setRefreshHints({\n        ignoreDiffsBefore: range.top,\n        ignoreDiffsAfter: range.bottom + 1\n      });\n\n      if (item.collapsed) {\n        this.getData().expandGroup(item.groupingKey);\n      } else {\n        this.getData().collapseGroup(item.groupingKey);\n      }\n\n      e.stopImmediatePropagation();\n      e.preventDefault();\n    }\n  }\n\n  // TODO:  add -/+ handling\n  function handleGridKeyDown(e) {\n    if (options.enableExpandCollapse && e.which == Slick.keyCode.SPACE) {\n      let activeCell = this.getActiveCell();\n      if (activeCell) {\n        let item = this.getDataItem(activeCell.row);\n        if (item && item instanceof Slick.Group) {\n          let range = _grid.getRenderedRange();\n          this.getData().setRefreshHints({\n            ignoreDiffsBefore: range.top,\n            ignoreDiffsAfter: range.bottom + 1\n          });\n\n          if (item.collapsed) {\n            this.getData().expandGroup(item.groupingKey);\n          } else {\n            this.getData().collapseGroup(item.groupingKey);\n          }\n\n          e.stopImmediatePropagation();\n          e.preventDefault();\n        }\n      }\n    }\n  }\n\n  function getGroupRowMetadata(item) {\n    return {\n      selectable: false,\n      focusable: options.groupFocusable,\n      cssClasses: options.groupCssClass,\n      columns: {\n        0: {\n          colspan: '*',\n          formatter: options.groupFormatter,\n          editor: null\n        }\n      }\n    };\n  }\n\n  function getTotalsRowMetadata(item) {\n    return {\n      selectable: false,\n      focusable: options.totalsFocusable,\n      cssClasses: options.totalsCssClass,\n      formatter: options.totalsFormatter,\n      editor: null\n    };\n  }\n\n  return {\n    init,\n    destroy,\n    getGroupRowMetadata,\n    getTotalsRowMetadata\n  };\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/slick.groupmetadataprovider.js"],"sourceRoot":""}